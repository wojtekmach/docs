<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.30.9">
    <meta name="project" content="erl_interface v5.4">


    <title>Erl_Interface User's Guide — erl_interface v5.4</title>
    <link rel="stylesheet" href="dist/html-erlang-QW5RMTQD.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-43PMFBC7.js"></script>
    <script src="dist/sidebar_items-76FCAAFE.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/html-LRUIU55G.js"></script>

<style>.dark img { background-color: white; }</style>
  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="api-reference.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="erl_interface" />
        </a>

      <div>
        <a href="api-reference.html" class="sidebar-projectName" translate="no">
erl_interface
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v5.4
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Pages
        </button>
      </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">
      <div class="top-search">
        <div class="search-settings">
          <form class="search-bar" action="search.html">
            <label class="search-label">
              <span class="sr-only">Search documentation of erl_interface</span>
              <input name="q" type="text" class="search-input" placeholder="Search Documentation (press /)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            </label>
            <button type="submit" class="search-button" aria-label="Submit Search">
              <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
            </button>
            <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
              <i class="ri-close-line ri-lg" title="Cancel search"></i>
            </button>
          </form>
          <button class="icon-settings display-settings">
            <i class="ri-settings-3-line"></i>
            <span class="sr-only">Settings</span>
          </button>
        </div>
      </div>
      <div class="autocomplete">
        <div class="autocomplete-results">
        </div>
      </div>

<h1>

    <a href="https://github.com/erlang/otp/blob/master/lib/erl_interface/doc/guides/ei_users_guide.md#L1" title="View Source" class="icon-action" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>


  <span>Erl_Interface User's Guide</span>
</h1>

<h2 id="introduction" class="section-heading">
  <a href="#introduction" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Introduction</span>
</h2>
<p>The <code class="inline">Erl_Interface</code> library contains functions that help you integrate programs
written in C and Erlang. The functions in <code class="inline">Erl_Interface</code> support the following:</p><ul><li>Manipulation of data represented as Erlang data types</li><li>Conversion of data between C and Erlang formats</li><li>Encoding and decoding of Erlang data types for transmission or storage</li><li>Communication between C nodes and Erlang processes</li><li>Backup and restore of C node state to and from <a href="../../../../lib/mnesia/doc/html/mnesia.html">Mnesia</a></li></ul><blockquote><h4 class="info">Note</h4><p>By default, the <code class="inline">Erl_Interface</code> library is only guaranteed to be compatible
with other Erlang/OTP components from the same release as the libraries
themselves. For information about how to communicate with Erlang/OTP
components from earlier releases, see function
<a href="ei.html#ei_set_compat_rel"><code class="inline">ei_set_compat_rel</code></a>.</p></blockquote><h3 id="scope" class="section-heading">
  <a href="#scope" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Scope</span>
</h3>
<p>In the following sections, these topics are described:</p><ul><li>Compiling your code for use with <code class="inline">Erl_Interface</code></li><li>Initializing <code class="inline">Erl_Interface</code></li><li>Encoding, decoding, and sending Erlang terms</li><li>Building terms and patterns</li><li>Pattern matching</li><li>Connecting to a distributed Erlang node</li><li>Using the Erlang Port Mapper Daemon (EPMD)</li><li>Sending and receiving Erlang messages</li><li>Remote procedure calls</li><li>Using global names</li></ul><h3 id="prerequisites" class="section-heading">
  <a href="#prerequisites" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Prerequisites</span>
</h3>
<p>It is assumed that the reader is familiar with the Erlang programming language.</p><h2 id="compiling-and-linking-your-code" class="section-heading">
  <a href="#compiling-and-linking-your-code" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Compiling and Linking Your Code</span>
</h2>
<p>To use any of the <code class="inline">Erl_Interface</code> functions, include the following line in your
code:</p><pre><code class="text">#include &quot;ei.h&quot;</code></pre><p>Determine where the top directory of your OTP installation is. To find this,
start Erlang and enter the following command at the Eshell prompt:</p><pre><code class="text">Eshell V4.7.4  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp</code></pre><p>To compile your code, ensure that your C compiler knows where to find <code class="inline">ei.h</code> by
specifying an appropriate <code class="inline">-I</code> argument on the command line, or add it to the
<code class="inline">CFLAGS</code> definition in your <code class="inline">Makefile</code>. The correct value for this path is
<code class="inline">$OTPROOT/lib/erl_interface-$EIVSN/include</code>, where:</p><ul><li><code class="inline">$OTPROOT</code> is the path reported by <a href="../../../../lib/kernel/doc/html/code.html#root_dir/0"><code class="inline">code:root_dir/0</code></a> in the example above.</li><li><code class="inline">$EIVSN</code> is the version of the <code class="inline">Erl_Interface</code> application, for example,
<code class="inline">erl_interface-3.2.3</code>.</li></ul><p>Compiling the code:</p><pre><code class="text">$ cc -c -I/usr/local/otp/lib/erl_interface-3.2.3/include myprog.c</code></pre><p>When linking:</p><ul><li>Specify the path to <code class="inline">libei.a</code> with <code class="inline">-L$OTPROOT/lib/erl_interface-3.2.3/lib</code>.</li><li>Specify the name of the library with <code class="inline">-lei</code>.</li></ul><p>Do this on the command line or add the flags to the <code class="inline">LDFLAGS</code> definition in your
<code class="inline">Makefile</code>.</p><p>Linking the code:</p><pre><code class="text">$ ld -L/usr/local/otp/lib/erl_interface-3.2.3/
                            lib myprog.o -lei -o myprog</code></pre><p>On some systems it can be necessary to link with some more libraries (for
example, <code class="inline">libnsl.a</code> and <code class="inline">libsocket.a</code> on Solaris, or <code class="inline">wsock32.lib</code> on Windows)
to use the communication facilities of <code class="inline">Erl_Interface</code>.</p><p>If you use the <code class="inline">Erl_Interface</code> functions in a threaded application based on
POSIX threads or Solaris threads, then <code class="inline">Erl_Interface</code> needs access to some of
the synchronization facilities in your threads package. You must specify extra
compiler flags to indicate which of the packages you use. Define <code class="inline">_REENTRANT</code>
and either <code class="inline">STHREADS</code> or <code class="inline">PTHREADS</code>. The default is to use POSIX threads if
<code class="inline">_REENTRANT</code> is specified.</p><h2 id="initializing-the-library" class="section-heading">
  <a href="#initializing-the-library" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Initializing the Library</span>
</h2>
<p>Before calling any of the other functions in the library, initialize it by
calling <code class="inline">ei_init()</code> exactly once.</p><h2 id="encoding-decoding-and-sending-erlang-terms" class="section-heading">
  <a href="#encoding-decoding-and-sending-erlang-terms" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Encoding, Decoding, and Sending Erlang Terms</span>
</h2>
<p>Data sent between distributed Erlang nodes is encoded in the Erlang external
format. You must therefore encode and decode Erlang terms into byte streams if
you want to use the distribution protocol to communicate between a C program and
Erlang.</p><p>The <code class="inline">Erl_Interface</code> library supports this activity. It has several C functions
that create and manipulate Erlang data structures. The following example shows
how to create and encode an Erlang tuple <code class="inline">{tobbe,3928}</code>:</p><pre><code class="text">ei_x_buff buf;
ei_x_new(&amp;buf);
int i = 0;
ei_x_encode_tuple_header(&amp;buf, 2);
ei_x_encode_atom(&amp;buf, &quot;tobbe&quot;);
ei_x_encode_long(&amp;buf, 3928);</code></pre><p>For a complete description, see the <a href="ei.html"><code class="inline">ei</code></a> module.</p><p><a href="" id="building_terms_and_patterns"></a></p><h2 id="building-terms" class="section-heading">
  <a href="#building-terms" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Building Terms</span>
</h2>
<p>The previous example can be simplified by using the
<a href="ei.html#ei_x_format_wo_ver"><code class="inline">ei_x_format_wo_ver</code></a> function to create an Erlang
term:</p><pre><code class="text">ei_x_buff buf;
ei_x_new(&amp;buf);
ei_x_format_wo_ver(&amp;buf, &quot;{~a,~i}&quot;, &quot;tobbe&quot;, 3928);</code></pre><p>For a complete description of the different format directives, see the the
<a href="ei.html#ei_x_format_wo_ver"><code class="inline">ei_x_format_wo_ver</code></a> function.</p><p>The following example is more complex:</p><pre><code class="text">ei_x_buff buf;
int i = 0;
ei_x_new(&amp;buf);
ei_x_format_wo_ver(&amp;buf,
                   &quot;[{name,~a},{age,~i},{data,[{adr,~s,~i}]}]&quot;,
                   &quot;madonna&quot;,
                   21,
                  &quot;E-street&quot;, 42);
ei_print_term(stdout, buf.buff, &amp;i);
ei_x_free(&amp;buf);</code></pre><p>As in the previous examples, it is your responsibility to free the memory
allocated for Erlang terms. In this example, <code class="inline">ei_x_free()</code> ensures that the data
pointed to by <code class="inline">buf</code> is released.</p><h2 id="connecting-to-a-distributed-erlang-node" class="section-heading">
  <a href="#connecting-to-a-distributed-erlang-node" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Connecting to a Distributed Erlang Node</span>
</h2>
<p>To connect to a distributed Erlang node, you must first initialize the
connection routine with one of the
<a href="ei_connect.html#ei_connect_init"><code class="inline">ei_connect_init_*</code></a> functions, which stores
information, such as the hostname, and node name for later use:</p><pre><code class="text">int identification_number = 99;
int creation=1;
char *cookie=&quot;a secret cookie string&quot;; /* An example */
const char* node_name = &quot;einode@durin&quot;;
const char *cookie = NULL;
short creation = time(NULL) + 1;
ei_cnode ec;
ei_connect_init(&amp;ec,
                node_name,
                cookie,
                creation);</code></pre><p>For more information, see the <a href="ei_connect.html"><code class="inline">ei_connect</code></a> module.</p><p>After initialization, you set up the connection to the Erlang node. To specify
the Erlang node you want to connect to, use the <code class="inline">ei_connect_*()</code> family of
functions. The following example sets up the connection and is to result in a
valid socket file descriptor:</p><pre><code class="text">int sockfd;
const char* node_name = &quot;einode@durin&quot;; /* An example */
if ((sockfd = ei_connect(&amp;ec, nodename)) &lt; 0)
  fprintf(stderr, &quot;ERROR: ei_connect failed&quot;);</code></pre><h2 id="using-epmd" class="section-heading">
  <a href="#using-epmd" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using EPMD</span>
</h2>
<p><a href="../../../../lib/../erts/doc/html/epmd_cmd.html"><code class="inline">erts:epmd</code></a> is the Erlang Port Mapper Daemon.
Distributed Erlang nodes register with <code class="inline">epmd</code> on the local host to indicate to
other nodes that they exist and can accept connections. <code class="inline">epmd</code> maintains a
register of node and port number information, and when a node wishes to connect
to another node, it first contacts <code class="inline">epmd</code> to find the correct port number to
connect to.</p><p>When you use <a href="ei_connect.html"><code class="inline">ei_connect</code></a> to connect to an Erlang node, a
connection is first made to <code class="inline">epmd</code> and, if the node is known, a connection is
then made to the Erlang node.</p><p>C nodes can also register themselves with <code class="inline">epmd</code> if they want other nodes in the
system to be able to find and connect to them.</p><p>Before registering with <code class="inline">epmd</code>, you must first create a listen socket and bind
it to a port. Then:</p><pre><code class="text">int pub;

pub = ei_publish(&amp;ec, port);</code></pre><p><code class="inline">pub</code> is a file descriptor now connected to <code class="inline">epmd</code>. <code class="inline">epmd</code> monitors the other
end of the connection. If it detects that the connection has been closed, the
node becomes unregistered. So, if you explicitly close the descriptor or if your
node fails, it becomes unregistered from <code class="inline">epmd</code>.</p><p>Notice that on some systems a failed node is not detected by this mechanism, as
the operating system does not automatically close descriptors that were left
open when the node failed. If a node has failed in this way, <code class="inline">epmd</code> prevents you
from registering a new node with the old name, as it thinks that the old name is
still in use. In this case, you must close the port explicitly</p><h2 id="sending-and-receiving-erlang-messages" class="section-heading">
  <a href="#sending-and-receiving-erlang-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sending and Receiving Erlang Messages</span>
</h2>
<p>Use one of the following two functions to send messages:</p><ul><li><a href="ei_connect.html#ei_send"><code class="inline">ei_send</code></a></li><li><a href="ei_connect.html#ei_reg_send"><code class="inline">ei_reg_send</code></a></li></ul><p>As in Erlang, messages can be sent to a pid or to a registered name. It is
easier to send a message to a registered name, as it avoids the problem of
finding a suitable pid.</p><p>Use one of the following two functions to receive messages:</p><ul><li><a href="ei_connect.html#ei_receive"><code class="inline">ei_receive</code></a></li><li><a href="ei_connect.html#ei_receive_msg"><code class="inline">ei_receive_msg</code></a></li></ul><h3 id="example-of-sending-messages" class="section-heading">
  <a href="#example-of-sending-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Example of Sending Messages</span>
</h3>
<p>In the following example, <code class="inline">{Pid, hello_world}</code> is sent to a registered process
<code class="inline">my_server</code>:</p><pre><code class="text">ei_x_buff buf;
ei_x_new_with_version(&amp;buf);

ei_x_encode_tuple_header(&amp;buf, 2);
ei_x_encode_pid(&amp;buf, ei_self(ec));
ei_x_encode_atom(&amp;buf, &quot;Hello world&quot;);

ei_reg_send(&amp;ec, fd, &quot;my_server&quot;, buf.buff, buf.index);</code></pre><p>The first element of the tuple that is sent is your own pid. This enables
<code class="inline">my_server</code> to reply. For more information about the primitives, see the
<a href="ei_connect.html"><code class="inline">ei_connect</code></a> module.</p><h3 id="example-of-receiving-messages" class="section-heading">
  <a href="#example-of-receiving-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Example of Receiving Messages</span>
</h3>
<p>In this example, <code class="inline">{Pid, Something}</code> is received.</p><pre><code class="text">erlang_msg msg;
int index = 0;
int version;
int arity = 0;
erlang_pid pid;
ei_x_buff buf;
ei_x_new(&amp;buf);
for (;;) {
  int got = ei_xreceive_msg(fd, &amp;msg, &amp;x);
  if (got == ERL_TICK)
    continue;
  if (got == ERL_ERROR) {
    fprintf(stderr, &quot;ei_xreceive_msg, got==%d&quot;, got);
    exit(1);
  }
  break;
}
ei_decode_version(buf.buff, &amp;index, &amp;version);
ei_decode_tuple_header(buf.buff, &amp;index, &amp;arity);
if (arity != 2) {
  fprintf(stderr, &quot;got wrong message&quot;);
  exit(1);
}
ei_decode_pid(buf.buff, &amp;index, &amp;pid);</code></pre><p>To provide robustness, a distributed Erlang node occasionally polls all its
connected neighbors in an attempt to detect failed nodes or communication links.
A node that receives such a message is expected to respond immediately with an
<code class="inline">ERL_TICK</code> message. This is done automatically by <code class="inline">ei_xreceive_msg()</code>. However,
when this has occurred, <code class="inline">ei_xreceive_msg</code> returns <code class="inline">ERL_TICK</code> to the caller
without storing a message into the <code class="inline">erlang_msg</code> structure.</p><p>When a message has been received, it is the caller's responsibility to free the
received message.</p><p>For more information, see the <a href="ei_connect.html"><code class="inline">ei_connect</code></a> and <a href="ei.html"><code class="inline">ei</code></a>
modules.</p><h2 id="remote-procedure-calls" class="section-heading">
  <a href="#remote-procedure-calls" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Remote Procedure Calls</span>
</h2>
<p>An Erlang node acting as a client to another Erlang node typically sends a
request and waits for a reply. Such a request is included in a function call at
a remote node and is called a remote procedure call.</p><p>The following example checks if a specific Erlang process is alive:</p><pre><code class="text">int index = 0, is_alive;
ei_x_buff args, result;

ei_x_new(&amp;result);
ei_x_new(&amp;args);
ei_x_encode_list_header(&amp;args, 1);
ei_x_encode_pid(&amp;args, &amp;check_pid);
ei_x_encode_empty_list(&amp;args);

if (ei_rpc(&amp;ec, fd, &quot;erlang&quot;, &quot;is_process_alive&quot;,
           args.buff, args.index, &amp;result) &lt; 0)
    handle_error();

if (ei_decode_version(result.buff, &amp;index) &lt; 0
    || ei_decode_bool(result.buff, &amp;index, &amp;is_alive) &lt; 0)
    handle_error();</code></pre><p>For more information about <code class="inline">ei_rpc()</code> and its companions <code class="inline">ei_rpc_to()</code> and
<code class="inline">ei_rpc_from()</code>, see the <a href="ei_connect.html"><code class="inline">ei_connect</code></a> module.</p><h2 id="using-global-names" class="section-heading">
  <a href="#using-global-names" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using Global Names</span>
</h2>
<p>A C node has access to names registered through the <a href="../../../../lib/kernel/doc/html/global.html"><code class="inline">global</code></a> module in Kernel.
Names can be looked up, allowing the C node to send messages to named Erlang
services. C nodes can also register global names, allowing them to provide named
services to Erlang processes or other C nodes.</p><p><code class="inline">Erl_Interface</code> does not provide a native implementation of the global service.
Instead it uses the global services provided by a &quot;nearby&quot; Erlang node. To use
the services described in this section, it is necessary to first open a
connection to an Erlang node.</p><p>To see what names there are:</p><pre><code class="text">char **names;
int count;
int i;

names = ei_global_names(&amp;ec,fd,&amp;count);

if (names)
  for (i=0; i&lt;count; i++)
    printf(&quot;%s\n&quot;,names[i]);

free(names);</code></pre><p><a href="ei_global.html#ei_global_names"><code class="inline">ei_global_names</code></a> allocates and returns a buffer
containing all the names known to the <code class="inline">global</code> module in <code class="inline">Kernel</code>. <code class="inline">count</code> is
initialized to indicate the number of names in the array. The array of strings
in names is terminated by a <code class="inline">NULL</code> pointer, so it is not necessary to use
<code class="inline">count</code> to determine when the last name is reached.</p><p>It is the caller's responsibility to free the array. <code class="inline">ei_global_names</code> allocates
the array and all the strings using a single call to <code class="inline">malloc()</code>, so
<code class="inline">free(names)</code> is all that is necessary.</p><p>To look up one of the names:</p><pre><code class="text">ETERM *pid;
char node[256];
erlang_pid the_pid;

if (ei_global_whereis(&amp;ec,fd,&quot;schedule&quot;,&amp;the_pid,node) &lt; 0)
   fprintf(stderr, &quot;ei_global_whereis error\n&quot;);</code></pre><p>If <code class="inline">&quot;schedule&quot;</code> is known to the <code class="inline">global</code> module in <code class="inline">Kernel</code>, an Erlang pid is
written to the_pid. This pid that can be used to send messages to the schedule
service. Also, <code class="inline">node</code> is initialized to contain the name of the node where the
service is registered, so that you can make a connection to it by simply passing
the variable to <a href="ei_connect.html"><code class="inline">ei_connect</code></a>.</p><p>Before registering a name, you should already have registered your port number
with <code class="inline">epmd</code>. This is not strictly necessary, but if you neglect to do so, then
other nodes wishing to communicate with your service cannot find or connect to
your process.</p><p>Create a name that Erlang processes can use to communicate with your service:</p><pre><code class="text">ei_global_register(fd,servicename,ei_self(ec));</code></pre><p>After registering the name, use <a href="ei_connect.html#ei_accept"><code class="inline">ei_accept</code></a> to wait
for incoming connections.</p><blockquote><h4 class="info">Note</h4><p>Remember to free <code class="inline">pid</code> later with <a href="ei.html#ei_x_free"><code class="inline">ei_x_free</code></a>.</p></blockquote><p>To unregister a name:</p><pre><code class="text">ei_global_unregister(&amp;ec,fd,servicename);</code></pre>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="notes.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Erl_interface Release Notes
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="erl_call_cmd.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
erl_call
        </span>
      </a>

  </div>
</div>
      <footer class="footer">
        <p>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
              Search HexDocs
            </button>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.30.9) for the

            <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

        </p>
      </footer>
    </div>
  </div>
</main>
</div>


  </body>
</html>
