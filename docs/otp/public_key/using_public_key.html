<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.30.9">
    <meta name="project" content="public_key v1.14.1">


    <title>Getting Started — public_key v1.14.1</title>
    <link rel="stylesheet" href="dist/html-erlang-QW5RMTQD.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-43PMFBC7.js"></script>
    <script src="dist/sidebar_items-562A6422.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/html-LRUIU55G.js"></script>

<style>.dark img { background-color: white; }</style>
  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="api-reference.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="public_key" />
        </a>

      <div>
        <a href="api-reference.html" class="sidebar-projectName" translate="no">
public_key
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v1.14.1
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Pages
        </button>
      </li>

        <li>
          <button id="modules-list-tab-button" role="tab" data-type="modules" aria-controls="modules-tab-panel" aria-selected="false" tabindex="-1">
            Modules
          </button>
        </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>

    <div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden>
      <ul id="modules-full-list" class="full-list"></ul>
    </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">
      <div class="top-search">
        <div class="search-settings">
          <form class="search-bar" action="search.html">
            <label class="search-label">
              <span class="sr-only">Search documentation of public_key</span>
              <input name="q" type="text" class="search-input" placeholder="Search Documentation (press /)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            </label>
            <button type="submit" class="search-button" aria-label="Submit Search">
              <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
            </button>
            <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
              <i class="ri-close-line ri-lg" title="Cancel search"></i>
            </button>
          </form>
          <button class="icon-settings display-settings">
            <i class="ri-settings-3-line"></i>
            <span class="sr-only">Settings</span>
          </button>
        </div>
      </div>
      <div class="autocomplete">
        <div class="autocomplete-results">
        </div>
      </div>

<h1>

    <a href="https://github.com/erlang/otp/blob/master/lib/public_key/doc/guides/using_public_key.md#L1" title="View Source" class="icon-action" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>


  <span>Getting Started</span>
</h1>

<p>This section describes examples of how to use the Public Key API. Keys and
certificates used in the following sections are generated only for testing the
Public Key application.</p><p>Some shell printouts in the following examples are abbreviated for increased
readability.</p><h2 id="pem-files" class="section-heading">
  <a href="#pem-files" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">PEM Files</span>
</h2>
<p>Public-key data (keys, certificates, and so on) can be stored in Privacy
Enhanced Mail (PEM) format. The PEM files have the following structure:</p><pre><code class="text">    &lt;text&gt;
    -----BEGIN &lt;SOMETHING&gt;-----
    &lt;Attribute&gt; : &lt;Value&gt;
    &lt;Base64 encoded DER data&gt;
    -----END &lt;SOMETHING&gt;-----
    &lt;text&gt;</code></pre><p>A file can contain several <code class="inline">BEGIN/END</code> blocks. Text lines between blocks are
ignored. Attributes, if present, are ignored except for <code class="inline">Proc-Type</code> and
<code class="inline">DEK-Info</code>, which are used when <code class="inline">DER</code> data is encrypted.</p><h3 id="dsa-private-key" class="section-heading">
  <a href="#dsa-private-key" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">DSA Private Key</span>
</h3>
<p>A DSA private key can look as follows:</p><blockquote><h4 class="info">Note</h4><p>File handling is not done by the Public Key application.</p></blockquote><pre><code class="text">1&gt; {ok, PemBin} = file:read_file(&quot;dsa.pem&quot;).
{ok,&lt;&lt;&quot;-----BEGIN DSA PRIVATE KEY-----\nMIIBuw&quot;...&gt;&gt;}</code></pre><p>The following PEM file has only one entry, a private DSA key:</p><pre><code class="text">2&gt; [DSAEntry] =  public_key:pem_decode(PemBin).
[{'DSAPrivateKey',&lt;&lt;48,130,1,187,2,1,0,2,129,129,0,183,
                    179,230,217,37,99,144,157,21,228,204,
		    162,207,61,246,...&gt;&gt;,
		    not_encrypted}]</code></pre><pre><code class="text">3&gt; Key = public_key:pem_entry_decode(DSAEntry).
#'DSAPrivateKey'{version = 0,
                 p = 12900045185019966618...6593,
                 q = 1216700114794736143432235288305776850295620488937,
                 g = 10442040227452349332...47213,
                 y = 87256807980030509074...403143,
                 x = 510968529856012146351317363807366575075645839654}</code></pre><h3 id="rsa-private-key-with-password" class="section-heading">
  <a href="#rsa-private-key-with-password" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">RSA Private Key with Password</span>
</h3>
<p>An RSA private key encrypted with a password can look as follows:</p><pre><code class="text">1&gt; {ok, PemBin} = file:read_file(&quot;rsa.pem&quot;).
{ok,&lt;&lt;&quot;Bag Attribute&quot;...&gt;&gt;}</code></pre><p>The following PEM file has only one entry, a private RSA key:</p><pre><code class="text">2&gt;[RSAEntry] = public_key:pem_decode(PemBin).
[{'RSAPrivateKey',&lt;&lt;224,108,117,203,152,40,15,77,128,126,
                    221,195,154,249,85,208,202,251,109,
                    119,120,57,29,89,19,9,...&gt;&gt;,
                  {&quot;DES-EDE3-CBC&quot;,&lt;&lt;&quot;kÙeø¼pµL&quot;&gt;&gt;}}]</code></pre><p>In this following example, the password is <code class="inline">&quot;abcd1234&quot;</code>:</p><pre><code class="text">3&gt; Key = public_key:pem_entry_decode(RSAEntry, &quot;abcd1234&quot;).
    #'RSAPrivateKey'{version = 'two-prime',
                 modulus = 1112355156729921663373...2737107,
                 publicExponent = 65537,
                 privateExponent = 58064406231183...2239766033,
                 prime1 = 11034766614656598484098...7326883017,
                 prime2 = 10080459293561036618240...77738643771,
                 exponent1 = 77928819327425934607...22152984217,
                 exponent2 = 36287623121853605733...20588523793,
                 coefficient = 924840412626098444...41820968343,
                 otherPrimeInfos = asn1_NOVALUE}</code></pre><h3 id="x509-certificates" class="section-heading">
  <a href="#x509-certificates" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">X509 Certificates</span>
</h3>
<p>The following is an example of X509 certificates:</p><pre><code class="text">1&gt; {ok, PemBin} = file:read_file(&quot;cacerts.pem&quot;).
{ok,&lt;&lt;&quot;-----BEGIN CERTIFICATE-----\nMIIC7jCCAl&quot;...&gt;&gt;}</code></pre><p>The following file includes two certificates:</p><pre><code class="text">2&gt; [CertEntry1, CertEntry2] = public_key:pem_decode(PemBin).
[{'Certificate',&lt;&lt;48,130,2,238,48,130,2,87,160,3,2,1,2,2,
                  9,0,230,145,97,214,191,2,120,150,48,13,
                  ...&gt;&gt;,
                not_encrypted},
 {'Certificate',&lt;&lt;48,130,3,200,48,130,3,49,160,3,2,1,2,2,1,
                  1,48,13,6,9,42,134,72,134,247,...&gt;&gt;,
                not_encrypted}]</code></pre><p>Certificates can be decoded as usual:</p><pre><code class="text">2&gt; Cert = public_key:pem_entry_decode(CertEntry1).
#'Certificate'{
    tbsCertificate =
        #'TBSCertificate'{
            version = v3,serialNumber = 16614168075301976214,
            signature =
                #'AlgorithmIdentifier'{
                    algorithm = {1,2,840,113549,1,1,5},
                    parameters = &lt;&lt;5,0&gt;&gt;},
            issuer =
                {rdnSequence,
                    [[#'AttributeTypeAndValue'{
                          type = {2,5,4,3},
                          value = &lt;&lt;19,8,101,114,108,97,110,103,67,65&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,11},
                          value = &lt;&lt;19,10,69,114,108,97,110,103,32,79,84,80&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,10},
                          value = &lt;&lt;19,11,69,114,105,99,115,115,111,110,32,65,66&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,7},
                          value = &lt;&lt;19,9,83,116,111,99,107,104,111,108,109&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,6},
                          value = &lt;&lt;19,2,83,69&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {1,2,840,113549,1,9,1},
                          value = &lt;&lt;22,22,112,101,116,101,114,64,101,114,...&gt;&gt;}]]},
            validity =
                #'Validity'{
                    notBefore = {utcTime,&quot;080109082929Z&quot;},
                    notAfter = {utcTime,&quot;080208082929Z&quot;}},
            subject =
                {rdnSequence,
                    [[#'AttributeTypeAndValue'{
                          type = {2,5,4,3},
                          value = &lt;&lt;19,8,101,114,108,97,110,103,67,65&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,11},
                          value = &lt;&lt;19,10,69,114,108,97,110,103,32,79,84,80&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,10},
                          value = &lt;&lt;19,11,69,114,105,99,115,115,111,110,32,...&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,7},
                          value = &lt;&lt;19,9,83,116,111,99,107,104,111,108,...&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,6},
                          value = &lt;&lt;19,2,83,69&gt;&gt;}],
                     [#'AttributeTypeAndValue'{
                          type = {1,2,840,113549,1,9,1},
                          value = &lt;&lt;22,22,112,101,116,101,114,64,...&gt;&gt;}]]},
            subjectPublicKeyInfo =
                #'SubjectPublicKeyInfo'{
                    algorithm =
                        #'AlgorithmIdentifier'{
                            algorithm = {1,2,840,113549,1,1,1},
                            parameters = &lt;&lt;5,0&gt;&gt;},
                    subjectPublicKey =
                        {0,&lt;&lt;48,129,137,2,129,129,0,203,209,187,77,73,231,90,...&gt;&gt;}},
            issuerUniqueID = asn1_NOVALUE,
            subjectUniqueID = asn1_NOVALUE,
            extensions =
                [#'Extension'{
                     extnID = {2,5,29,19},
                     critical = true,
                     extnValue = [48,3,1,1,255]},
                 #'Extension'{
                     extnID = {2,5,29,15},
                     critical = false,
                     extnValue = [3,2,1,6]},
                 #'Extension'{
                     extnID = {2,5,29,14},
                     critical = false,
                     extnValue = [4,20,27,217,65,152,6,30,142|...]},
                 #'Extension'{
                     extnID = {2,5,29,17},
                     critical = false,
                     extnValue = [48,24,129,22,112,101,116,101|...]}]},
    signatureAlgorithm =
        #'AlgorithmIdentifier'{
            algorithm = {1,2,840,113549,1,1,5},
            parameters = &lt;&lt;5,0&gt;&gt;},
    signature =
    &lt;&lt;163,186,7,163,216,152,63,47,154,234,139,73,154,96,120,
    165,2,52,196,195,109,167,192,...&gt;&gt;}</code></pre><p>Parts of certificates can be decoded with <a href="public_key.html#der_decode/2"><code class="inline">public_key:der_decode/2</code></a>, using the
ASN.1 type of that part. However, an application-specific certificate extension
requires application-specific ASN.1 decode/encode-functions. In the recent
example, the first value of <code class="inline">rdnSequence</code> is of ASN.1 type
<code class="inline">'X520CommonName'. ({2,5,4,3} = ?id-at-commonName)</code>:</p><pre><code class="text">public_key:der_decode('X520CommonName', &lt;&lt;19,8,101,114,108,97,110,103,67,65&gt;&gt;).
{printableString,&quot;erlangCA&quot;}</code></pre><p>However, certificates can also be decoded using <code class="inline">pkix_decode_cert/2</code>, which can
customize and recursively decode standard parts of a certificate:</p><pre><code class="text">3&gt;{_, DerCert, _} = CertEntry1.</code></pre><pre><code class="text">4&gt; public_key:pkix_decode_cert(DerCert, otp).
#'OTPCertificate'{
    tbsCertificate =
        #'OTPTBSCertificate'{
            version = v3,serialNumber = 16614168075301976214,
            signature =
                #'SignatureAlgorithm'{
                    algorithm = {1,2,840,113549,1,1,5},
                    parameters = 'NULL'},
            issuer =
                {rdnSequence,
                    [[#'AttributeTypeAndValue'{
                          type = {2,5,4,3},
                          value = {printableString,&quot;erlangCA&quot;}}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,11},
                          value = {printableString,&quot;Erlang OTP&quot;}}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,10},
                          value = {printableString,&quot;Ericsson AB&quot;}}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,7},
                          value = {printableString,&quot;Stockholm&quot;}}],
                     [#'AttributeTypeAndValue'{type = {2,5,4,6},value = &quot;SE&quot;}],
                     [#'AttributeTypeAndValue'{
                          type = {1,2,840,113549,1,9,1},
                          value = &quot;peter@erix.ericsson.se&quot;}]]},
            validity =
                #'Validity'{
                    notBefore = {utcTime,&quot;080109082929Z&quot;},
                    notAfter = {utcTime,&quot;080208082929Z&quot;}},
            subject =
                {rdnSequence,
                    [[#'AttributeTypeAndValue'{
                          type = {2,5,4,3},
                          value = {printableString,&quot;erlangCA&quot;}}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,11},
                          value = {printableString,&quot;Erlang OTP&quot;}}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,10},
                          value = {printableString,&quot;Ericsson AB&quot;}}],
                     [#'AttributeTypeAndValue'{
                          type = {2,5,4,7},
                          value = {printableString,&quot;Stockholm&quot;}}],
                     [#'AttributeTypeAndValue'{type = {2,5,4,6},value = &quot;SE&quot;}],
                     [#'AttributeTypeAndValue'{
                          type = {1,2,840,113549,1,9,1},
                          value = &quot;peter@erix.ericsson.se&quot;}]]},
            subjectPublicKeyInfo =
                #'OTPSubjectPublicKeyInfo'{
                    algorithm =
                        #'PublicKeyAlgorithm'{
                            algorithm = {1,2,840,113549,1,1,1},
                            parameters = 'NULL'},
                    subjectPublicKey =
                        #'RSAPublicKey'{
                            modulus =
                                1431267547247997...37419,
                            publicExponent = 65537}},
            issuerUniqueID = asn1_NOVALUE,
            subjectUniqueID = asn1_NOVALUE,
            extensions =
                [#'Extension'{
                     extnID = {2,5,29,19},
                     critical = true,
                     extnValue =
                         #'BasicConstraints'{
                             cA = true,pathLenConstraint = asn1_NOVALUE}},
                 #'Extension'{
                     extnID = {2,5,29,15},
                     critical = false,
                     extnValue = [keyCertSign,cRLSign]},
                 #'Extension'{
                     extnID = {2,5,29,14},
                     critical = false,
                     extnValue = [27,217,65,152,6,30,142,132,245|...]},
                 #'Extension'{
                     extnID = {2,5,29,17},
                     critical = false,
                     extnValue = [{rfc822Name,&quot;peter@erix.ericsson.se&quot;}]}]},
    signatureAlgorithm =
        #'SignatureAlgorithm'{
            algorithm = {1,2,840,113549,1,1,5},
            parameters = 'NULL'},
    signature =
         &lt;&lt;163,186,7,163,216,152,63,47,154,234,139,73,154,96,120,
           165,2,52,196,195,109,167,192,...&gt;&gt;}</code></pre><p>This call is equivalent to <code class="inline">public_key:pem_entry_decode(CertEntry1)</code>:</p><pre><code class="text">5&gt; public_key:pkix_decode_cert(DerCert, plain).
#'Certificate'{ ...}</code></pre><h3 id="encoding-public-key-data-to-pem-format" class="section-heading">
  <a href="#encoding-public-key-data-to-pem-format" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Encoding Public-Key Data to PEM Format</span>
</h3>
<p>If you have public-key data and want to create a PEM file this can be done by
calling functions <a href="public_key.html#pem_entry_encode/2"><code class="inline">public_key:pem_entry_encode/2</code></a> and <code class="inline">pem_encode/1</code> and saving
the result to a file. For example, assume that you have
<code class="inline">PubKey = 'RSAPublicKey'{}</code>. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file
(ASN.1 type <code class="inline">'RSAPublicKey'</code>) or a PEM-&quot;PUBLIC KEY&quot; file
(<code class="inline">'SubjectPublicKeyInfo'</code> ASN.1 type).</p><p>The second element of the PEM-entry is the ASN.1 <code class="inline">DER</code> encoded key data:</p><pre><code class="text">1&gt; PemEntry = public_key:pem_entry_encode('RSAPublicKey', RSAPubKey).
{'RSAPublicKey', &lt;&lt;48,72,...&gt;&gt;, not_encrypted}

2&gt; PemBin = public_key:pem_encode([PemEntry]).
&lt;&lt;&quot;-----BEGIN RSA PUBLIC KEY-----\nMEgC...&gt;&gt;

3&gt; file:write_file(&quot;rsa_pub_key.pem&quot;, PemBin).
ok</code></pre><p>or:</p><pre><code class="text">1&gt; PemEntry = public_key:pem_entry_encode('SubjectPublicKeyInfo', RSAPubKey).
{'SubjectPublicKeyInfo', &lt;&lt;48,92...&gt;&gt;, not_encrypted}

2&gt; PemBin = public_key:pem_encode([PemEntry]).
&lt;&lt;&quot;-----BEGIN PUBLIC KEY-----\nMFw...&gt;&gt;

3&gt; file:write_file(&quot;pub_key.pem&quot;, PemBin).
ok</code></pre><h2 id="rsa-public-key-cryptography" class="section-heading">
  <a href="#rsa-public-key-cryptography" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">RSA Public-Key Cryptography</span>
</h2>
<p>Suppose you have the following private key and a corresponding public key:</p><ul><li><code class="inline">PrivateKey = #'RSAPrivateKey{}'</code> and the plaintext <code class="inline">Msg = binary()</code></li><li><code class="inline">PublicKey = #'RSAPublicKey'{}</code></li></ul><p>Then you can proceed as follows:</p><p>Encrypt with the private key:</p><pre><code class="text">RsaEncrypted = public_key:encrypt_private(Msg, PrivateKey),
Msg = public_key:decrypt_public(RsaEncrypted, PublicKey),</code></pre><p>Encrypt with the public key:</p><pre><code class="text">RsaEncrypted = public_key:encrypt_public(Msg, PublicKey),
Msg = public_key:decrypt_private(RsaEncrypted, PrivateKey),</code></pre><blockquote><h4 class="info">Note</h4><p>You normally do only one of the encrypt or decrypt operations, and the peer
does the other. This normally used in legacy applications as a primitive
digital signature.</p></blockquote><h2 id="digital-signatures" class="section-heading">
  <a href="#digital-signatures" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Digital Signatures</span>
</h2>
<p>Suppose you have the following private key and a corresponding public key:</p><ul><li><code class="inline">PrivateKey = #'RSAPrivateKey{}'</code> or <code class="inline">#'DSAPrivateKey'{}</code> and the plaintext
<code class="inline">Msg = binary()</code></li><li><code class="inline">PublicKey = #'RSAPublicKey'{}</code> or <code class="inline">{integer(), #'DssParams'{}}</code></li></ul><p>Then you can proceed as follows:</p><pre><code class="text">Signature = public_key:sign(Msg, sha, PrivateKey),
true = public_key:verify(Msg, sha, Signature, PublicKey),</code></pre><blockquote><h4 class="info">Note</h4><p>You normally do only one of the sign or verify operations, and the peer does
the other.</p></blockquote><p>It can be appropriate to calculate the message digest before calling <code class="inline">sign</code> or
<code class="inline">verify</code>, and then use <code class="inline">none</code> as second argument:</p><pre><code class="text">Digest = crypto:sha(Msg),
Signature = public_key:sign(Digest, none, PrivateKey),
true = public_key:verify(Digest, none, Signature, PublicKey),</code></pre><p><a href="" id="verify_hostname"></a></p><h2 id="verifying-a-certificate-hostname" class="section-heading">
  <a href="#verifying-a-certificate-hostname" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Verifying a certificate hostname</span>
</h2>
<h3 id="background" class="section-heading">
  <a href="#background" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Background</span>
</h3>
<p>When a client checks a server certificate there are a number of checks available
like checks that the certificate is not revoked, not forged or not out-of-date.</p><p>There are however attacks that are not detected by those checks. Suppose a bad
guy has succeeded with a DNS infection. Then the client could believe it is
connecting to one host but ends up at another but evil one. Though it is evil,
it could have a perfectly legal certificate! The certificate has a valid
signature, it is not revoked, the certificate chain is not faked and has a
trusted root and so on.</p><p>To detect that the server is not the intended one, the client must additionally
perform a <em>hostname verification</em>. This procedure is described in
<a href="https://tools.ietf.org/html/rfc6125">RFC 6125</a>. The idea is that the
certificate lists the hostnames it could be fetched from. This is checked by the
certificate issuer when the certificate is signed. So if the certificate is
issued by a trusted root the client could trust the host names signed in it.</p><p>There is a default hostname matching procedure defined in
<a href="https://tools.ietf.org/html/rfc6125#section/6">RFC 6125, section 6</a> as well as
protocol dependent variations defined in
<a href="https://tools.ietf.org/html/rfc6125#appendix-B">RFC 6125 appendix B</a>. The
default procedure is implemented in
<a href="public_key.html#pkix_verify_hostname/2">public_key:pkix_verify_hostname/2,3</a>. It
is possible for a client to hook in modified rules using the options list.</p><p>Some terminology is needed: the certificate presents hostname(s) on which it is
valid. Those are called <em>Presented IDs</em>. The hostname(s) the client believes it
connects to are called <em>Reference IDs</em>. The matching rules aims to verify that
there is at least one of the Reference IDs that matches one of the Presented
IDs. If not, the verification fails.</p><p>The IDs contains normal fully qualified domain names like e.g <code class="inline">foo.example.com</code>,
but IP addresses are not recommended. The rfc describes why this is not
recommended as well as security considerations about how to acquire the
Reference IDs.</p><p>Internationalized domain names are not supported.</p><h3 id="the-verification-process" class="section-heading">
  <a href="#the-verification-process" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">The verification process</span>
</h3>
<p>Traditionally the Presented IDs were found in the <code class="inline">Subject</code> certificate field as
<code class="inline">CN</code> names. This is still quite common. When printing a certificate they show up
as:</p><pre><code class="text"> $ openssl x509 -text &lt; cert.pem
 ...
 Subject: C=SE, CN=example.com, CN=*.example.com, O=erlang.org
 ...</code></pre><p>The example <code class="inline">Subject</code> field has one C, two CN and one O part. It is only the CN
(Common Name) that is used by hostname verification. The two other (C and O) is
not used here even when they contain a domain name like the O part. The C and O
parts are defined elsewhere and meaningful only for other functions.</p><p>In the example the Presented IDs are <code class="inline">example.com</code> as well as hostnames matching
<code class="inline">*.example.com</code>. For example <code class="inline">foo.example.com</code> and <code class="inline">bar.example.com</code> both
matches but not <code class="inline">foo.bar.example.com</code>. The name <code class="inline">erlang.org</code> matches neither
since it is not a CN.</p><p>In case where the Presented IDs are fetched from the <code class="inline">Subject</code> certificate
field, the names may contain wildcard characters. The function handles this as
defined in
<a href="https://tools.ietf.org/html/rfc6125#section-6.4.3">chapter 6.4.3 in RFC 6125</a>.</p><p>There may only be one wildcard character and that is in the first label, for
example: <code class="inline">*.example.com</code>. This matches <code class="inline">foo.example.com</code> but neither
<code class="inline">example.com</code> nor <code class="inline">foo.bar.example.com</code>.</p><p>There may be label characters before or/and after the wildcard. For example:
<code class="inline">a*d.example.com</code> matches <code class="inline">abcd.example.com</code> and <code class="inline">ad.example.com</code>, but not
<code class="inline">ab.cd.example.com</code>.</p><p>In the previous example there is no indication of which protocols are expected.
So a client has no indication of whether it is a web server, an ldap server or
maybe a sip server it is connected to. There are fields in the certificate that
can indicate this. To be more exact, the rfc introduces the usage of the
<code class="inline">X509v3 Subject Alternative Name</code> in the <code class="inline">X509v3 extensions</code> field:</p><pre><code class="text"> $ openssl x509 -text &lt; cert.pem
 ...
 X509v3 extensions:
     X509v3 Subject Alternative Name:
         DNS:kb.example.org, URI:https://www.example.org
 ...</code></pre><p>Here <code class="inline">kb.example.org</code> serves any protocol while <code class="inline">www.example.org</code> presents a
secure web server.</p><p>The next example has both <code class="inline">Subject</code> and <code class="inline">Subject Alternate Name</code> present:</p><pre><code class="text"> $ openssl x509 -text &lt; cert.pem
 ...
 Subject: C=SE, CN=example.com, CN=*.example.com, O=erlang.org
 ...
 X509v3 extensions:
     X509v3 Subject Alternative Name:
         DNS:kb.example.org, URI:https://www.example.org
 ...</code></pre><p>The RFC states that if a certificate defines Reference IDs in a
<code class="inline">Subject Alternate Name</code> field, the <code class="inline">Subject</code> field MUST NOT be used for host
name checking, even if it contains valid CN names. Therefore only
<code class="inline">kb.example.org</code> and <code class="inline">https://www.example.org</code> matches. The match fails both for
<code class="inline">example.com</code> and <code class="inline">foo.example.com</code> because they are in the <code class="inline">Subject</code> field
which is not checked because the <code class="inline">Subject Alternate Name</code> field is present.</p><p><a href="" id="verify_hostname_examples"></a></p><h3 id="function-call-examples" class="section-heading">
  <a href="#function-call-examples" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Function call examples</span>
</h3>
<blockquote><h4 class="info">Note</h4><p>Other applications like ssl/tls or https might have options that are passed
down to the <code class="inline">public_key:pkix_verify_hostname</code>. You will probably not have to
call it directly</p></blockquote><p>Suppose our client expects to connect to the web server <a href="https://www.example.net">https://www.example.net</a>.
This URI is therefore the Reference IDs of the client. The call will be:</p><pre><code class="text"> public_key:pkix_verify_hostname(CertFromHost,
                                 [{uri_id, &quot;https://www.example.net&quot;}
                                 ]).</code></pre><p>The call will return <code class="inline">true</code> or <code class="inline">false</code> depending on the check. The caller do not
need to handle the matching rules in the rfc. The matching will proceed as:</p><ul><li>If there is a <code class="inline">Subject Alternate Name</code> field, the <code class="inline">{uri_id,string()}</code> in the
function call will be compared to any <code class="inline">{uniformResourceIdentifier,string()}</code>
in the Certificate field. If the two <code class="inline">strings()</code> are equal (case insensitive),
there is a match. The same applies for any <code class="inline">{dns_id,string()}</code> in the call
which is compared with all <code class="inline">{dNSName,string()}</code> in the Certificate field.</li><li>If there is NO <code class="inline">Subject Alternate Name</code> field, the <code class="inline">Subject</code> field will be
checked. All <code class="inline">CN</code> names will be compared to all hostnames <em>extracted</em> from
<code class="inline">{uri_id,string()}</code> and from <code class="inline">{dns_id,string()}</code>.</li></ul><h3 id="extending-the-search-mechanism" class="section-heading">
  <a href="#extending-the-search-mechanism" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Extending the search mechanism</span>
</h3>
<p>The caller can use own extraction and matching rules. This is done with the two
options <code class="inline">fqdn_fun</code> and <code class="inline">match_fun</code>.</p><p><a href="" id="hostname_extraction"></a></p><h4>Hostname extraction</h4><p>The <code class="inline">fqdn_fun</code> extracts hostnames (Fully Qualified Domain Names) from uri_id or
other ReferenceIDs that are not pre-defined in the public_key function. Suppose
you have some URI with a very special protocol-part: <code class="inline">myspecial://example.com&quot;</code>.
Since this a non-standard URI there will be no hostname extracted for matching
CN-names in the <code class="inline">Subject</code>.</p><p>To &quot;teach&quot; the function how to extract, you can give a fun which replaces the
default extraction function. The <code class="inline">fqdn_fun</code> takes one argument and returns
either a <code class="inline">t:string()</code> to be matched to each CN-name or the atom <code class="inline">default</code> which
will invoke the default fqdn extraction function. The return value <code class="inline">undefined</code>
removes the current URI from the fqdn extraction.</p><pre><code class="text"> ...
 Extract = fun({uri_id, &quot;myspecial://&quot;++HostName}) -&gt; HostName;
              (_Else) -&gt; default
           end,
 ...
 public_key:pkix_verify_hostname(CertFromHost, RefIDs,
                                 [{fqdn_fun, Extract}])
 ...</code></pre><p><a href="" id="redefining_match_op"></a></p><h4>Re-defining the match operation</h4><p>The default matching handles dns_id and uri_id. In an uri_id the value is tested
for equality with a value from the <code class="inline">Subject Alternate Name</code>. If some other kind
of matching is needed, use the <code class="inline">match_fun</code> option.</p><p>The <code class="inline">match_fun</code> takes two arguments and returns either <code class="inline">true</code>, <code class="inline">false</code> or
<code class="inline">default</code>. The value <code class="inline">default</code> will invoke the default match function.</p><pre><code class="text"> ...
 Match = fun({uri_id,&quot;myspecial://&quot;++A},
             {uniformResourceIdentifier,&quot;myspecial://&quot;++B}) -&gt;
                                                    my_match(A,B);
            (_RefID, _PresentedID) -&gt;
                                default
         end,
 ...
 public_key:pkix_verify_hostname(CertFromHost, RefIDs,
                                 [{match_fun, Match}]),
 ...</code></pre><p>In case of a match operation between a ReferenceID and a CN value from the
<code class="inline">Subject</code> field, the first argument to the fun is the extracted hostname from
the ReferenceID, and the second argument is the tuple <code class="inline">{cn, string()}</code> taken
from the <code class="inline">Subject</code> field. That makes it possible to have separate matching rules
for Presented IDs from the <code class="inline">Subject</code> field and from the <code class="inline">Subject Alternate Name</code>
field.</p><p>The default matching transformes the ascii values in strings to lowercase before
comparing. The <code class="inline">match_fun</code> is however called without any transformation applied
to the strings. The reason is to enable the user to do unforeseen handling of
the strings where the original format is needed.</p><h3 id="pinning-a-certificate" class="section-heading">
  <a href="#pinning-a-certificate" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">&quot;Pinning&quot; a Certificate</span>
</h3>
<p>The <a href="https://tools.ietf.org/html/rfc6125">RFC 6125</a> defines <em>pinning</em> as:</p><blockquote><p>&quot;The act of establishing a cached name association between the application
service's certificate and one of the client's reference identifiers, despite
the fact that none of the presented identifiers matches the given reference
identifier. ...&quot;</p></blockquote><p>The purpose is to have a mechanism for a human to accept an otherwise faulty
Certificate. In for example a web browser, you could get a question like</p><blockquote><p>Warning: you wanted to visit the site www.example.com, but the certificate is
for shop.example.com. Accept anyway (yes/no)?&quot;</p></blockquote><p>This could be accomplished with the option <code class="inline">fail_callback</code> which will be called
if the hostname verification fails:</p><pre><code class="text"> -include_lib(&quot;public_key/include/public_key.hrl&quot;). % Record def
 ...
 Fail = fun(#'OTPCertificate'{}=C) -&gt;
              case in_my_cache(C) orelse my_accept(C) of
                  true -&gt;
                       enter_my_cache(C),
                       true;
                  false -&gt;
                       false
         end,
 ...
 public_key:pkix_verify_hostname(CertFromHost, RefIDs,
                                 [{fail_callback, Fail}]),
 ...</code></pre>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="public_key_records.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Public-Key Records
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="public_key_app.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
public_key
        </span>
      </a>

  </div>
</div>
      <footer class="footer">
        <p>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
              Search HexDocs
            </button>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.30.9) for the

            <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

        </p>
      </footer>
    </div>
  </div>
</main>
</div>


  </body>
</html>
