<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.30.9">
    <meta name="project" content="observer v2.15.1">


    <title>Trace Tool Builder — observer v2.15.1</title>
    <link rel="stylesheet" href="dist/html-erlang-QW5RMTQD.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-43PMFBC7.js"></script>
    <script src="dist/sidebar_items-FDFFE937.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/html-LRUIU55G.js"></script>

<style>.dark img { background-color: white; }</style>
  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="api-reference.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="observer" />
        </a>

      <div>
        <a href="api-reference.html" class="sidebar-projectName" translate="no">
observer
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v2.15.1
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Pages
        </button>
      </li>

        <li>
          <button id="modules-list-tab-button" role="tab" data-type="modules" aria-controls="modules-tab-panel" aria-selected="false" tabindex="-1">
            Modules
          </button>
        </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>

    <div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden>
      <ul id="modules-full-list" class="full-list"></ul>
    </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">
      <div class="top-search">
        <div class="search-settings">
          <form class="search-bar" action="search.html">
            <label class="search-label">
              <span class="sr-only">Search documentation of observer</span>
              <input name="q" type="text" class="search-input" placeholder="Search Documentation (press /)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            </label>
            <button type="submit" class="search-button" aria-label="Submit Search">
              <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
            </button>
            <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
              <i class="ri-close-line ri-lg" title="Cancel search"></i>
            </button>
          </form>
          <button class="icon-settings display-settings">
            <i class="ri-settings-3-line"></i>
            <span class="sr-only">Settings</span>
          </button>
        </div>
      </div>
      <div class="autocomplete">
        <div class="autocomplete-results">
        </div>
      </div>

<h1>

    <a href="https://github.com/erlang/otp/blob/master/lib/observer/doc/guides/ttb_ug.md#L1" title="View Source" class="icon-action" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>


  <span>Trace Tool Builder</span>
</h1>

<h2 id="introduction" class="section-heading">
  <a href="#introduction" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Introduction</span>
</h2>
<p>Trace Tool Builder is a base for building trace tools for single node or
distributed Erlang systems. It requires the Runtime_Tools application to be
available on the traced node.</p><p>The following are the main features of Trace Tool Builder:</p><ul><li>Start tracing to file ports on many nodes with one function call.</li><li>Write more information to a trace information file, which is read during
formatting.</li><li>Restore previous configuration by maintaining a history buffer and handling
configuration files.</li><li>Provide some simple support for sequential tracing.</li><li>Format binary trace logs and merge logs from multiple nodes.</li></ul><p>The intention of Trace Tool Builder is to serve as a base for tailor-made trace
tools, but it can also be used directly from the Erlang shell (it can mimic
<code class="inline">dbg</code> behaviour while still providing useful additions, such as match
specification shortcuts). Trace Tool Builder only allows the use of file port
tracer, so to use other types of trace clients it is better to use <code class="inline">dbg</code>
directly.</p><h2 id="getting-started" class="section-heading">
  <a href="#getting-started" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Getting Started</span>
</h2>
<p>Module <code class="inline">ttb</code> is the interface to all functions in Trace Tool Builder.</p><p>To get started, the least you need to do is to start a tracer with
<a href="ttb.html#tracer/0"><code class="inline">ttb:tracer/0,1,2</code></a>, and set the required trace flags on the
processes you want to trace with <a href="ttb.html#p/2"><code class="inline">ttb:p/2</code></a>.</p><p>When the tracing is completed, stop the tracer with
<a href="ttb.html#stop/0"><code class="inline">ttb:stop/0,1</code></a> and format the trace log with
<a href="ttb.html#format/1"><code class="inline">ttb:format/1,2</code></a> (if there is anything to format).</p><p><em>Useful functions:</em></p><ul><li><p><strong><a href="ttb.html#tracer/0"><code class="inline">ttb:tracer/0,1,2</code></a></strong> - Opens a trace port on each node to
be traced. By default, trace messages are written to binary files on remote
nodes (the binary trace log).</p></li><li><p><strong><a href="ttb.html#p/2"><code class="inline">ttb:p/2</code></a></strong> - Specifies the processes to be traced. Trace flags specified in
this call specify what to trace on each process. This function can be called
many times if you like different trace flags to be set on different processes.</p></li><li><p><strong><a href="ttb.html#tp/2"><code class="inline">ttb:tp/2,3,4</code></a> or <a href="ttb.html#tpl/2"><code class="inline">ttb:tpl/2,3,4</code></a></strong> - If you
want to trace function calls (that is, if you have trace flag <code class="inline">call</code> set on
any process), you must also set trace patterns on the required function(s)
with <a href="ttb.html#tp/2"><code class="inline">ttb:tp/2,3,4</code></a> or <a href="ttb.html#tpl/2"><code class="inline">ttb:tpl/2,3,4</code></a>. A
function is only traced if it has a trace pattern. The trace pattern specifies
how to trace the function by using match specifications. Match specifications
are described in the <a href="../../../../lib/../erts/doc/html/index.html">ERTS User's Guide</a>.</p></li><li><p><strong><a href="ttb.html#stop/0"><code class="inline">ttb:stop/0,1</code></a></strong> - Stops tracing on all nodes, deletes all
trace patterns, and flushes the trace port buffer.</p></li><li><p><strong><a href="ttb.html#format/1"><code class="inline">ttb:format/1/2</code></a></strong> - Translates the binary trace logs into
something readable. By default, <code class="inline">ttb</code> presents each trace message as a line of
text, but you can also write your own handler to make more complex
interpretations of the trace information. A trace log can also be presented
graphically with application Event Tracer (ET).</p><p>If option <code class="inline">format</code> is specified to <a href="ttb.html#stop/1"><code class="inline">ttb:stop/1</code></a>, the formatting is
automatically done when stopping <code class="inline">ttb</code>.</p></li></ul><h3 id="tracing-local-node-from-erlang-shell" class="section-heading">
  <a href="#tracing-local-node-from-erlang-shell" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Tracing Local Node from Erlang Shell</span>
</h3>
<p>The following small module is used in the subsequent example:</p><pre><code class="text">-module(m).
-export([f/0]).
f() -&gt;
   receive
      From when is_pid(From) -&gt;
         Now = erlang:now(),
         From ! {self(),Now}
   end.</code></pre><p>The following example shows the basic use of <code class="inline">ttb</code> from the Erlang shell.
Default options are used both for starting the tracer and for formatting (the
custom fetch directory is however provided). This gives a trace log named
<code class="inline">Node-ttb</code> in the newly created directory, where <code class="inline">Node</code> is the node name. The
default handler prints the formatted trace messages in the shell:</p><pre><code class="text">(tiger@durin)47&gt; %% First I spawn a process running my test function
(tiger@durin)47&gt; Pid = spawn(m,f,[]).
&lt;0.125.0&gt;
(tiger@durin)48&gt;
(tiger@durin)48&gt; %% Then I start a tracer...
(tiger@durin)48&gt; ttb:tracer().
{ok,[tiger@durin]}
(tiger@durin)49&gt;
(tiger@durin)49&gt; %% and activate the new process for tracing
(tiger@durin)49&gt; %% function calls and sent messages.
(tiger@durin)49&gt; ttb:p(Pid,[call,send]).
{ok,[{&lt;0.125.0&gt;,[{matched,tiger@durin,1}]}]}
(tiger@durin)50&gt;
(tiger@durin)50&gt; %% Here I set a trace pattern on erlang:now/0
(tiger@durin)50&gt; %% The trace pattern is a simple match spec
(tiger@durin)50&gt; %% indicating that the return value should be
(tiger@durin)50&gt; %% traced. Refer to the reference_manual for
(tiger@durin)50&gt; %% the full list of match spec shortcuts
(tiger@durin)50&gt; %% available.
(tiger@durin)51&gt; ttb:tp(erlang,now,return).
{ok,[{matched,tiger@durin,1},{saved,1}]}
(tiger@durin)52&gt;
(tiger@durin)52&gt; %% I run my test (i.e. send a message to
(tiger@durin)52&gt; %% my new process)
(tiger@durin)52&gt; Pid ! self().
&lt;0.72.0&gt;
(tiger@durin)53&gt;
(tiger@durin)53&gt; %% And then I have to stop ttb in order to flush
(tiger@durin)53&gt; %% the trace port buffer
(tiger@durin)53&gt; ttb:stop([return, {fetch_dir, &quot;fetch&quot;}]).
{stopped, &quot;fetch&quot;}
(tiger@durin)54&gt;
(tiger@durin)54&gt; %% Finally I format my trace log
(tiger@durin)54&gt; ttb:format(&quot;fetch&quot;).
({&lt;0.125.0&gt;,{m,f,0},tiger@durin}) call erlang:now()
({&lt;0.125.0&gt;,{m,f,0},tiger@durin}) returned from erlang:now/0 -&gt;
{1031,133451,667611}
({&lt;0.125.0&gt;,{m,f,0},tiger@durin}) &lt;0.72.0&gt; !
{&lt;0.125.0&gt;,{1031,133451,667611}}
ok</code></pre><h3 id="build-your-own-tool" class="section-heading">
  <a href="#build-your-own-tool" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Build Your Own Tool</span>
</h3>
<p>The following example shows a simple tool for &quot;debug tracing&quot;, that is, tracing
of function calls with return values:</p><pre><code class="text">-module(mydebug).
-export([start/0,trc/1,stop/0,format/1]).
-export([print/4]).
%% Include ms_transform.hrl so that I can use dbg:fun2ms/2 to
%% generate match specifications.
-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).
%%% -------------Tool API-------------
%%% ----------------------------------
%%% Star the &quot;mydebug&quot; tool
start() -&gt;
    %% The options specify that the binary log shall be named
    %% &lt;Node&gt;-debug_log and that the print/4 function in this
    %% module shall be used as format handler
    ttb:tracer(all,[{file,&quot;debug_log&quot;},{handler,{{?MODULE,print},0}}]),
    %% All processes (existing and new) shall trace function calls
    %% We want trace messages to be sorted upon format, which requires
    %% timestamp flag. The flag is however enabled by default in ttb.
    ttb:p(all,call).

%%% Set trace pattern on function(s)
trc(M) when is_atom(M) -&gt;
    trc({M,'_','_'});
trc({M,F}) when is_atom(M), is_atom(F) -&gt;
    trc({M,F,'_'});
trc({M,F,_A}=MFA) when is_atom(M), is_atom(F) -&gt;
    %% This match spec shortcut specifies that return values shall
    %% be traced.
    MatchSpec = dbg:fun2ms(fun(_) -&gt; return_trace() end),
    ttb:tpl(MFA,MatchSpec).

%%% Format a binary trace log
format(Dir) -&gt;
    ttb:format(Dir).

%%% Stop the &quot;mydebug&quot; tool
stop() -&gt;
    ttb:stop(return).

%%% --------Internal functions--------
%%% ----------------------------------
%%% Format handler
print(_Out,end_of_trace,_TI,N) -&gt;
    N;
print(Out,Trace,_TI,N) -&gt;
    do_print(Out,Trace,N),
    N+1.

do_print(Out,{trace_ts,P,call,{M,F,A},Ts},N) -&gt;
    io:format(Out,
              &quot;~w: ~w, ~w:~n&quot;
              &quot;Call      : ~w:~w/~w~n&quot;
              &quot;Arguments :~p~n~n&quot;,
              [N,Ts,P,M,F,length(A),A]);
do_print(Out,{trace_ts,P,return_from,{M,F,A},R,Ts},N) -&gt;
    io:format(Out,
              &quot;~w: ~w, ~w:~n&quot;
              &quot;Return from  : ~w:~w/~w~n&quot;
              &quot;Return value :~p~n~n&quot;,
              [N,Ts,P,M,F,A,R]).</code></pre><p>To distinguish trace logs produced with this tool from other logs, option <code class="inline">file</code>
is used in <a href="ttb.html#tracer/2"><code class="inline">tracer/2</code></a>. The logs are therefore fetched to a
directory named <code class="inline">ttb_upload_debug_log-YYYYMMDD-HHMMSS</code></p><p>By using option <code class="inline">handler</code> when starting the tracer, the information about how to
format the file is stored in the trace information file (<code class="inline">.ti</code>). This is not
necessary, as it can be specified when formatting instead. However, It can be
useful if you, for example, want to format trace logs automatically using option
<code class="inline">format</code> in <a href="ttb.html#stop/1"><code class="inline">ttb:stop/1</code></a>. Also, you do not need any knowledge of the content of
a binary log to format it the way it is intended. If option <code class="inline">handler</code> is
specified both when starting the tracer and when formatting, the one specified
when formatting is used.</p><p>Trace flag <code class="inline">call</code> is set on all processes. This means that any function
activated with command <code class="inline">trc/1</code> is traced on all existing and new processes.</p><h2 id="running-trace-tool-builder-against-remote-node" class="section-heading">
  <a href="#running-trace-tool-builder-against-remote-node" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Running Trace Tool Builder against Remote Node</span>
</h2>
<p>The Observer application might not always be available on the node to be traced
(in the following called the &quot;traced node&quot;). However, Trace Tool Builder can
still be run from another node (in the following called the &quot;trace control
node&quot;) as long as the following is fulfilled:</p><ul><li>The Observer application is available on the trace control node.</li><li>The Runtime_Tools application is available on both the trace control node and
the traced node.</li></ul><p>If Trace Tool Builder is to be used against a remote node, it is highly
recommended to start the trace control node as <em>hidden</em>. This way it can connect
to the traced node without being &quot;seen&quot; by it, that is, if the <code class="inline">nodes()</code> BIF is
called on the traced node, the trace control node does not show. To start a
hidden node, add option <code class="inline">-hidden</code> to the <code class="inline">erl</code> command, for example:</p><pre><code class="text">% erl -sname trace_control -hidden</code></pre><h3 id="diskless-node" class="section-heading">
  <a href="#diskless-node" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Diskless Node</span>
</h3>
<p>If the traced node is diskless, <code class="inline">ttb</code> must be started from a trace control node
with disk access, and option <code class="inline">file</code> must be specified to function <code class="inline">tracer/2</code>
with value <code class="inline">{local, File}</code>, for example:</p><pre><code class="text">(trace_control@durin)1&gt; ttb:tracer(mynode@diskless,
                                   {file,{local,{wrap,&quot;mytrace&quot;}}}).
{ok,[mynode@diskless]}</code></pre><h2 id="more-tracing-options" class="section-heading">
  <a href="#more-tracing-options" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">More Tracing Options</span>
</h2>
<p>When setting up a trace, the following features can also be activated:</p><ul><li>Time-constrained tracing</li><li>Overload protection</li><li>Autoresume</li><li><code class="inline">dbg</code> mode</li></ul><h3 id="time-constrained-tracing" class="section-heading">
  <a href="#time-constrained-tracing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Time-Constrained Tracing</span>
</h3>
<p>It can sometimes be helpful to enable trace for a specified period of time (for
example, to monitor a system for 24 hours or half a second). This can be done
with option <code class="inline">{timer, TimerSpec}</code>. If <code class="inline">TimerSpec</code> has the form of <code class="inline">MSec</code>, the
trace is stopped after <code class="inline">MSec</code> milliseconds using <a href="ttb.html#stop/0"><code class="inline">ttb:stop/0</code></a>. If more options
are provided (<code class="inline">TimerSpec = {MSec, Opts}</code>), <a href="ttb.html#stop/1"><code class="inline">ttb:stop/1</code></a> is called instead with
<code class="inline">Opts</code> as argument.</p><p>The timer is started with <a href="ttb.html#p/2"><code class="inline">ttb:p/2</code></a>, so any trace patterns must be set up in
advance. <a href="ttb.html#start_trace/4"><code class="inline">ttb:start_trace/4</code></a> always sets up all patterns before invoking
<a href="ttb.html#p/2"><code class="inline">ttb:p/2</code></a>.</p><p>The following example shows how to set up a trace that is automatically stopped
and formatted after 5 seconds:</p><pre><code class="text">(tiger@durin)1&gt; ttb:start_trace([node()],
                                [{erlang, now,[]}],
                                {all, call},
                                [{timer, {5000, format}}]).</code></pre><blockquote><h4 class="info">Note</h4><p>Because of network and processing delays, the period of tracing is
approximate.</p></blockquote><h3 id="overload-protection" class="section-heading">
  <a href="#overload-protection" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Overload Protection</span>
</h3>
<p>When tracing live systems, always take special care to not overload a node with
too heavy tracing. <code class="inline">ttb</code> provides option <code class="inline">overload</code> to address this problem.</p><p><code class="inline">{overload, MSec, Module, Function}</code> instructs the <code class="inline">ttb</code> back end (a part of the
<a href="../../../../lib/runtime_tools/doc/html/index.html">Runtime_Tools</a> application) to perform overload
check every <code class="inline">MSec</code> millisecond. If the check (named <code class="inline">Module:Function(check)</code>)
returns <code class="inline">true</code>, tracing is disabled on the selected node.</p><p>Overload protection activated on one node does not affect other nodes, where the
tracing continues as normal. <a href="ttb.html#stop/0"><code class="inline">ttb:stop/0</code></a> fetches data from all clients,
including everything collected before the activation of overload protection.</p><blockquote><h4 class="info">Note</h4><p>It is not allowed to change trace details (with <a href="ttb.html#p/2"><code class="inline">ttb:p/2</code></a> and <code class="inline">ttb:tp/tpl...</code>)
once overload protection is activated in one of the traced nodes. This is to
avoid trace setup being inconsistent between nodes.</p></blockquote><p><code class="inline">Module:Function</code> provided with option <code class="inline">overload</code> must handle three calls:
<code class="inline">init</code>, <code class="inline">check</code>, and <code class="inline">stop</code>. <code class="inline">init</code> and <code class="inline">stop</code> allow some setup and teardown
required by the check. An overload check module can look as follows:</p><pre><code class="text">-module(overload).
-export([check/1]).

check(init) -&gt;
    Pid = sophisticated_module:start(),
    put(pid, Pid);
check(check) -&gt;
    get(pid) ! is_overloaded,
    receive
        Reply -&gt;
            Reply
    after 5000 -&gt;
            true
    end;
check(stop) -&gt;
    get(pid) ! stop.</code></pre><blockquote><h4 class="info">Note</h4><p><code class="inline">check</code> is always called by the same process, so <code class="inline">put</code> and <code class="inline">get</code> are possible.</p></blockquote><h3 id="autoresume" class="section-heading">
  <a href="#autoresume" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Autoresume</span>
</h3>
<p>A node can crash (probably a buggy one, hence traced). Use <code class="inline">resume</code> to resume
tracing on the node automatically when it gets back. The failing node then tries
to reconnect to trace control node when <code class="inline">Runtime_Tools</code> is started. This implies
that <code class="inline">Runtime_Tools</code> must be included in the startup chain of other nodes (if
not, you can still resume tracing by starting <code class="inline">Runtime_Tools</code> manually, that is,
by an RPC call).</p><p>To not lose the data that the failing node stored up to the point of crash, the
control node tries to fetch it before restarting trace. This must occur within
the allowed time frame, otherwise it is aborted (default is 10 seconds, but it
can be changed with <code class="inline">{resume, MSec}</code>). The data fetched this way is then merged
with all other traces.</p><p>The autostart feature requires more data to be stored on traced nodes. By
default, the data is stored automatically to the file named &quot;ttb_autostart.bin&quot;
in the current working directory (cwd) of the traced node. Users can change this
behaviour (that is, on diskless nodes) by specifying their own module to handle
autostart data storage and retrieval (<code class="inline">ttb_autostart_module</code> environment
variable of <code class="inline">runtime_tools</code>). For information about the API, see module <a href="ttb.html"><code class="inline">ttb</code></a>.
The following example shows the default handler:</p><pre><code class="text">-module(ttb_autostart).
-export([read_config/0,
         write_config/1,
         delete_config/0]).

-define(AUTOSTART_FILENAME, &quot;ttb_autostart.bin&quot;).

delete_config() -&gt;
    file:delete(?AUTOSTART_FILENAME).

read_config() -&gt;
    case file:read_file(?AUTOSTART_FILENAME) of
        {ok, Data} -&gt; {ok, binary_to_term(Data)};
        Error      -&gt; Error
    end.

write_config(Data) -&gt;
    file:write_file(?AUTOSTART_FILENAME, term_to_binary(Data)).</code></pre><blockquote><h4 class="info">Note</h4><p>Remember that file trace ports buffer the data by default. If the node
crashes, trace messages are not flushed to the binary log. If the risk of
failure is high, it can be a good idea to flush the buffers every now and then
automatically. Passing <code class="inline">{flush, MSec}</code> as an option of <a href="ttb.html#tracer/2"><code class="inline">ttb:tracer/2</code></a> flushes
all buffers every <code class="inline">MSec</code> millisecond.</p></blockquote><h3 id="dbg-mode" class="section-heading">
  <a href="#dbg-mode" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">dbg Mode</span>
</h3>
<p>Option <code class="inline">{shell, ShellType}</code> allows making <code class="inline">ttb</code> operation similar to <a href="../../../../lib/runtime_tools/doc/html/dbg.html"><code class="inline">dbg</code></a>.
Using <code class="inline">{shell, true}</code> displays all trace messages in the shell before storing
them. <code class="inline">{shell, only}</code> additionally disables message storage (making the tool to
behave exactly like <code class="inline">dbg</code>). This is allowed only with IP trace ports
(<code class="inline">{trace, {local, File}}</code>).</p><p>Command <code class="inline">ttb:tracer(dbg)</code> is a shortcut for the pure <code class="inline">dbg</code> mode
(<code class="inline">{shell, only}</code>).</p><p><a href="" id="trace_info"></a></p><h2 id="trace-information-and-file-ti" class="section-heading">
  <a href="#trace-information-and-file-ti" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Trace Information and File .ti</span>
</h2>
<p>In addition to the trace log file(s), a file with extension <code class="inline">.ti</code> is created
when Trace Tool Builder is started. This is the trace information file. It is a
binary file, which contains the process information, trace flags used, the name
of the node to which it belongs, and all information written with function
<a href="ttb.html#write_trace_info/2"><code class="inline">ttb:write_trace_info/2</code></a>. <code class="inline">.ti</code> files are always fetched with other logs when
the trace is stopped.</p><p>Except for the process information, everything in the trace information file is
passed on to the handler function when formatting. Parameter <code class="inline">TI</code> is a list of
<code class="inline">{Key,ValueList}</code> tuples. The keys <code class="inline">flags</code>, <code class="inline">handler</code>, <code class="inline">file</code>, and <code class="inline">node</code> are
used for information written directly by <code class="inline">ttb</code>.</p><p>Information to the trace information file by can be added by calling
<a href="ttb.html#write_trace_info/2"><code class="inline">ttb:write_trace_info/2</code></a>. Notice that <code class="inline">ValueList</code> always is a list, and if you
call <code class="inline">write_trace_info/2</code> many times with the same <code class="inline">Key</code>, the <code class="inline">ValueList</code> is
extended with a new value each time.</p><p><em>Example:</em></p><p><code class="inline">ttb:write_trace_info(mykey,1)</code> gives the entry <code class="inline">{mykey,[1]}</code> in <code class="inline">TI</code>. Another
call, <code class="inline">ttb:write_trace_info(mykey,2)</code>, changes this entry to <code class="inline">{mykey,[1,2]}</code>.</p><h2 id="wrap-logs" class="section-heading">
  <a href="#wrap-logs" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Wrap Logs</span>
</h2>
<p>If you want to limit the size of the trace logs, you can use wrap logs. This
works almost like a circular buffer. You can specify the maximum number of
binary logs and the maximum size of each log. <code class="inline">ttb</code> then creates a new binary
log each time a log reaches the maximum size. When the maximum number of logs
are reached, the oldest log is deleted before a new one is created.</p><blockquote><h4 class="info">Note</h4><p>The overall size of data generated by <code class="inline">ttb</code> can be greater than the wrap
specification suggests. If a traced node restarts and autoresume is enabled,
the old wrap log is always stored and a new one is created.</p></blockquote><p>Wrap logs can be formatted one by one or all at once. See
<a href="ttb_ug.html#format">Formatting</a>.</p><p><a href="" id="format"></a></p><h2 id="formatting" class="section-heading">
  <a href="#formatting" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Formatting</span>
</h2>
<p>Formatting can be done automatically when stopping <code class="inline">ttb</code> (see section
<a href="ttb_ug.html#fetch_format">Automatically Collect and Format Logs from All Nodes</a>),
or explicitly by calling function <code class="inline">ttb:format/1,2</code>.</p><p>Formatting means to read a binary log and present it in a readable format. You
can use the default format handler in <code class="inline">ttb</code> to present each trace message as a
line of text, or write your own handler to make more complex interpretations of
the trace information. You can also use application ET to present the trace log
graphically (see section
<a href="ttb_ug.html#et_viewer">Presenting Trace Logs with Event Tracer</a>).</p><p>The first argument to <code class="inline">ttb:format/1,2</code> specifies which binary log(s) to format.
This is usually the name of a directory that <code class="inline">ttb</code> created during log fetch.
Unless option <code class="inline">disable_sort</code> is provided, the logs from different files are
always sorted according to time-stamp in traces.</p><p>The second argument to <a href="ttb.html#format/2"><code class="inline">ttb:format/2</code></a> is a list of options as follows:</p><ul><li><p><strong><code class="inline">out</code></strong> - Specifies the destination to write the formatted text. Default
destination is <code class="inline">standard_io</code>, but a filename can also be specified.</p></li><li><p><strong><code class="inline">handler</code></strong> - Specifies the format handler to use. If this option is not
specified, option <code class="inline">handler</code> that is specified when starting the tracer is
used. If option <code class="inline">handler</code> is not specified when starting the tracer either, a
default handler is used, which prints each trace message as a text line.</p></li><li><p><strong><code class="inline">disable_sort</code></strong> - Indicates that the logs are not to be merged according to
time-stamp, but processed one file after another (this can be a bit faster).</p></li></ul><p>A format handler is a fun taking four arguments. This fun is called for each
trace message in the binary log(s). A simple example that only prints each trace
message can be as follows:</p><pre><code class="text">fun(Fd, Trace, _TraceInfo, State) -&gt;
   io:format(Fd, &quot;Trace: ~p~n&quot;, [Trace]),
   State
end.</code></pre><p>Here, <code class="inline">Fd</code> is the file descriptor for the destination file, or the atom
<code class="inline">standard_io</code>. <code class="inline">_TraceInfo</code> contains information from the trace information file
(see section <a href="ttb_ug.html#trace_info">Trace Information and File .ti</a>). <code class="inline">State</code> is
a state variable for the format handler fun. The initial value of variable
<code class="inline">State</code> is specified with the handler option, for example:</p><pre><code class="text">ttb:format(&quot;tiger@durin-ttb&quot;, [{handler, {{Mod,Fun}, initial_state}}])
                                                     ^^^^^^^^^^^^^</code></pre><p>Another format handler can be used to calculate the time spent by the garbage
collector:</p><pre><code class="text">fun(_Fd,{trace_ts,P,gc_start,_Info,StartTs},_TraceInfo,State) -&gt;
      [{P,StartTs}|State];
   (Fd,{trace_ts,P,gc_end,_Info,EndTs},_TraceInfo,State) -&gt;
      {value,{P,StartTs}} = lists:keysearch(P,1,State),
      Time = diff(StartTs,EndTs),
      io:format(&quot;GC in process ~w: ~w milliseconds~n&quot;, [P,Time]),
      State -- [{P,StartTs}]
end</code></pre><p>A more refined version of this format handler is function <code class="inline">handle_gc/4</code> in
module <code class="inline">multitrace.erl</code> included in directory <code class="inline">src</code> of the Observer application.</p><p>The trace message is passed as the second argument (<code class="inline">Trace</code>). The possible
values of <code class="inline">Trace</code> are the following:</p><ul><li>All trace messages described in <a href="../../../../lib/../erts/doc/html/erlang.html#trace/3"><code class="inline">erlang:trace/3</code></a></li><li><code class="inline">{drop, N}</code> if IP tracer is used (see <a href="../../../../lib/runtime_tools/doc/html/dbg.html#trace_port/2"><code class="inline">dbg:trace_port/2</code></a>)</li><li><code class="inline">end_of_trace</code> received once when all trace messages are processed</li></ul><p>By giving the format handler <a href="ttb.html#get_et_handler/0"><code class="inline">ttb:get_et_handler()</code></a>,
you can have the trace log presented graphically with <code class="inline">et_viewer</code> in the ET
application (see section
<a href="ttb_ug.html#et_viewer">Presenting Trace Logs with Event Tracer</a>).</p><p>You can always decide not to format the whole trace data contained in the fetch
directory, but analyze single files instead. To do so, a single file (or list of
files) must be passed as the first argument to <code class="inline">format/1,2</code>.</p><p>Wrap logs can be formatted one by one or all at once. To format one of the wrap
logs in a set, specify the exact file name. To format the whole set of wrap
logs, specify the name with <code class="inline">*</code> instead of the wrap count.</p><p><em>Example:</em></p><p>Start tracing:</p><pre><code class="text">(tiger@durin)1&gt; ttb:tracer(node(),{file,{wrap,&quot;trace&quot;}}).
{ok,[tiger@durin]}
(tiger@durin)2&gt; ttb:p(...)
...</code></pre><p>This gives a set of binary logs, for example:</p><pre><code class="text">tiger@durin-trace.0.wrp
tiger@durin-trace.1.wrp
tiger@durin-trace.2.wrp
...</code></pre><p>Format the whole set of logs:</p><pre><code class="text">1&gt; ttb:format(&quot;tiger@durin-trace.*.wrp&quot;).
....
ok
2&gt;</code></pre><p>Format only the first log:</p><pre><code class="text">1&gt; ttb:format(&quot;tiger@durin-trace.0.wrp&quot;).
....
ok
2&gt;</code></pre><p>To merge all wrap logs from two nodes:</p><pre><code class="text">1&gt; ttb:format([&quot;tiger@durin-trace.*.wrp&quot;,&quot;lion@durin-trace.*.wrp&quot;]).
....
ok
2&gt;</code></pre><p><a href="" id="et_viewer"></a></p><h3 id="presenting-trace-logs-with-event-tracer" class="section-heading">
  <a href="#presenting-trace-logs-with-event-tracer" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Presenting Trace Logs with Event Tracer</span>
</h3>
<p>For detailed information about the Event Tracer, see the <a href="../../../../lib/et/doc/html/index.html">ET</a>
application.</p><p>By giving the format handler <a href="ttb.html#get_et_handler/0"><code class="inline">ttb:get_et_handler()</code></a>,
you can have the trace log presented graphically with <code class="inline">et_viewer</code> in the ET
application. <code class="inline">ttb</code> provides filters that can be selected from the menu <em>Filter</em>
in the <code class="inline">et_viewer</code> window. The filters are names according to the type of actors
they present (that is, what each vertical line in the sequence diagram
represents). Interaction between actors is shown as red arrows between two
vertical lines, and activities within an actor are shown as blue text to the
right of the actors line.</p><p>The <code class="inline">processes</code> filter is the only filter showing all trace messages from a
trace log. Each vertical line in the sequence diagram represents a process.
Erlang messages, spawn, and link/unlink are typical interactions between
processes. Function calls, scheduling, and garbage collection, are typical
activities within a process. <code class="inline">processes</code> is the default filter.</p><p>The remaining filters only show function calls and function returns. All other
trace message are discarded. To get the most out of these filters, <code class="inline">et_viewer</code>
must know the caller of each function and the time of return. This can be
obtained using both the <code class="inline">call</code> and <code class="inline">return_to</code> flags when tracing. Notice that
flag <code class="inline">return_to</code> only works with local call trace, that is, when trace patterns
are set with <code class="inline">ttb:tpl</code>.</p><p>The same result can be obtained by using the flag <code class="inline">call</code> only and setting a
match specification on local or global function calls as follows:</p><pre><code class="text">1&gt; dbg:fun2ms(fun(_) -&gt; return_trace(),message(caller()) end).
[{'_',[],[{return_trace},{message,{caller}}]}]</code></pre><p>This must however be done with care, as function <code class="inline">{return_trace}</code> in the match
specification destroys tail recursiveness.</p><p>The <code class="inline">modules</code> filter shows each module as a vertical line in the sequence
diagram. External function calls/returns are shown as interactions between
modules, and internal function calls/returns are shown as activities within a
module.</p><p>The <code class="inline">functions</code> filter shows each function as a vertical line in the sequence
diagram. A function calling itself is shown as an activity within a function,
and all other function calls are shown as interactions between functions.</p><p>The <code class="inline">mods_and_procs</code> and <code class="inline">funcs_and_procs</code> filters are equivalent to the
<code class="inline">modules</code> and <code class="inline">functions</code> filters respectively, except that each module or
function can have many vertical lines, one for each process it resides on.</p><p>In the following example, modules <code class="inline">foo</code> and <code class="inline">bar</code> are used:</p><pre><code class="text">-module(foo).
-export([start/0,go/0]).

start() -&gt;
    spawn(?MODULE, go, []).

go() -&gt;
    receive
        stop -&gt;
            ok;
        go -&gt;
            bar:f1(),
            go()
    end.</code></pre><pre><code class="text">-module(bar).
-export([f1/0,f3/0]).
f1() -&gt;
    f2(),
    ok.
f2() -&gt;
    spawn(?MODULE,f3,[]).
f3() -&gt;
    ok.</code></pre><p>Setting up the trace:</p><pre><code class="text">(tiger@durin)1&gt; %%First we retrieve the Pid to limit traced processes set
(tiger@durin)1&gt; Pid = foo:start().
(tiger@durin)2&gt; %%Now we set up tracing
(tiger@durin)2&gt; ttb:tracer().
(tiger@durin)3&gt; ttb:p(Pid, [call, return_to, procs, set_on_spawn]).
(tiger@durin)4&gt; ttb:tpl(bar, []).
(tiger@durin)5&gt; %%Invoke our test function and see output with et viewer
(tiger@durin)5&gt; Pid ! go.
(tiger@durin)6&gt; ttb:stop({format, {handler, ttb:get_et_handler()}}).</code></pre><p>This renders a result similar to the following:</p><p><img src="assets/et_processes.gif" alt="Filter: &quot;processes&quot;" title="Filter: "processes""/></p><p><img src="assets/et_modsprocs.gif" alt="Filter: &quot;mods_and_procs&quot;" title="Filter: "mods_and_procs""/></p><p>Notice that function <a href="ttb.html#start_trace/4"><code class="inline">ttb:start_trace/4</code></a> can be used as help as follows:</p><pre><code class="text">(tiger@durin)1&gt; Pid = foo:start().
(tiger@durin)2&gt; ttb:start_trace([node()],
                                [{bar,[]}],
                                {Pid, [call, return_to, procs, set_on_spawn]}
                                {handler, ttb:get_et_handler()}).
(tiger@durin)3&gt; Pid ! go.
(tiger@durin)4&gt; ttb:stop(format).</code></pre><p><a href="" id="fetch_format"></a></p><h2 id="automatically-collect-and-format-logs-from-all-nodes" class="section-heading">
  <a href="#automatically-collect-and-format-logs-from-all-nodes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Automatically Collect and Format Logs from All Nodes</span>
</h2>
<p>By default, <a href="ttb.html#stop/1"><code class="inline">ttb:stop/1</code></a> fetches trace logs and trace information files from all
nodes. The logs are stored in a new directory named
<code class="inline">ttb_upload-Filename-Timestamp</code> under the working directory of the trace control
node. Fetching can be disabled by providing option <code class="inline">nofetch</code> to <a href="ttb.html#stop/1"><code class="inline">ttb:stop/1</code></a>.
The user can specify a fetch directory by passing option <code class="inline">{fetch_dir, Dir}</code>.</p><p>If option <code class="inline">format</code> is specified to <a href="ttb.html#stop/1"><code class="inline">ttb:stop/1</code></a>, the trace logs are
automatically formatted after tracing is stopped.</p><h2 id="history-and-configuration-files" class="section-heading">
  <a href="#history-and-configuration-files" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">History and Configuration Files</span>
</h2>
<p>For the tracing functionality, <a href="../../../../lib/runtime_tools/doc/html/dbg.html"><code class="inline">dbg</code></a> can be used instead of <code class="inline">ttb</code> for setting
trace flags on processes and trace patterns for call trace, that is, the
functions <code class="inline">p</code>, <code class="inline">tp</code>, <code class="inline">tpl</code>, <code class="inline">ctp</code>, <code class="inline">ctpl</code>, and <code class="inline">ctpg</code>. Only the following two
things are added by <code class="inline">ttb</code> for these functions:</p><ul><li>All calls are stored in the history buffer and can be recalled and stored in a
configuration file. This makes it easy to set up the same trace environment,
for example, if you want to compare two test runs. It also reduces the amount
of typing when using <code class="inline">ttb</code> from the Erlang shell.</li><li>Shortcuts are provided for the most common match specifications (to not force
you to use <a href="../../../../lib/runtime_tools/doc/html/dbg.html#fun2ms/1"><code class="inline">dbg:fun2ms</code></a> continually).</li></ul><p>Use <a href="ttb.html#list_history/0"><code class="inline">ttb:list_history/0</code></a> to see the content of the history buffer and
<a href="ttb.html#run_history/1"><code class="inline">ttb:run_history/1</code></a> to re-execute one of the entries.</p><p>The main purpose of the history buffer is the possibility to create
configuration files. Any function stored in the history buffer can be written to
a configuration file and used for creating a specific configuration at any time
with a single function call.</p><p>A configuration file is created or extended with
<a href="ttb.html#write_config/2"><code class="inline">ttb:write_config/2,3</code></a>. Configuration files are binary
files and can therefore only be read and written with functions provided by
<code class="inline">ttb</code>.</p><p>The complete content of the history buffer can be written to a configuration
file by calling <code class="inline">ttb:write_config(ConfigFile,all)</code>. Selected entries from the
history can be written by calling <code class="inline">ttb:write_config(ConfigFile,NumList)</code>, where
<code class="inline">NumList</code> is a list of integers pointing out the history entries to write.
Moreover, the history buffer is always dumped to <code class="inline">ttb_last_config</code> when
<code class="inline">ttb:stop/0,1</code> is called.</p><p>User-defined entries can also be written to a configuration file by calling
function <code class="inline">ttb:write_config(ConfigFile,ConfigList)</code>, where <code class="inline">ConfigList</code> is a list
of <code class="inline">{Module,Function,Args}</code>.</p><p>Any existing file <code class="inline">ConfigFile</code> is deleted and a new file is created when
<code class="inline">write_config/2</code> is called. Option <code class="inline">append</code> can be used to add something at the
end of an existing configuration file, for example,
<code class="inline">ttb:write_config(ConfigFile,What,[append])</code>.</p><p><em>Example:</em></p><p>See the content of the history buffer:</p><pre><code class="text">(tiger@durin)191&gt; ttb:tracer().
{ok,[tiger@durin]}
(tiger@durin)192&gt; ttb:p(self(),[garbage_collection,call]).
{ok,{[&lt;0.1244.0&gt;],[garbage_collection,call]}}
(tiger@durin)193&gt; ttb:tp(ets,new,2,[]).
{ok,[{matched,1}]}
(tiger@durin)194&gt; ttb:list_history().
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}}]</code></pre><p>Execute an entry from the history buffer:</p><pre><code class="text">(tiger@durin)195&gt; ttb:ctp(ets,new,2).
{ok,[{matched,1}]}
(tiger@durin)196&gt; ttb:list_history().
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}}]
(tiger@durin)197&gt; ttb:run_history(3).
ttb:tp(ets,new,2,[]) -&gt;
{ok,[{matched,1}]}</code></pre><p>Write the content of the history buffer to a configuration file:</p><pre><code class="text">(tiger@durin)198&gt; ttb:write_config(&quot;myconfig&quot;,all).
ok
(tiger@durin)199&gt; ttb:list_config(&quot;myconfig&quot;).
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}},
 {5,{ttb,tp,[ets,new,2,[]]}}]</code></pre><p>Extend an existing configuration:</p><pre><code class="text">(tiger@durin)200&gt; ttb:write_config(&quot;myconfig&quot;,[{ttb,tp,[ets,delete,1,[]]}],
[append]).
ok
(tiger@durin)201&gt; ttb:list_config(&quot;myconfig&quot;).
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}},
 {5,{ttb,tp,[ets,new,2,[]]}},
 {6,{ttb,tp,[ets,delete,1,[]]}}]</code></pre><p>Go back to a previous configuration after stopping Trace Tool Builder:</p><pre><code class="text">(tiger@durin)202&gt; ttb:stop().
ok
(tiger@durin)203&gt; ttb:run_config(&quot;myconfig&quot;).
ttb:tracer(tiger@durin,[]) -&gt;
{ok,[tiger@durin]}

ttb:p(&lt;0.1244.0&gt;,[garbage_collection,call]) -&gt;
{ok,{[&lt;0.1244.0&gt;],[garbage_collection,call]}}

ttb:tp(ets,new,2,[]) -&gt;
{ok,[{matched,1}]}

ttb:ctp(ets,new,2) -&gt;
{ok,[{matched,1}]}

ttb:tp(ets,new,2,[]) -&gt;
{ok,[{matched,1}]}

ttb:tp(ets,delete,1,[]) -&gt;
{ok,[{matched,1}]}

ok</code></pre><p>Write selected entries from the history buffer to a configuration file:</p><pre><code class="text">(tiger@durin)204&gt; ttb:list_history().
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,ctp,[ets,new,2]}},
 {5,{ttb,tp,[ets,new,2,[]]}},
 {6,{ttb,tp,[ets,delete,1,[]]}}]
(tiger@durin)205&gt; ttb:write_config(&quot;myconfig&quot;,[1,2,3,6]).
ok
(tiger@durin)206&gt; ttb:list_config(&quot;myconfig&quot;).
[{1,{ttb,tracer,[tiger@durin,[]]}},
 {2,{ttb,p,[&lt;0.1244.0&gt;,[garbage_collection,call]]}},
 {3,{ttb,tp,[ets,new,2,[]]}},
 {4,{ttb,tp,[ets,delete,1,[]]}}]
(tiger@durin)207&gt;</code></pre><h2 id="sequential-tracing" class="section-heading">
  <a href="#sequential-tracing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sequential Tracing</span>
</h2>
<p>To learn what sequential tracing is and how it can be used, see the Reference
Manual for <a href="../../../../lib/kernel/doc/html/seq_trace.html"><code class="inline">seq_trace</code></a>.</p><p>The support for sequential tracing provided by Trace Tool Builder includes the
following:</p><ul><li>Initiation of the system tracer. This is automatically done when a trace port
is started with <a href="ttb.html#tracer/0"><code class="inline">ttb:tracer/0,1,2</code></a>.</li><li>Creation of match specifications that activates sequential tracing.</li></ul><p>Starting sequential tracing requires that a tracer is started with function
<code class="inline">ttb:tracer/0,1,2</code>. Sequential tracing can then be started in either of the
following ways:</p><ul><li>Through a trigger function with a match specification created with
<a href="ttb.html#seq_trigger_ms/0"><code class="inline">ttb:seq_trigger_ms/0,1</code></a>.</li><li>Directly by using module <a href="../../../../lib/kernel/doc/html/seq_trace.html"><code class="inline">seq_trace</code></a>.</li></ul><p><em>Example 1:</em></p><p>In the following example, function <a href="../../../../lib/runtime_tools/doc/html/dbg.html#get_tracer/0"><code class="inline">dbg:get_tracer/0</code></a> is used as trigger for
sequential tracing:</p><pre><code class="text">(tiger@durin)110&gt; ttb:tracer().
{ok,[tiger@durin]}
(tiger@durin)111&gt; ttb:p(self(),call).
{ok,{[&lt;0.158.0&gt;],[call]}}
(tiger@durin)112&gt; ttb:tp(dbg,get_tracer,0,ttb:seq_trigger_ms(send)).
{ok,[{matched,1},{saved,1}]}
(tiger@durin)113&gt; dbg:get_tracer(), seq_trace:reset_trace().
true
(tiger@durin)114&gt; ttb:stop(format).
({&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin}) call dbg:get_tracer()
SeqTrace [0]: ({&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin})
{&lt;0.237.0&gt;,dbg,tiger@durin} ! {&lt;0.158.0&gt;,{get_tracer,tiger@durin}}
[Serial: {0,1}]
SeqTrace [0]: ({&lt;0.237.0&gt;,dbg,tiger@durin})
{&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin} ! {dbg,{ok,#Port&lt;0.222&gt;}}
[Serial: {1,2}]
ok
(tiger@durin)116&gt;</code></pre><p><em>Example 2:</em></p><p>Starting sequential tracing with a trigger is more useful if the trigger
function is not called directly from the shell, but rather implicitly within a
larger system. When calling a function from the shell, it is simpler to start
sequential tracing directly, for example, as follows:</p><pre><code class="text">(tiger@durin)116&gt; ttb:tracer().
{ok,[tiger@durin]}
(tiger@durin)117&gt; seq_trace:set_token(send,true), dbg:get_tracer(),
seq_trace:reset_trace().
true
(tiger@durin)118&gt; ttb:stop(format).
SeqTrace [0]: ({&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin})
{&lt;0.246.0&gt;,dbg,tiger@durin} ! {&lt;0.158.0&gt;,{get_tracer,tiger@durin}}
[Serial: {0,1}]
SeqTrace [0]: ({&lt;0.246.0&gt;,dbg,tiger@durin})
{&lt;0.158.0&gt;,{shell,evaluator,3},tiger@durin} ! {dbg,{ok,#Port&lt;0.229&gt;}}
[Serial: {1,2}]
ok
(tiger@durin)120&gt;</code></pre><p>In both previous examples, <a href="../../../../lib/kernel/doc/html/seq_trace.html#reset_trace/0"><code class="inline">seq_trace:reset_trace/0</code></a> resets the trace token
immediately after the traced function to avoid many trace messages because of
the printouts in the Erlang shell.</p><p>All functions in module <code class="inline">seq_trace</code>, except <code class="inline">set_system_tracer/1</code>, can be used
after the trace port is started with <code class="inline">ttb:tracer/0,1,2</code>.</p><h2 id="multipurpose-trace-tool" class="section-heading">
  <a href="#multipurpose-trace-tool" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Multipurpose Trace Tool</span>
</h2>
<p>Module <code class="inline">multitrace</code> in directory <code class="inline">src</code> of the Observer application provides a
small tool with three possible trace settings. The trace messages are written to
binary files, which can be formatted with function <code class="inline">multitrace:format/1,2</code>:</p><ul><li><p><strong><code class="inline">multitrace:debug(What)</code></strong> - Start calltrace on all processes and trace the
specified function(s). The format handler used is <code class="inline">multitrace:handle_debug/4</code>
that prints each call and returns. <code class="inline">What</code> must be an item or a list of items
to trace, specified on the format <code class="inline">{Module,Function,Arity}</code>,
<code class="inline">{Module,Function}</code>, or only <code class="inline">Module</code>.</p></li><li><p><strong><code class="inline">multitrace:gc(Procs)</code></strong> - Trace garbage collection on the specified
process(es). The format handler used is <code class="inline">multitrace:handle_gc/4</code> that prints
start, stop, and the time spent for each garbage collection.</p></li><li><p><strong><code class="inline">multitrace:schedule(Procs)</code></strong> - Trace in-scheduling and out-scheduling on
the specified process(es). The format handler used is
<code class="inline">multitrace:handle_schedule/4</code> that prints each in-scheduling and
out-scheduling with process, time-stamp, and current function. It also prints
the total time each traced process was scheduled in.</p></li></ul>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="observer_ug.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Observer
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="etop_ug.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Erlang Top
        </span>
      </a>

  </div>
</div>
      <footer class="footer">
        <p>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
              Search HexDocs
            </button>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.30.9) for the

            <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

        </p>
      </footer>
    </div>
  </div>
</main>
</div>


  </body>
</html>
