<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.23.0">
    <meta name="project" content="stdlib vHEAD">

    <title>binary â€” stdlib vHEAD</title>
    <link rel="stylesheet" href="dist/elixir-ec941ecbc4f85ab01625.css" />

    <script src="dist/sidebar_items-e3ebb08225.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f97730d45ef67f3e6188.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="api-reference.html" class="sidebar-projectName">
stdlib
      </a>
      <strong class="sidebar-projectVersion">
        vHEAD
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
binary <small class="app-vsn">(stdlib vHEAD)</small>

      </h1>


        <section id="moduledoc">
<p>This module contains functions for manipulating byte-oriented binaries. Although the majority of functions could be provided using bit-syntax, the functions in this library are highly optimized and are expected to either execute faster or consume less memory, or both, than a counterpart written in pure Erlang.</p><p>The module is provided according to Erlang Enhancement Proposal (EEP) 31.</p><div class="note"><p>The library handles byte-oriented data. For bitstrings that are not binaries (does not contain whole octets of bits) a <code>badarg</code> exception is thrown from any of the functions in this module.</p></div>
        </section>


        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>

  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:cp/0">cp()</a>

  </div>

    <div class="summary-synopsis"><p>Opaque data type representing a compiled search pattern. Guaranteed to be a <code>tuple()</code> to allow programs to distinguish it from non-precompiled search patterns.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:part/0">part()</a>

  </div>

    <div class="summary-synopsis"><p>A representation of a part (or range) in a binary. <code>Start</code> is a zero-based offset into a <code>binary()</code> and <code>Length</code> is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative <code>Length</code>, so that the part of the binary begins at <code>Start</code> + <code>Length</code> and is -<code>Length</code> long. This is useful for referencing the last <code>N</code> bytes of a binary as <code>{size(Binary), -N}</code>. The functions in this module always return <code>part()</code>s with positive <code>Length</code>.</p></div>

</div>

  </div>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#at/2">at/2</a>

  </div>

    <div class="summary-synopsis"><p>Returns the byte at position <code>Pos</code> (zero-based) in binary <code>Subject</code> as an integer. If <code>Pos</code> &gt;= <code>byte_size(Subject)</code>, a <code>badarg</code> exception is raised.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bin_to_list/1">bin_to_list/1</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>bin_to_list(Subject, {0,byte_size(Subject)})</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bin_to_list/2">bin_to_list/2</a>

  </div>

    <div class="summary-synopsis"><p>Converts <code>Subject</code> to a list of <code>byte()</code>s, each representing the value of one byte. <code>part()</code> denotes which part of the <code>binary()</code> to convert.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#bin_to_list/3">bin_to_list/3</a>

  </div>

    <div class="summary-synopsis"><p>Same as<code> bin_to_list(Subject, {Pos, Len})</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile_pattern/1">compile_pattern/1</a>

  </div>

    <div class="summary-synopsis"><p>Builds an internal structure representing a compilation of a search pattern, later to be used in functions <a href="stdlib:binary#match/3" rel="https://erlang.org/doc/link/seemfa"><code>match/3</code></a>, <a href="stdlib:binary#matches/3" rel="https://erlang.org/doc/link/seemfa"><code>matches/3</code></a>, <a href="stdlib:binary#split/3" rel="https://erlang.org/doc/link/seemfa"><code>split/3</code></a>, or <a href="stdlib:binary#replace/4" rel="https://erlang.org/doc/link/seemfa"><code>replace/4</code></a>. The <code>cp()</code> returned is guaranteed to be a <code>tuple()</code> to allow programs to distinguish it from non-precompiled search patterns.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#copy/1">copy/1</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>copy(Subject, 1)</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#copy/2">copy/2</a>

  </div>

    <div class="summary-synopsis"><p>Creates a binary with the content of <code>Subject</code> duplicated <code>N</code> times.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#decode_unsigned/1">decode_unsigned/1</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>decode_unsigned(Subject, big)</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#decode_unsigned/2">decode_unsigned/2</a>

  </div>

    <div class="summary-synopsis"><p>Converts the binary digit representation, in big endian or little endian, of a positive integer in <code>Subject</code> to an Erlang <code>integer()</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#encode_unsigned/1">encode_unsigned/1</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>encode_unsigned(Unsigned, big)</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#encode_unsigned/2">encode_unsigned/2</a>

  </div>

    <div class="summary-synopsis"><p>Converts a positive integer to the smallest possible representation in a binary digit representation, either big endian or little endian.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#first/1">first/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns the first byte of binary <code>Subject</code> as an integer. If the size of <code>Subject</code> is zero, a <code>badarg</code> exception is raised.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#last/1">last/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns the last byte of binary <code>Subject</code> as an integer. If the size of <code>Subject</code> is zero, a <code>badarg</code> exception is raised.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#list_to_bin/1">list_to_bin/1</a>

  </div>

    <div class="summary-synopsis"><p>Works exactly as <a href="erts:erlang#list_to_binary/1" rel="https://erlang.org/doc/link/seemfa"><code>erlang:list_to_binary/1</code></a>, added for completeness.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#longest_common_prefix/1">longest_common_prefix/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns the length of the longest common prefix of the binaries in list <code>Binaries</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#longest_common_suffix/1">longest_common_suffix/1</a>

  </div>

    <div class="summary-synopsis"><p>Returns the length of the longest common suffix of the binaries in list <code>Binaries</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match/2">match/2</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>match(Subject, Pattern, [])</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#match/3">match/3</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="part"></li></ul><p>Searches for the first occurrence of <code>Pattern</code> in <code>Subject</code> and returns the position and length.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#matches/2">matches/2</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>matches(Subject, Pattern, [])</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#matches/3">matches/3</a>

  </div>

    <div class="summary-synopsis"><ul class="types"><li name="part"></li></ul><p>As <a href="stdlib:binary#match/2" rel="https://erlang.org/doc/link/seemfa"><code>match/2</code></a>, but <code>Subject</code> is searched until exhausted and a list of all non-overlapping parts matching <code>Pattern</code> is returned (in order).</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#part/2">part/2</a>

  </div>

    <div class="summary-synopsis"><p>Extracts the part of binary <code>Subject</code> described by <code>PosLen</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#part/3">part/3</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>part(Subject, {Pos, Len})</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#referenced_byte_size/1">referenced_byte_size/1</a>

  </div>

    <div class="summary-synopsis"><p>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of <a href="stdlib:binary#copy/1" rel="https://erlang.org/doc/link/seemfa"><code>copy/1</code></a>. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#replace/3">replace/3</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>replace(Subject, Pattern, Replacement,[])</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#replace/4">replace/4</a>

  </div>

    <div class="summary-synopsis"><p>Constructs a new binary by replacing the parts in <code>Subject</code> matching <code>Pattern</code> with the content of <code>Replacement</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/2">split/2</a>

  </div>

    <div class="summary-synopsis"><p>Same as <code>split(Subject, Pattern, [])</code>.</p></div>

</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/3">split/3</a>

  </div>

    <div class="summary-synopsis"><p>Splits <code>Subject</code> into a list of binaries based on <code>Pattern</code>. If option <code>global</code> is not specified, only the first occurrence of <code>Pattern</code> in <code>Subject</code> gives rise to a split.</p></div>

</div>

  </div>

        </section>


        <section id="types" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Types
          </h1>
          <div class="types-list">
<section class="detail" id="t:cp/0">

  <div class="detail-header">
    <a href="#t:cp/0" class="detail-link" title="Link to this opaque">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this opaque</span>
    </a>
    <h1 class="signature">cp()</h1>


      <span class="note">(opaque)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>cp()</pre>

      </div>

<p>Opaque data type representing a compiled search pattern. Guaranteed to be a <code>tuple()</code> to allow programs to distinguish it from non-precompiled search patterns.</p>
  </section>
</section>
<section class="detail" id="t:part/0">

  <div class="detail-header">
    <a href="#t:part/0" class="detail-link" title="Link to this type">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this type</span>
    </a>
    <h1 class="signature">part()</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>part() :: {start :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>(), length :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()}</pre>

      </div>

<p>A representation of a part (or range) in a binary. <code>Start</code> is a zero-based offset into a <code>binary()</code> and <code>Length</code> is the length of that part. As input to functions in this module, a reverse part specification is allowed, constructed with a negative <code>Length</code>, so that the part of the binary begins at <code>Start</code> + <code>Length</code> and is -<code>Length</code> long. This is useful for referencing the last <code>N</code> bytes of a binary as <code>{size(Binary), -N}</code>. The functions in this module always return <code>part()</code>s with positive <code>Length</code>.</p>
  </section>
</section>

          </div>
        </section>

        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions
          </h1>
          <div class="functions-list">
<section class="detail" id="at/2">

  <div class="detail-header">
    <a href="#at/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">at/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>at(subject, pos) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">byte</a>() when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), pos: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()</pre>

      </div>

<p>Returns the byte at position <code>Pos</code> (zero-based) in binary <code>Subject</code> as an integer. If <code>Pos</code> &gt;= <code>byte_size(Subject)</code>, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="bin_to_list/1">

  <div class="detail-header">
    <a href="#bin_to_list/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">bin_to_list/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>bin_to_list(subject) :: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">byte</a>()] when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>Same as <code>bin_to_list(Subject, {0,byte_size(Subject)})</code>.</p>
  </section>
</section>
<section class="detail" id="bin_to_list/2">

  <div class="detail-header">
    <a href="#bin_to_list/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">bin_to_list/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>bin_to_list(subject, posLen) :: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">byte</a>()] when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), posLen: part()</pre>

      </div>

<p>Converts <code>Subject</code> to a list of <code>byte()</code>s, each representing the value of one byte. <code>part()</code> denotes which part of the <code>binary()</code> to convert.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:bin_to_list</span><span class="p" data-group-id="6639784891-1">(</span><span class="p" data-group-id="6639784891-2">&lt;&lt;</span><span class="s">&quot;erlang&quot;</span><span class="p" data-group-id="6639784891-2">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6639784891-3">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="6639784891-3">}</span><span class="p" data-group-id="6639784891-1">)</span><span class="o">.</span><span class="w">
</span><span class="s">&quot;rla&quot;</span><span class="w">
</span><span class="p">%</span><span class="p">%</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="p" data-group-id="6639784891-4">[</span><span class="mi">114</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">97</span><span class="p" data-group-id="6639784891-4">]</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">notation</span><span class="o">.</span></code></pre><p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="bin_to_list/3">

  <div class="detail-header">
    <a href="#bin_to_list/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">bin_to_list/3</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>bin_to_list(subject, pos, len) :: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">byte</a>()]
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), pos: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>(), len: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()</pre>

      </div>

<p>Same as<code> bin_to_list(Subject, {Pos, Len})</code>.</p>
  </section>
</section>
<section class="detail" id="compile_pattern/1">

  <div class="detail-header">
    <a href="#compile_pattern/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile_pattern/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>compile_pattern(pattern) :: <a href="#type-cp">cp</a>() when pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()]</pre>

      </div>

<p>Builds an internal structure representing a compilation of a search pattern, later to be used in functions <a href="stdlib:binary#match/3" rel="https://erlang.org/doc/link/seemfa"><code>match/3</code></a>, <a href="stdlib:binary#matches/3" rel="https://erlang.org/doc/link/seemfa"><code>matches/3</code></a>, <a href="stdlib:binary#split/3" rel="https://erlang.org/doc/link/seemfa"><code>split/3</code></a>, or <a href="stdlib:binary#replace/4" rel="https://erlang.org/doc/link/seemfa"><code>replace/4</code></a>. The <code>cp()</code> returned is guaranteed to be a <code>tuple()</code> to allow programs to distinguish it from non-precompiled search patterns.</p><p>When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if <code>[&lt;&lt;&quot;functional&quot;&gt;&gt;,&lt;&lt;&quot;programming&quot;&gt;&gt;]</code> is specified as <code>Pattern</code>, this means either <code>&lt;&lt;&quot;functional&quot;&gt;&gt;</code> or <code>&lt;&lt;&quot;programming&quot;&gt;&gt;</code>&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant.</p><p>The list of binaries used for search alternatives must be flat and proper.</p><p>If <code>Pattern</code> is not a binary or a flat proper list of binaries with length &gt; 0, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="copy/1">

  <div class="detail-header">
    <a href="#copy/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">copy/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>copy(subject) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>Same as <code>copy(Subject, 1)</code>.</p>
  </section>
</section>
<section class="detail" id="copy/2">

  <div class="detail-header">
    <a href="#copy/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">copy/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>copy(subject, n) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), n: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()</pre>

      </div>

<p>Creates a binary with the content of <code>Subject</code> duplicated <code>N</code> times.</p><p>This function always creates a new binary, even if <code>N = 1</code>. By using <a href="stdlib:binary#copy/1" rel="https://erlang.org/doc/link/seemfa"><code>copy/1</code></a> on a binary referencing a larger binary, one can free up the larger binary for garbage collection.</p><div class="note"><p>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</p></div><p>If <code>N</code> &lt; <code>0</code>, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="decode_unsigned/1">

  <div class="detail-header">
    <a href="#decode_unsigned/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">decode_unsigned/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>decode_unsigned(subject) :: unsigned
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), unsigned: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()</pre>

      </div>

<p>Same as <code>decode_unsigned(Subject, big)</code>.</p>
  </section>
</section>
<section class="detail" id="decode_unsigned/2">

  <div class="detail-header">
    <a href="#decode_unsigned/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">decode_unsigned/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>decode_unsigned(subject, endianness) :: unsigned
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), endianness: :big | :little, unsigned: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()</pre>

      </div>

<p>Converts the binary digit representation, in big endian or little endian, of a positive integer in <code>Subject</code> to an Erlang <code>integer()</code>.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:decode_unsigned</span><span class="p" data-group-id="8570528428-1">(</span><span class="p" data-group-id="8570528428-2">&lt;&lt;</span><span class="mi">169</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">199</span><span class="p" data-group-id="8570528428-2">&gt;&gt;</span><span class="p">,</span><span class="n">big</span><span class="p" data-group-id="8570528428-1">)</span><span class="o">.</span><span class="w">
</span><span class="mi">11111111</span></code></pre>
  </section>
</section>
<section class="detail" id="encode_unsigned/1">

  <div class="detail-header">
    <a href="#encode_unsigned/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">encode_unsigned/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>encode_unsigned(unsigned) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() when unsigned: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()</pre>

      </div>

<p>Same as <code>encode_unsigned(Unsigned, big)</code>.</p>
  </section>
</section>
<section class="detail" id="encode_unsigned/2">

  <div class="detail-header">
    <a href="#encode_unsigned/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">encode_unsigned/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>encode_unsigned(unsigned, endianness) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()
when unsigned: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>(), endianness: :big | :little</pre>

      </div>

<p>Converts a positive integer to the smallest possible representation in a binary digit representation, either big endian or little endian.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:encode_unsigned</span><span class="p" data-group-id="0617064705-1">(</span><span class="mi">11111111</span><span class="p">,</span><span class="w"> </span><span class="n">big</span><span class="p" data-group-id="0617064705-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="0617064705-2">&lt;&lt;</span><span class="mi">169</span><span class="p">,</span><span class="mi">138</span><span class="p">,</span><span class="mi">199</span><span class="p" data-group-id="0617064705-2">&gt;&gt;</span></code></pre>
  </section>
</section>
<section class="detail" id="first/1">

  <div class="detail-header">
    <a href="#first/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">first/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>first(subject) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">byte</a>() when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>Returns the first byte of binary <code>Subject</code> as an integer. If the size of <code>Subject</code> is zero, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="last/1">

  <div class="detail-header">
    <a href="#last/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">last/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>last(subject) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">byte</a>() when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>Returns the last byte of binary <code>Subject</code> as an integer. If the size of <code>Subject</code> is zero, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="list_to_bin/1">

  <div class="detail-header">
    <a href="#list_to_bin/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">list_to_bin/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>list_to_bin(byteList) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() when byteList: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iolist</a>()</pre>

      </div>

<p>Works exactly as <a href="erts:erlang#list_to_binary/1" rel="https://erlang.org/doc/link/seemfa"><code>erlang:list_to_binary/1</code></a>, added for completeness.</p>
  </section>
</section>
<section class="detail" id="longest_common_prefix/1">

  <div class="detail-header">
    <a href="#longest_common_prefix/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">longest_common_prefix/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>longest_common_prefix(binaries) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>() when binaries: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()]</pre>

      </div>

<p>Returns the length of the longest common prefix of the binaries in list <code>Binaries</code>.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:longest_common_prefix</span><span class="p" data-group-id="0032667901-1">(</span><span class="p" data-group-id="0032667901-2">[</span><span class="p" data-group-id="0032667901-3">&lt;&lt;</span><span class="s">&quot;erlang&quot;</span><span class="p" data-group-id="0032667901-3">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0032667901-4">&lt;&lt;</span><span class="s">&quot;ergonomy&quot;</span><span class="p" data-group-id="0032667901-4">&gt;&gt;</span><span class="p" data-group-id="0032667901-2">]</span><span class="p" data-group-id="0032667901-1">)</span><span class="o">.</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:longest_common_prefix</span><span class="p" data-group-id="0032667901-5">(</span><span class="p" data-group-id="0032667901-6">[</span><span class="p" data-group-id="0032667901-7">&lt;&lt;</span><span class="s">&quot;erlang&quot;</span><span class="p" data-group-id="0032667901-7">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0032667901-8">&lt;&lt;</span><span class="s">&quot;perl&quot;</span><span class="p" data-group-id="0032667901-8">&gt;&gt;</span><span class="p" data-group-id="0032667901-6">]</span><span class="p" data-group-id="0032667901-5">)</span><span class="o">.</span><span class="w">
</span><span class="mi">0</span></code></pre><p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="longest_common_suffix/1">

  <div class="detail-header">
    <a href="#longest_common_suffix/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">longest_common_suffix/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>longest_common_suffix(binaries) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>() when binaries: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()]</pre>

      </div>

<p>Returns the length of the longest common suffix of the binaries in list <code>Binaries</code>.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:longest_common_suffix</span><span class="p" data-group-id="0639745494-1">(</span><span class="p" data-group-id="0639745494-2">[</span><span class="p" data-group-id="0639745494-3">&lt;&lt;</span><span class="s">&quot;erlang&quot;</span><span class="p" data-group-id="0639745494-3">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0639745494-4">&lt;&lt;</span><span class="s">&quot;fang&quot;</span><span class="p" data-group-id="0639745494-4">&gt;&gt;</span><span class="p" data-group-id="0639745494-2">]</span><span class="p" data-group-id="0639745494-1">)</span><span class="o">.</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:longest_common_suffix</span><span class="p" data-group-id="0639745494-5">(</span><span class="p" data-group-id="0639745494-6">[</span><span class="p" data-group-id="0639745494-7">&lt;&lt;</span><span class="s">&quot;erlang&quot;</span><span class="p" data-group-id="0639745494-7">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0639745494-8">&lt;&lt;</span><span class="s">&quot;perl&quot;</span><span class="p" data-group-id="0639745494-8">&gt;&gt;</span><span class="p" data-group-id="0639745494-6">]</span><span class="p" data-group-id="0639745494-5">)</span><span class="o">.</span><span class="w">
</span><span class="mi">0</span></code></pre><p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="match/2">

  <div class="detail-header">
    <a href="#match/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">match/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>match(subject, pattern) :: found | :nomatch
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(), found: part()</pre>

      </div>

<p>Same as <code>match(Subject, Pattern, [])</code>.</p>
  </section>
</section>
<section class="detail" id="match/3">

  <div class="detail-header">
    <a href="#match/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">match/3</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>match(subject, pattern, options) :: found | :nomatch
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(),
     found: part(),
     options: [option],
     option: {:scope, part()}</pre>

      </div>

<ul class="types"><li name="part"></li></ul><p>Searches for the first occurrence of <code>Pattern</code> in <code>Subject</code> and returns the position and length.</p><p>The function returns <code>{Pos, Length}</code> for the binary in <code>Pattern</code>, starting at the lowest position in <code>Subject</code>.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:match</span><span class="p" data-group-id="1758575748-1">(</span><span class="p" data-group-id="1758575748-2">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="1758575748-2">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1758575748-3">[</span><span class="p" data-group-id="1758575748-4">&lt;&lt;</span><span class="s">&quot;bcde&quot;</span><span class="p" data-group-id="1758575748-4">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1758575748-5">&lt;&lt;</span><span class="s">&quot;cd&quot;</span><span class="p" data-group-id="1758575748-5">&gt;&gt;</span><span class="p" data-group-id="1758575748-3">]</span><span class="p">,</span><span class="p" data-group-id="1758575748-6">[</span><span class="p" data-group-id="1758575748-6">]</span><span class="p" data-group-id="1758575748-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="1758575748-7">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="1758575748-7">}</span></code></pre><p>Even though <code>&lt;&lt;&quot;cd&quot;&gt;&gt;</code> ends before <code>&lt;&lt;&quot;bcde&quot;&gt;&gt;</code>, <code>&lt;&lt;&quot;bcde&quot;&gt;&gt;</code> begins first and is therefore the first match. If two overlapping matches begin at the same position, the longest is returned.</p><p>Summary of the options:</p><dl><dt>{scope, {Start, Length}}</dt><dd><p>Only the specified part is searched. Return values still have offsets from the beginning of <code>Subject</code>. A negative <code>Length</code> is allowed as described in section Data Types in this manual.</p></dd></dl><p>If none of the strings in <code>Pattern</code> is found, the atom <code>nomatch</code> is returned.</p><p>For a description of <code>Pattern</code>, see function <a href="stdlib:binary#compile_pattern/1" rel="https://erlang.org/doc/link/seemfa"><code>compile_pattern/1</code></a>.</p><p>If <code>{scope, {Start,Length}}</code> is specified in the options such that <code>Start</code> &gt; size of <code>Subject</code>, <code>Start</code> + <code>Length</code> &lt; 0 or <code>Start</code> + <code>Length</code> &gt; size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="matches/2">

  <div class="detail-header">
    <a href="#matches/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">matches/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>matches(subject, pattern) :: found
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(), found: [part()]</pre>

      </div>

<p>Same as <code>matches(Subject, Pattern, [])</code>.</p>
  </section>
</section>
<section class="detail" id="matches/3">

  <div class="detail-header">
    <a href="#matches/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">matches/3</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>matches(subject, pattern, options) :: found
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(),
     found: [part()],
     options: [option],
     option: {:scope, part()}</pre>

      </div>

<ul class="types"><li name="part"></li></ul><p>As <a href="stdlib:binary#match/2" rel="https://erlang.org/doc/link/seemfa"><code>match/2</code></a>, but <code>Subject</code> is searched until exhausted and a list of all non-overlapping parts matching <code>Pattern</code> is returned (in order).</p><p>The first and longest match is preferred to a shorter, which is illustrated by the following example:</p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:matches</span><span class="p" data-group-id="6936942379-1">(</span><span class="p" data-group-id="6936942379-2">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="6936942379-2">&gt;&gt;</span><span class="p">,</span><span class="w">
                  </span><span class="p" data-group-id="6936942379-3">[</span><span class="p" data-group-id="6936942379-4">&lt;&lt;</span><span class="s">&quot;bcde&quot;</span><span class="p" data-group-id="6936942379-4">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="6936942379-5">&lt;&lt;</span><span class="s">&quot;bc&quot;</span><span class="p" data-group-id="6936942379-5">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="6936942379-6">&lt;&lt;</span><span class="s">&quot;de&quot;</span><span class="p" data-group-id="6936942379-6">&gt;&gt;</span><span class="p" data-group-id="6936942379-3">]</span><span class="p">,</span><span class="p" data-group-id="6936942379-7">[</span><span class="p" data-group-id="6936942379-7">]</span><span class="p" data-group-id="6936942379-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="6936942379-8">[</span><span class="p" data-group-id="6936942379-9">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="6936942379-9">}</span><span class="p" data-group-id="6936942379-8">]</span></code></pre><p>The result shows that &lt;&lt;&quot;bcde&quot;&gt;&gt; is selected instead of the shorter match &lt;&lt;&quot;bc&quot;&gt;&gt; (which would have given raise to one more match, &lt;&lt;&quot;de&quot;&gt;&gt;). This corresponds to the behavior of POSIX regular expressions (and programs like awk), but is not consistent with alternative matches in <code>re</code> (and Perl), where instead lexical ordering in the search pattern selects which string matches.</p><p>If none of the strings in a pattern is found, an empty list is returned.</p><p>For a description of <code>Pattern</code>, see <a href="stdlib:binary#compile_pattern/1" rel="https://erlang.org/doc/link/seemfa"><code>compile_pattern/1</code></a>. For a description of available options, see <a href="stdlib:binary#match/3" rel="https://erlang.org/doc/link/seemfa"><code>match/3</code></a>.</p><p>If <code>{scope, {Start,Length}}</code> is specified in the options such that <code>Start</code> &gt; size of <code>Subject</code>, <code>Start + Length</code> &lt; 0 or <code>Start + Length</code> is &gt; size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="part/2">

  <div class="detail-header">
    <a href="#part/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">part/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>part(subject, posLen) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), posLen: part()</pre>

      </div>

<p>Extracts the part of binary <code>Subject</code> described by <code>PosLen</code>.</p><p>A negative length can be used to extract bytes at the end of a binary:</p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">Bin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7389568989-1">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="7389568989-1">&gt;&gt;</span><span class="o">.</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:part</span><span class="p" data-group-id="7389568989-2">(</span><span class="nc">Bin</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7389568989-3">{</span><span class="n">byte_size</span><span class="p" data-group-id="7389568989-4">(</span><span class="nc">Bin</span><span class="p" data-group-id="7389568989-4">)</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">5</span><span class="p" data-group-id="7389568989-3">}</span><span class="p" data-group-id="7389568989-2">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7389568989-5">&lt;&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="7389568989-5">&gt;&gt;</span></code></pre><div class="note"><p><a href="stdlib:binary#part/2" rel="https://erlang.org/doc/link/seemfa">part/2</a> and <a href="stdlib:binary#part/3" rel="https://erlang.org/doc/link/seemfa">part/3</a> are also available in the <a href="stdlib:binary#erts:erlang" rel="https://erlang.org/doc/link/seeerl"><code>erlang</code></a> module under the names <code>binary_part/2</code> and <a href="https://hexdocs.pm/elixir/Kernel.html#binary_part/3"><code>binary_part/3</code></a>. Those BIFs are allowed in guard tests.</p></div><p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code> exception is raised.</p>
  </section>
</section>
<section class="detail" id="part/3">

  <div class="detail-header">
    <a href="#part/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">part/3</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>part(subject, pos, len) :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), pos: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>(), len: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()</pre>

      </div>

<p>Same as <code>part(Subject, {Pos, Len})</code>.</p>
  </section>
</section>
<section class="detail" id="referenced_byte_size/1">

  <div class="detail-header">
    <a href="#referenced_byte_size/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">referenced_byte_size/1</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>referenced_byte_size(binary) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>() when binary: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of <a href="stdlib:binary#copy/1" rel="https://erlang.org/doc/link/seemfa"><code>copy/1</code></a>. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="n">store</span><span class="p" data-group-id="8452383476-1">(</span><span class="nc">Binary</span><span class="p">,</span><span class="w"> </span><span class="nc">GBSet</span><span class="p" data-group-id="8452383476-1">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="nc">NewBin</span><span class="w"> </span><span class="o">=</span><span class="w">
      </span><span class="k">case</span><span class="w"> </span><span class="n">binary</span><span class="ss">:referenced_byte_size</span><span class="p" data-group-id="8452383476-2">(</span><span class="nc">Binary</span><span class="p" data-group-id="8452383476-2">)</span><span class="w"> </span><span class="n">of</span><span class="w">
          </span><span class="nc">Large</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="nc">Large</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">byte_size</span><span class="p" data-group-id="8452383476-3">(</span><span class="nc">Binary</span><span class="p" data-group-id="8452383476-3">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
             </span><span class="n">binary</span><span class="ss">:copy</span><span class="p" data-group-id="8452383476-4">(</span><span class="nc">Binary</span><span class="p" data-group-id="8452383476-4">)</span><span class="p">;</span><span class="w">
          </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
             </span><span class="nc">Binary</span><span class="w">
      </span><span class="k">end</span><span class="p">,</span><span class="w">
  </span><span class="n">gb_sets</span><span class="ss">:insert</span><span class="p" data-group-id="8452383476-5">(</span><span class="nc">NewBin</span><span class="p">,</span><span class="nc">GBSet</span><span class="p" data-group-id="8452383476-5">)</span><span class="o">.</span></code></pre><p>In this example, we chose to copy the binary content before inserting it in <code>gb_sets:set()</code> if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</p><p>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with <a href="#copy-1"><code>copy/1</code></a> can be useful when optimizing for memory use.</p><p>Example of binary sharing:</p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binary</span><span class="ss">:copy</span><span class="p" data-group-id="7087864619-1">(</span><span class="p" data-group-id="7087864619-2">&lt;&lt;</span><span class="mi">1</span><span class="p" data-group-id="7087864619-2">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p" data-group-id="7087864619-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7087864619-3">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">byte_size</span><span class="p" data-group-id="7087864619-4">(</span><span class="nc">A</span><span class="p" data-group-id="7087864619-4">)</span><span class="o">.</span><span class="w">
</span><span class="mi">100</span><span class="w">
</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:referenced_byte_size</span><span class="p" data-group-id="7087864619-5">(</span><span class="nc">A</span><span class="p" data-group-id="7087864619-5">)</span><span class="o">.</span><span class="w">
</span><span class="mi">100</span><span class="w">
</span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="7087864619-6">&lt;&lt;</span><span class="nc">B</span><span class="p">:</span><span class="mi">10</span><span class="o">/</span><span class="n">binary</span><span class="p">,</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span><span class="mi">90</span><span class="o">/</span><span class="n">binary</span><span class="p" data-group-id="7087864619-6">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">A</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7087864619-7">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="n">...</span><span class="w">
</span><span class="mi">5</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="7087864619-8">{</span><span class="n">byte_size</span><span class="p" data-group-id="7087864619-9">(</span><span class="nc">B</span><span class="p" data-group-id="7087864619-9">)</span><span class="p">,</span><span class="w"> </span><span class="n">binary</span><span class="ss">:referenced_byte_size</span><span class="p" data-group-id="7087864619-10">(</span><span class="nc">B</span><span class="p" data-group-id="7087864619-10">)</span><span class="p" data-group-id="7087864619-8">}</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7087864619-11">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="7087864619-11">}</span><span class="w">
</span><span class="mi">6</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="7087864619-12">{</span><span class="n">byte_size</span><span class="p" data-group-id="7087864619-13">(</span><span class="nc">C</span><span class="p" data-group-id="7087864619-13">)</span><span class="p">,</span><span class="w"> </span><span class="n">binary</span><span class="ss">:referenced_byte_size</span><span class="p" data-group-id="7087864619-14">(</span><span class="nc">C</span><span class="p" data-group-id="7087864619-14">)</span><span class="p" data-group-id="7087864619-12">}</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7087864619-15">{</span><span class="mi">90</span><span class="p">,</span><span class="mi">100</span><span class="p" data-group-id="7087864619-15">}</span></code></pre><p>In the above example, the small binary <code>B</code> was copied while the larger binary <code>C</code> references binary <code>A</code>.</p><div class="note"><p>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</p></div>
  </section>
</section>
<section class="detail" id="replace/3">

  <div class="detail-header">
    <a href="#replace/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">replace/3</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>replace(subject, pattern, replacement) :: result
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(),
     replacement: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     result: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>Same as <code>replace(Subject, Pattern, Replacement,[])</code>.</p>
  </section>
</section>
<section class="detail" id="replace/4">

  <div class="detail-header">
    <a href="#replace/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">replace/4</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>replace(subject, pattern, replacement, options) :: result
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(),
     replacement: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     options: [option],
     option: :global | {:scope, part()} | {:insert_replaced, insPos},
     insPos: onePos | [onePos],
     onePos: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>(),
     result: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()</pre>

      </div>

<p>Constructs a new binary by replacing the parts in <code>Subject</code> matching <code>Pattern</code> with the content of <code>Replacement</code>.</p><p>If the matching subpart of <code>Subject</code> giving raise to the replacement is to be inserted in the result, option <code>{insert_replaced, InsPos}</code> inserts the matching part into <code>Replacement</code> at the specified position (or positions) before inserting <code>Replacement</code> into <code>Subject</code>.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:replace</span><span class="p" data-group-id="9631306380-1">(</span><span class="p" data-group-id="9631306380-2">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="9631306380-2">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-3">&lt;&lt;</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="9631306380-3">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-4">&lt;&lt;</span><span class="s">&quot;[]&quot;</span><span class="p" data-group-id="9631306380-4">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9631306380-5">[</span><span class="p" data-group-id="9631306380-6">{</span><span class="n">insert_replaced</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="9631306380-6">}</span><span class="p" data-group-id="9631306380-5">]</span><span class="p" data-group-id="9631306380-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9631306380-7">&lt;&lt;</span><span class="s">&quot;a[b]cde&quot;</span><span class="p" data-group-id="9631306380-7">&gt;&gt;</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:replace</span><span class="p" data-group-id="9631306380-8">(</span><span class="p" data-group-id="9631306380-9">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="9631306380-9">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-10">[</span><span class="p" data-group-id="9631306380-11">&lt;&lt;</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="9631306380-11">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-12">&lt;&lt;</span><span class="s">&quot;d&quot;</span><span class="p" data-group-id="9631306380-12">&gt;&gt;</span><span class="p" data-group-id="9631306380-10">]</span><span class="p">,</span><span class="p" data-group-id="9631306380-13">&lt;&lt;</span><span class="s">&quot;[]&quot;</span><span class="p" data-group-id="9631306380-13">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-14">[</span><span class="n">global</span><span class="p">,</span><span class="p" data-group-id="9631306380-15">{</span><span class="n">insert_replaced</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="9631306380-15">}</span><span class="p" data-group-id="9631306380-14">]</span><span class="p" data-group-id="9631306380-8">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9631306380-16">&lt;&lt;</span><span class="s">&quot;a[b]c[d]e&quot;</span><span class="p" data-group-id="9631306380-16">&gt;&gt;</span><span class="w">
</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:replace</span><span class="p" data-group-id="9631306380-17">(</span><span class="p" data-group-id="9631306380-18">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="9631306380-18">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-19">[</span><span class="p" data-group-id="9631306380-20">&lt;&lt;</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="9631306380-20">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-21">&lt;&lt;</span><span class="s">&quot;d&quot;</span><span class="p" data-group-id="9631306380-21">&gt;&gt;</span><span class="p" data-group-id="9631306380-19">]</span><span class="p">,</span><span class="p" data-group-id="9631306380-22">&lt;&lt;</span><span class="s">&quot;[]&quot;</span><span class="p" data-group-id="9631306380-22">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-23">[</span><span class="n">global</span><span class="p">,</span><span class="p" data-group-id="9631306380-24">{</span><span class="n">insert_replaced</span><span class="p">,</span><span class="p" data-group-id="9631306380-25">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="9631306380-25">]</span><span class="p" data-group-id="9631306380-24">}</span><span class="p" data-group-id="9631306380-23">]</span><span class="p" data-group-id="9631306380-17">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9631306380-26">&lt;&lt;</span><span class="s">&quot;a[bb]c[dd]e&quot;</span><span class="p" data-group-id="9631306380-26">&gt;&gt;</span><span class="w">
</span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:replace</span><span class="p" data-group-id="9631306380-27">(</span><span class="p" data-group-id="9631306380-28">&lt;&lt;</span><span class="s">&quot;abcde&quot;</span><span class="p" data-group-id="9631306380-28">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-29">[</span><span class="p" data-group-id="9631306380-30">&lt;&lt;</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="9631306380-30">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-31">&lt;&lt;</span><span class="s">&quot;d&quot;</span><span class="p" data-group-id="9631306380-31">&gt;&gt;</span><span class="p" data-group-id="9631306380-29">]</span><span class="p">,</span><span class="p" data-group-id="9631306380-32">&lt;&lt;</span><span class="s">&quot;[-]&quot;</span><span class="p" data-group-id="9631306380-32">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9631306380-33">[</span><span class="n">global</span><span class="p">,</span><span class="p" data-group-id="9631306380-34">{</span><span class="n">insert_replaced</span><span class="p">,</span><span class="p" data-group-id="9631306380-35">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="9631306380-35">]</span><span class="p" data-group-id="9631306380-34">}</span><span class="p" data-group-id="9631306380-33">]</span><span class="p" data-group-id="9631306380-27">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9631306380-36">&lt;&lt;</span><span class="s">&quot;a[b-b]c[d-d]e&quot;</span><span class="p" data-group-id="9631306380-36">&gt;&gt;</span></code></pre><p>If any position specified in <code>InsPos</code> &gt; size of the replacement binary, a <code>badarg</code> exception is raised.</p><p>Options <code>global</code> and <code>{scope, part()}</code> work as for <a href="stdlib:binary#split/3" rel="https://erlang.org/doc/link/seemfa"><code>split/3</code></a>. The return type is always a <code>binary()</code>.</p><p>For a description of <code>Pattern</code>, see <a href="stdlib:binary#compile_pattern/1" rel="https://erlang.org/doc/link/seemfa"><code>compile_pattern/1</code></a>.</p>
  </section>
</section>
<section class="detail" id="split/2">

  <div class="detail-header">
    <a href="#split/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">split/2</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>split(subject, pattern) :: parts
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(), pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(), parts: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()]</pre>

      </div>

<p>Same as <code>split(Subject, Pattern, [])</code>.</p>
  </section>
</section>
<section class="detail" id="split/3">

  <div class="detail-header">
    <a href="#split/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">split/3</h1>


      <span class="note">(since OTP R14B)</span>

  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre>split(subject, pattern, options) :: parts
when subject: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
     pattern: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()] | <a href="#type-cp">cp</a>(),
     options: [option],
     option: {:scope, part()} | :trim | :global | :trim_all,
     parts: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()]</pre>

      </div>

<p>Splits <code>Subject</code> into a list of binaries based on <code>Pattern</code>. If option <code>global</code> is not specified, only the first occurrence of <code>Pattern</code> in <code>Subject</code> gives rise to a split.</p><p>The parts of <code>Pattern</code> found in <code>Subject</code> are not included in the result.</p><p><em>Example:</em></p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:split</span><span class="p" data-group-id="8113847081-1">(</span><span class="p" data-group-id="8113847081-2">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="8113847081-2">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8113847081-3">[</span><span class="p" data-group-id="8113847081-4">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="8113847081-4">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8113847081-5">&lt;&lt;</span><span class="mi">2</span><span class="p" data-group-id="8113847081-5">&gt;&gt;</span><span class="p" data-group-id="8113847081-3">]</span><span class="p">,</span><span class="p" data-group-id="8113847081-6">[</span><span class="p" data-group-id="8113847081-6">]</span><span class="p" data-group-id="8113847081-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="8113847081-7">[</span><span class="p" data-group-id="8113847081-8">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8113847081-8">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8113847081-9">&lt;&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="8113847081-9">&gt;&gt;</span><span class="p" data-group-id="8113847081-7">]</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:split</span><span class="p" data-group-id="8113847081-10">(</span><span class="p" data-group-id="8113847081-11">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">9</span><span class="p" data-group-id="8113847081-11">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8113847081-12">[</span><span class="p" data-group-id="8113847081-13">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="8113847081-13">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8113847081-14">&lt;&lt;</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p" data-group-id="8113847081-14">&gt;&gt;</span><span class="p" data-group-id="8113847081-12">]</span><span class="p">,</span><span class="p" data-group-id="8113847081-15">[</span><span class="n">global</span><span class="p" data-group-id="8113847081-15">]</span><span class="p" data-group-id="8113847081-10">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="8113847081-16">[</span><span class="p" data-group-id="8113847081-17">&lt;&lt;</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p" data-group-id="8113847081-17">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8113847081-18">&lt;&lt;</span><span class="mi">4</span><span class="p" data-group-id="8113847081-18">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="8113847081-19">&lt;&lt;</span><span class="mi">9</span><span class="p" data-group-id="8113847081-19">&gt;&gt;</span><span class="p" data-group-id="8113847081-16">]</span></code></pre><p>Summary of options:</p><dl><dt>{scope, part()}</dt><dd><p>Works as in <a href="stdlib:binary#match/3" rel="https://erlang.org/doc/link/seemfa"><code>match/3</code></a> and <a href="stdlib:binary#matches/3" rel="https://erlang.org/doc/link/seemfa"><code>matches/3</code></a>. Notice that this only defines the scope of the search for matching strings, it does not cut the binary before splitting. The bytes before and after the scope are kept in the result. See the example below.</p></dd><dt>trim</dt><dd><p>Removes trailing empty parts of the result (as does <code>trim</code> in <a href="stdlib:re#split/3" rel="https://erlang.org/doc/link/seemfa"><code>re:split/3</code></a>.</p></dd><dt>trim_all</dt><dd><p>Removes all empty parts of the result.</p></dd><dt>global</dt><dd><p>Repeats the split until <code>Subject</code> is exhausted. Conceptually option <code>global</code> makes split work on the positions returned by <a href="stdlib:binary#matches/3" rel="https://erlang.org/doc/link/seemfa"><code>matches/3</code></a>, while it normally works on the position returned by <a href="stdlib:binary#match/3" rel="https://erlang.org/doc/link/seemfa"><code>match/3</code></a>.</p></dd></dl><p>Example of the difference between a scope and taking the binary apart before splitting:</p><pre><code class="makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:split</span><span class="p" data-group-id="3623395659-1">(</span><span class="p" data-group-id="3623395659-2">&lt;&lt;</span><span class="s">&quot;banana&quot;</span><span class="p" data-group-id="3623395659-2">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3623395659-3">[</span><span class="p" data-group-id="3623395659-4">&lt;&lt;</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="3623395659-4">&gt;&gt;</span><span class="p" data-group-id="3623395659-3">]</span><span class="p">,</span><span class="p" data-group-id="3623395659-5">[</span><span class="p" data-group-id="3623395659-6">{</span><span class="n">scope</span><span class="p">,</span><span class="p" data-group-id="3623395659-7">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="3623395659-7">}</span><span class="p" data-group-id="3623395659-6">}</span><span class="p" data-group-id="3623395659-5">]</span><span class="p" data-group-id="3623395659-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="3623395659-8">[</span><span class="p" data-group-id="3623395659-9">&lt;&lt;</span><span class="s">&quot;ban&quot;</span><span class="p" data-group-id="3623395659-9">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="3623395659-10">&lt;&lt;</span><span class="s">&quot;na&quot;</span><span class="p" data-group-id="3623395659-10">&gt;&gt;</span><span class="p" data-group-id="3623395659-8">]</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">binary</span><span class="ss">:split</span><span class="p" data-group-id="3623395659-11">(</span><span class="n">binary</span><span class="ss">:part</span><span class="p" data-group-id="3623395659-12">(</span><span class="p" data-group-id="3623395659-13">&lt;&lt;</span><span class="s">&quot;banana&quot;</span><span class="p" data-group-id="3623395659-13">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="3623395659-14">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="3623395659-14">}</span><span class="p" data-group-id="3623395659-12">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3623395659-15">[</span><span class="p" data-group-id="3623395659-16">&lt;&lt;</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="3623395659-16">&gt;&gt;</span><span class="p" data-group-id="3623395659-15">]</span><span class="p">,</span><span class="p" data-group-id="3623395659-17">[</span><span class="p" data-group-id="3623395659-17">]</span><span class="p" data-group-id="3623395659-11">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="3623395659-18">[</span><span class="p" data-group-id="3623395659-19">&lt;&lt;</span><span class="s">&quot;n&quot;</span><span class="p" data-group-id="3623395659-19">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="3623395659-20">&lt;&lt;</span><span class="s">&quot;n&quot;</span><span class="p" data-group-id="3623395659-20">&gt;&gt;</span><span class="p" data-group-id="3623395659-18">]</span></code></pre><p>The return type is always a list of binaries that are all referencing <code>Subject</code>. This means that the data in <code>Subject</code> is not copied to new binaries, and that <code>Subject</code> cannot be garbage collected until the results of the split are no longer referenced.</p><p>For a description of <code>Pattern</code>, see <a href="stdlib:binary#compile_pattern/1" rel="https://erlang.org/doc/link/seemfa"><code>compile_pattern/1</code></a>.</p>
  </section>
</section>

          </div>
        </section>

      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.23.0) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
