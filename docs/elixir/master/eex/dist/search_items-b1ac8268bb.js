searchNodes=[{"doc":"EEx stands for Embedded Elixir. It allows you to embed Elixir code inside a string in a robust way. iex&gt; EEx . eval_string ( &quot;foo &lt;%= bar %&gt;&quot; , bar : &quot;baz&quot; ) &quot;foo baz&quot; API This module provides three main APIs for you to use: Evaluate a string ( eval_string/3 ) or a file ( eval_file/3 ) directly. This is the simplest API to use but also the slowest, since the code is evaluated at runtime and not precompiled. Define a function from a string ( function_from_string/5 ) or a file ( function_from_file/5 ). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time. Compile a string ( compile_string/2 ) or a file ( compile_file/2 ) into Elixir syntax tree. This is the API used by both functions above and is available to you if you want to provide your own ways of handling the compiled template. Options All functions in this module accept EEx-related options. They are: :file - the file to be used in the template. Defaults to the given file the template is read from or to &quot;nofile&quot; when compiling from a string. :line - the line to be used as the template start. Defaults to 1 . :indentation - (since v1.11.0) an integer added to the column after every new line. Defaults to 0 . :engine - the EEx engine to be used for compilation. :trim - if true , trims whitespace left and right of quotation as long as at least one newline is present. All subsequent newlines and spaces are removed but one newline is retained. Defaults to false . Engine EEx has the concept of engines which allows you to modify or transform the code extracted from the given string or file. By default, EEx uses the EEx.SmartEngine that provides some conveniences on top of the simple EEx.Engine . Tags EEx.SmartEngine supports the following tags: &lt; % Elixir expression - inline with output % &gt; &lt; % = Elixir expression - replace with result % &gt; &lt; % % EEx quotation - returns the contents inside % &gt; &lt; % # Comments - they are discarded from source %&gt; All expressions that output something to the template must use the equals sign ( = ). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case if clauses, they are treated the same in EEx and also require = in order to have their result printed: &lt; % = if true do % &gt; It is obviously true &lt; % else % &gt; This will never appear &lt; % end % &gt; To escape an EEx expression in EEx use &lt;%% content %&gt; . For example: &lt; % % = x + 3 % &gt; will be rendered as &lt;%= x + 3 %&gt; . Note that different engines may have different rules for each tag. Other tags may be added in future versions. Macros EEx.SmartEngine also adds some macros to your template. An example is the @ macro which allows easy data access in a template: iex&gt; EEx . eval_string ( &quot;&lt;%= @foo %&gt;&quot; , assigns : [ foo : 1 ] ) &quot;1&quot; In other words, &lt;%= @foo %&gt; translates to: &lt; % = { :ok , v } = Access . fetch ( assigns , :foo ) ; v % &gt; The assigns extension is useful when the number of variables required by the template is not specified at compilation time.","ref":"EEx.html","title":"EEx","type":"module"},{"doc":"Gets a filename and generates a quoted expression that can be evaluated by Elixir or compiled to a function. This is useful if you want to compile a EEx template into code and inject that code somewhere or evaluate it at runtime. The generated quoted code will use variables defined in the template that will be taken from the context where the code is evaluated. If you have a template such as &lt;%= a + b %&gt; , then the returned quoted code will use the a and b variables in the context where it's evaluated. See examples below. Examples # sample.eex &lt; % = a + b % &gt; # In code: quoted = EEx . compile_file ( &quot;sample.eex&quot; ) { result , _bindings } = Code . eval_quoted ( quoted , a : 1 , b : 2 ) result #=&gt; &quot;3&quot;","ref":"EEx.html#compile_file/2","title":"EEx.compile_file/2","type":"function"},{"doc":"Gets a string source and generates a quoted expression that can be evaluated by Elixir or compiled to a function. This is useful if you want to compile a EEx template into code and inject that code somewhere or evaluate it at runtime. The generated quoted code will use variables defined in the template that will be taken from the context where the code is evaluated. If you have a template such as &lt;%= a + b %&gt; , then the returned quoted code will use the a and b variables in the context where it's evaluated. See examples below. Examples iex&gt; quoted = EEx . compile_string ( &quot;&lt;%= a + b %&gt;&quot; ) iex&gt; { result , _bindings } = Code . eval_quoted ( quoted , a : 1 , b : 2 ) iex&gt; result &quot;3&quot;","ref":"EEx.html#compile_string/2","title":"EEx.compile_string/2","type":"function"},{"doc":"Gets a filename and evaluate the values using the bindings . Examples # sample.eex foo &lt; % = bar % &gt; # IEx EEx . eval_file ( &quot;sample.eex&quot; , bar : &quot;baz&quot; ) #=&gt; &quot;foo baz&quot;","ref":"EEx.html#eval_file/3","title":"EEx.eval_file/3","type":"function"},{"doc":"Gets a string source and evaluate the values using the bindings . Examples iex&gt; EEx . eval_string ( &quot;foo &lt;%= bar %&gt;&quot; , bar : &quot;baz&quot; ) &quot;foo baz&quot;","ref":"EEx.html#eval_string/3","title":"EEx.eval_string/3","type":"function"},{"doc":"Generates a function definition from the file contents. The first argument is the kind of the generated function ( :def or :defp ). The name argument is the name that the generated function will have. file is the path to the EEx template file. args is a list of arguments that the generated function will accept. They will be available inside the EEx template. options is a list of EEx compilation options (see the module documentation). This function is useful in case you have templates but you want to precompile inside a module for speed. Examples # sample.eex &lt; % = a + b % &gt; # sample.ex defmodule Sample do require EEx EEx . function_from_file ( :def , :sample , &quot;sample.eex&quot; , [ :a , :b ] ) end # iex Sample . sample ( 1 , 2 ) #=&gt; &quot;3&quot;","ref":"EEx.html#function_from_file/5","title":"EEx.function_from_file/5","type":"macro"},{"doc":"Generates a function definition from the given string. The first argument is the kind of the generated function ( :def or :defp ). The name argument is the name that the generated function will have. template is the string containing the EEx template. args is a list of arguments that the generated function will accept. They will be available inside the EEx template. options is a list of EEx compilation options (see the module documentation). Examples iex&gt; defmodule Sample do ...&gt; require EEx ...&gt; EEx . function_from_string ( :def , :sample , &quot;&lt;%= a + b %&gt;&quot; , [ :a , :b ] ) ...&gt; end iex&gt; Sample . sample ( 1 , 2 ) &quot;3&quot;","ref":"EEx.html#function_from_string/5","title":"EEx.function_from_string/5","type":"macro"},{"doc":"Basic EEx engine that ships with Elixir. An engine needs to implement all callbacks below. This module also ships with a default engine implementation you can delegate to. See EEx.SmartEngine as an example.","ref":"EEx.Engine.html","title":"EEx.Engine","type":"behaviour"},{"doc":"Handles assigns in quoted expressions. A warning will be printed on missing assigns. Future versions will raise. This can be added to any custom engine by invoking handle_assign/1 with Macro.prewalk/2 : def handle_expr ( state , token , expr ) do expr = Macro . prewalk ( expr , &amp; EEx.Engine . handle_assign / 1 ) super ( state , token , expr ) end","ref":"EEx.Engine.html#handle_assign/1","title":"EEx.Engine.handle_assign/1","type":"function"},{"doc":"Default implementation for handle_begin/1 .","ref":"EEx.Engine.html#handle_begin/1","title":"EEx.Engine.handle_begin/1","type":"function"},{"doc":"Invoked at the beginning of every nesting. It must return a new state that is used only inside the nesting. Once the nesting terminates, the current state is resumed.","ref":"EEx.Engine.html#c:handle_begin/1","title":"EEx.Engine.handle_begin/1","type":"callback"},{"doc":"Default implementation for handle_body/1 .","ref":"EEx.Engine.html#handle_body/1","title":"EEx.Engine.handle_body/1","type":"function"},{"doc":"Called at the end of every template. It must return Elixir's quoted expressions for the template.","ref":"EEx.Engine.html#c:handle_body/1","title":"EEx.Engine.handle_body/1","type":"callback"},{"doc":"Default implementation for handle_end/1 .","ref":"EEx.Engine.html#handle_end/1","title":"EEx.Engine.handle_end/1","type":"function"},{"doc":"Invokes at the end of a nesting. It must return Elixir's quoted expressions for the nesting.","ref":"EEx.Engine.html#c:handle_end/1","title":"EEx.Engine.handle_end/1","type":"callback"},{"doc":"Default implementation for handle_expr/3 .","ref":"EEx.Engine.html#handle_expr/3","title":"EEx.Engine.handle_expr/3","type":"function"},{"doc":"Called for the dynamic/code parts of a template. The marker is what follows exactly after &lt;% . For example, &lt;% foo %&gt; has an empty marker, but &lt;%= foo %&gt; has &quot;=&quot; as marker. The allowed markers so far are: &quot;&quot; &quot;=&quot; &quot;/&quot; &quot;|&quot; Markers &quot;/&quot; and &quot;|&quot; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises EEx.SyntaxError . It must return the updated state.","ref":"EEx.Engine.html#c:handle_expr/3","title":"EEx.Engine.handle_expr/3","type":"callback"},{"doc":"Default implementation for handle_text/3 .","ref":"EEx.Engine.html#handle_text/3","title":"EEx.Engine.handle_text/3","type":"function"},{"doc":"Called for the text/static parts of a template. It must return the updated state.","ref":"EEx.Engine.html#c:handle_text/3","title":"EEx.Engine.handle_text/3","type":"callback"},{"doc":"Default implementation for init/1 .","ref":"EEx.Engine.html#init/1","title":"EEx.Engine.init/1","type":"function"},{"doc":"Called at the beginning of every template. It must return the initial state.","ref":"EEx.Engine.html#c:init/1","title":"EEx.Engine.init/1","type":"callback"},{"doc":"","ref":"EEx.Engine.html#t:state/0","title":"EEx.Engine.state/0","type":"type"},{"doc":"The default engine used by EEx. It includes assigns (like @foo ) and possibly other conveniences in the future. Examples iex&gt; EEx . eval_string ( &quot;&lt;%= @foo %&gt;&quot; , assigns : [ foo : 1 ] ) &quot;1&quot; In the example above, we can access the value foo under the binding assigns using @foo . This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set. Assigns can also be used when compiled to a function: # sample.eex &lt; % = @a + @b % &gt; # sample.ex defmodule Sample do require EEx EEx . function_from_file ( :def , :sample , &quot;sample.eex&quot; , [ :assigns ] ) end # iex Sample . sample ( a : 1 , b : 2 ) #=&gt; &quot;3&quot;","ref":"EEx.SmartEngine.html","title":"EEx.SmartEngine","type":"module"},{"doc":"","ref":"EEx.SyntaxError.html","title":"EEx.SyntaxError","type":"exception"}]