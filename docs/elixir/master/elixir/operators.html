<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.24.1">
    <meta name="project" content="Elixir v1.13.0-dev">

    <title>Operators — Elixir v1.13.0-dev</title>
    <link rel="stylesheet" href="dist/elixir-a172fe91e725dcb259e2.css" />

      <link rel="canonical" href="https://hexdocs.pm/elixir/master/operators.html" />

    <script src="dist/sidebar_items-ed39eda610.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f27ff079945e43879c46.js"></script>


  </head>
  <body data-type="extras">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="https://elixir-lang.org/docs.html" class="sidebar-projectName">
Elixir
      </a>
      <strong class="sidebar-projectVersion">
        v1.13.0-dev
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>Operators</h1><p>This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.</p><h2 id="operator-precedence-and-associativity" class="section-heading">
  <a href="#operator-precedence-and-associativity" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Operator precedence and associativity
</h2>
<p>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</p><p>Operator                                                                                 | Associativity
------------------------------------------------------| -------------
<code class="inline">@</code>                                                   | Unary
<code class="inline">.</code>                                                   | Left
<code class="inline">+</code> <code class="inline">-</code> <code class="inline">!</code> <code class="inline">^</code> <code class="inline">not</code> <code class="inline">~~~</code>                           | Unary
<code class="inline">*</code> <code class="inline">/</code>                                               | Left
<code class="inline">+</code> <code class="inline">-</code>                                               | Left
<code class="inline">++</code> <code class="inline">--</code> <code class="inline">+++</code> <code class="inline">---</code> <code class="inline">..</code> <code class="inline">&lt;&gt;</code>                       | Right
<code class="inline">in</code> <code class="inline">not in</code>                                         | Left
<code class="inline">\|&gt;</code> <code class="inline">&lt;&lt;&lt;</code> <code class="inline">&gt;&gt;&gt;</code> <code class="inline">&lt;&lt;~</code> <code class="inline">~&gt;&gt;</code> <code class="inline">&lt;~</code> <code class="inline">~&gt;</code> <code class="inline">&lt;~&gt;</code> <code class="inline">&lt;\|&gt;</code>  | Left
<code class="inline">&lt;</code> <code class="inline">&gt;</code> <code class="inline">&lt;=</code> <code class="inline">&gt;=</code>                                     | Left
<code class="inline">==</code> <code class="inline">!=</code> <code class="inline">=~</code> <code class="inline">===</code> <code class="inline">!==</code>                            | Left
<code class="inline">&amp;&amp;</code> <code class="inline">&amp;&amp;&amp;</code> <code class="inline">and</code>                                      | Left
<code class="inline">\|\|</code> <code class="inline">\|\|\|</code> <code class="inline">or</code>                                  | Left
<code class="inline">=</code>                                                   | Right
<code class="inline">&amp;</code>                                                   | Unary
<code class="inline">=&gt;</code> (valid only inside <code class="inline">%{}</code>)                        | Right
<code class="inline">\|</code>                                                  | Right
<code class="inline">::</code>                                                  | Right
<code class="inline">when</code>                                                | Right
<code class="inline">&lt;-</code> <code class="inline">\\</code>                                             | Left</p><h2 id="general-operators" class="section-heading">
  <a href="#general-operators" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  General operators
</h2>
<p>Elixir provides the following built-in operators that are defined as functions that can be overridden:</p><ul><li><a href="Kernel.html#+/1"><code class="inline">+</code></a> and <a href="Kernel.html#-/1"><code class="inline">-</code></a> - unary positive/negative</li><li><a href="Kernel.html#+/2"><code class="inline">+</code></a>, <a href="Kernel.html#-/2"><code class="inline">-</code></a>, <a href="Kernel.html#*/2"><code class="inline">*</code></a>, and <a href="Kernel.html#//2"><code class="inline">/</code></a> - basic arithmetic operations</li><li><a href="Kernel.html#++/2"><code class="inline">++</code></a> and <a href="Kernel.html#--/2"><code class="inline">--</code></a> - list concatenation and subtraction</li><li><a href="Kernel.html#and/2"><code class="inline">and</code></a> and <a href="Kernel.html#&&/2"><code class="inline">&amp;&amp;</code></a> - strict and relaxed boolean &quot;and&quot;</li><li><a href="Kernel.html#or/2"><code class="inline">or</code></a> and <a href="Kernel.html#%7C%7C/2"><code class="inline">||</code></a> - strict and relaxed boolean &quot;or&quot;</li><li><a href="Kernel.html#not/1"><code class="inline">not</code></a> and <a href="Kernel.html#!/1"><code class="inline">!</code></a> - strict and relaxed boolean &quot;not&quot;</li><li><a href="Kernel.html#in/2"><code class="inline">in</code></a> and <a href="Kernel.html#in/2"><code class="inline">not in</code></a> - membership</li><li><a href="Kernel.html#@/1"><code class="inline">@</code></a> - module attribute</li><li><a href="Kernel.html#../2"><code class="inline">..</code></a> - range creation</li><li><a href="Kernel.html#%3C%3E/2"><code class="inline">&lt;&gt;</code></a> - binary concatenation</li><li><a href="Kernel.html#%7C%3E/2"><code class="inline">|&gt;</code></a> - pipeline</li><li><a href="Kernel.html#=~/2"><code class="inline">=~</code></a> - text-based match</li></ul><p>Many of those can be used in guards; consult the <a href="patterns-and-guards.html#list-of-allowed-functions-and-operators">list of allowed guard functions and operators</a>.</p><p>Additionally, there are a few other operators that Elixir parses but doesn't actually use.
See <a href="#custom-and-overridden-operators">Custom and overridden operators</a> below for a list and for guidelines about their use.</p><p>Some other operators are special forms and cannot be overridden:</p><ul><li><a href="Kernel.SpecialForms.html#%5E/1"><code class="inline">^</code></a> - pin operator</li><li><a href="Kernel.SpecialForms.html#./2"><code class="inline">.</code></a> - dot operator</li><li><a href="Kernel.SpecialForms.html#=/2"><code class="inline">=</code></a> - match operator</li><li><a href="Kernel.SpecialForms.html#&/1"><code class="inline">&amp;</code></a> - capture operator</li><li><a href="Kernel.SpecialForms.html#::/2"><code class="inline">::</code></a> - type operator</li></ul><p>Finally, these operators appear in the precedence table above but are only meaningful within certain constructs:</p><ul><li><code class="inline">=&gt;</code> - see <a href="Kernel.SpecialForms.html#%25%7B%7D/1"><code class="inline">%{}</code></a></li><li><code class="inline">when</code> - see <a href="patterns-and-guards.html#guards">Guards</a></li><li><code class="inline">&lt;-</code> - see <a href="Kernel.SpecialForms.html#for/1"><code class="inline">for</code></a> and <a href="Kernel.SpecialForms.html#with/1"><code class="inline">with</code></a></li><li><code class="inline">\\</code> - see <a href="Kernel.html#def/2-default-arguments">Default arguments</a></li></ul><h2 id="comparison-operators" class="section-heading">
  <a href="#comparison-operators" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Comparison operators
</h2>
<p>Elixir provides the following built-in comparison operators (all of which can be used in guards):</p><ul><li><a href="Kernel.html#==/2"><code class="inline">==</code></a> - equal to</li><li><a href="Kernel.html#===/2"><code class="inline">===</code></a> - strictly equal to</li><li><a href="Kernel.html#!=/2"><code class="inline">!=</code></a> - inequal to</li><li><a href="Kernel.html#!==/2"><code class="inline">!==</code></a> - strictly inequal to</li><li><a href="Kernel.html#%3C/2"><code class="inline">&lt;</code></a> - less-than</li><li><a href="Kernel.html#%3E/2"><code class="inline">&gt;</code></a> - greater-than</li><li><a href="Kernel.html#%3C=/2"><code class="inline">&lt;=</code></a> - less-than or equal to</li><li><a href="Kernel.html#%3E=/2"><code class="inline">&gt;=</code></a> - greater-than or equal to</li></ul><p>The only difference between <a href="Kernel.html#==/2"><code class="inline">==</code></a> and <a href="Kernel.html#===/2"><code class="inline">===</code></a> is that <a href="Kernel.html#===/2"><code class="inline">===</code></a> is strict when it comes to comparing integers and floats:</p><pre><code class="makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1.0</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1.0</span><span class="w">
</span><span class="no">false</span></code></pre><p><a href="Kernel.html#!=/2"><code class="inline">!=</code></a> and <a href="Kernel.html#!==/2"><code class="inline">!==</code></a> act as the negation of <a href="Kernel.html#==/2"><code class="inline">==</code></a> and <a href="Kernel.html#===/2"><code class="inline">===</code></a>, respectively.</p><h3 id="term-ordering" class="section-heading">
  <a href="#term-ordering" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Term ordering
</h3>
<p>In Elixir, different data types can be compared using comparison operators:</p><pre><code class="makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="ss">:an_atom</span><span class="w">
</span><span class="no">true</span></code></pre><p>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</p><pre><code class="makeup elixir"><span class="n">number</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">atom</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">port</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bitstring</span></code></pre><p>When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either <a href="Kernel.html#===/2"><code class="inline">===</code></a> or <a href="Kernel.html#!==/2"><code class="inline">!==</code></a>. A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive.</p><p>The collection types are compared using the following rules:</p><ul><li>Tuples are compared by size, then element by element.</li><li>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</li><li>Lists are compared element by element.</li><li>Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit.</li><li>Atoms are compared using their string value, codepoint by codepoint.</li></ul><h2 id="custom-and-overridden-operators" class="section-heading">
  <a href="#custom-and-overridden-operators" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Custom and overridden operators
</h2>
<h3 id="defining-custom-operators" class="section-heading">
  <a href="#defining-custom-operators" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Defining custom operators
</h3>
<p>Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are <em>used</em> by Elixir: for example, <code class="inline">+</code> and <code class="inline">||</code> are used by Elixir for addition and boolean <em>or</em>, but <code class="inline">&lt;~&gt;</code> is not used (but valid).</p><p>To define an operator, you can use the usual <code class="inline">def*</code> constructs (<code class="inline">def</code>, <code class="inline">defp</code>, <code class="inline">defmacro</code>, and so on) but with a syntax similar to how the operator is used:</p><pre><code class="makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyOperators</span><span class="w"> </span><span class="k" data-group-id="7311164113-1">do</span><span class="w">
  </span><span class="c1"># We define ~&gt; to return the maximum of the given two numbers,</span><span class="w">
  </span><span class="c1"># and &lt;~ to return the minimum.</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">~&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">max</span><span class="p" data-group-id="7311164113-2">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7311164113-2">)</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">min</span><span class="p" data-group-id="7311164113-3">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p" data-group-id="7311164113-3">)</span><span class="w">
</span><span class="k" data-group-id="7311164113-1">end</span></code></pre><p>To use the newly defined operators, we <strong>have to</strong> import the module that defines them:</p><pre><code class="makeup elixir"><span class="gp unselectable">iex&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nc">MyOperators</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">~&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;~</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="mi">1</span></code></pre><p>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</p><ul><li><code class="inline">|||</code></li><li><code class="inline">&amp;&amp;&amp;</code></li><li><code class="inline">&lt;&lt;&lt;</code></li><li><code class="inline">&gt;&gt;&gt;</code></li><li><code class="inline">&lt;&lt;~</code></li><li><code class="inline">~&gt;&gt;</code></li><li><code class="inline">&lt;~</code></li><li><code class="inline">~&gt;</code></li><li><code class="inline">&lt;~&gt;</code></li><li><code class="inline">&lt;|&gt;</code></li><li><code class="inline">+++</code></li><li><code class="inline">---</code></li><li><code class="inline">~~~</code></li></ul><p>The following operators are used by the <a href="Bitwise.html"><code class="inline">Bitwise</code></a> module when imported: <a href="Bitwise.html#&&&/2"><code class="inline">&amp;&amp;&amp;</code></a>, <a href="Bitwise.html#%3C%3C%3C/2"><code class="inline">&lt;&lt;&lt;</code></a>, <a href="Bitwise.html#%3E%3E%3E/2"><code class="inline">&gt;&gt;&gt;</code></a>, <a href="Bitwise.html#%7C%7C%7C/2"><code class="inline">|||</code></a>, <a href="Bitwise.html#~~~/1"><code class="inline">~~~</code></a>. See the documentation for <a href="Bitwise.html"><code class="inline">Bitwise</code></a> for more information.</p><p>Note the Elixir community generally discourages custom operators. They can be hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices.</p><p>It is also possible replace predefined operators, such as <code class="inline">+</code>, but doing so is extremely discouraged.</p>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="naming-conventions.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Naming Conventions
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="patterns-and-guards.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Patterns and Guards
        </span>
      </a>

  </div>
</div>

      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.24.1) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
