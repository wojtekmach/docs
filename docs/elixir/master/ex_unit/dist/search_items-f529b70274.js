searchNodes=[{"doc":"Unit testing framework for Elixir. Example A basic setup for ExUnit is shown below: # File: assertion_test.exs # 1) Start ExUnit. ExUnit . start ( ) # 2) Create a new test module (test case) and use &quot;ExUnit.Case&quot;. defmodule AssertionTest do # 3) Note that we pass &quot;async: true&quot;, this runs the test case # concurrently with other test cases. The individual tests # within each test case are still run serially. use ExUnit.Case , async : true # 4) Use the &quot;test&quot; macro instead of &quot;def&quot; for clarity. test &quot;the truth&quot; do assert true end end To run the tests above, run the file using elixir from the command line. Assuming you named the file assertion_test.exs , you can run it as: elixir assertion_test . exs Case, Callbacks and Assertions See ExUnit.Case and ExUnit.Callbacks for more information about defining test cases and setting up callbacks. The ExUnit.Assertions module contains a set of macros to generate assertions with appropriate error messages. Integration with Mix Mix is the project management and build tool for Elixir. Invoking mix test from the command line will run the tests in each file matching the pattern *_test.exs found in the test directory of your project. You must create a test_helper.exs file inside the test directory and put the code common to all tests there. The minimum example of a test_helper.exs file would be: # test/test_helper.exs ExUnit . start ( ) Mix will load the test_helper.exs file before executing the tests. It is not necessary to require the test_helper.exs file in your test files. Run mix help test for more information.","ref":"ExUnit.html","title":"ExUnit","type":"module"},{"doc":"Sets a callback to be executed after the completion of a test suite. Callbacks set with after_suite/1 must accept a single argument, which is a map containing the results of the test suite's execution. If after_suite/1 is called multiple times, the callbacks will be called in reverse order. In other words, the last callback set will be the first to be called.","ref":"ExUnit.html#after_suite/1","title":"ExUnit.after_suite/1","type":"function"},{"doc":"Returns ExUnit configuration.","ref":"ExUnit.html#configuration/0","title":"ExUnit.configuration/0","type":"function"},{"doc":"Configures ExUnit. Options ExUnit supports the following options: :assert_receive_timeout - the timeout to be used on assert_receive calls in milliseconds, defaults to 100 ; :autorun - if ExUnit should run by default on exit. Defaults to true ; :capture_log - if ExUnit should default to keeping track of log messages and print them on test failure. Can be overridden for individual tests via @tag capture_log: false . Defaults to false ; :colors - a keyword list of color options to be used by some formatters: :enabled - boolean option to enable colors, defaults to IO.ANSI.enabled?/0 ; :diff_insert - color of the insertions on diffs, defaults to :green ; :diff_insert_whitespace - color of the whitespace insertions on diffs, defaults to IO.ANSI.color_background(2, 0, 0) ; :diff_delete - color of the deletions on diffs, defaults to :red ; :diff_delete_whitespace - color of the whitespace deletions on diffs, defaults to IO.ANSI.color_background(0, 2, 0) ; :exclude - specifies which tests are run by skipping tests that match the filter; :failures_manifest_file - specifies a path to the file used to store failures between runs; :formatters - the formatters that will print results, defaults to [ExUnit.CLIFormatter] ; :include - specifies which tests are run by skipping tests that do not match the filter. Keep in mind that all tests are included by default, so unless they are excluded first, the :include option has no effect. To only run the tests that match the :include filter, exclude the :test tag first (see the documentation for ExUnit.Case for more information on tags); :max_cases - maximum number of tests to run in parallel. Only tests from different modules run in parallel. It defaults to System.schedulers_online * 2 to optimize both CPU-bound and IO-bound tests; :max_failures - the suite stops evaluating tests when this number of test failures is reached. All tests within a module that fail when using the setup_all/1,2 callbacks are counted as failures. Defaults to :infinity ; :only_test_ids - a list of {module_name, test_name} tuples that limits what tests get run; :refute_receive_timeout - the timeout to be used on refute_receive calls in milliseconds, defaults to 100 ; :seed - an integer seed value to randomize the test suite. This seed is also mixed with the test module and name to create a new unique seed on every test, which is automatically fed into the :rand module. This provides randomness between tests, but predictable and reproducible results; :slowest - prints timing information for the N slowest tests. Running ExUnit with slow test reporting automatically runs in trace mode. It is disabled by default; :stacktrace_depth - configures the stacktrace depth to be used on formatting and reporters, defaults to 20 ; :timeout - sets the timeout for the tests in milliseconds, defaults to 60_000 ; :trace - sets ExUnit into trace mode, this sets :max_cases to 1 and prints each test case and test while running. Note that in trace mode test timeouts will be ignored as timeout is set to :infinity . :test_location_relative_path - the test location is the file:line information printed by tests as a shortcut to run a given test. When this value is set, the value is used as a prefix for the test itself. This is typically used by Mix to properly set-up umbrella projects Any arbitrary configuration can also be passed to configure/1 or start/1 , and these options can then be used in places such as custom formatters. These other options will be ignored by ExUnit itself.","ref":"ExUnit.html#configure/1","title":"ExUnit.configure/1","type":"function"},{"doc":"Fetches the test supervisor for the current test. Returns {:ok, supervisor_pid} or :error if not called from the test process. This is the same supervisor as used by ExUnit.Callbacks.start_supervised/2 and similar, see ExUnit.Callbacks module documentation for more information.","ref":"ExUnit.html#fetch_test_supervisor/0","title":"ExUnit.fetch_test_supervisor/0","type":"function"},{"doc":"Returns the pluralization for word . If one is not registered, returns the word appended with an &quot;s&quot;.","ref":"ExUnit.html#plural_rule/1","title":"ExUnit.plural_rule/1","type":"function"},{"doc":"Registers a pluralization for word . If one is already registered, it is replaced.","ref":"ExUnit.html#plural_rule/2","title":"ExUnit.plural_rule/2","type":"function"},{"doc":"Runs the tests. It is invoked automatically if ExUnit is started via start/1 . Returns a map containing the total number of tests, the number of failures, the number of excluded tests and the number of skipped tests.","ref":"ExUnit.html#run/0","title":"ExUnit.run/0","type":"function"},{"doc":"Starts ExUnit and automatically runs tests right before the VM terminates. It accepts a set of options to configure ExUnit (the same ones accepted by configure/1 ). If you want to run tests manually, you can set the :autorun option to false and use run/0 to run tests.","ref":"ExUnit.html#start/1","title":"ExUnit.start/1","type":"function"},{"doc":"The error state returned by ExUnit.Test and ExUnit.TestModule","ref":"ExUnit.html#t:failed/0","title":"ExUnit.failed/0","type":"type"},{"doc":"All tests start with a state of nil . A finished test can be in one of five states: Passed (also represented by nil ) Failed Skipped (via @tag :skip) Excluded (via :exclude filters) Invalid (when setup_all fails)","ref":"ExUnit.html#t:state/0","title":"ExUnit.state/0","type":"type"},{"doc":"A map representing the results of running a test suite","ref":"ExUnit.html#t:suite_result/0","title":"ExUnit.suite_result/0","type":"type"},{"doc":"","ref":"ExUnit.html#t:test_id/0","title":"ExUnit.test_id/0","type":"type"},{"doc":"This module contains a set of assertion functions that are imported by default into your test cases. In general, a developer will want to use the general assert macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, assert some_fun() == 10 will fail (assuming some_fun() returns 13 ): Comparison ( using == ) failed in : code : assert some_fun ( ) == 10 left : 13 right : 10 This module also provides other convenience functions like assert_in_delta and assert_raise to easily handle other common cases such as checking a floating-point number or handling exceptions.","ref":"ExUnit.Assertions.html","title":"ExUnit.Assertions","type":"module"},{"doc":"Asserts its argument is a truthy value. assert introspects the underlying expression and provides good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion assert 1 + 2 + 3 + 4 &gt; 15 will fail with the message: Assertion with &gt; failed code : assert 1 + 2 + 3 + 4 &gt; 15 left : 10 right : 15 Similarly, if a match expression is given, it will report any failure in terms of that match. Given assert [ 1 ] = [ 2 ] you'll see: match ( = ) failed code : assert [ 1 ] = [ 2 ] left : [ 1 ] right : [ 2 ] Keep in mind that assert does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail: assert nil = some_function_that_returns_nil ( ) Even though the match works, assert still expects a truth value. In such cases, simply use Kernel.==/2 or Kernel.match?/2 .","ref":"ExUnit.Assertions.html#assert/1","title":"ExUnit.Assertions.assert/1","type":"macro"},{"doc":"Asserts value is truthy, displaying the given message otherwise. Examples assert false , &quot;it will never be true&quot; assert x == :foo , &quot;expected x to be foo&quot; assert match? ( { :ok , _ } , x ) , &quot;expected x to match {:ok, _}&quot;","ref":"ExUnit.Assertions.html#assert/2","title":"ExUnit.Assertions.assert/2","type":"function"},{"doc":"Asserts that value1 and value2 differ by no more than delta . This difference is inclusive, so the test will pass if the difference and the delta are equal. Examples assert_in_delta 1.1 , 1.5 , 0.2 assert_in_delta 10 , 15 , 2 assert_in_delta 10 , 15 , 5","ref":"ExUnit.Assertions.html#assert_in_delta/4","title":"ExUnit.Assertions.assert_in_delta/4","type":"function"},{"doc":"Asserts the exception is raised during function execution. Returns the rescued exception, fails otherwise. Examples assert_raise ArithmeticError , fn -&gt; 1 + &quot;test&quot; end","ref":"ExUnit.Assertions.html#assert_raise/2","title":"ExUnit.Assertions.assert_raise/2","type":"function"},{"doc":"Asserts the exception is raised during function execution with the expected message , which can be a Regex or an exact String . Returns the rescued exception, fails otherwise. Examples assert_raise ArithmeticError , &quot;bad argument in arithmetic expression&quot; , fn -&gt; 1 + &quot;test&quot; end assert_raise RuntimeError , ~r/^today&#39;s lucky number is 0 \\. \\d +!$/ , fn -&gt; raise &quot;today&#39;s lucky number is \#{ :rand . uniform ( ) } !&quot; end","ref":"ExUnit.Assertions.html#assert_raise/3","title":"ExUnit.Assertions.assert_raise/3","type":"function"},{"doc":"Asserts that a message matching pattern was or is going to be received within the timeout period, specified in milliseconds. Unlike assert_received , it has a default timeout of 100 milliseconds. The pattern argument must be a match pattern. Flunks with failure_message if a message matching pattern is not received. Examples assert_receive :hello Asserts against a larger timeout: assert_receive :hello , 20_000 You can also match against specific patterns: assert_receive { :hello , _ } x = 5 assert_receive { :count , ^ x }","ref":"ExUnit.Assertions.html#assert_receive/3","title":"ExUnit.Assertions.assert_receive/3","type":"macro"},{"doc":"Asserts that a message matching pattern was received and is in the current process' mailbox. The pattern argument must be a match pattern. Flunks with failure_message if a message matching pattern was not received. Timeout is set to 0, so there is no waiting time. Examples send ( self ( ) , :hello ) assert_received :hello send ( self ( ) , :bye ) assert_received :hello , &quot;Oh No!&quot; ** (ExUnit.AssertionError) Oh No! You can also match against specific patterns: send ( self ( ) , { :hello , &quot;world&quot; } ) assert_received { :hello , _ }","ref":"ExUnit.Assertions.html#assert_received/2","title":"ExUnit.Assertions.assert_received/2","type":"macro"},{"doc":"Asserts expression will cause an error. Returns the error or fails otherwise. Examples assert catch_error ( error ( 1 ) ) == 1","ref":"ExUnit.Assertions.html#catch_error/1","title":"ExUnit.Assertions.catch_error/1","type":"macro"},{"doc":"Asserts expression will exit. Returns the exit status/message of the current process or fails otherwise. Examples assert catch_exit ( exit ( 1 ) ) == 1 To assert exits from linked processes started from the test, trap exits with Process.flag/2 and assert the exit message with assert_received/2 . Process . flag ( :trap_exit , true ) pid = spawn_link ( fn -&gt; Process . exit ( self ( ) , :normal ) end ) assert_receive { :EXIT , ^ pid , :normal }","ref":"ExUnit.Assertions.html#catch_exit/1","title":"ExUnit.Assertions.catch_exit/1","type":"macro"},{"doc":"Asserts expression will throw a value. Returns the thrown value or fails otherwise. Examples assert catch_throw ( throw ( 1 ) ) == 1","ref":"ExUnit.Assertions.html#catch_throw/1","title":"ExUnit.Assertions.catch_throw/1","type":"macro"},{"doc":"Fails with a message. Examples flunk ( &quot;This should raise an error&quot; )","ref":"ExUnit.Assertions.html#flunk/1","title":"ExUnit.Assertions.flunk/1","type":"function"},{"doc":"A negative assertion, expects the expression to be false or nil . Keep in mind that refute does not change the semantics of the given expression. In other words, the following will fail: refute { :ok , _ } = some_function_that_returns_error_tuple ( ) The code above will fail because the = operator always fails when the sides do not match and refute/2 does not change it. The correct way to write the refutation above is to use Kernel.match?/2 : refute match? ( { :ok , _ } , some_function_that_returns_error_tuple ( ) ) Examples refute age &lt; 0","ref":"ExUnit.Assertions.html#refute/1","title":"ExUnit.Assertions.refute/1","type":"macro"},{"doc":"Asserts value is nil or false (that is, value is not truthy). Examples refute true , &quot;This will obviously fail&quot;","ref":"ExUnit.Assertions.html#refute/2","title":"ExUnit.Assertions.refute/2","type":"function"},{"doc":"Asserts value1 and value2 are not within delta . This difference is exclusive, so the test will fail if the difference and the delta are equal. If you supply message , information about the values will automatically be appended to it. Examples refute_in_delta 1.1 , 1.2 , 0.2 refute_in_delta 10 , 11 , 2","ref":"ExUnit.Assertions.html#refute_in_delta/4","title":"ExUnit.Assertions.refute_in_delta/4","type":"function"},{"doc":"Asserts that a message matching pattern was not received (and won't be received) within the timeout period, specified in milliseconds. The pattern argument must be a match pattern. Flunks with failure_message if a message matching pattern is received. Examples refute_receive :bye Refute received with an explicit timeout: refute_receive :bye , 1000","ref":"ExUnit.Assertions.html#refute_receive/3","title":"ExUnit.Assertions.refute_receive/3","type":"macro"},{"doc":"Asserts a message matching pattern was not received (i.e. it is not in the current process' mailbox). The pattern argument must be a match pattern. Flunks with failure_message if a message matching pattern was received. Timeout is set to 0, so there is no waiting time. Examples send ( self ( ) , :hello ) refute_received :bye send ( self ( ) , :hello ) refute_received :hello , &quot;Oh No!&quot; ** (ExUnit.AssertionError) Oh No!","ref":"ExUnit.Assertions.html#refute_received/2","title":"ExUnit.Assertions.refute_received/2","type":"macro"},{"doc":"Defines ExUnit callbacks. This module defines the setup/1 , setup/2 , setup_all/1 , and setup_all/2 callbacks, as well as the on_exit/2 , start_supervised/2 and stop_supervised/1 functions. The setup callbacks may be used to define test fixtures and run any initialization code which help bring the system into a known state. They are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as the context . Optionally, the context to be used in the tests can be extended by the setup callbacks by returning a properly structured value (see below). The setup_all callbacks are invoked only once per module, before any test is run. All setup callbacks are run before each test. No callback is run if the test case has no tests or all tests have been filtered out. setup and setup_all callbacks can be defined by a block, by passing an atom naming a one-arity function, or by passing a list of such atoms. Both can opt to receive the current context by specifying it as parameter if defined by a block. Functions used to define a test setup must accept the context as single argument. A test module can define multiple setup and setup_all callbacks, and they are invoked in order of appearance. start_supervised/2 is used to start processes under a supervisor. The supervisor is linked to the current test process. The supervisor as well as all child processes are guaranteed to terminate before any on_exit/2 callback runs. on_exit/2 callbacks are registered on demand, usually to undo an action performed by a setup callback. on_exit/2 may also take a reference, allowing the callback to be overridden in the future. A registered on_exit/2 callback will always run, while failures in setup and setup_all will stop all remaining setup callbacks from executing. Finally, setup_all callbacks run in a separate process per module, while all setup callbacks run in the same process as the test itself. on_exit/2 callbacks always run in a separate process, as implied by their name. The test process always exits with reason :shutdown , which means any process linked to the test process will also exit, although asynchronously. Therefore it is preferred to use start_supervised/2 to guarantee synchronous termination. Here is a rundown of the life-cycle of the test process: the test process is spawned it runs setup/2 callbacks it runs the test itself it stops all supervised processes the test process exits with reason :shutdown on_exit/2 callbacks are executed in a separate process Context If setup_all or setup return a keyword list, a map, or a tuple in the shape of {:ok, keyword() | map()} , the keyword list or map will be merged into the current context and will be available in all subsequent setup_all , setup , and the test itself. Returning :ok leaves the context unchanged (in setup and setup_all callbacks). Returning anything else from setup_all will force all tests to fail, while a bad response from setup causes the current test to fail. Examples defmodule AssertionTest do use ExUnit.Case , async : true # &quot;setup_all&quot; is called once per module before any test runs setup_all do IO . puts ( &quot;Starting AssertionTest&quot; ) # Context is not updated here :ok end # &quot;setup&quot; is called before each test setup do IO . puts ( &quot;This is a setup callback for \#{ inspect ( self ( ) ) } &quot; ) on_exit ( fn -&gt; IO . puts ( &quot;This is invoked once the test is done. Process: \#{ inspect ( self ( ) ) } &quot; ) end ) # Returns extra metadata to be merged into context. # Any of the following would also work: # # {:ok, %{hello: &quot;world&quot;}} # {:ok, [hello: &quot;world&quot;]} # %{hello: &quot;world&quot;} # [ hello : &quot;world&quot; ] end # Same as above, but receives the context as argument setup context do IO . puts ( &quot;Setting up: \#{ context . test } &quot; ) # We can simply return :ok when we don&#39;t want to add any extra metadata :ok end # Setups can also invoke a local or imported function that returns a context setup :invoke_local_or_imported_function test &quot;always pass&quot; do assert true end test &quot;uses metadata from setup&quot; , context do assert context [ :hello ] == &quot;world&quot; assert context [ :from_named_setup ] == true end defp invoke_local_or_imported_function ( context ) do [ from_named_setup : true ] end end It is also common to define your setup as a series of functions, which are put together by calling setup or setup_all with a list of atoms. Each of these functions receive the context and can return any of the values allowed in setup blocks: defmodule ExampleContextTest do use ExUnit.Case setup [ :step1 , :step2 , :step3 ] defp step1 ( _context ) , do : [ step_one : true ] defp step2 ( _context ) , do : { :ok , step_two : true } # return values with shape of {:ok, keyword() | map()} allowed defp step3 ( _context ) , do : :ok # Context not modified test &quot;context was modified&quot; , context do assert context [ :step_one ] == true assert context [ :step_two ] == true end end Finally, as discussed in the ExUnit.Case documentation, remember that the initial context metadata can also be set via @tag s, which can then be accessed in the setup block: defmodule ExampleTagModificationTest do use ExUnit.Case setup %{ login_as : username } do { :ok , current_user : username } end @tag login_as : &quot;max&quot; test &quot;tags modify context&quot; , context do assert context [ :login_as ] == &quot;max&quot; assert context [ :current_user ] == &quot;max&quot; end end","ref":"ExUnit.Callbacks.html","title":"ExUnit.Callbacks","type":"module"},{"doc":"Defines a callback that runs once the test exits. callback is a function that receives no arguments and runs in a separate process than the caller. on_exit/2 is usually called from setup and setup_all callbacks, often to undo the action performed during the setup. However, on_exit/2 may also be called dynamically, where a reference can be used to guarantee the callback will be invoked only once. on_exit/2 gets executed in a blocking fashion after a test exits and before running the next test. This means that no other test from the same test case will be running while the on_exit/2 callback for a previous test is running. on_exit/2 is executed in a different process than the test process. Examples setup do File . write! ( &quot;fixture.json&quot; , &quot;{}&quot; ) on_exit ( fn -&gt; File . rm! ( &quot;fixture.json&quot; ) end ) end","ref":"ExUnit.Callbacks.html#on_exit/2","title":"ExUnit.Callbacks.on_exit/2","type":"function"},{"doc":"Defines a callback to be run before each test in a case. Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms. Can return values to be merged into the context, to set up the state for tests. For more details, see the &quot;Context&quot; section shown above. setup/1 callbacks are executed in the same process as the test process. Examples def clean_up_tmp_directory ( context ) do # perform setup :ok end setup :clean_up_tmp_directory setup do [ conn : Plug.Conn . build_conn ( ) ] end","ref":"ExUnit.Callbacks.html#setup/1","title":"ExUnit.Callbacks.setup/1","type":"macro"},{"doc":"Defines a callback to be run before each test in a case. Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms. Can return values to be merged into the context , to set up the state for tests. For more details, see the &quot;Context&quot; section shown above. Examples setup context do [ conn : Plug.Conn . build_conn ( ) ] end","ref":"ExUnit.Callbacks.html#setup/2","title":"ExUnit.Callbacks.setup/2","type":"macro"},{"doc":"Defines a callback to be run before all tests in a case. Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms. Can return values to be merged into the context , to set up the state for tests. For more details, see the &quot;Context&quot; section shown above. setup_all/1 callbacks are executed in a separate process than tests. All setup_all/1 callbacks are executed in order in the same process. Examples # One-arity function name setup_all :clean_up_tmp_directory def clean_up_tmp_directory ( _context ) do # perform setup :ok end # Block setup_all do [ conn : Plug.Conn . build_conn ( ) ] end The context returned by setup_all/1 will be available in all subsequent setup_all , setup , and the test itself. For instance, the conn from the previous example can be accessed as: test &quot;fetches current users&quot; , %{ conn : conn } do # ... end","ref":"ExUnit.Callbacks.html#setup_all/1","title":"ExUnit.Callbacks.setup_all/1","type":"macro"},{"doc":"Defines a callback to be run before all tests in a case. Same as setup_all/1 but also takes a context. See the &quot;Context&quot; section in the module documentation. Examples setup_all _context do [ conn : Plug.Conn . build_conn ( ) ] end","ref":"ExUnit.Callbacks.html#setup_all/2","title":"ExUnit.Callbacks.setup_all/2","type":"macro"},{"doc":"Starts a child process under the test supervisor. It expects a child specification or a module, similar to the ones given to Supervisor.start_link/2 . For example, if your application starts a supervision tree by running: Supervisor . start_link ( [ MyServer , { OtherSupervisor , ... } ] , ... ) You can start those processes under test in isolation by running: start_supervised ( MyServer ) start_supervised ( { OtherSupervisor , :initial_value } ) A keyword list can also be given if there is a need to change the child specification for the given child process: start_supervised ( { MyServer , :initial_value } , restart : :temporary ) See the Supervisor module for a discussion on child specifications and the available specification keys. The advantage of starting a process under the test supervisor is that it is guaranteed to exit before the next test starts. Therefore, you don't need to remove the process at the end of your tests via stop_supervised/1 . You only need to use stop_supervised/1 if you want to remove a process from the supervision tree in the middle of a test, as simply shutting down the process would cause it to be restarted according to its :restart value. This function returns {:ok, pid} in case of success, otherwise it returns {:error, reason} .","ref":"ExUnit.Callbacks.html#start_supervised/2","title":"ExUnit.Callbacks.start_supervised/2","type":"function"},{"doc":"Same as start_supervised/2 but returns the PID on success and raises if not started properly.","ref":"ExUnit.Callbacks.html#start_supervised!/2","title":"ExUnit.Callbacks.start_supervised!/2","type":"function"},{"doc":"Stops a child process started via start_supervised/2 . This function expects the id in the child specification. For example: { :ok , _ } = start_supervised ( MyServer ) :ok = stop_supervised ( MyServer ) It returns :ok if there is a supervised process with such id , {:error, :not_found} otherwise.","ref":"ExUnit.Callbacks.html#stop_supervised/1","title":"ExUnit.Callbacks.stop_supervised/1","type":"function"},{"doc":"Same as stop_supervised/1 but raises if it cannot be stopped.","ref":"ExUnit.Callbacks.html#stop_supervised!/1","title":"ExUnit.Callbacks.stop_supervised!/1","type":"function"},{"doc":"Functionality to capture IO for testing. Examples defmodule AssertionTest do use ExUnit.Case import ExUnit.CaptureIO test &quot;example&quot; do assert capture_io ( fn -&gt; IO . puts ( &quot;a&quot; ) end ) == &quot;a \\n &quot; end end","ref":"ExUnit.CaptureIO.html","title":"ExUnit.CaptureIO","type":"module"},{"doc":"Captures IO generated when evaluating fun . Returns the binary which is the captured output. By default, capture_io replaces the group_leader ( :stdio ) for the current process. Capturing the group leader is done per process and therefore can be done concurrently. However, the capturing of any other named device, such as :stderr , happens globally and persists until the function has ended. While this means it is safe to run your tests with async: true in many cases, captured output may include output from a different test and care must be taken when using capture_io with a named process asynchronously. A developer can set a string as an input. The default input is an empty string. If capturing a named device asynchronously, an input can only be given to the first capture. Any further capture that is given to a capture on that device will raise an exception and would indicate that the test should be run synchronously. Similarly, once a capture on a named device has begun, the encoding on that device cannot be changed in a subsequent concurrent capture. An error will be raised in this case. IO devices You may capture the IO from any registered IO device. The device name given must be an atom representing the name of a registered process. In addition, Elixir provides two shortcuts: :stdio - a shortcut for :standard_io , which maps to the current Process.group_leader/0 in Erlang :stderr - a shortcut for the named process :standard_error provided in Erlang Options :capture_prompt - Define if prompts (specified as arguments to IO.get* functions) should be captured. Defaults to true . For IO devices other than :stdio , the option is ignored. :encoding (since v1.10.0) - encoding of the IO device. Allowed values are :unicode (default) and :latin1 . Examples iex&gt; capture_io ( fn -&gt; IO . write ( &quot;john&quot; ) end ) == &quot;john&quot; true iex&gt; capture_io ( :stderr , fn -&gt; IO . write ( :stderr , &quot;john&quot; ) end ) == &quot;john&quot; true iex&gt; capture_io ( :standard_error , fn -&gt; IO . write ( :stderr , &quot;john&quot; ) end ) == &quot;john&quot; true iex&gt; capture_io ( &quot;this is input&quot; , fn -&gt; ...&gt; input = IO . gets ( &quot;&gt; &quot; ) ...&gt; IO . write ( input ) ...&gt; end ) == &quot;&gt; this is input&quot; true iex&gt; capture_io ( [ input : &quot;this is input&quot; , capture_prompt : false ] , fn -&gt; ...&gt; input = IO . gets ( &quot;&gt; &quot; ) ...&gt; IO . write ( input ) ...&gt; end ) == &quot;this is input&quot; true Returning values As seen in the examples above, capture_io returns the captured output. If you want to also capture the result of the function executed inside the capture_io , you can use Kernel.send/2 to send yourself a message and use ExUnit.Assertions.assert_received/2 to match on the results: capture_io ( [ input : &quot;this is input&quot; , capture_prompt : false ] , fn -&gt; send ( self ( ) , { :block_result , 42 } ) # ... end ) assert_received { :block_result , 42 }","ref":"ExUnit.CaptureIO.html#capture_io/1","title":"ExUnit.CaptureIO.capture_io/1","type":"function"},{"doc":"","ref":"ExUnit.CaptureIO.html#capture_io/2","title":"ExUnit.CaptureIO.capture_io/2","type":"function"},{"doc":"","ref":"ExUnit.CaptureIO.html#capture_io/3","title":"ExUnit.CaptureIO.capture_io/3","type":"function"},{"doc":"Functionality to capture logs for testing. Examples defmodule AssertionTest do use ExUnit.Case import ExUnit.CaptureLog require Logger test &quot;example&quot; do assert capture_log ( fn -&gt; Logger . error ( &quot;log msg&quot; ) end ) =~ &quot;log msg&quot; end test &quot;check multiple captures concurrently&quot; do fun = fn -&gt; for msg &lt;- [ &quot;hello&quot; , &quot;hi&quot; ] do assert capture_log ( fn -&gt; Logger . error ( msg ) end ) =~ msg end Logger . debug ( &quot;testing&quot; ) end assert capture_log ( fun ) =~ &quot;hello&quot; assert capture_log ( fun ) =~ &quot;testing&quot; end end","ref":"ExUnit.CaptureLog.html","title":"ExUnit.CaptureLog","type":"module"},{"doc":"Captures Logger messages generated when evaluating fun . Returns the binary which is the captured output. This function mutes the :console backend and captures any log messages sent to Logger from the calling processes. It is possible to ensure explicit log messages from other processes are captured by waiting for their exit or monitor signal. Note that when the async is set to true , the messages from another test might be captured. This is OK as long you consider such cases in your assertions. It is possible to configure the level to capture with :level , which will set the capturing level for the duration of the capture, for instance, if the log level is set to :error any message with the lower level will be ignored. The default level is nil , which will capture all messages. The behaviour is undetermined if async tests change Logger level. The format, metadata and colors can be configured with :format , :metadata and :colors respectively. These three options defaults to the :console backend configuration parameters.","ref":"ExUnit.CaptureLog.html#capture_log/2","title":"ExUnit.CaptureLog.capture_log/2","type":"function"},{"doc":"Helpers for defining test cases. This module must be used in other modules as a way to configure and prepare them for testing. When used, it accepts the following options: :async - configures tests in this module to run concurrently with tests in other modules. Tests in the same module never run concurrently. It should be enabled only if tests do not change any global state. Defaults to false . This module automatically includes all callbacks defined in ExUnit.Callbacks . See that module for more information on setup , start_supervised , on_exit and the test process life cycle. For grouping tests together, see describe/2 in this module. Examples defmodule AssertionTest do # Use the module use ExUnit.Case , async : true # The &quot;test&quot; macro is imported by ExUnit.Case test &quot;always pass&quot; do assert true end end Context All tests receive a context as an argument. The context is particularly useful for sharing information between callbacks and tests: defmodule KVTest do use ExUnit.Case setup do { :ok , pid } = KV . start_link ( ) { :ok , pid : pid } end test &quot;stores key-value pairs&quot; , context do assert KV . put ( context [ :pid ] , :hello , :world ) == :ok assert KV . get ( context [ :pid ] , :hello ) == :world end end As the context is a map, it can be pattern matched on to extract information: test &quot;stores key-value pairs&quot; , %{ pid : pid } = _context do assert KV . put ( pid , :hello , :world ) == :ok assert KV . get ( pid , :hello ) == :world end Tags The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags. By tagging a test, the tag value can be accessed in the context, allowing the developer to customize the test. Let's see an example: defmodule FileTest do # Changing directory cannot be async use ExUnit.Case , async : false setup context do # Read the :cd tag value if cd = context [ :cd ] do prev_cd = File . cwd! ( ) File . cd! ( cd ) on_exit ( fn -&gt; File . cd! ( prev_cd ) end ) end :ok end @tag cd : &quot;fixtures&quot; test &quot;reads UTF-8 fixtures&quot; do File . read ( &quot;README.md&quot; ) end end In the example above, we have defined a tag called :cd that is read in the setup callback to configure the working directory the test is going to run on. Tags are also very effective when used with case templates ( ExUnit.CaseTemplate ) allowing callbacks in the case template to customize the test behaviour. Note a tag can be set in two different ways: @tag key : value @tag :key # equivalent to setting @tag key: true If a tag is given more than once, the last value wins. Module and describe tags A tag can be set for all tests in a module or describe block by setting @moduletag or @describetag inside each context respectively: defmodule ApiTest do use ExUnit.Case @moduletag :external describe &quot;makes calls to the right endpoint&quot; do @describetag :endpoint # ... end end If you are setting a @moduletag or @describetag attribute, you must set them after your call to use ExUnit.Case otherwise you will see compilation errors. If the same key is set via @tag , the @tag value has higher precedence. Known tags The following tags are set automatically by ExUnit and are therefore reserved: :module - the module on which the test was defined :file - the file on which the test was defined :line - the line on which the test was defined :test - the test name :async - if the test case is in async mode :registered - used for ExUnit.Case.register_attribute/3 values :describe - the describe block the test belongs to The following tags customize how tests behave: :capture_log - see the &quot;Log Capture&quot; section below :skip - skips the test with the given reason :timeout - customizes the test timeout in milliseconds (defaults to 60000). Accepts :infinity as a timeout value. :tmp_dir - (since v1.11.0) see the &quot;Tmp Dir&quot; section below The :test_type tag is automatically set by ExUnit, but is not reserved. This tag is available for users to customize if they desire. Filters Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via ExUnit.configure/1 : # Exclude all external tests from running ExUnit . configure ( exclude : [ external : true ] ) From now on, ExUnit will not run any test that has the :external option set to true . This behaviour can be reversed with the :include option which is usually passed through the command line: mix test -- include external :true Run mix help test for more information on how to run filters via Mix. Another use case for tags and filters is to exclude all tests that have a particular tag by default, regardless of its value, and include only a certain subset: ExUnit . configure ( exclude : :os , include : [ os : :unix ] ) A given include/exclude filter can be given more than once: ExUnit . configure ( exclude : [ os : :unix , os : :windows ] ) Keep in mind that all tests are included by default, so unless they are excluded first, the include option has no effect. Log Capture ExUnit can optionally suppress printing of log messages that are generated during a test. Log messages generated while running a test are captured and only if the test fails are they printed to aid with debugging. You can opt into this behaviour for individual tests by tagging them with :capture_log or enable log capture for all tests in the ExUnit configuration: ExUnit . start ( capture_log : true ) This default can be overridden by @tag capture_log: false or @moduletag capture_log: false . Since setup_all blocks don't belong to a specific test, log messages generated in them (or between tests) are never captured. If you want to suppress these messages as well, remove the console backend globally by setting: config :logger , backends : [ ] Tmp Dir ExUnit automatically creates a temporary directory for tests tagged with :tmp_dir and puts the path to that directory into the test context. The directory is removed before being created to ensure we start with a blank slate. The temporary directory path is unique (includes the test module and test name) and thus appropriate for running tests concurrently. You can customize the path further by setting the tag to a string, e.g.: tmp_dir: &quot;my_path&quot; , which would make the final path to be: tmp/&lt;module&gt;/&lt;test&gt;/my_path . Example: defmodule MyTest do use ExUnit.Case , async : true @tag :tmp_dir test &quot;with tmp_dir&quot; , %{ tmp_dir : tmp_dir } do assert tmp_dir =~ &quot;with tmp_dir&quot; assert File . dir? ( tmp_dir ) end end As with other tags, :tmp_dir can also be set as @moduletag and @describetag .","ref":"ExUnit.Case.html","title":"ExUnit.Case","type":"module"},{"doc":"Describes tests together. Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, ExUnit.Callbacks.setup/1 may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks. Examples defmodule StringTest do use ExUnit.Case , async : true describe &quot;String.capitalize/1&quot; do test &quot;first grapheme is in uppercase&quot; do assert String . capitalize ( &quot;hello&quot; ) == &quot;Hello&quot; end test &quot;converts remaining graphemes to lowercase&quot; do assert String . capitalize ( &quot;HELLO&quot; ) == &quot;Hello&quot; end end end When using Mix, you can run all tests in a describe block by name: mix test -- only describe :&quot;String.capitalize/1&quot; or by passing the exact line the describe block starts on: mix test path / to / file : 123 Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, developers should build on top of named setups. For example: defmodule UserManagementTest do use ExUnit.Case , async : true describe &quot;when user is logged in and is an admin&quot; do setup [ :log_user_in , :set_type_to_admin ] test ... end describe &quot;when user is logged in and is a manager&quot; do setup [ :log_user_in , :set_type_to_manager ] test ... end defp log_user_in ( context ) do # ... end end By forbidding hierarchies in favor of named setups, it is straightforward for the developer to glance at each describe block and know exactly the setup steps involved.","ref":"ExUnit.Case.html#describe/2","title":"ExUnit.Case.describe/2","type":"macro"},{"doc":"Registers a new attribute to be used during ExUnit.Case tests. The attribute values will be available through context.registered . Registered values are cleared after each test/3 similar to @tag . This function takes the same options as Module.register_attribute/3 . Examples defmodule MyTest do use ExUnit.Case ExUnit.Case . register_attribute ( __MODULE__ , :fixtures , accumulate : true ) @fixtures :user @fixtures { :post , insert : false } test &quot;using custom attribute&quot; , context do assert context . registered . fixtures == [ { :post , insert : false } , :user ] end test &quot;custom attributes are cleared per test&quot; , context do assert context . registered . fixtures == [ ] end end","ref":"ExUnit.Case.html#register_attribute/3","title":"ExUnit.Case.register_attribute/3","type":"function"},{"doc":"Registers a new describe attribute to be used during ExUnit.Case tests. The attribute values will be available through context.registered . Registered values are cleared after each describe/2 similar to @describetag . This function takes the same options as Module.register_attribute/3 . Examples defmodule MyTest do use ExUnit.Case ExUnit.Case . register_describe_attribute ( __MODULE__ , :describe_fixtures , accumulate : true ) describe &quot;using custom attribute&quot; do @describe_fixtures :user @describe_fixtures { :post , insert : false } test &quot;has attribute&quot; , context do assert context . registered . describe_fixtures == [ { :post , insert : false } , :user ] end end describe &quot;custom attributes are cleared per describe&quot; do test &quot;doesn&#39;t have attributes&quot; , context do assert context . registered . describe_fixtures == [ ] end end end","ref":"ExUnit.Case.html#register_describe_attribute/3","title":"ExUnit.Case.register_describe_attribute/3","type":"function"},{"doc":"Registers a new module attribute to be used during ExUnit.Case tests. The attribute values will be available through context.registered . This function takes the same options as Module.register_attribute/3 . Examples defmodule MyTest do use ExUnit.Case ExUnit.Case . register_module_attribute ( __MODULE__ , :module_fixtures , accumulate : true ) @module_fixtures :user @module_fixtures { :post , insert : false } test &quot;using custom attribute&quot; , context do assert context . registered . module_fixtures == [ { :post , insert : false } , :user ] end test &quot;still using custom attribute&quot; , context do assert context . registered . module_fixtures == [ { :post , insert : false } , :user ] end end","ref":"ExUnit.Case.html#register_module_attribute/3","title":"ExUnit.Case.register_module_attribute/3","type":"function"},{"doc":"Registers a test with the given environment. This function is deprecated in favor of register_test/6 which performs better under tight loops by avoiding __ENV__ .","ref":"ExUnit.Case.html#register_test/4","title":"ExUnit.Case.register_test/4","type":"function"},{"doc":"Registers a function to run as part of this case. This is used by third-party projects, like QuickCheck, to implement macros like property/3 that works like test but instead defines a property. See test/3 implementation for an example of invoking this function. The test type will be converted to a string and pluralized for display. You can use ExUnit.plural_rule/2 to set a custom pluralization.","ref":"ExUnit.Case.html#register_test/6","title":"ExUnit.Case.register_test/6","type":"function"},{"doc":"Defines a not implemented test with a string. Provides a convenient macro that allows a test to be defined with a string, but not yet implemented. The resulting test will always fail and print a &quot;Not implemented&quot; error message. The resulting test case is also tagged with :not_implemented . Examples test &quot;this will be a test in future&quot;","ref":"ExUnit.Case.html#test/1","title":"ExUnit.Case.test/1","type":"macro"},{"doc":"Defines a test with message . The test may also define a pattern, which will be matched against the test context. For more information on contexts, see ExUnit.Callbacks . Examples test &quot;true is equal to true&quot; do assert true == true end","ref":"ExUnit.Case.html#test/3","title":"ExUnit.Case.test/3","type":"macro"},{"doc":"","ref":"ExUnit.Case.html#t:env/0","title":"ExUnit.Case.env/0","type":"type"},{"doc":"Defines a module template to be used throughout your test suite. This is useful when there are a set of setup callbacks or a set of functions that should be shared between test modules. Once a case template is used, the regular functionality in ExUnit.Case plus the functionality defined in the template will become available. Example defmodule MyCase do use ExUnit.CaseTemplate setup do IO . puts ( &quot;This will run before each test that uses this case&quot; ) end end defmodule MyTest do use MyCase , async : true test &quot;truth&quot; do assert true end end","ref":"ExUnit.CaseTemplate.html","title":"ExUnit.CaseTemplate","type":"module"},{"doc":"Allows a developer to customize the using block when the case template is used. Example defmodule MyCase do use ExUnit.CaseTemplate using do quote do # This code is injected into every case that calls &quot;use MyCase&quot; alias MyApp.FunModule end end end","ref":"ExUnit.CaseTemplate.html#using/2","title":"ExUnit.CaseTemplate.using/2","type":"macro"},{"doc":"Extract test cases from the documentation. Doctests allow us to generate tests from code examples found in @moduledoc and @doc attributes. To do this, invoke the doctest/1 macro from within your test case and ensure your code examples are written according to the syntax and guidelines below. Syntax Every new test starts on a new line, with an iex&gt; prefix. Multiline expressions can be used by prefixing subsequent lines with either ...&gt; (recommended) or iex&gt; . The expected result should start the line after the iex&gt; and ...&gt; line(s) and be terminated by a newline. Examples To run doctests include them in an ExUnit case with a doctest macro: defmodule MyModuleTest do use ExUnit.Case , async : true doctest MyModule end The doctest macro loops through all functions and macros defined in MyModule , parsing their documentation in search of code examples. A very basic example is: iex&gt; 1 + 1 2 Expressions on multiple lines are also supported: iex&gt; Enum . map ( [ 1 , 2 , 3 ] , fn x -&gt; ...&gt; x * 2 ...&gt; end ) [ 2 , 4 , 6 ] Multiple results can be checked within the same test: iex&gt; a = 1 1 iex&gt; a + 1 2 If you want to keep any two tests separate, add an empty line between them: iex&gt; a = 1 1 iex&gt; a + 1 # will fail with a &quot;undefined function a/0&quot; error 2 If you don't want to assert for every result in a doctest, you can omit the result. You can do so between expressions: iex&gt; pid = spawn ( fn -&gt; :ok end ) iex&gt; is_pid ( pid ) true As well as at the end: iex&gt; Mod . do_a_call_that_should_not_raise! ( ... ) This is useful when the result is something variable (like a PID in the example above) or when the result is a complicated data structure and you don't want to show it all, but just parts of it or some of its properties. Similarly to IEx you can use numbers in your &quot;prompts&quot;: iex(1)&gt; [ 1 + 2 , ...(1)&gt; 3 ] [ 3 , 3 ] This is useful in two cases: being able to refer to specific numbered scenarios copy-pasting examples from an actual IEx session You can also select or skip functions when calling doctest . See the documentation on the :except and :only options below for more information. Opaque types Some types' internal structures are kept hidden and instead show a user-friendly structure when inspected. The idiom in Elixir is to print those data types in the format #Name&lt;...&gt; . Because those values are treated as comments in Elixir code due to the leading # sign, they require special care when being used in doctests. Imagine you have a map that contains a MapSet and is printed as: %{ users : # MapSet &lt; [ :foo , :bar ] &gt; } If you try to match on such an expression, doctest will fail to compile. There are two ways to resolve this. The first is to rely on the fact that doctest can compare internal structures as long as they are at the root. So one could write: iex&gt; map = %{ users : Enum . into ( [ :foo , :bar ] , MapSet . new ( ) ) } iex&gt; map . users # MapSet &lt; [ :foo , :bar ] &gt; Whenever a doctest starts with &quot;#Name&lt;&quot;, doctest will perform a string comparison. For example, the above test will perform the following match: inspect ( map . users ) == &quot;#MapSet&lt;[:foo, :bar]&gt;&quot; Alternatively, since doctest results are actually evaluated, you can have the MapSet building expression as the doctest result: iex&gt; %{ users : Enum . into ( [ :foo , :bar ] , MapSet . new ( ) ) } %{ users : Enum . into ( [ :foo , :bar ] , MapSet . new ( ) ) } The downside of this approach is that the doctest result is not really what users would see in the terminal. Exceptions You can also showcase expressions raising an exception, for example: iex(1)&gt; raise &quot;some error&quot; ** (RuntimeError) some error Doctest will looking for a line starting with ** ( and it will parse it accordingly to extract the exception name and message. The exception parser will consider all following lines part of the exception message until there is an empty line or there is a new expression prefixed with iex&gt; . Therefore, it is possible to match on multiline messages as long as there are no empty lines on the message itself. When not to use doctest In general, doctests are not recommended when your code examples contain side effects. For example, if a doctest prints to standard output, doctest will not try to capture the output. Similarly, doctests do not run in any kind of sandbox. So any module defined in a code example is going to linger throughout the whole test suite run.","ref":"ExUnit.DocTest.html","title":"ExUnit.DocTest","type":"module"},{"doc":"This macro is used to generate ExUnit test cases for doctests. Calling doctest(Module) will generate tests for all doctests found in the module . Options can also be given: :except - generates tests for all functions except those listed (list of {function, arity} tuples, and/or :moduledoc ). :only - generates tests only for functions listed (list of {function, arity} tuples, and/or :moduledoc ). :import - when true , one can test a function defined in the module without referring to the module name. However, this is not feasible when there is a clash with a module like Kernel . In these cases, :import should be set to false and a full Module.function construct should be used. :tags - a list of tags to apply to all generated doctests. Examples doctest MyModule , except : [ :moduledoc , trick_fun : 1 ] This macro is auto-imported with every ExUnit.Case .","ref":"ExUnit.DocTest.html#doctest/2","title":"ExUnit.DocTest.doctest/2","type":"macro"},{"doc":"Conveniences for parsing and evaluating filters.","ref":"ExUnit.Filters.html","title":"ExUnit.Filters","type":"module"},{"doc":"Evaluates the include and exclude filters against the given tags to determine if tests should be skipped or excluded. Some filters, like :line , may require the whole test collection to find the closest line, that's why it must also be passed as an argument. Filters can either be a regular expression or any data structure that implements the String.Chars protocol, which is invoked before comparing the filter with the :tag value. Precedence Tests are first excluded, then included, and then skipped (if any left). If a :skip tag is found in tags , {:skipped, message} is returned if the test has been left after the exclude and include filters. Otherwise {:exclude, message} is returned. The only exception to this rule is that :skip is found in the include filter, :ok is returned regardless of whether the test was excluded or not. Examples iex&gt; ExUnit.Filters . eval ( [ foo : &quot;bar&quot; ] , [ :foo ] , %{ foo : &quot;bar&quot; } , [ ] ) :ok iex&gt; ExUnit.Filters . eval ( [ foo : &quot;bar&quot; ] , [ :foo ] , %{ foo : &quot;baz&quot; } , [ ] ) { :excluded , &quot;due to foo filter&quot; }","ref":"ExUnit.Filters.html#eval/4","title":"ExUnit.Filters.eval/4","type":"function"},{"doc":"Returns a tuple containing useful information about test failures from the manifest. The tuple contains: A set of files that contain tests that failed the last time they ran. The paths are absolute paths. A set of test IDs that failed the last time they ran","ref":"ExUnit.Filters.html#failure_info/1","title":"ExUnit.Filters.failure_info/1","type":"function"},{"doc":"Normalizes include and exclude filters to remove duplicates and keep precedence. Examples iex&gt; ExUnit.Filters . normalize ( nil , nil ) { [ ] , [ ] } iex&gt; ExUnit.Filters . normalize ( [ :foo , :bar , :bar ] , [ :foo , :baz ] ) { [ :foo , :bar ] , [ :baz ] } iex&gt; ExUnit.Filters . normalize ( [ foo : &quot;true&quot; ] , [ :foo ] ) { [ foo : &quot;true&quot; ] , [ :foo ] } iex&gt; ExUnit.Filters . normalize ( [ :foo ] , [ foo : &quot;true&quot; ] ) { [ :foo ] , [ ] } iex&gt; ExUnit.Filters . normalize ( [ foo : &quot;true&quot; ] , [ foo : true ] ) { [ foo : &quot;true&quot; ] , [ ] } iex&gt; ExUnit.Filters . normalize ( [ foo : true ] , [ foo : &quot;true&quot; ] ) { [ foo : true ] , [ ] } iex&gt; ExUnit.Filters . normalize ( [ foo : 1 , foo : 1 , foo : 2 ] , [ ] ) { [ foo : 1 , foo : 2 ] , [ ] } iex&gt; ExUnit.Filters . normalize ( [ ] , [ foo : 1 , foo : 1 , foo : 2 ] ) { [ ] , [ foo : 1 , foo : 2 ] }","ref":"ExUnit.Filters.html#normalize/2","title":"ExUnit.Filters.normalize/2","type":"function"},{"doc":"Parses the given filters, as one would receive from the command line. Examples iex&gt; ExUnit.Filters . parse ( [ &quot;foo:bar&quot; , &quot;baz&quot; , &quot;line:9&quot; , &quot;bool:true&quot; ] ) [ { :foo , &quot;bar&quot; } , :baz , { :line , &quot;9&quot; } , { :bool , &quot;true&quot; } ]","ref":"ExUnit.Filters.html#parse/1","title":"ExUnit.Filters.parse/1","type":"function"},{"doc":"Parses filters out of a path. Determines whether a given file path (supplied to ExUnit/Mix as arguments on the command line) includes a line number filter, and if so returns the appropriate ExUnit configuration options.","ref":"ExUnit.Filters.html#parse_path/1","title":"ExUnit.Filters.parse_path/1","type":"function"},{"doc":"","ref":"ExUnit.Filters.html#t:t/0","title":"ExUnit.Filters.t/0","type":"type"},{"doc":"Helper functions for formatting and the formatting protocols. Formatters are GenServer s specified during ExUnit configuration that receive a series of events as casts. The following events are possible: {:suite_started, opts} - the suite has started with the specified options to the runner. {:suite_finished, times_us} - the suite has finished. Returns several measurements in microseconds for running the suite. See t:times_us for more information. {:module_started, test_module} - a test module has started. See ExUnit.TestModule for details. {:module_finished, test_module} - a test module has finished. See ExUnit.TestModule for details. {:test_started, test} - a test has started. See ExUnit.Test for details. {:test_finished, test} - a test has finished. See ExUnit.Test for details. {:sigquit, [test | test_module]} - the VM is going to shutdown. It receives the test cases (or test module in case of setup_all ) still running. The formatter will also receive the following events but they are deprecated and should be ignored: {:case_started, test_module} - a test module has started. See ExUnit.TestModule for details. {:case_finished, test_module} - a test module has finished. See ExUnit.TestModule for details. The full ExUnit configuration is passed as the argument to GenServer.init/1 callback when the formatters are started. If you need to do runtime configuration of a formatter, you can add any configuration needed by using ExUnit.configure/1 or ExUnit.start/1 , and this will then be included in the options passed to the GenServer.init/1 callback.","ref":"ExUnit.Formatter.html","title":"ExUnit.Formatter","type":"module"},{"doc":"Formats filters used to constrain cases to be run. Examples iex&gt; format_filters ( [ run : true , slow : false ] , :include ) &quot;Including tags: [run: true, slow: false]&quot;","ref":"ExUnit.Formatter.html#format_filters/2","title":"ExUnit.Formatter.format_filters/2","type":"function"},{"doc":"Receives a test module and formats its failure.","ref":"ExUnit.Formatter.html#format_test_all_failure/5","title":"ExUnit.Formatter.format_test_all_failure/5","type":"function"},{"doc":"Receives a test and formats its failure.","ref":"ExUnit.Formatter.html#format_test_failure/5","title":"ExUnit.Formatter.format_test_failure/5","type":"function"},{"doc":"Formats time taken running the test suite. Examples iex&gt; format_times ( %{ run : 10000 , async : nil , load : nil } ) &quot;Finished in 0.01 seconds (0.00s async, 0.01s sync)&quot; iex&gt; format_times ( %{ run : 10000 , async : nil , load : 20000 } ) &quot;Finished in 0.03 seconds (0.02s on load, 0.00s async, 0.01s sync)&quot; iex&gt; format_times ( %{ run : 10000 , async : nil , load : 200_000 } ) &quot;Finished in 0.2 seconds (0.2s on load, 0.00s async, 0.01s sync)&quot; iex&gt; format_times ( %{ run : 100_000 , async : 50000 , load : 200_000 } ) &quot;Finished in 0.3 seconds (0.2s on load, 0.05s async, 0.05s sync)&quot;","ref":"ExUnit.Formatter.html#format_times/1","title":"ExUnit.Formatter.format_times/1","type":"function"},{"doc":"","ref":"ExUnit.Formatter.html#t:id/0","title":"ExUnit.Formatter.id/0","type":"type"},{"doc":"","ref":"ExUnit.Formatter.html#t:test/0","title":"ExUnit.Formatter.test/0","type":"type"},{"doc":"The times spent on several parts of the test suite. The following properties can be computed: sync = run - ( async || 0 ) total = run + ( load || 0 ) async is nil when there are no async tests. load is nil when the test suite is running and loading tests concurrently.","ref":"ExUnit.Formatter.html#t:times_us/0","title":"ExUnit.Formatter.times_us/0","type":"type"},{"doc":"A struct that keeps information about the test. It is received by formatters and contains the following fields: :name - the test name :module - the test module :state - the finished test state (see ExUnit.state/0 ) :time - the duration in microseconds of the test's runtime :tags - the test tags :logs - the captured logs","ref":"ExUnit.Test.html","title":"ExUnit.Test","type":"module"},{"doc":"","ref":"ExUnit.Test.html#t:t/0","title":"ExUnit.Test.t/0","type":"type"},{"doc":"A struct that keeps information about the test module. It is received by formatters and contains the following fields: :file - (since v1.11.0) the file of the test module :name - the test module name :state - the test error state (see ExUnit.state/0 ) :tests - all tests in this module","ref":"ExUnit.TestModule.html","title":"ExUnit.TestModule","type":"module"},{"doc":"","ref":"ExUnit.TestModule.html#t:t/0","title":"ExUnit.TestModule.t/0","type":"type"},{"doc":"Raised to signal an assertion error.","ref":"ExUnit.AssertionError.html","title":"ExUnit.AssertionError","type":"exception"},{"doc":"Indicates no meaningful value for a field.","ref":"ExUnit.AssertionError.html#no_value/0","title":"ExUnit.AssertionError.no_value/0","type":"function"},{"doc":"","ref":"ExUnit.DocTest.Error.html","title":"ExUnit.DocTest.Error","type":"exception"},{"doc":"","ref":"ExUnit.DuplicateDescribeError.html","title":"ExUnit.DuplicateDescribeError","type":"exception"},{"doc":"","ref":"ExUnit.DuplicateTestError.html","title":"ExUnit.DuplicateTestError","type":"exception"},{"doc":"Raised to signal multiple errors happened in a test case.","ref":"ExUnit.MultiError.html","title":"ExUnit.MultiError","type":"exception"},{"doc":"","ref":"ExUnit.TimeoutError.html","title":"ExUnit.TimeoutError","type":"exception"}]