searchNodes=[{"doc":"Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more. Mix.Project The foundation of Mix is a project. A project can be defined by using Mix.Project in a module, usually placed in a file named mix.exs : defmodule MyApp.MixProject do use Mix.Project def project do [ app : :my_app , version : &quot;1.0.0&quot; ] end end See the Mix.Project module for detailed documentation on Mix projects. Once the project is defined, a number of default Mix tasks can be run directly from the command line: mix compile - compiles the current project mix test - runs tests for the given project mix run - runs a particular command inside the project Each task has its own options and sometimes specific configuration to be defined in the project/0 function. You can use mix help to list all available tasks and mix help NAME to show help for a particular task. The best way to get started with your first project is by calling mix new my_project from the command line. Mix.Task Tasks are what make Mix extensible. Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project: defmodule Mix.Tasks.Hello do use Mix.Task def run ( _ ) do Mix . shell ( ) . info ( &quot;Hello world&quot; ) end end The task can now be invoked with mix hello . See the Mix.Task behaviour for detailed documentation on Mix tasks. Dependencies Mix also manages your dependencies and integrates nicely with the Hex package manager . In order to use dependencies, you need to add a :deps key to your project configuration. We often extract the list of dependencies into its own function: defmodule MyApp.MixProject do use Mix.Project def project do [ app : :my_app , version : &quot;1.0.0&quot; , deps : deps ( ) ] end defp deps do [ { :ecto , &quot;~&gt; 2.0&quot; } , { :plug , github : &quot;elixir-lang/plug&quot; } ] end end You can run mix help deps to learn more about dependencies in Mix. Environments Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments: :dev - the default environment :test - the environment mix test runs on :prod - the environment your dependencies run on The environment can be changed via the command line by setting the MIX_ENV environment variable, for example: $ MIX_ENV = prod mix run server . exs You can also specify that certain dependencies are available only for certain environments: { :some_test_dependency , &quot;~&gt; 1.0&quot; , only : :test } The environment can be read via Mix.env/0 . Targets Besides environments, Mix supports targets. Targets are useful when a project needs to compile to different architectures and some of the dependencies are only available to some of them. By default, the target is :host but it can be set via the MIX_TARGET environment variable. The target can be read via Mix.target/0 . Aliases Aliases are shortcuts or tasks specific to the current project. In the Mix.Task section , we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias: defmodule MyApp.MixProject do use Mix.Project def project do [ app : :my_app , version : &quot;1.0.0&quot; , aliases : aliases ( ) ] end defp aliases do [ c : &quot;compile&quot; , hello : &amp; hello / 1 ] end defp hello ( _ ) do Mix . shell ( ) . info ( &quot;Hello world&quot; ) end end In the example above, we have defined two aliases. One is mix c which is a shortcut for mix compile . The other is named mix hello , which is the equivalent to the Mix.Tasks.Hello we have defined in the Mix.Task section . Aliases may also be lists, specifying multiple tasks to be run consecutively: [ all : [ &amp; hello / 1 , &quot;deps.get --only \#{ Mix . env ( ) } &quot; , &quot;compile&quot; ] ] In the example above, we have defined an alias named mix all , that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project. Aliases can also be used to augment existing tasks. Let's suppose you want to augment mix clean to clean another directory Mix does not know about: [ clean : [ &quot;clean&quot; , &amp; clean_extra / 1 ] ] Where &amp;clean_extra/1 would be a function in your mix.exs with extra cleanup logic. Arguments given to the alias will be appended to the arguments of the last task in the list. Except when overriding an existing task. In this case, the arguments will be given to the original task, in order to preserve semantics. For example, in the :clean alias above, the arguments given to the alias will be passed to &quot;clean&quot; and not to clean_extra/1 . Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project. Aliases can be used very powerfully to also run Elixir scripts and shell commands, for example: # priv/hello1.exs IO . puts ( &quot;Hello One&quot; ) # priv/hello2.exs IO . puts ( &quot;Hello Two&quot; ) # priv/world.sh #!/bin/sh echo &quot;world!&quot; # mix.exs defp aliases do [ some_alias : [ &quot;hex.info&quot; , &quot;run priv/hello1.exs&quot; , &quot;cmd priv/world.sh&quot; ] ] end In the example above we have created the alias some_alias that will run the task mix hex.info , then mix run to run an Elixir script, then mix cmd to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be. Mix tasks are designed to run only once. This prevents the same task from being executed multiple times. For example, if there are several tasks depending on mix compile , the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using Mix.Task.reenable/1 : another_alias : [ &quot;format --check-formatted priv/hello1.exs&quot; , &quot;cmd priv/world.sh&quot; , fn _ -&gt; Mix.Task . reenable ( &quot;format&quot; ) end , &quot;format --check-formatted priv/hello2.exs&quot; ] Some tasks are automatically reenabled though, as they are expected to be invoked multiple times. They are: mix cmd , mix do , mix loadconfig , mix profile.cprof , mix profile.eprof , mix profile.fprof , mix run , and mix xref . It is worth mentioning that some tasks, such as in the case of the mix format command in the example above, can accept multiple files so it could be rewritten as: another_alias : [ &quot;format --check-formatted priv/hello1.exs priv/hello2.exs&quot; ] Environment variables Several environment variables can be used to modify Mix's behaviour. Mix responds to the following variables: MIX_ARCHIVES - specifies the directory into which the archives should be installed (default: ~/.mix/archives ) MIX_BUILD_ROOT - sets the root directory where build artifacts should be written to. For example, &quot;_build&quot;. If MIX_BUILD_PATH is set, this option is ignored. MIX_BUILD_PATH - sets the project Mix.Project.build_path/0 config. This option must always point to a subdirectory inside a temporary directory. For instance, never &quot;/tmp&quot; or &quot;_build&quot; but &quot;_build/PROD&quot; or &quot;/tmp/PROD&quot;, as required by Mix MIX_DEPS_PATH - sets the project Mix.Project.deps_path/0 config (default: deps ) MIX_DEBUG - outputs debug information about each task before running it MIX_ENV - specifies which environment should be used. See Environments MIX_TARGET - specifies which target should be used. See Targets MIX_EXS - changes the full path to the mix.exs file MIX_HOME - path to Mix's home directory, stores configuration files and scripts used by Mix (default: ~/.mix ) MIX_INSTALL_DIR - (since v1.12.0) specifies directory where Mix.install/2 keeps installs cache MIX_PATH - appends extra code paths MIX_QUIET - does not print information messages to the terminal MIX_REBAR - path to rebar command that overrides the one Mix installs (default: ~/.mix/rebar ) MIX_REBAR3 - path to rebar3 command that overrides the one Mix installs (default: ~/.mix/rebar3 ) MIX_XDG - asks Mix to follow the XDG Directory Specification for its home directory and configuration files. This behaviour needs to be opt-in due to backwards compatibility. MIX_HOME has higher preference than MIX_XDG . If none of the variables are set, the default directory ~/.mix will be used Environment variables that are not meant to hold a value (and act basically as flags) should be set to either 1 or true , for example: $ MIX_DEBUG = 1 mix compile","ref":"Mix.html","title":"Mix","type":"module"},{"doc":"Returns the default compilers used by Mix. It can be used in your mix.exs to prepend or append new compilers to Mix: def project do [ compilers : Mix . compilers ( ) ++ [ :foo , :bar ] ] end","ref":"Mix.html#compilers/0","title":"Mix.compilers/0","type":"function"},{"doc":"Sets Mix debug mode.","ref":"Mix.html#debug/1","title":"Mix.debug/1","type":"function"},{"doc":"Returns true if Mix is in debug mode, false otherwise.","ref":"Mix.html#debug?/0","title":"Mix.debug?/0","type":"function"},{"doc":"Returns the current Mix environment. This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release). To differentiate the program behavior depending on the environment, it is recommended to use application environment through Application.get_env/3 . Proper configuration can be set in config files, often per-environment (see the Config module for more information).","ref":"Mix.html#env/0","title":"Mix.env/0","type":"function"},{"doc":"Changes the current Mix environment to env . Be careful when invoking this function as any project configuration won't be reloaded. This function should not be used at runtime in application code (see env/0 for more information).","ref":"Mix.html#env/1","title":"Mix.env/1","type":"function"},{"doc":"Installs and starts dependencies. The given deps should be in the same format as defined in a regular Mix project. See mix help deps for more information. As a shortcut, an atom can be given as dependency to mean the latest version. In other words, specifying :decimal is the same as {:decimal, &quot;&gt;= 0.0.0&quot;} . After each successful installation, a given set of dependencies is cached so starting another VM and calling Mix.install/2 with the same dependencies will avoid unnecessary downloads and compilations. The location of the cache directory can be controlled using the MIX_INSTALL_DIR environment variable. This function can only be called outside of a Mix project and only once in a given VM. Note: this feature is currently experimental and it may change in future releases. Options :force - if true , removes install cache. This is useful when you want to update your dependencies or your install got into an inconsistent state (Default: false ) :verbose - if true , prints additional debugging information (Default: false ) :consolidate_protocols - if true , runs protocol consolidation via the mix compile.protocols task (Default: true ) Examples Mix . install ( [ :decimal , { :jason , &quot;~&gt; 1.0&quot; } ] )","ref":"Mix.html#install/2","title":"Mix.install/2","type":"function"},{"doc":"The path for local archives or escripts.","ref":"Mix.html#path_for/1","title":"Mix.path_for/1","type":"function"},{"doc":"Raises a Mix error that is nicely formatted, defaulting to exit code 1 .","ref":"Mix.html#raise/1","title":"Mix.raise/1","type":"function"},{"doc":"Raises a Mix error that is nicely formatted. Options :exit_code - defines exit code value, defaults to 1","ref":"Mix.html#raise/2","title":"Mix.raise/2","type":"function"},{"doc":"Returns the current shell. shell/0 can be used as a wrapper for the current shell. It contains conveniences for requesting information from the user, printing to the shell and so forth. The Mix shell is swappable (see shell/1 ), allowing developers to use a test shell that simply sends messages to the current process instead of performing IO (see Mix.Shell.Process ). By default, this returns Mix.Shell.IO . Examples Mix . shell ( ) . info ( &quot;Preparing to do something dangerous...&quot; ) if Mix . shell ( ) . yes? ( &quot;Are you sure?&quot; ) do # do something dangerous end","ref":"Mix.html#shell/0","title":"Mix.shell/0","type":"function"},{"doc":"Sets the current shell. As an argument you may pass Mix.Shell.IO , Mix.Shell.Process , Mix.Shell.Quiet , or any module that implements the Mix.Shell behaviour. After calling this function, shell becomes the shell that is returned by shell/0 . Examples iex&gt; Mix . shell ( Mix.Shell.IO ) :ok You can use shell/0 and shell/1 to temporarily switch shells, for example, if you want to run a Mix Task that normally produces a lot of output: shell = Mix . shell ( ) Mix . shell ( Mix.Shell.Quiet ) try do Mix.Task . run ( &quot;noisy.task&quot; ) after Mix . shell ( shell ) end","ref":"Mix.html#shell/1","title":"Mix.shell/1","type":"function"},{"doc":"Returns the Mix target.","ref":"Mix.html#target/0","title":"Mix.target/0","type":"function"},{"doc":"Changes the current Mix target to target . Be careful when invoking this function as any project configuration won't be reloaded.","ref":"Mix.html#target/1","title":"Mix.target/1","type":"function"},{"doc":"Conveniences for working with paths and generating content.","ref":"Mix.Generator.html","title":"Mix.Generator","type":"module"},{"doc":"Copies source to target . If target already exists and the contents are not the same, it asks for user confirmation. Options :force - forces copying without a shell prompt :quiet - does not log command output Examples iex&gt; Mix.Generator . copy_file ( &quot;source/gitignore&quot; , &quot;.gitignore&quot; ) * creating . gitignore true","ref":"Mix.Generator.html#copy_file/3","title":"Mix.Generator.copy_file/3","type":"function"},{"doc":"Evaluates and copy templates at source to target . The template in source is evaluated with the given assigns . If target already exists and the contents are not the same, it asks for user confirmation. Options :force - forces copying without a shell prompt :quiet - does not log command output Examples iex&gt; assigns = [ project_path : &quot;/Users/joe/newproject&quot; ] iex&gt; Mix.Generator . copy_template ( &quot;source/gitignore&quot; , &quot;.gitignore&quot; , assigns ) * creating . gitignore true","ref":"Mix.Generator.html#copy_template/4","title":"Mix.Generator.copy_template/4","type":"function"},{"doc":"Creates a directory if one does not exist yet. This function does nothing if the given directory already exists; in this case, it still logs the directory creation. Options :quiet - does not log command output Examples iex&gt; Mix.Generator . create_directory ( &quot;path/to/dir&quot; ) * creating path / to / dir true","ref":"Mix.Generator.html#create_directory/2","title":"Mix.Generator.create_directory/2","type":"function"},{"doc":"Creates a file with the given contents. If the file already exists and the contents are not the same, it asks for user confirmation. Options :force - forces creation without a shell prompt :quiet - does not log command output Examples iex&gt; Mix.Generator . create_file ( &quot;.gitignore&quot; , &quot;_build \\n deps \\n &quot; ) * creating . gitignore true","ref":"Mix.Generator.html#create_file/3","title":"Mix.Generator.create_file/3","type":"function"},{"doc":"Embeds a template given by contents into the current module. It will define a private function with the name followed by _template that expects assigns as arguments. This function must be invoked passing a keyword list. Each key in the keyword list can be accessed in the template using the @ macro. For more information, check EEx.SmartEngine . Examples defmodule Mix.Tasks.MyTask do require Mix.Generator Mix.Generator . embed_template ( :log , &quot;Log: &lt;%= @log %&gt;&quot; ) end","ref":"Mix.Generator.html#embed_template/2","title":"Mix.Generator.embed_template/2","type":"macro"},{"doc":"Embeds a text given by contents into the current module. It will define a private function with the name followed by _text that expects no arguments. Examples defmodule Mix.Tasks.MyTask do require Mix.Generator Mix.Generator . embed_text ( :error , &quot;There was an error!&quot; ) end","ref":"Mix.Generator.html#embed_text/2","title":"Mix.Generator.embed_text/2","type":"macro"},{"doc":"Prompts the user to overwrite the file if it exists. Returns false if the file exists and the user forbade to override it. Returns true otherwise.","ref":"Mix.Generator.html#overwrite?/1","title":"Mix.Generator.overwrite?/1","type":"function"},{"doc":"Prompts the user to overwrite the file if it exists. The contents are compared to avoid asking the user to override if the contents did not change. Returns false if the file exists and the content is the same or the user forbade to override it. Returns true otherwise.","ref":"Mix.Generator.html#overwrite?/2","title":"Mix.Generator.overwrite?/2","type":"function"},{"doc":"Defines and manipulates Mix projects. A Mix project is defined by calling use Mix.Project in a module, usually placed in mix.exs : defmodule MyApp.MixProject do use Mix.Project def project do [ app : :my_app , version : &quot;1.0.0&quot; ] end end Configuration In order to configure Mix, the module that use s Mix.Project should export a project/0 function that returns a keyword list representing configuration for the project. This configuration can be read using Mix.Project.config/0 . Note that config/0 won't fail if a project is not defined; this allows many Mix tasks to work without a project. If a task requires a project to be defined or needs to access a special function within the project, the task can call Mix.Project.get!/0 which fails with Mix.NoProjectError in the case a project is not defined. There isn't a comprehensive list of all the options that can be returned by project/0 since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the Mix.Tasks.Compile task. These are a few options that are not used by just one Mix task (and will thus be documented here): :build_per_environment - if true , builds will be per-environment . If false , builds will go in _build/shared regardless of the Mix environment. Defaults to true . :aliases - a list of task aliases. For more information, check out the &quot;Aliases&quot; section in the documentation for the Mix module. Defaults to [] . :config_path - a string representing the path of the main config file. See config_files/0 for more information. Defaults to &quot;config/config.exs&quot; . :default_task - a string representing the default task to be run by mix when no task is specified. Defaults to &quot;run&quot; . :deps - a list of dependencies of this project. Refer to the documentation for the Mix.Tasks.Deps task for more information. Defaults to [] . :deps_path - directory where dependencies are stored. Also see deps_path/1 . Defaults to &quot;deps&quot; . :lockfile - the name of the lockfile used by the mix deps.* family of tasks. Defaults to &quot;mix.lock&quot; . :preferred_cli_env - a keyword list of {task, env} tuples where task is the task name as an atom (for example, :&quot;deps.get&quot; ) and env is the preferred environment (for example, :test ). This option overrides what is specified by the tasks with the @preferred_cli_env attribute (see the docs for Mix.Task ). Defaults to [] . :preferred_cli_target - a keyword list of {task, target} tuples where task is the task name as an atom (for example, :test ) and target is the preferred target (for example, :host ). Defaults to [] . For more options, keep an eye on the documentation for single Mix tasks; good examples are the Mix.Tasks.Compile task and all the specific compiler tasks (such as Mix.Tasks.Compile.Elixir or Mix.Tasks.Compile.Erlang ). Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, :erlc_paths is used by mix compile.erlang , mix compile.yecc , and other tasks). Erlang projects Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, language: :erlang has to be part of the configuration returned by project/0 . This setting also makes sure Elixir is not added as a dependency to the generated .app file or to the escript generated with mix escript.build , and so on.","ref":"Mix.Project.html","title":"Mix.Project","type":"module"},{"doc":"Returns the application path inside the build. The returned path will be expanded. Examples Mix.Project . app_path ( ) #=&gt; &quot;/path/to/project/_build/shared/lib/app&quot;","ref":"Mix.Project.html#app_path/1","title":"Mix.Project.app_path/1","type":"function"},{"doc":"Returns a map with the umbrella child applications paths. These paths are based on the :apps_path and :apps configurations. If the given project configuration identifies an umbrella project, the return value is a map of app =&gt; path where app is a child app of the umbrella and path is its path relative to the root of the umbrella project. If the given project configuration does not identify an umbrella project, nil is returned. Examples Mix.Project . apps_paths ( ) #=&gt; %{my_app1: &quot;apps/my_app1&quot;, my_app2: &quot;apps/my_app2&quot;}","ref":"Mix.Project.html#apps_paths/1","title":"Mix.Project.apps_paths/1","type":"function"},{"doc":"Returns the build path for the given project. If no configuration is given, the one for the current project is used. The returned path will be expanded. Examples Mix.Project . build_path ( ) #=&gt; &quot;/path/to/project/_build/shared&quot; If :build_per_environment is set to true , it will create a new build per environment: Mix . env ( ) #=&gt; :dev Mix.Project . build_path ( ) #=&gt; &quot;/path/to/project/_build/dev&quot;","ref":"Mix.Project.html#build_path/1","title":"Mix.Project.build_path/1","type":"function"},{"doc":"Builds the project structure for the given application. Options :symlink_ebin - symlink ebin instead of copying it","ref":"Mix.Project.html#build_structure/2","title":"Mix.Project.build_structure/2","type":"function"},{"doc":"Clears the dependency for the current environment. Useful when dependencies need to be reloaded due to change of global state. For example, Nerves uses this function to force all dependencies to be reloaded after it updates the system environment. It goes roughly like this: Nerves fetches all dependencies and looks for the system specific deps Once the system specific dep is found, it loads it alongside env vars Nerves then clears the cache, forcing dependencies to be loaded again Dependencies are loaded again, now with an updated env environment","ref":"Mix.Project.html#clear_deps_cache/0","title":"Mix.Project.clear_deps_cache/0","type":"function"},{"doc":"Returns the paths the given project compiles to. If no configuration is given, the one for the current project will be used. The returned path will be expanded. Examples Mix.Project . compile_path ( ) #=&gt; &quot;/path/to/project/_build/dev/lib/app/ebin&quot;","ref":"Mix.Project.html#compile_path/1","title":"Mix.Project.compile_path/1","type":"function"},{"doc":"Returns the project configuration. If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project. Note this configuration is cached once the project is pushed onto the stack. Calling it multiple times won't cause it to be recomputed. Do not use Mix.Project.config/0 to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.","ref":"Mix.Project.html#config/0","title":"Mix.Project.config/0","type":"function"},{"doc":"Returns a list of project configuration files for this project. This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. It returns the mix.exs file, the lock manifest, and all config files in the config directory that do not start with a leading period (for example, .my_config.exs ).","ref":"Mix.Project.html#config_files/0","title":"Mix.Project.config_files/0","type":"function"},{"doc":"Returns the latest modification time from config files. This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. For this reason, the mtime is cached to avoid file system lookups.","ref":"Mix.Project.html#config_mtime/0","title":"Mix.Project.config_mtime/0","type":"function"},{"doc":"Returns the path where protocol consolidations are stored. The returned path will be expanded. Examples Mix.Project . consolidation_path ( ) #=&gt; &quot;/path/to/project/_build/dev/lib/my_app/consolidated&quot; Inside umbrellas: Mix.Project . consolidation_path ( ) #=&gt; &quot;/path/to/project/_build/dev/consolidated&quot;","ref":"Mix.Project.html#consolidation_path/1","title":"Mix.Project.consolidation_path/1","type":"function"},{"doc":"Returns all dependencies app names. The order they are returned is guaranteed to be sorted for proper dependency resolution. For example, if A depends on B, then B will listed before A.","ref":"Mix.Project.html#deps_apps/0","title":"Mix.Project.deps_apps/0","type":"function"},{"doc":"Returns the path where dependencies are stored for the given project. If no configuration is given, the one for the current project is used. The returned path will be expanded. Examples Mix.Project . deps_path ( ) #=&gt; &quot;/path/to/project/deps&quot;","ref":"Mix.Project.html#deps_path/1","title":"Mix.Project.deps_path/1","type":"function"},{"doc":"Returns the full path of all dependencies as a map. Options :depth - only returns dependencies to the depth level, a depth of 1 will only return top-level dependencies :parents - starts the dependency traversal from the given parents instead of the application root Examples Mix.Project . deps_paths ( ) #=&gt; %{foo: &quot;deps/foo&quot;, bar: &quot;custom/path/dep&quot;}","ref":"Mix.Project.html#deps_paths/1","title":"Mix.Project.deps_paths/1","type":"function"},{"doc":"Returns the SCMs of all dependencies as a map. See Mix.SCM module documentation to learn more about SCMs. Options :depth - only returns dependencies to the depth level, a depth of 1 will only return top-level dependencies :parents - starts the dependency traversal from the given parents instead of the application root Examples Mix.Project . deps_scms ( ) #=&gt; %{foo: Mix.SCM.Path, bar: Mix.SCM.Git}","ref":"Mix.Project.html#deps_scms/1","title":"Mix.Project.deps_scms/1","type":"function"},{"doc":"Ensures the project structure for the given project exists. In case it does exist, it is a no-op. Otherwise, it is built.","ref":"Mix.Project.html#ensure_structure/2","title":"Mix.Project.ensure_structure/2","type":"function"},{"doc":"Retrieves the current project if there is one. If there is no current project, nil is returned. This may happen in cases there is no mix.exs in the current directory. If you expect a project to be defined, i.e., it is a requirement of the current task, you should call get!/0 instead.","ref":"Mix.Project.html#get/0","title":"Mix.Project.get/0","type":"function"},{"doc":"Same as get/0 , but raises an exception if there is no current project. This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a Mix.NoProjectError exception in case no project is available.","ref":"Mix.Project.html#get!/0","title":"Mix.Project.get!/0","type":"function"},{"doc":"Runs the given fun inside the given project. This function changes the current working directory and loads the project at the given directory onto the project stack. A post_config can be passed that will be merged into the project configuration. fun is called with the module name of the given Mix.Project . The return value of this function is the return value of fun . Examples Mix.Project . in_project ( :my_app , &quot;/path/to/my_app&quot; , fn module -&gt; &quot;Mix project is: \#{ inspect ( module ) } &quot; end ) #=&gt; &quot;Mix project is: MyApp.MixProject&quot;","ref":"Mix.Project.html#in_project/4","title":"Mix.Project.in_project/4","type":"function"},{"doc":"","ref":"Mix.Project.html#load_paths/1","title":"Mix.Project.load_paths/1","type":"function"},{"doc":"Returns the path where manifests are stored. By default they are stored in the app path inside the build directory. Umbrella applications have the manifest path set to the root of the build directory. Directories may be changed in future releases. The returned path will be expanded. Examples Mix.Project . manifest_path ( ) #=&gt; &quot;/path/to/project/_build/shared/lib/app/.mix&quot;","ref":"Mix.Project.html#manifest_path/1","title":"Mix.Project.manifest_path/1","type":"function"},{"doc":"Returns true if config is the configuration for an umbrella project. When called with no arguments, tells whether the current project is an umbrella project.","ref":"Mix.Project.html#umbrella?/1","title":"Mix.Project.umbrella?/1","type":"function"},{"doc":"Defines the release structure and convenience for assembling releases.","ref":"Mix.Release.html","title":"Mix.Release","type":"module"},{"doc":"The Mix.Release struct has the following read-only fields: :name - the name of the release as an atom :version - the version of the release as a string or {:from_app, app_name} :path - the path to the release root :version_path - the path to the release version inside the release :applications - a map of application with their definitions :erts_source - the erts source as a charlist (or nil) :erts_version - the erts version as a charlist The following fields may be modified as long as they keep their defined types: :boot_scripts - a map of boot scripts with the boot script name as key and a keyword list with all applications that are part of it and their modes as value :config_providers - a list of {config_provider, term} tuples where the first element is a module that implements the Config.Provider behaviour and term is the value given to it on Config.Provider.init/1 :options - a keyword list with all other user supplied release options :overlays - a list of extra files added to the release. If you have a custom step adding extra files to a release, you can add these files to the :overlays field so they are also considered on further commands, such as tar/zip. Each entry in overlays is the relative path to the release root of each file :steps - a list of functions that receive the release and returns a release. Must also contain the atom :assemble which is the internal assembling step. May also contain the atom :tar to create a tarball of the release.","ref":"Mix.Release.html#__struct__/0","title":"Mix.Release.__struct__/0","type":"function"},{"doc":"Copies the given application specification into the release. It assumes the application exists in the release.","ref":"Mix.Release.html#copy_app/2","title":"Mix.Release.copy_app/2","type":"function"},{"doc":"Copies the ebin directory at source to target respecting release options such a :strip_beams .","ref":"Mix.Release.html#copy_ebin/3","title":"Mix.Release.copy_ebin/3","type":"function"},{"doc":"Copies ERTS if the release is configured to do so. Returns true if the release was copied, false otherwise.","ref":"Mix.Release.html#copy_erts/1","title":"Mix.Release.copy_erts/1","type":"function"},{"doc":"Makes boot scripts. It receives a path to the boot file, without extension, such as releases/0.1.0/start and this command will write start.rel , start.boot , and start.script to the given path, returning {:ok, rel_path} or {:error, message} . The boot script uses the RELEASE_LIB environment variable, which must be accordingly set with --boot-var and point to the release lib dir.","ref":"Mix.Release.html#make_boot_script/4","title":"Mix.Release.make_boot_script/4","type":"function"},{"doc":"Copies the cookie to the given path. If a cookie option was given, we compare it with the contents of the file (if any), and ask the user if they want to override. If there is no option, we generate a random one the first time.","ref":"Mix.Release.html#make_cookie/2","title":"Mix.Release.make_cookie/2","type":"function"},{"doc":"Makes the start_erl.data file with the ERTS version and release versions.","ref":"Mix.Release.html#make_start_erl/2","title":"Mix.Release.make_start_erl/2","type":"function"},{"doc":"Makes the sys.config structure. If there are config providers, then a value is injected into the :elixir application configuration in sys_config to be read during boot and trigger the providers. It uses the following release options to customize its behaviour: :reboot_system_after_config :start_distribution_during_config :prune_runtime_sys_config_after_boot In case there are no config providers, it doesn't change sys_config .","ref":"Mix.Release.html#make_sys_config/3","title":"Mix.Release.make_sys_config/3","type":"function"},{"doc":"Finds a template path for the release.","ref":"Mix.Release.html#rel_templates_path/2","title":"Mix.Release.rel_templates_path/2","type":"function"},{"doc":"Strips a beam file for a release. This keeps only significant chunks necessary for the VM operation, discarding documentation, debug info, compile information and others. The exact chunks that are kept are not documented and may change in future versions.","ref":"Mix.Release.html#strip_beam/2","title":"Mix.Release.strip_beam/2","type":"function"},{"doc":"","ref":"Mix.Release.html#t:application/0","title":"Mix.Release.application/0","type":"type"},{"doc":"","ref":"Mix.Release.html#t:mode/0","title":"Mix.Release.mode/0","type":"type"},{"doc":"","ref":"Mix.Release.html#t:t/0","title":"Mix.Release.t/0","type":"type"},{"doc":"This module provides helper functions and defines the behaviour required by any source code manager (SCM) used by Mix.","ref":"Mix.SCM.html","title":"Mix.SCM","type":"behaviour"},{"doc":"This behaviour function receives a keyword list of opts and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency: { :foo , &quot;0.1.0&quot; , github : &quot;foo/bar&quot; } Each registered SCM will be asked if they consume this dependency, receiving [github: &quot;foo/bar&quot;] as argument. Since this option makes sense for the Git SCM, it will return an update list of options while other SCMs would simply return nil .","ref":"Mix.SCM.html#c:accepts_options/2","title":"Mix.SCM.accepts_options/2","type":"callback"},{"doc":"Appends the given SCM module to the list of available SCMs.","ref":"Mix.SCM.html#append/1","title":"Mix.SCM.append/1","type":"function"},{"doc":"Returns all available SCMs. Each SCM is tried in order until a matching one is found.","ref":"Mix.SCM.html#available/0","title":"Mix.SCM.available/0","type":"function"},{"doc":"This behaviour function returns a boolean if the dependency is available.","ref":"Mix.SCM.html#c:checked_out?/1","title":"Mix.SCM.checked_out?/1","type":"callback"},{"doc":"This behaviour function checks out dependencies. If the dependency is locked, a lock is received in opts and the repository must be check out at the lock. Otherwise, no lock is given and the repository can be checked out to the latest version. It must return the current lock.","ref":"Mix.SCM.html#c:checkout/1","title":"Mix.SCM.checkout/1","type":"callback"},{"doc":"Receives two options and must return true if they refer to the same repository. The options are guaranteed to belong to the same SCM.","ref":"Mix.SCM.html#c:equal?/2","title":"Mix.SCM.equal?/2","type":"callback"},{"doc":"Returns a boolean if the dependency can be fetched or it is meant to be previously available in the file system. Local dependencies (i.e. non-fetchable ones) are automatically recompiled every time the parent project is compiled.","ref":"Mix.SCM.html#c:fetchable?/0","title":"Mix.SCM.fetchable?/0","type":"callback"},{"doc":"Returns a string representing the SCM. This is used when printing the dependency and not for inspection, so the amount of information should be concise and easy to spot.","ref":"Mix.SCM.html#c:format/1","title":"Mix.SCM.format/1","type":"callback"},{"doc":"Returns a string representing the SCM. This is used when printing the dependency and not for inspection, so the amount of information should be concise and easy to spot. If nil is returned, it means no lock information is available.","ref":"Mix.SCM.html#c:format_lock/1","title":"Mix.SCM.format_lock/1","type":"callback"},{"doc":"This behaviour function checks the status of the lock. In particular, it checks if the revision stored in the lock is the same as the repository it is currently in. It may return: :mismatch - if the lock doesn't match and we need to simply move to the latest lock :outdated - the repository options are outdated in the lock and we need to trigger a full update :ok - everything is fine The lock is sent via opts[:lock] but it may not always be available. In such cases, if the SCM requires a lock, it must return :mismatch , otherwise simply :ok . Note the lock may also belong to another SCM and as such, an structural check is required. A structural mismatch should always return :outdated .","ref":"Mix.SCM.html#c:lock_status/1","title":"Mix.SCM.lock_status/1","type":"callback"},{"doc":"Returns the usable managers for the dependency. This can be used if the SCM has extra knowledge of the dependency, otherwise it should return an empty list.","ref":"Mix.SCM.html#c:managers/1","title":"Mix.SCM.managers/1","type":"callback"},{"doc":"Prepends the given SCM module to the list of available SCMs.","ref":"Mix.SCM.html#prepend/1","title":"Mix.SCM.prepend/1","type":"function"},{"doc":"This behaviour function updates dependencies. It may be called by deps.get or deps.update . In the first scenario, a lock is received in opts and the repository must be updated to the lock. In the second, no lock is given and the repository can be updated freely. It must return the current lock.","ref":"Mix.SCM.html#c:update/1","title":"Mix.SCM.update/1","type":"callback"},{"doc":"","ref":"Mix.SCM.html#t:opts/0","title":"Mix.SCM.opts/0","type":"type"},{"doc":"A module implementing the Mix.SCM behaviour.","ref":"Mix.SCM.html#t:t/0","title":"Mix.SCM.t/0","type":"type"},{"doc":"Defines Mix.Shell contract.","ref":"Mix.Shell.html","title":"Mix.Shell","type":"behaviour"},{"doc":"Executes the given command and returns its exit status.","ref":"Mix.Shell.html#c:cmd/1","title":"Mix.Shell.cmd/1","type":"callback"},{"doc":"Executes the given command and returns its exit status. Options :print_app - when false , does not print the app name when the command outputs something :stderr_to_stdout - when false , does not redirect stderr to stdout :quiet - when true , do not print the command output :env - environment options to the executed command","ref":"Mix.Shell.html#c:cmd/2","title":"Mix.Shell.cmd/2","type":"callback"},{"doc":"Executes the given command as a shell command and invokes the callback for the streamed response. This is most commonly used by shell implementations but can also be invoked directly. Options :cd - (since v1.11.0) the directory to run the command in :stderr_to_stdout - redirects stderr to stdout, defaults to true :env - a list of environment variables, defaults to [] :quiet - overrides the callback to no-op","ref":"Mix.Shell.html#cmd/3","title":"Mix.Shell.cmd/3","type":"function"},{"doc":"Prints the given ANSI error to the shell.","ref":"Mix.Shell.html#c:error/1","title":"Mix.Shell.error/1","type":"callback"},{"doc":"Prints the given ANSI message to the shell.","ref":"Mix.Shell.html#c:info/1","title":"Mix.Shell.info/1","type":"callback"},{"doc":"Prints the current application to the shell if it was not printed yet.","ref":"Mix.Shell.html#c:print_app/0","title":"Mix.Shell.print_app/0","type":"callback"},{"doc":"Returns the printable app name. This function returns the current application name, but only if the application name should be printed. Calling this function automatically toggles its value to false until the current project is re-entered. The goal is to avoid printing the application name multiple times.","ref":"Mix.Shell.html#printable_app_name/0","title":"Mix.Shell.printable_app_name/0","type":"function"},{"doc":"Prompts the user for input.","ref":"Mix.Shell.html#c:prompt/1","title":"Mix.Shell.prompt/1","type":"callback"},{"doc":"Prompts the user for confirmation.","ref":"Mix.Shell.html#c:yes?/1","title":"Mix.Shell.yes?/1","type":"callback"},{"doc":"This is Mix's default shell. It simply prints messages to stdio and stderr.","ref":"Mix.Shell.IO.html","title":"Mix.Shell.IO","type":"module"},{"doc":"Executes the given command and prints its output to stdout as it comes.","ref":"Mix.Shell.IO.html#cmd/2","title":"Mix.Shell.IO.cmd/2","type":"function"},{"doc":"Prints the given ANSI error to the shell followed by a newline.","ref":"Mix.Shell.IO.html#error/1","title":"Mix.Shell.IO.error/1","type":"function"},{"doc":"Prints the given ANSI message to the shell followed by a newline.","ref":"Mix.Shell.IO.html#info/1","title":"Mix.Shell.IO.info/1","type":"function"},{"doc":"Prints the current application to the shell if it was not printed yet.","ref":"Mix.Shell.IO.html#print_app/0","title":"Mix.Shell.IO.print_app/0","type":"function"},{"doc":"Prints a message and prompts the user for input. Input will be consumed until Enter is pressed.","ref":"Mix.Shell.IO.html#prompt/1","title":"Mix.Shell.IO.prompt/1","type":"function"},{"doc":"Prints a message and asks the user if they want to proceed. The user must press Enter or type one of &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot; or &quot;Yes&quot;. Examples if Mix . shell ( ) . yes? ( &quot;Are you sure?&quot; ) do # do something... end","ref":"Mix.Shell.IO.html#yes?/1","title":"Mix.Shell.IO.yes?/1","type":"function"},{"doc":"Mix shell that uses the current process mailbox for communication. This module provides a Mix shell implementation that uses the current process mailbox for communication instead of IO. As an example, when Mix.shell().info(&quot;hello&quot;) is called, the following message will be sent to the calling process: { :mix_shell , :info , [ &quot;hello&quot; ] } This is mainly useful in tests, allowing us to assert if given messages were received or not instead of performing checks on some captured IO. Since we need to guarantee a clean slate between tests, there is also a flush/1 function responsible for flushing all :mix_shell related messages from the process inbox. Examples Mix . shell ( ) . info ( &quot;hello&quot; ) receive do { :mix_shell , :info , [ msg ] } -&gt; msg end #=&gt; &quot;hello&quot; send ( self ( ) , { :mix_shell_input , :prompt , &quot;Pretty cool&quot; } ) Mix . shell ( ) . prompt? ( &quot;How cool was that?!&quot; ) #=&gt; &quot;Pretty cool&quot;","ref":"Mix.Shell.Process.html","title":"Mix.Shell.Process","type":"module"},{"doc":"Executes the given command and forwards its messages to the current process.","ref":"Mix.Shell.Process.html#cmd/2","title":"Mix.Shell.Process.cmd/2","type":"function"},{"doc":"Forwards the error to the current process.","ref":"Mix.Shell.Process.html#error/1","title":"Mix.Shell.Process.error/1","type":"function"},{"doc":"Flushes all :mix_shell and :mix_shell_input messages from the current process. If a callback is given, it is invoked for each received message. Examples flush ( &amp; IO . inspect / 1 )","ref":"Mix.Shell.Process.html#flush/1","title":"Mix.Shell.Process.flush/1","type":"function"},{"doc":"Forwards the message to the current process.","ref":"Mix.Shell.Process.html#info/1","title":"Mix.Shell.Process.info/1","type":"function"},{"doc":"Prints the current application if it was not printed yet.","ref":"Mix.Shell.Process.html#print_app/0","title":"Mix.Shell.Process.print_app/0","type":"function"},{"doc":"Forwards the message to the current process. It also checks the inbox for an input message matching: { :mix_shell_input , :prompt , value } If one does not exist, it will abort since there was no shell process inputs given. value must be a string. Examples The following will answer with &quot;Meg&quot; to the prompt &quot;What's your name?&quot; : # The response is sent before calling prompt/1 so that prompt/1 can read it send ( self ( ) , { :mix_shell_input , :prompt , &quot;Meg&quot; } ) Mix . shell ( ) . prompt ( &quot;What&#39;s your name?&quot; )","ref":"Mix.Shell.Process.html#prompt/1","title":"Mix.Shell.Process.prompt/1","type":"function"},{"doc":"Forwards the message to the current process. It also checks the inbox for an input message matching: { :mix_shell_input , :yes? , value } If one does not exist, it will abort since there was no shell process inputs given. value must be true or false . Example # Send the response to self() first so that yes?/1 will be able to read it send ( self ( ) , { :mix_shell_input , :yes? , true } ) Mix . shell ( ) . yes? ( &quot;Are you sure you want to continue?&quot; )","ref":"Mix.Shell.Process.html#yes?/1","title":"Mix.Shell.Process.yes?/1","type":"function"},{"doc":"This is Mix's default shell when the MIX_QUIET environment variable is set. It's just like Mix.Shell.IO , but prints far less.","ref":"Mix.Shell.Quiet.html","title":"Mix.Shell.Quiet","type":"module"},{"doc":"Executes the given command quietly without outputting anything.","ref":"Mix.Shell.Quiet.html#cmd/2","title":"Mix.Shell.Quiet.cmd/2","type":"function"},{"doc":"Prints the error to the shell followed by a newline.","ref":"Mix.Shell.Quiet.html#error/1","title":"Mix.Shell.Quiet.error/1","type":"function"},{"doc":"Prints nothing to the shell.","ref":"Mix.Shell.Quiet.html#info/1","title":"Mix.Shell.Quiet.info/1","type":"function"},{"doc":"Prints the current application if it was not printed yet.","ref":"Mix.Shell.Quiet.html#print_app/0","title":"Mix.Shell.Quiet.print_app/0","type":"function"},{"doc":"Prints a message and prompts the user for input. Input will be consumed until Enter is pressed.","ref":"Mix.Shell.Quiet.html#prompt/1","title":"Mix.Shell.Quiet.prompt/1","type":"function"},{"doc":"Prints a message and asks the user if they want to proceed. The user must press Enter or type one of &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot; or &quot;Yes&quot;.","ref":"Mix.Shell.Quiet.html#yes?/1","title":"Mix.Shell.Quiet.yes?/1","type":"function"},{"doc":"Provides conveniences for creating, loading, and manipulating Mix tasks. A Mix task can be defined by using Mix.Task in a module whose name begins with Mix.Tasks. and which defines the run/1 function. Typically, task modules live inside the lib/mix/tasks/ directory, and their file names use dot separators instead of underscores (e.g. deps.clean.ex ) - although ultimately the file name is not relevant. For example: # lib/mix/tasks/echo.ex defmodule Mix.Tasks.Echo do @moduledoc &quot;Printed when the user requests `mix help echo`&quot; @shortdoc &quot;Echoes arguments&quot; use Mix.Task @impl Mix.Task def run ( args ) do Mix . shell ( ) . info ( Enum . join ( args , &quot; &quot; ) ) end end The command name will correspond to the portion of the module name following Mix.Tasks. . For example, a module name of Mix.Tasks.Deps.Clean corresponds to a task name of deps.clean . The run/1 function will receive a list of all command line arguments passed, according to the user's terminal. For example, if the args in the above echo task were inspected, you might see something like this: mix echo &#39;A and B&#39; C -- test [ &quot;A and B&quot; , &quot;C&quot; , &quot;--test&quot; ] Define the @shortdoc attribute if you wish to make the task publicly visible on mix help . Omit this attribute if you do not want your task to be listed via mix help . If a task has requirements, they can be listed using the @requirements attribute. For example: @requirements [ &quot;app.config&quot; ] Tasks typically depend on the &quot;app.config&quot; task, when they need to access code from the current project with all apps already configured, or the &quot;app.start&quot; task, when they also need those apps to be already started: @requirements [ &quot;app.start&quot; ] You can also run tasks directly with run/2 . Attributes There are a few attributes available in Mix tasks to configure them in Mix: @shortdoc - makes the task public with a short description that appears on mix help @recursive - runs the task recursively in umbrella projects @requirements - list of required tasks to be run before the task @preferred_cli_env - recommends an environment in which to run the task. It is used only if MIX_ENV is not yet set. Note @preferred_cli_env is not loaded from dependencies as we need to know the environment in order to load the dependencies themselves. In those cases, you can set the preferred_cli_env configuration under def project in your mix.exs Documentation Users can read the documentation for public Mix tasks by running mix help my_task . The documentation that will be shown is the @moduledoc of the task's module.","ref":"Mix.Task.html","title":"Mix.Task","type":"behaviour"},{"doc":"Checks if the given task name is an alias. Returns false if the given name is not an alias or if it is not a task. For more information about task aliasing, take a look at the &quot;Aliases&quot; section in the docs for Mix .","ref":"Mix.Task.html#alias?/1","title":"Mix.Task.alias?/1","type":"function"},{"doc":"Returns all loaded task modules. Modules that are not yet loaded won't show up. Check load_all/0 if you want to preload all tasks.","ref":"Mix.Task.html#all_modules/0","title":"Mix.Task.all_modules/0","type":"function"},{"doc":"Clears all invoked tasks, allowing them to be reinvoked. This operation is not recursive.","ref":"Mix.Task.html#clear/0","title":"Mix.Task.clear/0","type":"function"},{"doc":"Receives a task name and returns the corresponding task module if one exists. Returns nil if the module cannot be found, if it is an alias, or if it is not a valid Mix.Task .","ref":"Mix.Task.html#get/1","title":"Mix.Task.get/1","type":"function"},{"doc":"Receives a task name and retrieves the corresponding task module. Exceptions Mix.NoTaskError - raised if the task could not be found Mix.InvalidTaskError - raised if the task is not a valid Mix.Task","ref":"Mix.Task.html#get!/1","title":"Mix.Task.get!/1","type":"function"},{"doc":"Loads all tasks in all code paths.","ref":"Mix.Task.html#load_all/0","title":"Mix.Task.load_all/0","type":"function"},{"doc":"Loads all tasks in the given paths .","ref":"Mix.Task.html#load_tasks/1","title":"Mix.Task.load_tasks/1","type":"function"},{"doc":"Gets the moduledoc for the given task module . Returns the moduledoc or nil .","ref":"Mix.Task.html#moduledoc/1","title":"Mix.Task.moduledoc/1","type":"function"},{"doc":"Gets preferred CLI environment for the task. Returns environment (for example, :test , or :prod ), or nil .","ref":"Mix.Task.html#preferred_cli_env/1","title":"Mix.Task.preferred_cli_env/1","type":"function"},{"doc":"Indicates if the current task is recursing. This returns true if a task is marked as recursive and it is being executed inside an umbrella project.","ref":"Mix.Task.html#recursing?/0","title":"Mix.Task.recursing?/0","type":"function"},{"doc":"Checks if the task should be run recursively for all sub-apps in umbrella projects. Returns true or false .","ref":"Mix.Task.html#recursive/1","title":"Mix.Task.recursive/1","type":"function"},{"doc":"Reenables a given task so it can be executed again down the stack. Both alias and the regular stack are reenabled when this function is called. If an umbrella project reenables a task, it is reenabled for all child projects.","ref":"Mix.Task.html#reenable/1","title":"Mix.Task.reenable/1","type":"function"},{"doc":"Gets the list of requirements for the given task. Returns a list of strings, where the string is expected to be a task optionally followed by its arguments.","ref":"Mix.Task.html#requirements/1","title":"Mix.Task.requirements/1","type":"function"},{"doc":"Reruns task with the given arguments. This function reruns the given task; to do that, it first re-enables the task and then runs it as normal.","ref":"Mix.Task.html#rerun/2","title":"Mix.Task.rerun/2","type":"function"},{"doc":"A task needs to implement run which receives a list of command line args.","ref":"Mix.Task.html#c:run/1","title":"Mix.Task.run/1","type":"callback"},{"doc":"Conditionally runs the task (or alias) with the given args . If there exists a task matching the given task name and it has not yet been invoked, this will run the task with the given args and return the result. If there is an alias defined for the given task name, the alias will be invoked instead of the original task. If the task or alias has already been invoked, subsequent calls to run/2 will abort without executing and return :noop . Remember: by default, tasks will only run once , even when called repeatedly! If you need to run a task multiple times, you need to re-enable it via reenable/1 or call it using rerun/2 . run/2 raises an exception if an alias or a task cannot be found or if the task is invalid. See get!/1 for more information.","ref":"Mix.Task.html#run/2","title":"Mix.Task.run/2","type":"function"},{"doc":"Gets the shortdoc for the given task module . Returns the shortdoc or nil .","ref":"Mix.Task.html#shortdoc/1","title":"Mix.Task.shortdoc/1","type":"function"},{"doc":"Returns true if given module is a task.","ref":"Mix.Task.html#task?/1","title":"Mix.Task.task?/1","type":"function"},{"doc":"Returns the task name for the given module . Examples iex&gt; Mix.Task . task_name ( Mix.Tasks.Test ) &quot;test&quot;","ref":"Mix.Task.html#task_name/1","title":"Mix.Task.task_name/1","type":"function"},{"doc":"","ref":"Mix.Task.html#t:task_module/0","title":"Mix.Task.task_module/0","type":"type"},{"doc":"","ref":"Mix.Task.html#t:task_name/0","title":"Mix.Task.task_name/0","type":"type"},{"doc":"This module defines the behaviour for a Mix task that does compilation. A Mix compiler task can be defined by simply using Mix.Task.Compiler in a module whose name starts with Mix.Tasks.Compile. and defining the run/1 function: defmodule Mix.Tasks.Compile.MyLanguage do use Mix.Task.Compiler def run ( _args ) do :ok end end The run/1 function returns an atom indicating the status of the compilation, and optionally can also return a list of &quot;diagnostics&quot; such as warnings or compilation errors. Doing this enables code editors to display issues inline without having to analyze the command-line output. If the compiler uses manifest files to track stale sources, it should define manifests/0 , and if it writes any output to disk it should also define clean/0 . A compiler supports the same attributes for configuration and documentation as a regular Mix task. See Mix.Task for more information.","ref":"Mix.Task.Compiler.html","title":"Mix.Task.Compiler","type":"behaviour"},{"doc":"Adds a callback that runs after a given compiler. The callback is invoked after the compiler runs and it receives a tuple with current status and the list of diagnostic. It must return the updated status and diagnostics.","ref":"Mix.Task.Compiler.html#after_compiler/2","title":"Mix.Task.Compiler.after_compiler/2","type":"function"},{"doc":"Removes build artifacts and manifests.","ref":"Mix.Task.Compiler.html#c:clean/0","title":"Mix.Task.Compiler.clean/0","type":"callback"},{"doc":"Lists manifest files for the compiler.","ref":"Mix.Task.Compiler.html#c:manifests/0","title":"Mix.Task.Compiler.manifests/0","type":"callback"},{"doc":"Receives command-line arguments and performs compilation. If it produces errors, warnings, or any other diagnostic information, it should return a tuple with the status and a list of diagnostics.","ref":"Mix.Task.Compiler.html#c:run/1","title":"Mix.Task.Compiler.run/1","type":"callback"},{"doc":"","ref":"Mix.Task.Compiler.html#t:status/0","title":"Mix.Task.Compiler.status/0","type":"type"},{"doc":"Diagnostic information such as a warning or compilation error.","ref":"Mix.Task.Compiler.Diagnostic.html","title":"Mix.Task.Compiler.Diagnostic","type":"module"},{"doc":"Where in a file the diagnostic applies. Can be either a line number, a range specified as {start_line, start_col, end_line, end_col} , or nil if unknown. Line numbers are one-based, and column numbers in a range are zero-based and refer to the cursor position at the start of the character at that index. For example, to indicate that a diagnostic applies to the first n characters of the first line, the range would be {1, 0, 1, n} .","ref":"Mix.Task.Compiler.Diagnostic.html#t:position/0","title":"Mix.Task.Compiler.Diagnostic.position/0","type":"type"},{"doc":"Severity of a diagnostic: :error - An issue that caused compilation to fail :warning - An issue that did not cause failure but suggests the programmer may have made a mistake :hint - A suggestion for style or good practices that is not as severe as a warning :information - Any other information relevant to compilation that does not fit into the above categories","ref":"Mix.Task.Compiler.Diagnostic.html#t:severity/0","title":"Mix.Task.Compiler.Diagnostic.severity/0","type":"type"},{"doc":"","ref":"Mix.Task.Compiler.Diagnostic.html#t:t/0","title":"Mix.Task.Compiler.Diagnostic.t/0","type":"type"},{"doc":"Loads and configures all registered apps. This is done by loading config/runtime.exs if one exists. Command line options --force - forces compilation regardless of compilation times --temporary - starts the application as temporary --permanent - starts the application as permanent --preload-modules - preloads all modules defined in applications --no-archives-check - does not check archives --no-app-loading - does not load applications (including from deps) --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-elixir-version-check - does not check Elixir version --no-validate-compile-env - does not validate the application compile environment","ref":"Mix.Tasks.App.Config.html","title":"Mix.Tasks.App.Config","type":"task"},{"doc":"Starts all registered apps. First, this task guarantees that all dependencies are in place and that the current project has been compiled. Then, the current application is started as a temporary application, unless :start_permanent is set to true in your project configuration or the --permanent option is given. Setting it to permanent guarantees the node will shut down if the application terminates (typically because its root supervisor has terminated). Configuration :start_permanent - the application and all of its children applications are started in permanent mode. Defaults to false . Command line options --force - forces compilation regardless of compilation times --temporary - starts the application as temporary --permanent - starts the application as permanent --preload-modules - preloads all modules defined in applications --no-archives-check - does not check archives --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-elixir-version-check - does not check Elixir version --no-start - does not actually start applications, only compiles and loads code","ref":"Mix.Tasks.App.Start.html","title":"Mix.Tasks.App.Start","type":"task"},{"doc":"Prints the application tree. mix app . tree -- exclude logger -- exclude elixir If no application is given, it uses the current application defined in the mix.exs file. Command line options --exclude - exclude applications which you do not want to see printed. kernel , stdlib and compiler are always excluded from the tree. --format - Can be set to one of either: pretty - uses Unicode code points for formatting the tree. This is the default except on Windows. plain - does not use Unicode code points for formatting the tree. This is the default on Windows. dot - produces a DOT graph description of the application tree in app_tree.dot in the current directory. Warning: this will overwrite any previously generated file.","ref":"Mix.Tasks.App.Tree.html","title":"Mix.Tasks.App.Tree","type":"task"},{"doc":"Lists all installed archives. Archives are typically installed at ~/.mix/archives although the installation path can be customized by setting the MIX_ARCHIVES environment variable. Since archives are specific to Elixir versions, it is expected from build tools to swap the MIX_ARCHIVES variable to different locations based on a particular Elixir installation.","ref":"Mix.Tasks.Archive.html","title":"Mix.Tasks.Archive","type":"task"},{"doc":"Builds an archive according to the specification of the Erlang archive format . Archives are meant to contain small projects, usually installed locally. Archives may be installed into a Mix environment by running mix archive.install . Once installed, the archive is available to all Mix projects. For this reason, the functionality behind archives is limited. For instance, archives do not include dependencies, as those would conflict with any dependency in a Mix project after the archive is installed. In general, we recommend the usage of archives to be limited for extensions of Mix, such as custom SCMs, package managers, and the like. For general scripts to be distributed to developers, please see mix escript.build . The archive will be created in the current directory (which is expected to be the project root), unless an argument -o is provided with the file name. By default, this command archives the current project but the -i option can be used to archive any directory. For example, mix archive.build with no options translates to: mix archive . build - i _build / ENV / lib / APP - o APP - VERSION . ez Command line options -o - specifies output file name. If there is a mix.exs , defaults to &quot;APP-VERSION.ez&quot;. -i - specifies the input directory to archive. If there is a mix.exs , defaults to the current application build. --no-compile - skips compilation. Only applies when mix.exs is available. --include-dot-files - adds dot files from priv directory to the archive.","ref":"Mix.Tasks.Archive.Build.html","title":"Mix.Tasks.Archive.Build","type":"task"},{"doc":"Checks all archives are available. Mix projects can specify required archives using the :archives option: archives : [ { :foo , &quot;~&gt; 1.0.0&quot; } ] This task guarantees this option is respected.","ref":"Mix.Tasks.Archive.Check.html","title":"Mix.Tasks.Archive.Check","type":"task"},{"doc":"Installs an archive locally. If no argument is supplied but there is an archive in the project's root directory (created with mix archive.build ), then the archive will be installed locally. For example: mix do archive . build , archive . install If an argument is provided, it should be a local path to a prebuilt archive, a Git repository, a GitHub repository, or a Hex package. mix archive . install archive . ez mix archive . install path / to / archive . ez mix archive . install git https :/ / path / to / git / repo mix archive . install git https :/ / path / to / git / repo branch git_branch mix archive . install git https :/ / path / to / git / repo tag git_tag mix archive . install git https :/ / path / to / git / repo ref git_ref mix archive . install github user / project mix archive . install github user / project branch git_branch mix archive . install github user / project tag git_tag mix archive . install github user / project ref git_ref mix archive . install hex hex_package mix archive . install hex hex_package 1.2 . 3 After installation, the tasks in the archive are available locally: mix some_task Note that installing via Git, GitHub, or Hex fetches the source of the archive and builds it, while using local path uses a pre-built archive. Command line options --sha512 - checks the archive matches the given SHA-512 checksum. Only applies to installations via a local path --force - forces installation without a shell prompt; primarily intended for automation in build systems like Make --submodules - fetches repository submodules before building archive from Git or GitHub --app - specifies a custom app name to be used for building the archive from Git, GitHub, or Hex --organization - set this for Hex private packages belonging to an organization --repo - set this for self-hosted Hex instances, defaults to hexpm","ref":"Mix.Tasks.Archive.Install.html","title":"Mix.Tasks.Archive.Install","type":"task"},{"doc":"Uninstalls local archives. mix archive . uninstall archive . ez Command line options --force - forces uninstallation without a shell prompt; primarily intended for automation","ref":"Mix.Tasks.Archive.Uninstall.html","title":"Mix.Tasks.Archive.Uninstall","type":"task"},{"doc":"Deletes generated application files. This command deletes all build artifacts for the current project. Dependencies' sources and build files are cleaned only if the --deps option is given. By default this task works across all environments, unless --only is given.","ref":"Mix.Tasks.Clean.html","title":"Mix.Tasks.Clean","type":"task"},{"doc":"Executes the given command. Useful in umbrella applications to execute a command on each child app: mix cmd pwd You can limit which apps the cmd runs in by passing the app names before the cmd using --app: mix cmd -- app app1 -- app app2 pwd Aborts when a command exits with a non-zero status. This task is automatically reenabled, so it can be called multiple times with different arguments. Command line options --app - limit running the command to the given app. This option may be given multiple times --cd - (since v1.10.4) the directory to run the command in Zombie operating system processes Beware that the Erlang VM does not terminate child processes when it shuts down. Therefore, if you use mix cmd to start long running processes and then shut down the VM, it is likely that those child processes won't be terminated with the VM. A solution is to make sure the child processes listen to the standard input and terminate when standard input is closed. We discuss this topic at length in the &quot;Zombie operating system processes&quot; of the Port module documentation.","ref":"Mix.Tasks.Cmd.html","title":"Mix.Tasks.Cmd","type":"task"},{"doc":"The main entry point to compile source files. It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics. Before compiling code, it loads the code in all dependencies and perform a series of checks to ensure the project is up to date. Configuration :compilers - compilers to run, defaults to Mix.compilers/0 , which are [:yecc, :leex, :erlang, :elixir, :app] . :consolidate_protocols - when true , runs protocol consolidation via the mix compile.protocols task. The default value is true . :build_embedded - when true , embeds all code and priv content in the _build directory instead of using symlinks. :build_path - the directory where build artifacts should be written to. This option is intended only for child apps within a larger umbrella application so that each child app can use the common _build directory of the parent umbrella. In a non-umbrella context, configuring this has undesirable side-effects (such as skipping some compiler checks) and should be avoided. Compilers To see documentation for each specific compiler, you must invoke help directly for the compiler command: mix help compile . elixir mix help compile . erlang You can get a list of all compilers by running: mix compile -- list Command line options --erl-config - path to an Erlang term file that will be loaded as Mix config --force - forces compilation --list - lists all enabled compilers --no-app-loading - does not load applications (including from deps) before compiling --no-archives-check - skips checking of archives --no-compile - does not actually compile, only loads code and perform checks --no-deps-check - skips checking of dependencies --no-elixir-version-check - does not check Elixir version --no-protocol-consolidation - skips protocol consolidation --no-validate-compile-env - does not validate the application compile environment --return-errors - returns error status and diagnostics instead of exiting on error --warnings-as-errors - exit with non-zero status if compilation has one or more warnings","ref":"Mix.Tasks.Compile.html","title":"Mix.Tasks.Compile","type":"task"},{"doc":"Returns all compilers.","ref":"Mix.Tasks.Compile.html#compilers/1","title":"Mix.Tasks.Compile.compilers/1","type":"function"},{"doc":"Writes an .app file. An .app file is a file containing Erlang terms that defines your application. Mix automatically generates this file based on your mix.exs configuration. In order to generate the .app file, Mix expects your project to have both :app and :version keys. Furthermore, you can configure the generated application by defining an application/0 function in your mix.exs that returns a keyword list. The most commonly used keys are: :extra_applications - a list of OTP applications your application depends on which are not included in :deps (usually defined in deps/0 in your mix.exs ). For example, here you can declare a dependency on applications that ship with Erlang/OTP or Elixir, like :crypto or :logger . Optional extra applications can be declared as a tuple, such as {:ex_unit, :optional} . Mix guarantees all non-optional applications are started before your application starts. :registered - the name of all registered processes in the application. If your application defines a local GenServer with name MyServer , it is recommended to add MyServer to this list. It is most useful in detecting conflicts between applications that register the same names. :env - the default values for the application environment. The application environment is one of the most common ways to configure applications. See the Application module for mechanisms to read and write to the application environment. For example: def application do [ extra_applications : [ :logger , :crypto , ex_unit : :optional ] , env : [ key : :value ] , registered : [ MyServer ] ] end Other options include: :applications - all applications your application depends on at runtime. By default, this list is automatically inferred from your dependencies. Mix and other tools use the application list in order to start your dependencies before starting the application itself. :mod - specifies a module to invoke when the application is started. It must be in the format {Mod, args} where args is often an empty list. The module specified must implement the callbacks defined by the Application module. :start_phases - specifies a list of phases and their arguments to be called after the application is started. See the &quot;Phases&quot; section below. :included_applications - specifies a list of applications that will be included in the application. It is the responsibility of the primary application to start the supervision tree of all included applications, as only the primary application will be started. A process in an included application considers itself belonging to the primary application. :maxT - specifies the maximum time the application is allowed to run, in milliseconds. Applications are stopped if :maxT is reached, and their top-level supervisor terminated with reason :normal . This threshold is technically valid in any resource file, but it is only effective for applications with a callback module. Defaults to :infinity . Besides the options above, .app files also expect other options like :modules and :vsn , but these are automatically added by Mix. Command line options --force - forces compilation regardless of modification times --compile-path - where to find .beam files and write the resulting .app file, defaults to Mix.Project.compile_path/0 Phases Applications provide a start phases mechanism which will be called, in order, for the application and all included applications. If a phase is not defined for an included application, that application is skipped. Let's see an example MyApp.application/0 function: def application do [ start_phases : [ init : [ ] , go : [ ] , finish : [ ] ] , included_applications : [ :my_included_app ] ] end And an example :my_included_app defines on its mix.exs the function: def application do [ mod : { MyIncludedApp , [ ] } , start_phases : [ go : [ ] ] ] end In this example, the order that the application callbacks are called in is: Application . start ( MyApp ) MyApp . start ( :normal , [ ] ) MyApp . start_phase ( :init , :normal , [ ] ) MyApp . start_phase ( :go , :normal , [ ] ) MyIncludedApp . start_phase ( :go , :normal , [ ] ) MyApp . start_phase ( :finish , :normal , [ ] )","ref":"Mix.Tasks.Compile.App.html","title":"Mix.Tasks.Compile.App","type":"task"},{"doc":"Compiles Elixir source files. Elixir is smart enough to recompile only files that have changed and their dependencies. This means if lib/a.ex is invoking a function defined over lib/b.ex , whenever lib/b.ex changes, lib/a.ex is also recompiled. Note it is important to recompile a file's dependencies as there are often compile time dependencies between them. __mix_recompile__?/0 A module may export a __mix_recompile__?/0 function that can cause the module to be recompiled using custom rules. For example, @external_resource already adds a compile-time dependency on an external file, however to depend on a dynamic list of files we can do: defmodule MyModule do paths = Path . wildcard ( &quot;*.txt&quot; ) paths_hash = :erlang . md5 ( paths ) for path &lt;- paths do @external_resource path end def __mix_recompile__? ( ) do Path . wildcard ( &quot;*.txt&quot; ) |&gt; :erlang . md5 ( ) != unquote ( paths_hash ) end end Compiler calls __mix_recompile__?/0 for every module being compiled (or previously compiled) and thus it is very important to do there as little work as possible to not slow down the compilation. If module has @compile {:autoload, false} , __mix_recompile__?/0 will not be used. Command line options --verbose - prints each file being compiled --force - forces compilation regardless of modification times --docs ( --no-docs ) - attaches (or not) documentation to compiled modules --debug-info ( --no-debug-info ) - attaches (or not) debug info to compiled modules --ignore-module-conflict - does not emit warnings if a module was previously defined --warnings-as-errors - treats warnings in the current project as errors and return a non-zero exit code --long-compilation-threshold N - sets the &quot;long compilation&quot; threshold (in seconds) to N (see the docs for Kernel.ParallelCompiler.compile/2 ) --profile - if set to time , outputs timing information of compilation steps --all-warnings - prints warnings even from files that do not need to be recompiled --tracer - adds a compiler tracer in addition to any specified in the mix.exs file Configuration :elixirc_paths - directories to find source files. Defaults to [&quot;lib&quot;] . :elixirc_options - compilation options that apply to Elixir's compiler. See Code.put_compiler_option/2 for a complete list of options. These options are often overridable from the command line using the switches above. [xref: [exclude: ...]] - a list of module or {module, function, arity} that should not be warned on in case on undefined modules or undefined application warnings.","ref":"Mix.Tasks.Compile.Elixir.html","title":"Mix.Tasks.Compile.Elixir","type":"task"},{"doc":"Compiles Erlang source files. When this task runs, it will first check the modification times of all files to be compiled and if they haven't been changed since the last compilation, it will not compile them. If any of them have changed, it compiles everything. For this reason, the task touches your :compile_path directory and sets the modification time to the current time and date at the end of each compilation. You can force compilation regardless of modification times by passing the --force option. Command line options --force - forces compilation regardless of modification times --all-warnings - prints warnings even from files that do not need to be recompiled Configuration ERL_COMPILER_OPTIONS - can be used to give default compile options. The value must be a valid Erlang term. If the value is a list, it will be used as is. If it is not a list, it will be put into a list. :erlc_paths - directories to find source files. Defaults to [&quot;src&quot;] . :erlc_include_path - directory for adding include files. Defaults to &quot;include&quot; . :erlc_options - compilation options that apply to Erlang's compiler. Defaults to [] . For a complete list of options, see :compile.file/2 . The option :debug_info is always added to the end of it. You can disable that using: erlc_options : [ debug_info : false ]","ref":"Mix.Tasks.Compile.Erlang.html","title":"Mix.Tasks.Compile.Erlang","type":"task"},{"doc":"Compiles Leex source files. When this task runs, it will check the modification time of every file, and if it has changed, the file will be compiled. Files will be compiled in the same source directory with a .erl extension. You can force compilation regardless of modification times by passing the --force option. Command line options --force - forces compilation regardless of modification times --all-warnings - prints warnings even from files that do not need to be recompiled Configuration :erlc_paths - directories to find source files. Defaults to [&quot;src&quot;] . :leex_options - compilation options that apply to Leex's compiler. For a complete list of options, see :leex.file/2 . Note that the :report , :return_errors , and :return_warnings options are overridden by this compiler, thus setting them has no effect.","ref":"Mix.Tasks.Compile.Leex.html","title":"Mix.Tasks.Compile.Leex","type":"task"},{"doc":"Consolidates all protocols in all paths. This task is automatically invoked unless the project disables the :consolidate_protocols option in their configuration. Consolidation Protocol consolidation is useful in production when no dynamic code loading will happen, effectively optimizing protocol dispatches by not accounting for code loading. This task consolidates all protocols in the code path and outputs the new binary files to the given directory. Defaults to &quot;_build/MIX_ENV/lib/YOUR_APP/consolidated&quot; for regular apps and &quot;_build/MIX_ENV/consolidated&quot; in umbrella projects. In case you are manually compiling protocols or building releases, you need to take the generated protocols into account. This can be done with: $ elixir - pa _build / MIX_ENV / lib / YOUR_APP / consolidated - S mix run Or in umbrellas: $ elixir - pa _build / MIX_ENV / consolidated - S mix run You can verify a protocol is consolidated by checking its attributes: iex&gt; Protocol . consolidated? ( Enumerable ) true","ref":"Mix.Tasks.Compile.Protocols.html","title":"Mix.Tasks.Compile.Protocols","type":"task"},{"doc":"Returns if protocols have been consolidated at least once.","ref":"Mix.Tasks.Compile.Protocols.html#consolidated?/0","title":"Mix.Tasks.Compile.Protocols.consolidated?/0","type":"function"},{"doc":"Compiles Yecc source files. When this task runs, it will check the modification time of every file, and if it has changed, the file will be compiled. Files will be compiled in the same source directory with a .erl extension. You can force compilation regardless of modification times by passing the --force option. Command line options --force - forces compilation regardless of modification times --all-warnings - prints warnings even from files that do not need to be recompiled Configuration :erlc_paths - directories to find source files. Defaults to [&quot;src&quot;] . :yecc_options - compilation options that apply to Yecc's compiler. For a complete list of options, see :yecc.file/1 . Note that the :report , :return_errors , and :return_warnings options are overridden by this compiler, thus setting them has no effect.","ref":"Mix.Tasks.Compile.Yecc.html","title":"Mix.Tasks.Compile.Yecc","type":"task"},{"doc":"Lists all dependencies and their status. Dependencies must be specified in the mix.exs file in one of the following formats: { app , requirement } { app , opts } { app , requirement , opts } Where: app is an atom requirement is a Version requirement or a regular expression opts is a keyword list of options For example: { :plug , &quot;&gt;= 0.4.0&quot; } { :gettext , git : &quot;https://github.com/elixir-lang/gettext.git&quot; , tag : &quot;0.1&quot; } { :local_dependency , path : &quot;path/to/local_dependency&quot; } By default, dependencies are fetched using the Hex package manager : { :plug , &quot;&gt;= 0.4.0&quot; } By specifying such dependencies, Mix will automatically install Hex (if it wasn't previously installed) and download a package suitable to your project. Note Hex expects the dependency requirement to always be given and it will warn otherwise. Mix also supports Git and path dependencies: { :foobar , git : &quot;https://github.com/elixir-lang/foobar.git&quot; , tag : &quot;0.1&quot; } { :foobar , path : &quot;path/to/foobar&quot; } And also in umbrella dependencies: { :my_app , in_umbrella : true } Path and in umbrella dependencies are automatically recompiled by the parent project whenever they change. While fetchable dependencies, like the ones using :git , are recompiled only when fetched/updated. The dependencies' versions are expected to be formatted according to Semantic Versioning and the requirements must be specified as defined in the Version module. Options Below we provide a more detailed look into the available options. Dependency definition options :app - when set to false , does not read the app file for this dependency. By default, the app file is read :env - the environment (as an atom) to run the dependency on; defaults to :prod :compile - a command (string) to compile the dependency; defaults to a mix , rebar or make command :optional - marks the dependency as optional. In such cases, the current project will always include the optional dependency but any other project that depends on the current project won't be forced to use the optional dependency. However, if the other project includes the optional dependency on its own, the requirements and options specified here will also be applied. Optional dependencies will not be started by the application. :only - the dependency is made available only in the given environments, useful when declaring dev- or test-only dependencies; by default the dependency will be available in all environments. The value of this option can either be a single environment (like :dev ) or a list of environments (like [:dev, :test] ) :targets - the dependency is made available only for the given targets. By default the dependency will be available in all environments. The value of this option can either be a single target (like :host ) or a list of environments (like [:host, :rpi3] ) :override - if set to true the dependency will override any other definitions of itself by other dependencies :manager - Mix can also compile Rebar, Rebar3 and makefile projects and can fetch sub dependencies of Rebar and Rebar3 projects. Mix will try to infer the type of project but it can be overridden with this option by setting it to :mix , :rebar3 , :rebar or :make . In case there are conflicting definitions, the first manager in the list above will be picked up. For example, if a dependency is found with :rebar3 and :rebar managers in different part of the trees, :rebar3 will be automatically picked. You can find the manager by running mix deps and override it by setting the :override option in a top-level project. :runtime - whether the dependency is part of runtime applications. If the :applications key is not provided in def application in your mix.exs file, Mix will automatically include all dependencies as a runtime application, except if runtime: false is given. Defaults to true. :system_env - an enumerable of key-value tuples of binaries to be set as environment variables when loading or compiling the dependency Git options ( :git ) :git - the Git repository URI :github - a shortcut for specifying Git repos from GitHub, uses :git :ref - the reference to checkout (may be a branch, a commit SHA or a tag) :branch - the Git branch to checkout :tag - the Git tag to checkout :submodules - when true , initialize submodules for the repo :sparse - checkout a single directory inside the Git repository and use it as your Mix dependency. Search &quot;sparse Git checkouts&quot; for more information. If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control. git config -- global url . &quot;https://YOUR_USER:YOUR_PASS@example.com/&quot; . insteadOf &quot;https://example.com/&quot; For more information, see the git config documentation: https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf Path options ( :path ) :path - the path for the dependency :in_umbrella - when true , sets a path dependency pointing to &quot;../\#{app}&quot;, sharing the same environment as the current application Hex options ( :hex ) See the Hex usage documentation for Hex options. Deps task mix deps task lists all dependencies in the following format: APP VERSION ( SCM ) ( MANAGER ) [ locked at REF ] STATUS For dependencies satisfied by Hex, REF is the package checksum. For dependencies satisfied by git, REF is the commit object name, and may include branch or tag information. It supports the following options: --all - lists all dependencies, regardless of specified environment","ref":"Mix.Tasks.Deps.html","title":"Mix.Tasks.Deps","type":"task"},{"doc":"Deletes the given dependencies' files, including build artifacts and fetched sources. Since this is a destructive action, cleaning of dependencies only occurs when passing arguments/options: dep1 dep2 - the names of dependencies to be deleted separated by a space --unlock - also unlocks the deleted dependencies --build - deletes only compiled files (keeps source files) --all - deletes all dependencies --unused - deletes only unused dependencies (i.e. dependencies no longer mentioned in mix.exs ) By default this task works across all environments, unless --only is given which will clean all dependencies for the chosen environment.","ref":"Mix.Tasks.Deps.Clean.html","title":"Mix.Tasks.Deps.Clean","type":"task"},{"doc":"Compiles dependencies. By default, compile all dependencies. A list of dependencies can be given to compile multiple dependencies in order. This task attempts to detect if the project contains one of the following files and act accordingly: mix.exs - invokes mix compile rebar.config - invokes rebar compile Makefile.win - invokes nmake /F Makefile.win (only on Windows) Makefile - invokes gmake on DragonFlyBSD, FreeBSD, NetBSD, and OpenBSD, invokes make on any other operating system (except on Windows) The compilation can be customized by passing a compile option in the dependency: { :some_dependency , &quot;0.1.0&quot; , compile : &quot;command to compile&quot; } If a list of dependencies is given, Mix will attempt to compile them as is. For example, if project a depends on b , calling mix deps.compile a will compile a even if b is out of date. This is to allow parts of the dependency tree to be recompiled without propagating those changes upstream. To ensure b is included in the compilation step, pass --include-children . Command line options --force - force compilation of deps --skip-umbrella-children - skips umbrella applications from compiling --skip-local-deps - skips non-remote dependencies, such as path deps, from compiling","ref":"Mix.Tasks.Deps.Compile.html","title":"Mix.Tasks.Deps.Compile","type":"task"},{"doc":"Gets all out of date dependencies, i.e. dependencies that are not available or have an invalid lock. Command line options --only - only fetches dependencies for given environment --no-archives-check - does not check archives before fetching deps","ref":"Mix.Tasks.Deps.Get.html","title":"Mix.Tasks.Deps.Get","type":"task"},{"doc":"Checks and loads all dependencies along the way. If there is an invalid dependency, its status is printed before aborting. Although this task does not show up in mix help , it is part of Mix public API and can be depended on. Command line options --no-deps-check - does not check or compile deps, only load available ones --no-compile - does not compile dependencies --no-load-deps - does not load deps from the code path","ref":"Mix.Tasks.Deps.Loadpaths.html","title":"Mix.Tasks.Deps.Loadpaths","type":"task"},{"doc":"Extension point for precompiling dependencies. This is a task that can be aliased by projects that need to execute certain tasks before compiling dependencies: aliases : [ &quot;deps.precompile&quot; : [ &quot;nerves.precompile&quot; , &quot;deps.precompile&quot; ] ] By default, this task's single responsibility is to load all dependency paths. Dependency loading is deliberately ad-hoc, loading as much as possible without validating the files.","ref":"Mix.Tasks.Deps.Precompile.html","title":"Mix.Tasks.Deps.Precompile","type":"task"},{"doc":"Prints the dependency tree. mix deps . tree If no dependency is given, it uses the tree defined in the mix.exs file. Command line options --only - the environment to show dependencies for --target - the target to show dependencies for --exclude - exclude dependencies which you do not want to see printed. --format - Can be set to one of either: pretty - uses Unicode code points for formatting the tree. This is the default except on Windows. plain - does not use Unicode code points for formatting the tree. This is the default on Windows. dot - produces a DOT graph description of the dependency tree in deps_tree.dot in the current directory. Warning: this will override any previously generated file.","ref":"Mix.Tasks.Deps.Tree.html","title":"Mix.Tasks.Deps.Tree","type":"task"},{"doc":"Unlocks the given dependencies. Since this is a destructive action, unlocking dependencies only occurs when passing arguments/options: dep1 dep2 - the name of dependencies to be unlocked --all - unlocks all dependencies --filter - unlocks only deps matching the given name --unused - unlocks only unused dependencies (no longer mentioned in the mix.exs file) --check-unused - checks that the mix.lock file has no unused dependencies. This is useful in pre-commit hooks and CI scripts if you want to reject contributions with extra dependencies","ref":"Mix.Tasks.Deps.Unlock.html","title":"Mix.Tasks.Deps.Unlock","type":"task"},{"doc":"Updates the given dependencies. The given dependencies and the projects they depend on will be unlocked and updated to the latest version according to their version requirements. Since this is a destructive action, updating all dependencies only occurs when the --all command line option is passed. All dependencies are automatically recompiled after update. mix deps.unlock + mix deps.get Upgrading a dependency often requires the projects it depends on to upgrade too. If you would rather update a single dependency and not touch its children, you can explicitly unlock the single dependency and run mix deps.get : $ mix deps . unlock some_dep $ mix deps . get Command line options --all - updates all dependencies --only - only fetches dependencies for given environment --target - only fetches dependencies for given target --no-archives-check - does not check archives before fetching deps","ref":"Mix.Tasks.Deps.Update.html","title":"Mix.Tasks.Deps.Update","type":"task"},{"doc":"Executes the tasks separated by comma. The comma should be followed by a space. Examples The example below prints the available compilers and then the list of dependencies. mix do compile -- list , deps Note however that the majority of Mix tasks are only executed once per invocation. So for example, the following command will only compile once: mix do compile , some_other_command , compile When compile is executed again, Mix will notice the task has already ran, and skip it.","ref":"Mix.Tasks.Do.html","title":"Mix.Tasks.Do","type":"task"},{"doc":"Lists all installed escripts. Escripts are installed at ~/.mix/escripts . Add that path to your PATH environment variable to be able to run installed escripts from any directory.","ref":"Mix.Tasks.Escript.html","title":"Mix.Tasks.Escript","type":"task"},{"doc":"Builds an escript for the project. An escript is an executable that can be invoked from the command line. An escript can run on any machine that has Erlang/OTP installed and by default does not require Elixir to be installed, as Elixir is embedded as part of the escript. This task guarantees the project and its dependencies are compiled and packages them inside an escript. Before invoking mix escript.build , it is only necessary to define a :escript key with a :main_module option in your mix.exs file: escript : [ main_module : MyApp.CLI ] Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using mix run or building releases. See the Application module for more information on systems life-cycles. All of the configuration defined in config/config.exs will be included as part of the escript. config/runtime.exs is also included for Elixir escripts. Once the configuration is loaded, this task starts the current application. If this is not desired, set the :app configuration to nil. This task also removes documentation and debugging chunks from the compiled .beam files to reduce the size of the escript. If this is not desired, check the :strip_beams option. Note: escripts do not support projects and dependencies that need to store or read artifacts from the priv directory. Command line options Expects the same command line options as mix compile . Configuration The following option must be specified in your mix.exs under the :escript key: :main_module - the module to be invoked once the escript starts. The module must contain a function named main/1 that will receive the command line arguments. By default the arguments are given as a list of binaries, but if project is configured with language: :erlang it will be a list of charlists. The remaining options can be specified to further customize the escript: :name - the name of the generated escript. Defaults to app name. :path - the path to write the escript to. Defaults to app name. :app - the app that starts with the escript. Defaults to app name. Set it to nil if no application should be started. :strip_beams - if true strips BEAM code in the escript to remove chunks unnecessary at runtime, such as debug information and documentation. Can be set to [keep: [&quot;Docs&quot;, &quot;Dbgi&quot;]] to strip while keeping some chunks that would otherwise be stripped, like docs, and debug info, for instance. Defaults to true . :embed_elixir - if true embeds Elixir and its children apps ( ex_unit , mix , and the like) mentioned in the :applications list inside the application/0 function in mix.exs . Defaults to true for Elixir projects, false for Erlang projects. Note: if you set this to false for an Elixir project, you will have to add paths to Elixir's ebin directories to ERL_LIBS environment variable when running the resulting escript, in order for the code loader to be able to find :elixir application and its children applications (if they are used). :shebang - shebang interpreter directive used to execute the escript. Defaults to &quot;#! /usr/bin/env escript\\n&quot; . :comment - comment line to follow shebang directive in the escript. Defaults to &quot;&quot; . :emu_args - emulator arguments to embed in the escript file. Defaults to &quot;&quot; . There is one project-level option that affects how the escript is generated: language: :elixir | :erlang - set it to :erlang for Erlang projects managed by Mix. Doing so will ensure Elixir is not embedded by default. Your app will still be started as part of escript loading, with the config used during build. Example defmodule MyApp.MixProject do use Mix.Project def project do [ app : :my_app , version : &quot;0.0.1&quot; , escript : escript ( ) ] end def escript do [ main_module : MyApp.CLI ] end end defmodule MyApp.CLI do def main ( _args ) do IO . puts ( &quot;Hello from MyApp!&quot; ) end end","ref":"Mix.Tasks.Escript.Build.html","title":"Mix.Tasks.Escript.Build","type":"task"},{"doc":"Installs an escript locally. If no argument is supplied but there is an escript in the project's root directory (created with mix escript.build ), then the escript will be installed locally. For example: mix do escript . build , escript . install If an argument is provided, it should be a local path to a prebuilt escript, a Git repository, a GitHub repository, or a Hex package. mix escript . install escript mix escript . install path / to / escript mix escript . install git https :/ / path / to / git / repo mix escript . install git https :/ / path / to / git / repo branch git_branch mix escript . install git https :/ / path / to / git / repo tag git_tag mix escript . install git https :/ / path / to / git / repo ref git_ref mix escript . install github user / project mix escript . install github user / project branch git_branch mix escript . install github user / project tag git_tag mix escript . install github user / project ref git_ref mix escript . install hex hex_package mix escript . install hex hex_package 1.2 . 3 After installation, the escript can be invoked as ~ / . mix / escripts / foo For convenience, consider adding ~/.mix/escripts directory to your PATH environment variable. For more information, check the wikipedia article on PATH: https://en.wikipedia.org/wiki/PATH_(variable) Command line options --sha512 - checks the escript matches the given SHA-512 checksum. Only applies to installations via a local path --force - forces installation without a shell prompt; primarily intended for automation in build systems like Make --submodules - fetches repository submodules before building escript from Git or GitHub --app - specifies a custom app name to be used for building the escript from Git, GitHub, or Hex --organization - set this for Hex private packages belonging to an organization --repo - set this for self-hosted Hex instances, defaults to hexpm","ref":"Mix.Tasks.Escript.Install.html","title":"Mix.Tasks.Escript.Install","type":"task"},{"doc":"Uninstalls local escripts: mix escript . uninstall escript_name Command line options --force - forces uninstallation without a shell prompt; primarily intended for automation","ref":"Mix.Tasks.Escript.Uninstall.html","title":"Mix.Tasks.Escript.Uninstall","type":"task"},{"doc":"Formats the given files and patterns. mix format mix . exs &quot;lib/**/*.{ex,exs}&quot; &quot;test/**/*.{ex,exs}&quot; If any of the files is - , then the output is read from stdin and written to stdout. Formatting options The formatter will read a .formatter.exs file in the current directory for formatter configuration. Evaluating this file should return a keyword list. Here is an example of a .formatter.exs file that works as a starting point: [ inputs : [ &quot;{mix,.formatter}.exs&quot; , &quot;{config,lib,test}/**/*.{ex,exs}&quot; ] ] Besides the options listed in Code.format_string!/2 , the .formatter.exs file supports the following options: :inputs (a list of paths and patterns) - specifies the default inputs to be used by this task. For example, [&quot;mix.exs&quot;, &quot;{config,lib,test}/**/*.{ex,exs}&quot;] . Patterns are expanded with Path.wildcard/2 . :subdirectories (a list of paths and patterns) - specifies subdirectories that have their own formatting rules. Each subdirectory should have a .formatter.exs that configures how entries in that subdirectory should be formatted as. Configuration between .formatter.exs are not shared nor inherited. If a .formatter.exs lists &quot;lib/app&quot; as a subdirectory, the rules in .formatter.exs won't be available in lib/app/.formatter.exs . Note that the parent .formatter.exs must not specify files inside the &quot;lib/app&quot; subdirectory in its :inputs configuration. If this happens, the behaviour of which formatter configuration will be picked is unspecified. :import_deps (a list of dependencies as atoms) - specifies a list of dependencies whose formatter configuration will be imported. When specified, the formatter should run in the same directory as the mix.exs file that defines those dependencies. See the &quot;Importing dependencies configuration&quot; section below for more information. :export (a keyword list) - specifies formatter configuration to be exported. See the &quot;Importing dependencies configuration&quot; section below. Task-specific options --check-formatted - checks that the file is already formatted. This is useful in pre-commit hooks and CI scripts if you want to reject contributions with unformatted code. However keep in mind that the formatted output may differ between Elixir versions as improvements and fixes are applied to the formatter. --check-equivalent - checks if the files after formatting have the same AST as before formatting. If the ASTs are not equivalent, it is a bug in the code formatter. This option is useful if you suspect you have ran into a formatter bug and you would like confirmation. --dry-run - does not save files after formatting. --dot-formatter - path to the file with formatter configuration. Defaults to .formatter.exs if one is available. See the &quot;Formatting options&quot; section above for more information. If any of the --check-* options are given and a check fails, the formatted contents won't be written to disk nor printed to standard output. When to format code We recommend developers to format code directly in their editors, either automatically when saving a file or via an explicit command or key binding. If such option is not yet available in your editor of choice, adding the required integration is usually a matter of invoking: cd $ project &amp;&amp; mix format $ file where $file refers to the current file and $project is the root of your project. It is also possible to format code across the whole project by passing a list of patterns and files to mix format , as shown at the top of this task documentation. This list can also be set in the .formatter.exs file under the :inputs key. Importing dependencies configuration This task supports importing formatter configuration from dependencies. A dependency that wants to export formatter configuration needs to have a .formatter.exs file at the root of the project. In this file, the dependency can export a :export option with configuration to export. For now, only one option is supported under :export : :locals_without_parens (whose value has the same shape as the value of the :locals_without_parens in Code.format_string!/2 ). The functions listed under :locals_without_parens in the :export option of a dependency can be imported in a project by listing that dependency in the :import_deps option of the formatter configuration file of the project. For example, consider you have a project called my_app that depends on another one called my_dep . my_dep wants to export some configuration, so my_dep/.formatter.exs would look like this: # my_dep/.formatter.exs [ # Regular formatter configuration for my_dep # ... export : [ locals_without_parens : [ some_dsl_call : 2 , some_dsl_call : 3 ] ] ] In order to import configuration, my_app 's .formatter.exs would look like this: # my_app/.formatter.exs [ import_deps : [ :my_dep ] ]","ref":"Mix.Tasks.Format.html","title":"Mix.Tasks.Format","type":"task"},{"doc":"Returns formatter options to be used for the given file.","ref":"Mix.Tasks.Format.html#formatter_opts_for_file/2","title":"Mix.Tasks.Format.formatter_opts_for_file/2","type":"function"},{"doc":"Lists all tasks and aliases or prints the documentation for a given task or alias. Arguments mix help - prints all aliases , tasks and their short descriptions mix help ALIAS - prints the definition for the given alias mix help TASK - prints full docs for the given task mix help -- search PATTERN - prints all tasks and aliases that contain PATTERN in the name mix help -- names - prints all task names and aliases ( useful for autocompleting ) Colors When possible, mix help is going to use coloring for formatting guides. The formatting can be customized by configuring the Mix application either inside your project (in config/config.exs ) or by using the local config (in ~/.mix/config.exs ). For example, to disable color, one may use the configuration: [ mix : [ colors : [ enabled : false ] ] ] The available color options are: :enabled - shows ANSI formatting (defaults to IO.ANSI.enabled?/0 ) :doc_code - the attributes for code blocks (cyan, bright) :doc_inline_code - inline code (cyan) :doc_headings - h1 and h2 (yellow, bright) :doc_title - the overall heading for the output (reverse, yellow, bright) :doc_bold - (bright) :doc_underline - (underline)","ref":"Mix.Tasks.Help.html","title":"Mix.Tasks.Help","type":"task"},{"doc":"A task that simply instructs users to run iex -S mix .","ref":"Mix.Tasks.Iex.html","title":"Mix.Tasks.Iex","type":"task"},{"doc":"Loads and persists the given configuration. mix loadconfig path / to / config . exs Any configuration file loaded with loadconfig is treated as a compile-time configuration. Note that &quot;config/config.exs&quot; is always loaded automatically by the Mix CLI when it boots. &quot;config/runtime.exs&quot; is loaded automatically by mix app.config before starting the current application. Therefore there is no need to load those config files directly. This task is automatically reenabled, so it can be called multiple times to load different configs.","ref":"Mix.Tasks.Loadconfig.html","title":"Mix.Tasks.Loadconfig","type":"task"},{"doc":"Loads the application and its dependencies paths. This task is never directly invoked from the command line, but it is rather used as building block by other tasks. Configuration :elixir - matches the current Elixir version against the given requirement Command line options --no-archives-check - does not check archive --no-deps-check - does not check dependencies --no-elixir-version-check - does not check Elixir version","ref":"Mix.Tasks.Loadpaths.html","title":"Mix.Tasks.Loadpaths","type":"task"},{"doc":"Lists local tasks.","ref":"Mix.Tasks.Local.html","title":"Mix.Tasks.Local","type":"task"},{"doc":"Installs Hex locally. mix local . hex If installing a precompiled Hex does not work, you can compile and install Hex directly with this command: mix archive . install github hexpm / hex branch latest Command line options --force - forces installation without a shell prompt; primarily intended for automation in build systems like make --if-missing - performs installation only if Hex is not installed yet; intended to avoid repeatedly reinstalling Hex in automation when a script may be run multiple times If both options are set, --force takes precedence. Mirrors If you want to change the default mirror used for fetching Hex, set the HEX_MIRROR environment variable.","ref":"Mix.Tasks.Local.Hex.html","title":"Mix.Tasks.Local.Hex","type":"task"},{"doc":"Public keys are used by Mix to install packages like Rebar and Hex. Mix by default ships with a public key but new ones can be added on demand. To list all available keys: $ mix local . public_keys To list all available keys showing the keys themselves: $ mix local . public_keys -- detailed To add a new key: $ mix local . public_keys local / path / to / key Be careful when adding new keys. Only add keys from sources you trust. Public keys are by default stored in your MIX_HOME under the public_keys directory. Command line options --force - forces installation without a shell prompt; primarily intended for automation in build systems like make","ref":"Mix.Tasks.Local.PublicKeys.html","title":"Mix.Tasks.Local.PublicKeys","type":"task"},{"doc":"Fetches a copy of rebar or rebar3 from the given path or URL. It defaults to safely download a Rebar copy from Hex's CDN. However, a URL can be given as argument, usually for an existing local copy of Rebar: mix local . rebar rebar path / to / rebar mix local . rebar rebar3 path / to / rebar If neither rebar or rebar3 are specified, both versions will be fetched. The local copy is stored in your MIX_HOME (defaults to ~/.mix ). This version of Rebar will be used as required by mix deps.compile . Command line options rebar PATH - specifies a path for rebar rebar3 PATH - specifies a path for rebar3 --sha512 - checks the Rebar script matches the given SHA-512 checksum --force - forces installation without a shell prompt; primarily intended for automation in build systems like make Mirrors If you want to change the default mirror to use for fetching rebar please set the HEX_MIRROR environment variable.","ref":"Mix.Tasks.Local.Rebar.html","title":"Mix.Tasks.Local.Rebar","type":"task"},{"doc":"Creates a new Elixir project. It expects the path of the project as argument. mix new PATH [ -- app APP ] [ -- module MODULE ] [ -- sup ] [ -- umbrella ] A project at the given PATH will be created. The application name and module name will be retrieved from the path, unless --module or --app is given. An --app option can be given in order to name the OTP application for the project. A --module option can be given in order to name the modules in the generated code skeleton. A --sup option can be given to generate an OTP application skeleton including a supervision tree. Normally an app is generated without a supervisor and without the app callback. An --umbrella option can be given to generate an umbrella project. Examples mix new hello_world Is equivalent to: mix new hello_world -- module HelloWorld To generate an app with a supervision tree and an application callback: mix new hello_world -- sup To generate an umbrella application with sub applications: mix new hello_world -- umbrella cd hello_world / apps mix new child_app","ref":"Mix.Tasks.New.html","title":"Mix.Tasks.New","type":"task"},{"doc":"Profiles the given file or expression using Erlang's cprof tool. cprof can be useful when you want to discover the bottlenecks related to function calls. Before running the code, it invokes the app.start task which compiles and loads your project. After that, the target expression is profiled together with all matching function calls, by setting breakpoints containing counters. These can only be set on BEAM code so BIFs cannot be call count traced. To profile the code, you can use syntax similar to the mix run task: mix profile . cprof - e Hello . world mix profile . cprof - e &quot;[1, 2, 3] |&gt; Enum.reverse |&gt; Enum.map(&amp;Integer.to_string/1)&quot; mix profile . cprof my_script . exs arg1 arg2 arg3 This task is automatically reenabled, so you can profile multiple times in the same Mix invocation. Command line options --matching - only profile calls matching the given Module.function/arity pattern --limit - filters out any results with a call count less than the limit --module - filters out any results not pertaining to the given module --eval , -e - evaluate the given code --require , -r - requires pattern before running the command --parallel , -p - makes all requires parallel --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-archives-check - does not check archives --no-halt - does not halt the system after running the command --no-start - does not start applications after compilation --no-elixir-version-check - does not check the Elixir version from mix.exs Profile output Example output: CNT Total 15 Enum 6 &lt;- - Enum . &quot;-map/2-lists^map/1-0-&quot; / 2 4 Enum . reverse / 1 1 Enum . map / 2 1 :elixir_compiler 4 &lt;- - anonymous fn / 1 in :elixir_compiler . __FILE__ / 1 3 anonymous fn / 0 in :elixir_compiler . __FILE__ / 1 1 String.Chars.Integer 3 &lt;- - String.Chars.Integer . to_string / 1 3 :erlang 2 &lt;- - :erlang . trace_pattern / 3 2 Profile done over 20229 matching functions The default output contains data gathered from all matching functions. The left column structures each module and its total call count trace is presented on the right. Each module has its count discriminated by function below. The &lt;-- symbol is meant to help visualize where a new module call count begins. The first row (Total) is the sum of all function calls. In the last row the number of matching functions that were considered for profiling is presented. When --matching option is specified, call count tracing will be started only for the functions matching the given pattern: String.Chars.Integer 3 &lt;- - String.Chars.Integer . to_string / 1 3 Profile done over 1 matching functions The pattern can be a module name, such as String to count all calls to that module, a call without arity, such as String.split , to count all calls to that function regardless of arity, or a call with arity, such as String.split/2 , to count all calls to that exact module, function and arity. Caveats You should be aware the profiler is stopped as soon as the code has finished running. This may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend. Other caveats are the impossibility to call count trace BIFs, since breakpoints can only be set on BEAM code; functions calls performed by :cprof are not traced; the maximum size of a call counter is equal to the host machine's word size (for example, 2147483647 in a 32-bit host).","ref":"Mix.Tasks.Profile.Cprof.html","title":"Mix.Tasks.Profile.Cprof","type":"task"},{"doc":"Allows to programmatically run the cprof profiler on expression in fun . Options :matching - only profile calls matching the given pattern in form of {module, function, arity} , where each element may be replaced by :_ to allow any value :limit - filters out any results with a call count less than the limit :module - filters out any results not pertaining to the given module","ref":"Mix.Tasks.Profile.Cprof.html#profile/2","title":"Mix.Tasks.Profile.Cprof.profile/2","type":"function"},{"doc":"Profiles the given file or expression using Erlang's eprof tool. :eprof provides time information of each function call and can be useful when you want to discover the bottlenecks related to this. Before running the code, it invokes the app.start task which compiles and loads your project. After that, the target expression is profiled together with all matching function calls using the Erlang trace BIFs. The tracing of the function calls for that is enabled when the profiling is begun, and disabled when profiling is stopped. To profile the code, you can use syntax similar to the mix run task: mix profile . eprof - e Hello . world mix profile . eprof - e &quot;[1, 2, 3] |&gt; Enum.reverse |&gt; Enum.map(&amp;Integer.to_string/1)&quot; mix profile . eprof my_script . exs arg1 arg2 arg3 This task is automatically reenabled, so you can profile multiple times in the same Mix invocation. Command line options --matching - only profile calls matching the given Module.function/arity pattern --calls - filters out any results with a call count lower than this --time - filters out any results that took lower than specified (in µs) --sort - sorts the results by time or calls (default: time ) --eval , -e - evaluates the given code --require , -r - requires pattern before running the command --parallel , -p - makes all requires parallel --no-warmup - skips the warmup step before profiling --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-archives-check - does not check archives --no-halt - does not halt the system after running the command --no-start - does not start applications after compilation --no-elixir-version-check - does not check the Elixir version from mix.exs Profile output Example output: # CALLS % TIME µS/CALL Total 24 100.0 26 1.08 Enum . reduce_range_inc / 4 5 3.85 1 0.20 :erlang . make_fun / 3 1 7.69 2 2.00 Enum . each / 2 1 7.69 2 2.00 anonymous fn / 0 in :elixir_compiler_0 . __FILE__ / 1 1 7.69 2 2.00 :erlang . integer_to_binary / 1 5 15.39 4 0.80 :erlang . apply / 2 1 15.39 4 4.00 anonymous fn / 3 in Enum . each / 2 5 19.23 5 1.00 String.Chars.Integer . to_string / 1 5 23.08 6 1.20 Profile done over 8 matching functions The default output contains data gathered from all matching functions. The first row after the header contains the sums of the partial results and the average time for all the function calls listed. The following rows contain the function call, followed by the number of times that the function was called, then by the percentage of time that the call uses, then the total time for that function in microseconds, and, finally, the average time per call in microseconds. When --matching option is specified, call count tracing will be started only for the functions matching the given pattern: # CALLS % TIME µS/CALL Total 5 100.0 6 1.20 String.Chars.Integer . to_string / 1 5 100.0 6 1.20 Profile done over 1 matching functions The pattern can be a module name, such as String to count all calls to that module, a call without arity, such as String.split , to count all calls to that function regardless of arity, or a call with arity, such as String.split/2 , to count all calls to that exact module, function and arity. Caveats You should be aware that the code being profiled is running in an anonymous function which is invoked by :eprof module . Thus, you'll see some additional entries in your profile output. It is also important to note that the profiler is stopped as soon as the code has finished running, and this may need special attention, when: running asynchronous code as function calls which were called before the profiler stopped will not be counted; running synchronous code as long running computations and a profiler without a proper MFA trace pattern or filter may lead to a result set which is difficult to comprehend. You should expect a slowdown in your code execution using this tool since :eprof has some performance impact on the execution, but the impact is considerably lower than Mix.Tasks.Profile.Fprof . If you have a large system try to profile a limited scenario or focus on the main modules or processes. Another alternative is to use Mix.Tasks.Profile.Cprof that uses :cprof and has a low performance degradation effect.","ref":"Mix.Tasks.Profile.Eprof.html","title":"Mix.Tasks.Profile.Eprof","type":"task"},{"doc":"Allows to programmatically run the eprof profiler on expression in fun . Options :matching - only profile calls matching the given pattern in form of {module, function, arity} , where each element may be replaced by :_ to allow any value :calls - filters out any results with a call count lower than this :time - filters out any results that took lower than specified (in µs) :sort - sort the results by :time or :calls (default: :time )","ref":"Mix.Tasks.Profile.Eprof.html#profile/2","title":"Mix.Tasks.Profile.Eprof.profile/2","type":"function"},{"doc":"Profiles the given file or expression using Erlang's fprof tool. fprof can be useful when you want to discover the bottlenecks of a sequential code. Before running the code, it invokes the app.start task which compiles and loads your project. After that, the target expression is profiled, together with all processes which are spawned by it. Other processes (for example, those residing in the OTP application supervision tree) are not profiled. To profile the code, you can use syntax similar to the mix run task: mix profile . fprof - e Hello . world mix profile . fprof my_script . exs arg1 arg2 arg3 This task is automatically reenabled, so you can profile multiple times in the same Mix invocation. Command line options --callers - prints detailed information about immediate callers and called functions --details - includes profile data for each profiled process --sort key - sorts the output by given key: acc (default) or own --eval , -e - evaluates the given code --require , -r - requires pattern before running the command --parallel , -p - makes all requires parallel --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-archives-check - does not check archives --no-start - does not start applications after compilation --no-elixir-version-check - does not check the Elixir version from mix.exs --no-warmup - does not execute code once before profiling Profile output Example output: # CNT ACC (ms) OWN (ms) Total 200279 1972.188 1964.579 :fprof . apply_start_stop / 4 0 1972.188 0.012 anonymous fn / 0 in :elixir_compiler_2 1 1972.167 0.001 Test . run / 0 1 1972.166 0.007 Test . do_something / 1 3 1972.131 0.040 Test . bottleneck / 0 1 1599.490 0.007 ... The default output contains data gathered from all profiled processes. All times are wall clock milliseconds. The columns have the following meaning: CNT - total number of invocations of the given function ACC - total time spent in the function OWN - time spent in the function, excluding the time of called functions The first row (Total) is the sum of all functions executed in all profiled processes. For the given output, we had a total of 200279 function calls and spent about 2 seconds running the code. More detailed information is returned if you provide the --callers and --details options. When --callers option is specified, you'll see expanded function entries: Mod . caller1 / 0 3 200.000 0.017 Mod . caller2 / 0 2 100.000 0.017 Mod . some_function / 0 5 300.000 0.017 &lt;- - Mod . called1 / 0 4 250.000 0.010 Mod . called2 / 0 1 50.000 0.030 Here, the arrow ( &lt;-- ) indicates the marked function - the function described by this paragraph. You also see its immediate callers (above) and called functions (below). All the values of caller functions describe the marked function. For example, the first row means that Mod.caller1/0 invoked Mod.some_function/0 3 times. 200ms of the total time spent in Mod.some_function/0 was spent processing calls from this particular caller. In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that Mod.called2/0 was called once by Mod.some_function/0 , and in that case the total time spent in the function was 50ms. For a detailed explanation it's worth reading the analysis in Erlang/OTP documentation for fprof . Caveats You should be aware that the code being profiled is running in an anonymous function which is invoked by :fprof module . Thus, you'll see some additional entries in your profile output, such as :fprof calls, an anonymous function with high ACC time, or an :undefined function which represents the outer caller (non-profiled code which started the profiler). Also, keep in mind that profiling might significantly increase the running time of the profiled processes. This might skew your results if, for example, those processes perform some I/O operations, since running time of those operations will remain unchanged, while CPU bound operations of the profiled processes might take significantly longer. Thus, when profiling some intensive program, try to reduce such dependencies, or be aware of the resulting bias. Finally, it's advised to profile your program with the prod environment, since this should provide more realistic insights into bottlenecks.","ref":"Mix.Tasks.Profile.Fprof.html","title":"Mix.Tasks.Profile.Fprof","type":"task"},{"doc":"Allows to programmatically run the fprof profiler on expression in fun . Options :callers - prints detailed information about immediate callers and called functions :details - includes profile data for each profiled process :sort - sorts the output by given key: :acc (default) or :own","ref":"Mix.Tasks.Profile.Fprof.html#profile/2","title":"Mix.Tasks.Profile.Fprof.profile/2","type":"function"},{"doc":"Assembles a self-contained release for the current project: MIX_ENV = prod mix release MIX_ENV = prod mix release NAME Once a release is assembled, it can be packaged and deployed to a target, as long as the target runs on the same operating system (OS) distribution and version as the machine running the mix release command. A release can be configured in your mix.exs file under the :releases key inside def project : def project do [ releases : [ demo : [ include_executables_for : [ :unix ] , applications : [ runtime_tools : :permanent ] ] , ... ] ] end You can specify multiple releases where the key is the release name and the value is a keyword list with the release configuration. Releasing a certain name is done with: MIX_ENV = prod mix release demo If the given name does not exist, an error is raised. If mix release , without a name, is invoked and there are multiple names, an error will be raised unless you set default_release: NAME at the root of your project configuration. If mix release is invoked and there are no names, a release using the application name and default values is assembled. Why releases? Releases allow developers to precompile and package all of their code and the runtime into a single unit. The benefits of releases are: Code preloading. The VM has two mechanisms for loading code: interactive and embedded. By default, it runs in the interactive mode which dynamically loads modules when they are used for the first time. The first time your application calls Enum.map/2 , the VM will find the Enum module and load it. There’s a downside. When you start a new server in production, it may need to load many other modules, causing the first requests to have an unusual spike in response time. When running in Erlang/OTP earlier than 23, the system always runs in embedded mode. When using Erlang/OTP 23+, they run in interactive mode while being configured and then it swaps to embedded mode, guaranteeing your system is ready to handle requests after booting. Configuration and customization. Releases give developers fine grained control over system configuration and the VM flags used to start the system. Self-contained. A release does not require the source code to be included in your production artifacts. All of the code is precompiled and packaged. Releases do not even require Erlang or Elixir in your servers, as it includes the Erlang VM and its runtime by default. Furthermore, both Erlang and Elixir standard libraries are stripped to bring only the parts you are actually using. Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether. Management scripts. Releases come with scripts to start, restart, connect to the running system remotely, execute RPC calls, run as daemon, run as a Windows service, and more. Running the release Once a release is assembled, you can start it by calling bin/RELEASE_NAME start inside the release. In production, you would do: MIX_ENV = prod mix release _build / prod / rel / my_app / bin / my_app start bin/my_app start will start the system connected to the current standard input/output, where logs are also written to by default. This is the preferred way to run the system. Many tools, such as systemd , platforms as a service, such as Heroku, and many containers platforms, such as Docker, are capable of processing the standard input/output and redirecting the log contents elsewhere. Those tools and platforms also take care of restarting the system in case it crashes. You can also execute one-off commands, run the release as a daemon on Unix-like system, or install it as a service on Windows. We will take a look at those next. You can also list all available commands by invoking bin/RELEASE_NAME . One-off commands (eval and rpc) If you want to invoke specific modules and functions in your release, you can do so in two ways: using eval or rpc . bin / RELEASE_NAME eval &quot;IO.puts(:hello)&quot; bin / RELEASE_NAME rpc &quot;IO.puts(:hello)&quot; The eval command starts its own instance of the VM but without starting any of the applications in the release and without starting distribution. For example, if you need to do some prep work before running the actual system, like migrating your database, eval can be a good fit. Just keep in mind any application you may use during eval has to be explicitly loaded and/or started. You can start an application by calling Application.ensure_all_started/1 . However, if for some reason you cannot start an application, maybe because it will run other services you do not want, you must at least load the application by calling Application.load/1 . If you don't load the application, any attempt at reading its environment or configuration may fail. Note that if you start an application, it is automatically loaded before started. Another way to run commands is with rpc , which will connect to the system currently running and instruct it to execute the given expression. This means you need to guarantee the system was already started and be careful with the instructions you are executing. You can also use remote to connect a remote IEx session to the system. Helper module As you operate your system, you may find yourself running some piece of code as a one-off command quite often. You may consider creating a module to group these tasks: # lib/my_app/release_tasks.ex defmodule MyApp.ReleaseTasks do def eval_purge_stale_data ( ) do # Eval commands needs to start the app before # Or Application.load(:my_app) if you can&#39;t start it Application . ensure_all_started ( :my_app ) # Code that purges stale data ... end def rpc_print_connected_users ( ) do # Code that print users connected to the current running system ... end end In the example above, we prefixed the function names with the command name used to execute them, but that is entirely optional. And to run them: bin / RELEASE_NAME eval &quot;MyApp.ReleaseTasks.eval_purge_stale_data()&quot; bin / RELEASE_NAME rpc &quot;MyApp.ReleaseTasks.rpc_print_connected_users()&quot; Daemon mode (Unix-like) You can run the release in daemon mode with the command: bin / RELEASE_NAME daemon In daemon mode, the system is started on the background via run_erl . You may also want to enable heart in daemon mode so it automatically restarts the system in case of crashes. See the generated releases/RELEASE_VSN/env.sh file. The daemon will write all of its standard output to the &quot;tmp/log/&quot; directory in the release root. You can watch the log file by doing tail -f tmp/log/erlang.log.1 or similar. Once files get too large, the index suffix will be incremented. A developer can also attach to the standard input of the daemon by invoking &quot;to_erl tmp/pipe/&quot; from the release root. However, note that attaching to the system should be done with extreme care, since the usual commands for exiting an Elixir system, such as hitting Ctrl+C twice or Ctrl+\\, will actually shut down the daemon. Therefore, using bin/RELEASE_NAME remote should be preferred, even in daemon mode. You can customize the tmp directory used both for logging and for piping in daemon mode by setting the RELEASE_TMP environment variable. See the &quot;Customization&quot; section. Services mode (Windows) While daemons are not available on Windows, it is possible to install a released system as a service on Windows with the help of erlsrv . This can be done by running: bin / RELEASE_NAME install Once installed, the service must be explicitly managed via the erlsrv executable, which is included in the erts-VSN/bin directory. The service is not started automatically after installing. For example, if you have a release named demo , you can install the service and then start it from the release root as follows: bin / demo install erts - VSN / bin / erlsrv . exe start demo_demo The name of the service is demo_demo because the name is built by concatenating the node name with the release name. Since Elixir automatically uses the same name for both, the service will be referenced as demo_demo . The install command must be executed as an administrator. bin/RELEASE_NAME commands The following commands are supported by bin/RELEASE_NAME : start Starts the system start_iex Starts the system with IEx attached daemon Starts the system as a daemon ( Unix - like only ) daemon_iex Starts the system as a daemon with IEx attached ( Unix - like only ) install Installs this system as a Windows service ( Windows only ) eval &quot;EXPR&quot; Executes the given expression on a new , non - booted system rpc &quot;EXPR&quot; Executes the given expression remotely on the running system remote Connects to the running system via a remote shell restart Restarts the running system via a remote command stop Stops the running system via a remote command pid Prints the operating system PID of the running system via a remote command version Prints the release name and version to be booted Deployments Requirements A release is built on a host , a machine which contains Erlang, Elixir, and any other dependencies needed to compile your application. A release is then deployed to a target , potentially the same machine as the host, but usually separate, and often there are many targets (either multiple instances, or the release is deployed to heterogeneous environments). To deploy straight from a host to a separate target without cross-compilation, the following must be the same between the host and the target: Target architecture (for example, x86_64 or ARM) Target vendor + operating system (for example, Windows, Linux, or Darwin/macOS) Target ABI (for example, musl or gnu) This is often represented in the form of target triples, for example, x86_64-unknown-linux-gnu , x86_64-unknown-linux-musl , x86_64-apple-darwin . So to be more precise, to deploy straight from a host to a separate target, the Erlang Runtime System (ERTS), and any native dependencies (NIFs), must be compiled for the same target triple. If you are building on a MacBook ( x86_64-apple-darwin ) and trying to deploy to a typical Ubuntu machine ( x86_64-unknown-linux-gnu ), the release will not work. Instead you should build the release on a x86_64-unknown-linux-gnu host. As we will see, this can be done in multiple ways, such as releasing on the target itself, or by using virtual machines or containers, usually as part of your release pipeline. In addition to matching the target triple, it is also important that the target has all of the system packages that your application will need at runtime. A common one is the need for OpenSSL when building an application that uses :crypto or :ssl , which is dynamically linked to ERTS. The other common source for native dependencies like this comes from dependencies containing NIFs (natively-implemented functions) which may expect to dynamically link to libraries they use. Of course, some operating systems and package managers can differ between versions, so if your goal is to have full compatibility between host and target, it is best to ensure the operating system and system package manager have the same versions on host and target. This may even be a requirement in some systems, especially so with package managers that try to create fully reproducible environments (Nix, Guix). Similarly, when creating a stand-alone package and release for Windows, note the Erlang Runtime System has a dependency to some Microsoft libraries (Visual C++ Redistributable Packages for Visual Studio 2013). These libraries are installed (if not present before) when Erlang is installed but it is not part of the standard Windows environment. Deploying a stand-alone release on a computer without these libraries will result in a failure when trying to run the release. One way to solve this is to download and install these Microsoft libraries the first time a release is deployed (the Erlang installer version 10.6 ships with “Microsoft Visual C++ 2013 Redistributable - 12.0.30501”). Alternatively, you can also bundle the compiled object files in the release, as long as they were compiled for the same target. If doing so, you need to update LD_LIBRARY_PATH environment variable with the paths containing the bundled objects on Unix-like systems or the PATH environment variable on Windows systems. Currently, there is no official way to cross-compile a release from one target triple to another, due to the complexities involved in the process. Techniques There are a couple of ways to guarantee that a release is built on a host with the same properties as the target. A simple option is to fetch the source, compile the code and assemble the release on the target itself. It would be something like this: git clone remote :/ / path / to / my_app . git my_app_source cd my_app_source mix deps . get -- only prod MIX_ENV = prod mix release _build / prod / rel / my_app / bin / my_app start If you prefer, you can also compile the release to a separate directory, so you can erase all source after the release is assembled: git clone remote :/ / path / to / my_app . git my_app_source cd my_app_source mix deps . get -- only prod MIX_ENV = prod mix release -- path . . / my_app_release cd . . / my_app_release rm - rf . . / my_app_source bin / my_app start However, this option can be expensive if you have multiple production nodes or if the release assembling process is a long one, as each node needs to individually assemble the release. You can automate this process in a couple different ways. One option is to make it part of your Continuous Integration (CI) / Continuous Deployment (CD) pipeline. When you have a CI/CD pipeline, it is common that the machines in your CI/CD pipeline run on the exact same target triple as your production servers (if they don't, they should). In this case, you can assemble the release at the end of your CI/CD pipeline by calling MIX_ENV=prod mix release and push the artifact to S3 or any other network storage. To perform the deployment, your production machines can fetch the deployment from the network storage and run bin/my_app start . Another mechanism to automate deployments is to use images, such as Amazon Machine Images, or container platforms, such as Docker. For instance, you can use Docker to run locally a system with the exact same target triple as your production servers. Inside the container, you can invoke MIX_ENV=prod mix release and build a complete image and/or container with the operating system, all dependencies as well as the releases. In other words, there are multiple ways systems can be deployed and releases can be automated and incorporated into all of them as long as you remember to build the system in the same target triple. Once a system is deployed, shutting down the system can be done by sending SIGINT/SIGTERM to the system, which is what most containers, platforms and tools do, or by explicitly invoking bin/RELEASE_NAME stop . Once the system receives the shutdown request, each application and their respective supervision trees will stop, one by one, in the opposite order that they were started. Customization There are a couple ways in which developers can customize the generated artifacts inside a release. Options The following options can be set inside your mix.exs on each release definition: :applications - a keyword list that configures and adds new applications to the release. The key is the application name and the value is one of: :permanent - the application is started and the node shuts down if the application terminates, regardless of reason :transient - the application is started and the node shuts down if the application terminates abnormally :temporary - the application is started and the node does not shut down if the application terminates :load - the application is only loaded :none - the application is part of the release but it is neither loaded nor started All applications default to :permanent . By default :applications includes the current application and all applications the current application depends on, recursively. You can include new applications or change the mode of existing ones by listing them here. The order of the applications given in :applications will be preserved as much as possible, with only :kernel , :stdlib , :sasl , and :elixir listed before the given application list. Releases assembled from an umbrella project require this configuration to be explicitly given. :strip_beams - controls if BEAM files should have their debug information, documentation chunks, and other non-essential metadata removed. Defaults to true . May be set to false to disable stripping. Also accepts [keep: [&quot;Docs&quot;, &quot;Dbgi&quot;]] to keep certain chunks that are usually stripped. :cookie - a string representing the Erlang Distribution cookie. If this option is not set, a random cookie is written to the releases/COOKIE file when the first release is assembled. At runtime, we will first attempt to fetch the cookie from the RELEASE_COOKIE environment variable and then we'll read the releases/COOKIE file. If you are setting this option manually, we recommend the cookie option to be a long and randomly generated string, such as: Base.url_encode64(:crypto.strong_rand_bytes(40)) . We also recommend to restrict the characters in the cookie to the subset returned by Base.url_encode64/1 . :validate_compile_env - by default a release will match all runtime configuration against any configuration that was marked at compile time in your application of its dependencies via the Application.compile_env/3 function. If there is a mismatch between those, it means your system is misconfigured and unable to boot. You can disable this check by setting this option to false. :path - the path the release should be installed to. Defaults to &quot;_build/MIX_ENV/rel/RELEASE_NAME&quot; . :version - the release version as a string or {:from_app, app_name} . Defaults to the current application version. The {:from_app, app_name} format can be used to easily reference the application version from another application. This is particularly useful in umbrella applications. :quiet - a boolean that controls if releases should write steps to the standard output. Defaults to false . :include_erts - a boolean, string, or anonymous function of arity zero. If a boolean, it indicates whether the Erlang Runtime System (ERTS), which includes the Erlang VM, should be included in the release. The default is true , which is also the recommended value. If a string, it represents the path to an existing ERTS installation. If an anonymous function of arity zero, it's a function that returns any of the above (boolean or string). You may also set this option to false if you desire to use the ERTS version installed on the target. Note, however, that the ERTS version on the target must have the exact version as the ERTS version used when the release is assembled. Setting it to false also disables hot code upgrades. Therefore, :include_erts should be set to false with caution and only if you are assembling the release on the same server that runs it. :include_executables_for - a list of atoms detailing for which Operating Systems executable files should be generated for. By default, it is set to [:unix, :windows] . You can customize those as follows: releases : [ demo : [ include_executables_for : [ :unix ] # Or [:windows] or [] ] ] :rel_templates_path - the path to find template files that are copied to the release, such as &quot;vm.args.eex&quot;, &quot;remote.vm.args.eex&quot;, &quot;env.sh.eex&quot; (or &quot;env.bat.eex&quot;), and &quot;overlays&quot;. Defaults to &quot;rel&quot; in the project root. :overlays - a list of directories with extra files to be copied as is to the release. The &quot;overlays&quot; directory at :rel_templates_path is always included in this list by default (typically at &quot;rel/overlays&quot;). See the &quot;Overlays&quot; section for more information. :steps - a list of steps to execute when assembling the release. See the &quot;Steps&quot; section for more information. Note each release definition can be given as an anonymous function. This is useful if some release attributes are expensive to compute: releases : [ demo : fn -&gt; [ version : @version &lt;&gt; &quot;+&quot; &lt;&gt; git_ref ( ) ] end ] Besides the options above, it is possible to customize the generated release with custom files, by tweaking the release steps or by running custom options and commands on boot. We will detail both approaches next. Overlays Often it is necessary to copy extra files to the release root after the release is assembled. This can be easily done by placing such files in the rel/overlays directory. Any file in there is copied as is to the release root. For example, if you have placed a &quot;rel/overlays/Dockerfile&quot; file, the &quot;Dockerfile&quot; will be copied as is to the release root. If you want to specify extra overlay directories, you can do so with the :overlays option. If you need to copy files dynamically, see the &quot;Steps&quot; section. Steps It is possible to add one or more steps before and after the release is assembled. This can be done with the :steps option: releases : [ demo : [ steps : [ &amp; set_configs / 1 , :assemble , &amp; copy_extra_files / 1 ] ] ] The :steps option must be a list and it must always include the atom :assemble , which does most of the release assembling. You can pass anonymous functions before and after the :assemble to customize your release assembling pipeline. Those anonymous functions will receive a Mix.Release struct and must return the same or an updated Mix.Release struct. It is also possible to build a tarball of the release by passing the :tar step anywhere after :assemble . If the release :path is not configured, the tarball is created in _build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz Otherwise it is created inside the configured :path . See Mix.Release for more documentation on the struct and which fields can be modified. Note that the :steps field itself can be modified and it is updated every time a step is called. Therefore, if you need to execute a command before and after assembling the release, you only need to declare the first steps in your pipeline and then inject the last step into the release struct. The steps field can also be used to verify if the step was set before or after assembling the release. vm.args and env.sh (env.bat) Developers may want to customize the VM flags and environment variables given when the release starts. The simplest way to customize those files is by running mix release.init . The Mix task will copy custom rel/vm.args.eex , rel/remote.vm.args.eex , rel/env.sh.eex , and rel/env.bat.eex files to your project root. You can modify those files and they will be evaluated every time you perform a new release. Those files are regular EEx templates and they have a single assign, called @release , with the Mix.Release struct. The vm.args and remote.vm.args files may contain any of the VM flags accepted by the erl command . The env.sh and env.bat is used to set environment variables. In there, you can set vars such as RELEASE_NODE , RELEASE_COOKIE , and RELEASE_TMP to customize your node name, cookie and tmp directory respectively. Whenever env.sh or env.bat is invoked, the variables RELEASE_ROOT , RELEASE_NAME , RELEASE_VSN , and RELEASE_COMMAND have already been set, so you can rely on them. See the section on environment variables for more information. Furthermore, while the vm.args files are static, you can use env.sh and env.bat to dynamically set VM options. For example, if you want to make sure the Erlang Distribution listens only on a given port known at runtime, you can set the following: case $ RELEASE_COMMAND in start * | daemon * ) ELIXIR_ERL_OPTIONS = &quot;-kernel inet_dist_listen_min $BEAM_PORT inet_dist_listen_max $BEAM_PORT&quot; export ELIXIR_ERL_OPTIONS ; ; * ) ; ; esac Note we only set the port on start/daemon commands. If you also limit the port on other commands, such as rpc , then you will be unable to establish a remote connection as the port will already be in use by the node. On Windows, your env.bat would look like this: IF NOT % RELEASE_COMMAND :start = % == % RELEASE_COMMAND % ( set ELIXIR_ERL_OPTIONS = &quot;-kernel inet_dist_listen_min %BEAM_PORT% inet_dist_listen_max %BEAM_PORT%&quot; ) Application configuration Releases provides two mechanisms for configuring OTP applications: build-time and runtime. Build-time configuration Whenever you invoke a mix command, Mix loads the configuration in config/config.exs , if said file exists. It is common for the config/config.exs file itself to import other configuration based on the current MIX_ENV , such as config/dev.exs , config/test.exs , and config/prod.exs . We say that this configuration is a build-time configuration as it is evaluated whenever you compile your code or whenever you assemble the release. In other words, if your configuration does something like: config :my_app , :secret_key , System . fetch_env! ( &quot;MY_APP_SECRET_KEY&quot; ) The :secret_key key under :my_app will be computed on the host machine, whenever the release is built. Setting the MY_APP_SECRET_KEY right before starting your release will have no effect. Luckily, releases also provide runtime configuration, which we will see next. Runtime configuration To enable runtime configuration in your release, all you need to do is to create a file named config/runtime.exs : import Config config :my_app , :secret_key , System . fetch_env! ( &quot;MY_APP_SECRET_KEY&quot; ) This file will be executed whenever your Mix project or your release starts. Your config/runtime.exs file needs to follow three important rules: It MUST import Config at the top instead of the deprecated use Mix.Config It MUST NOT import any other configuration file via import_config It MUST NOT access Mix in any way, as Mix is a build tool and it is not available inside releases If a config/runtime.exs exists, it will be copied to your release and executed early in the boot process, when only Elixir and Erlang's main applications have been started. Once the configuration is loaded, the Erlang system will be restarted (within the same Operating System process) and the new configuration will take place. You can change the path to the runtime configuration file by setting :runtime_config_path inside each release configuration. This path is resolved at build time as the given configuration file is always copied to inside the release: releases : [ demo : [ runtime_config_path : ... ] ] Finally, in order for runtime configuration to work properly (as well as any other &quot;Config provider&quot; as defined next), it needs to be able to persist the newly computed configuration to disk. The computed config file will be written to &quot;tmp&quot; directory inside the release every time the system boots. You can configure the &quot;tmp&quot; directory by setting the RELEASE_TMP environment variable, either explicitly or inside your releases/RELEASE_VSN/env.sh (or env.bat on Windows). Config providers Releases also supports custom mechanisms, called config providers, to load any sort of runtime configuration to the system while it boots. For instance, if you need to access a vault or load configuration from a JSON file, it can be achieved with config providers. The runtime configuration outlined in the previous section, which is handled by the Config.Reader provider. See the Config.Provider module for more information and more examples. The following options can be set inside your releases key in your mix.exs to control how config providers work: :reboot_system_after_config - every time your release is configured, the system is rebooted to allow the new configuration to take place. You can set this option to false to disable the rebooting for applications that are sensitive to boot time but, in doing so, note you won't be able to configure system applications, such as :kernel and :stdlib . Defaults to true if using the deprecated config/releases.exs , false otherwise. :prune_runtime_sys_config_after_boot - if :reboot_system_after_config is set, every time your system boots, the release will write a config file to your tmp directory. These configuration files are generally small. But if you are concerned with disk space or if you have other restrictions, you can ask the system to remove said config files after boot. The downside is that you will no longer be able to restart the system internally (neither via System.restart/0 nor bin/RELEASE_NAME restart ). If you need a restart, you will have to terminate the Operating System process and start a new one. Defaults to false . :start_distribution_during_config - if :reboot_system_after_config is set, releases only start the Erlang VM distribution features after the config files are evaluated. You can set it to true if you need distribution during configuration. Defaults to false . :config_providers - a list of tuples with custom config providers. See Config.Provider for more information. Defaults to [] . Customization and configuration summary Generally speaking, the following files are available for customizing and configuring the running system: config/config.exs (and config/prod.exs ) - provides build-time application configuration, which are executed when the release is assembled config/runtime.exs - provides runtime application configuration. It is executed every time your Mix project or your release boots and is further extensible via config providers. If you want to detect you are inside a release, you can check for release specific environment variables, such as RELEASE_NODE or RELEASE_MODE rel/vm.args.eex and rel/remote.vm.args.eex - template files that are copied into every release and provides static configuration of the Erlang Virtual Machine and other runtime flags. vm.args runs on start , daemon , and eval commands. remote.vm.args configures the VM for remote and rpc commands rel/env.sh.eex and rel/env.bat.eex - template files that are copied into every release and are executed on every command to set up environment variables, including specific ones to the VM, and the general environment Directory structure A release is organized as follows: bin / RELEASE_NAME erts - ERTS_VSN / lib / APP_NAME - APP_VSN / ebin / include / priv / releases / RELEASE_VSN / consolidated / elixir elixir . bat env . bat env . sh iex iex . bat remote . vm . args runtime . exs start . boot start . script start_clean . boot start_clean . script sys . config vm . args COOKIE start_erl . data tmp / We document this structure for completeness. In practice, developers should not modify any of those files after the release is assembled. Instead use env scripts, custom config provider, overlays, and all other mechanisms described in this guide to configure how your release works. Environment variables The system sets different environment variables. The following variables are set early on and can only be read by env.sh and env.bat : RELEASE_ROOT - points to the root of the release. If the system includes ERTS, then it is the same as :code.root_dir/0 . This variable is always computed and it cannot be set to a custom value RELEASE_COMMAND - the command given to the release, such as &quot;start&quot; , &quot;remote&quot; , &quot;eval&quot; , and so on. This is typically accessed inside env.sh and env.bat to set different environment variables under different conditions. Note, however, that RELEASE_COMMAND has not been validated by the time env.sh and env.bat are called, so it may be empty or contain invalid values. This variable is always computed and it cannot be set to a custom value RELEASE_NAME - the name of the release. It can be set to a custom value when invoking the release RELEASE_VSN - the version of the release, otherwise the latest version is used. It can be set to a custom value when invoking the release. The custom value must be an existing release version in the releases/ directory RELEASE_PROG - the command line executable used to start the release The following variables can be set before you invoke the release or inside env.sh and env.bat : RELEASE_COOKIE - the release cookie. By default uses the value in releases/COOKIE . It can be set to a custom value RELEASE_NODE - the release node name, in the format name or optionally name@host if running in distributed mode. It can be set to a custom value. The name part must be made only of letters, digits, underscores, and hyphens RELEASE_SYS_CONFIG - the location of the sys.config file. It can be set to a custom path and it must not include the .config extension RELEASE_VM_ARGS - the location of the vm.args file. It can be set to a custom path RELEASE_REMOTE_VM_ARGS - the location of the remote.vm.args file. It can be set to a custom path RELEASE_TMP - the directory in the release to write temporary files to. It can be set to a custom directory. It defaults to $RELEASE_ROOT/tmp RELEASE_MODE - if the release should start in embedded or interactive mode. Defaults to &quot;embedded&quot;. It applies only to start/daemon/install commands RELEASE_DISTRIBUTION - how do we want to run the distribution. May be name (long names), sname (short names) or none (distribution is not started automatically). Defaults to sname which allows access only within the current system. name allows external connections RELEASE_BOOT_SCRIPT - the name of the boot script to use when starting the release. This script is used when running commands such as start and daemon . The boot script is expected to be located at the path releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT.boot . Defaults to start RELEASE_BOOT_SCRIPT_CLEAN - the name of the boot script used when starting the release clean, without your application or its dependencies. This script is used by commands such as eval , rpc , and remote . The boot script is expected to be located at the path releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT_CLEAN.boot . Defaults to start_clean Umbrellas Releases are well integrated with umbrella projects, allowing you to release one or more subsets of your umbrella children. The only difference between performing a release in the umbrella project compared to a regular application is that umbrellas require you to explicitly list your release and the starting point for each release. For example, imagine this umbrella applications: my_app_umbrella / apps / my_app_core / my_app_event_processing / my_app_web / where both my_app_event_processing and my_app_web depend on my_app_core but they do not depend on each other. Inside your umbrella, you can define multiple releases: releases : [ web_and_event_processing : [ applications : [ my_app_event_processing : :permanent , my_app_web : :permanent ] ] , web_only : [ applications : [ my_app_web : :permanent ] ] , event_processing_only : [ applications : [ my_app_event_processing : :permanent ] ] ] Note you don't need to define all applications in :applications , only the entry points. Also remember that the recommended mode for all applications in the system is :permanent . Finally, keep in mind it is not required for you to assemble the release from the umbrella root. You can also assemble the release from each child application individually. Doing it from the root, however, allows you to include two applications that do not depend on each other as part of the same release. Hot Code Upgrades Erlang and Elixir are sometimes known for the capability of upgrading a node that is running in production without shutting down that node. However, this feature is not supported out of the box by Elixir releases. The reason we don't provide hot code upgrades is because they are very complicated to perform in practice, as they require careful coding of your processes and applications as well as extensive testing. Given most teams can use other techniques that are language agnostic to upgrade their systems, such as Blue/Green deployments, Canary deployments, Rolling deployments, and others, hot upgrades are rarely a viable option. Let's understand why. In a hot code upgrade, you want to update a node from version A to version B. To do so, the first step is to write recipes for every application that changed between those two releases, telling exactly how the application changed between versions, those recipes are called .appup files. While some of the steps in building .appup files can be automated, not all of them can. Furthermore, each process in the application needs to be explicitly coded with hot code upgrades in mind. Let's see an example. Imagine your application has a counter process as a GenServer: defmodule Counter do use GenServer def start_link ( _ ) do GenServer . start_link ( __MODULE__ , :ok , name : __MODULE__ ) end def bump do GenServer . call ( __MODULE__ , :bump ) end ## Callbacks def init ( :ok ) do { :ok , 0 } end def handle_call ( :bump , counter ) do { :reply , :ok , counter + 1 } end end You add this process as part of your supervision tree and ship version 0.1.0 of your system. Now let's imagine that on version 0.2.0 you added two changes: instead of bump/0 , that always increments the counter by one, you introduce bump/1 that passes the exact value to bump the counter. You also change the state, because you want to store the maximum bump value: defmodule Counter do use GenServer def start_link ( _ ) do GenServer . start_link ( __MODULE__ , :ok , name : __MODULE__ ) end def bump ( by ) do GenServer . call ( __MODULE__ , { :bump , by } ) end ## Callbacks def init ( :ok ) do { :ok , { 0 , 0 } } end def handle_call ( { :bump , by } , { counter , max } ) do { :reply , :ok , { counter + by , max ( max , by ) } } end end If you were to perform a hot code upgrade in such an application, it would crash, because in the initial version the state was just a counter but in the new version the state is a tuple. Furthermore, you changed the format of the call message from :bump to {:bump, by} and the process may have both old and new messages temporarily mixed, so we need to handle both. The final version would be: defmodule Counter do use GenServer def start_link ( _ ) do GenServer . start_link ( __MODULE__ , :ok , name : __MODULE__ ) end def bump ( by ) do GenServer . call ( __MODULE__ , { :bump , by } ) end ## Callbacks def init ( :ok ) do { :ok , { 0 , 0 } } end def handle_call ( :bump , { counter , max } ) do { :reply , :ok , { counter + 1 , max ( max , 1 ) } } end def handle_call ( { :bump , by } , { counter , max } ) do { :reply , :ok , { counter + by , max ( max , by ) } } end def code_change ( _ , counter , _ ) do { :ok , { counter , 0 } } end end Now you can proceed to list this process in the .appup file and hot code upgrade it. This is one of the many steps necessary to perform hot code upgrades and it must be taken into account by every process and application being upgraded in the system. The .appup cookbook provides a good reference and more examples. Once .appup s are created, the next step is to create a .relup file with all instructions necessary to update the release itself. Erlang documentation does provide a chapter on Creating and upgrading a target system . Learn You Some Erlang has a chapter on hot code upgrades . Overall, there are many steps, complexities and assumptions made during hot code upgrades, which is ultimately why they are not provided by Elixir out of the box. However, hot code upgrades can still be achieved by teams who desire to implement those steps on top of mix release in their projects or as separate libraries. Command line options --force - forces recompilation --no-archives-check - does not check archive --no-deps-check - does not check dependencies --no-elixir-version-check - does not check Elixir version --no-compile - does not compile before assembling the release --overwrite - if there is an existing release version, overwrite it --path - the path of the release --quiet - does not write progress to the standard output --version - the version of the release","ref":"Mix.Tasks.Release.html","title":"Mix.Tasks.Release","type":"task"},{"doc":"Generates sample files for releases. mix release . init * creating rel / vm . args . eex * creating rel / remote . vm . args . eex * creating rel / env . sh . eex * creating rel / env . bat . eex","ref":"Mix.Tasks.Release.Init.html","title":"Mix.Tasks.Release.Init","type":"task"},{"doc":"Starts the current application and runs code. mix run can be used to start the current application dependencies, the application itself, and optionally run some code in its context. For long running systems, this is typically done with the --no-halt option: mix run -- no - halt Once the current application and its dependencies have been started, you can run a script in its context by passing a filename: mix run my_app_script . exs arg1 arg2 arg3 Code to be executed can also be passed inline with the -e option: mix run - e &quot;DbUtils.delete_old_records()&quot; -- arg1 arg2 arg3 In both cases, the command-line arguments for the script or expression are available in System.argv/0 . Before doing anything, Mix will compile the current application if needed, unless you pass --no-compile . If for some reason the application needs to be configured before it is started, the --no-start option can be used and you are then responsible for starting all applications by using functions such as Application.ensure_all_started/1 . For more information about the application life-cycle and dynamically configuring applications, see the Application module. If you need to pass options to the Elixir executable at the same time you use mix run , it can be done as follows: elixir -- sname hello - S mix run -- no - halt This task is automatically reenabled, so it can be called multiple times with different arguments. Command-line options --config - loads the given configuration files --eval , -e - evaluates the given code --require , -r - executes the given pattern/file --parallel , -p - makes all requires parallel --preload-modules - preloads all modules defined in applications --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-archives-check - does not check archives --no-halt - does not halt the system after running the command --no-mix-exs - allows the command to run even if there is no mix.exs --no-start - does not start applications after compilation --no-elixir-version-check - does not check the Elixir version from mix.exs","ref":"Mix.Tasks.Run.html","title":"Mix.Tasks.Run","type":"task"},{"doc":"Runs the tests for a project. This task starts the current application, loads up test/test_helper.exs and then, requires all files matching the test/**/*_test.exs pattern in parallel. A list of files and/or directories can be given after the task name in order to select the files to run: mix test test / some / particular / file_test . exs mix test test / some / particular / dir Tests in umbrella projects can be run from the root by specifying the full suite path, including apps/my_app/test , in which case recursive tests for other child apps will be skipped completely: # To run all tests for my_app from the umbrella root mix test apps / my_app / test # To run a given test file on my_app from the umbrella root mix test apps / my_app / test / some / particular / file_test . exs Understanding test results When you run your test suite, it prints results as they run with a summary at the end, as seen below: $ mix test ... 1 ) test greets the world ( FooTest ) test / foo_test . exs : 5 Assertion with == failed code : assert Foo . hello ( ) == :world! left : :world right : :world! stacktrace : test / foo_test . exs : 6 : ( test ) ... ... . . Finished in 0.05 seconds ( 0.00 s async , 0.05 s sync ) 1 doctest , 11 tests , 1 failure Randomized with seed 646219 For each test, the test suite will print a dot. Failed tests are printed immediately in the format described in the next section. After all tests run, we print the suite summary. The first line contains the total time spent on the suite, followed by how much time was spent on async tests (defined with use ExUnit.Case, async: true ) vs sync ones: Finished in 0.05 seconds ( 0.00 s async , 0.05 s sync ) Developers want to minimize the time spent on sync tests whenever possible, as sync tests run serially and async tests run concurrently. Finally, how many tests we have run, how many of them failed, how many were invalid, etc. Understanding test failures First, it contains the failure counter, followed by the test name and the module the test was defined: 1 ) test greets the world ( FooTest ) The next line contains the exact location of the test in the FILE:LINE format: test / foo_test . exs : 5 If you want to re-run only this test, all you need to do is to copy the line above and past it in front of mix test : mix test test / foo_test . exs : 5 Then we show the error message, code snippet, and general information about the failed test: Assertion with == failed code : assert Foo . hello ( ) == :world! left : :world right : :world! If your terminal supports coloring (see the &quot;Coloring&quot; section below), a diff is typically shown between left and right sides. Finally, we print the stacktrace of the failure: stacktrace : test / foo_test . exs : 6 : ( test ) Command line options --color - enables color in the output --cover - runs coverage tool. See &quot;Coverage&quot; section below --exclude - excludes tests that match the filter --export-coverage - the name of the file to export coverage results to. Only has an effect when used with --cover --failed - runs only tests that failed the last time they ran. If there are no pending --failed tests, mix test will run all available tests --force - forces compilation regardless of modification times --formatter - sets the formatter module that will print the results. Defaults to ExUnit's built-in CLI formatter --include - includes tests that match the filter --listen-on-stdin - runs tests, and then listens on stdin. It will re-run tests once a newline is received. See the &quot;File system watchers&quot; section below --max-cases - sets the maximum number of tests running asynchronously. Only tests from different modules run in parallel. Defaults to twice the number of cores --max-failures - the suite stops evaluating tests when this number of test failures is reached. It runs all tests if omitted --no-archives-check - does not check archives --no-color - disables color in the output --no-compile - does not compile, even if files require compilation --no-deps-check - does not check dependencies --no-elixir-version-check - does not check the Elixir version from mix.exs --no-start - does not start applications after compilation --only - runs only tests that match the filter --partitions - sets the amount of partitions to split tests in. This option requires the MIX_TEST_PARTITION environment variable to be set. See the &quot;Operating system process partitioning&quot; section for more information --preload-modules - preloads all modules defined in applications --raise - raises if the test suite failed --seed - seeds the random number generator used to randomize the order of tests; --seed 0 disables randomization --slowest - prints timing information for the N slowest tests. Automatically sets --trace and --preload-modules --stale - runs only tests which reference modules that changed since the last time tests were ran with --stale . You can read more about this option in the &quot;The --stale option&quot; section below --timeout - sets the timeout for the tests --trace - runs tests with detailed reporting. Automatically sets --max-cases to 1 . Note that in trace mode test timeouts will be ignored as timeout is set to :infinity --warnings-as-errors - (since v1.12.0) treats warnings as errors and returns a non-zero exit code. This option only applies to test files. To treat warnings as errors during compilation and during tests, run: MIX_ENV = test mix do compile -- warnings - as - errors , test -- warnings - as - errors Configuration These configurations can be set in the def project section of your mix.exs : :test_paths - list of paths containing test files. Defaults to [&quot;test&quot;] if the test directory exists; otherwise, it defaults to [] . It is expected that all test paths contain a test_helper.exs file :test_pattern - a pattern to load test files. Defaults to *_test.exs :warn_test_pattern - a pattern to match potentially misnamed test files and display a warning. Defaults to *_test.ex :test_coverage - a set of options to be passed down to the coverage mechanism. See the &quot;Coverage&quot; section for more information Coloring Coloring is enabled by default on most Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command: reg add HKCU \\ Console / v VirtualTerminalLevel / t REG_DWORD / d 1 After running the command above, you must restart your current console. Filters ExUnit provides tags and filtering functionality that allow developers to select which tests to run. The most common functionality is to exclude some particular tests from running by default in your test helper file: # Exclude all external tests from running ExUnit . configure ( exclude : [ external : true ] ) Then, whenever desired, those tests could be included in the run via the --include option: mix test -- include external :true The example above will run all tests that have the external option set to true . It is also possible to include all examples that have a given tag, regardless of its value: mix test -- include external Note that all tests are included by default, so unless they are excluded first (either in the test helper or via the --exclude option) the --include option has no effect. For this reason, Mix also provides an --only option that excludes all tests and includes only the given ones: mix test -- only external Which is similar to: mix test -- include external -- exclude test It differs in that the test suite will fail if no tests are executed when the --only option is used. In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests: mix test test / some / particular / file_test . exs : 12 Which is equivalent to: mix test -- exclude test -- include line : 12 test / some / particular / file_test . exs Or: mix test test / some / particular / file_test . exs : 12 : 24 Which is equivalent to: mix test -- exclude test -- include line : 12 -- include line : 24 test / some / particular / file_test . exs If a given line starts a describe block, that line filter runs all tests in it. Otherwise, it runs the closest test on or before the given line number. Coverage The :test_coverage configuration accepts the following options: :output - the output directory for cover results. Defaults to &quot;cover&quot; :tool - the coverage tool :summary - summary output configuration; can be either a boolean or a keyword list. When a keyword list is passed, it can specify a :threshold , which is a boolean or numeric value that enables coloring of code coverage results in red or green depending on whether the percentage is below or above the specified threshold, respectively. Defaults to [threshold: 90] :export - a file name to export results to instead of generating the result on the fly. The .coverdata extension is automatically added to the given file. This option is automatically set via the --export-coverage option or when using process partitioning. See mix test.coverage to compile a report from multiple exports. :ignore_modules - modules to ignore from generating reports and in summaries :local_only - by default coverage only tracks local calls, set this option to false if you plan to run coverage across nodes By default, a very simple wrapper around OTP's cover is used as a tool, but it can be overridden as follows: def project ( ) do [ ... test_coverage : [ tool : CoverModule ] ... ] end CoverModule can be any module that exports start/2 , receiving the compilation path and the test_coverage options as arguments. It must return either nil or an anonymous function of zero arity that will be run after the test suite is done. Operating system process partitioning While ExUnit supports the ability to run tests concurrently within the same Elixir instance, it is not always possible to run all tests concurrently. For example, some tests may rely on global resources. For this reason, mix test supports partitioning the test files across different Elixir instances. This is done by setting the --partitions option to an integer, with the number of partitions, and setting the MIX_TEST_PARTITION environment variable to control which test partition that particular instance is running. This can also be useful if you want to distribute testing across multiple machines. For example, to split a test suite into 4 partitions and run them, you would use the following commands: MIX_TEST_PARTITION = 1 mix test -- partitions 4 MIX_TEST_PARTITION = 2 mix test -- partitions 4 MIX_TEST_PARTITION = 3 mix test -- partitions 4 MIX_TEST_PARTITION = 4 mix test -- partitions 4 The test files are sorted upfront in a round-robin fashion. Note the partition itself is given as an environment variable so it can be accessed in config files and test scripts. For example, it can be used to setup a different database instance per partition in config/test.exs . If partitioning is enabled and --cover is used, no cover reports are generated, as they only contain a subset of the coverage data. Instead, the coverage data is exported to files such as cover/MIX_TEST_PARTITION.coverdata . Once you have the results of all partitions inside cover/ , you can run mix test.coverage to get the unified report. The --stale option The --stale command line option attempts to run only the test files which reference modules that have changed since the last time you ran this task with --stale . The first time this task is run with --stale , all tests are run and a manifest is generated. On subsequent runs, a test file is marked &quot;stale&quot; if any modules it references (and any modules those modules reference, recursively) were modified since the last run with --stale . A test file is also marked &quot;stale&quot; if it has been changed since the last run with --stale . The --stale option is extremely useful for software iteration, allowing you to run only the relevant tests as you perform changes to the codebase. File-system watchers You can integrate mix test with filesystem watchers through the command line via the --listen-on-stdin option. For example, you can use fswatch or similar to emit newlines whenever there is a change, which will cause your test suite to re-run: fswatch lib test | mix test -- listen - on - stdin This can be combined with the --stale option to re-run only the test files that have changed as well as the tests that have gone stale due to changes in lib . Aborting the suite It is possible to abort the test suite with Ctrl+\\ , which sends a SIGQUIT signal to the Erlang VM. ExUnit will intercept this signal to show all tests that have been aborted and print the results collected so far. This can be useful in case the suite gets stuck and you don't want to wait until the timeout times passes (which defaults to 30 seconds).","ref":"Mix.Tasks.Test.html","title":"Mix.Tasks.Test","type":"task"},{"doc":"Build report from exported test coverage. When using --cover with the default coverage tool, the coverage tool supports an :export option to export the coverage results into a directory. This is useful when there are multiple test suites (such as in an umbrella app) or when a single test suite is partitioned across multiple runs when using the mix test --partitions N option. Once multiple test runs are exported, this task can be used to generate an aggregated report. Example: aggregating partitioned runs If you partition your tests across multiple runs, you can unify the report as shown below: MIX_TEST_PARTITION = 1 mix test -- partitions 2 -- cover MIX_TEST_PARTITION = 2 mix test -- partitions 2 -- cover mix test . coverage This works because the --partitions option automatically exports the coverage results. Example: aggregating coverage reports from all umbrella children If you run mix test.coverage inside an umbrella, it will automatically gather exported cover results from all umbrella children - as long as the coverage results have been exported, like this: # from the umbrella root mix test -- cover -- export - coverage default mix test . coverage Of course, if you want to actually partition the tests, you can also do: # from the umbrella root MIX_TEST_PARTITION = 1 mix test -- partitions 2 -- cover MIX_TEST_PARTITION = 2 mix test -- partitions 2 -- cover mix test . coverage On the other hand, if you want partitioned tests but per-app reports, you can do: # from the umbrella root MIX_TEST_PARTITION = 1 mix test -- partitions 2 -- cover MIX_TEST_PARTITION = 2 mix test -- partitions 2 -- cover mix cmd mix test . coverage When running test.coverage from the umbrella root, it will use the :test_coverage configuration from the umbrella root. Finally, note the coverage itself is not measured across the projects themselves. For example, if project B depends on A, and if there is code in A that is only executed from project B, those lines will not be marked as covered, which is important, as those projects should be developed and tested in isolation.","ref":"Mix.Tasks.Test.Coverage.html","title":"Mix.Tasks.Test.Coverage","type":"task"},{"doc":"Prints cross reference information between modules. This task is automatically reenabled, so you can print information multiple times in the same Mix invocation. Xref modes The xref task expects a mode as first argument: mix xref MODE All available modes are discussed below. callers CALLEE Prints all callers of the given MODULE . Example: mix xref callers MyMod graph Prints a file dependency graph where an edge from A to B indicates that A (source) depends on B (sink). mix xref graph -- format stats The following options are accepted: --exclude - paths to exclude --label - only shows relationships with the given label. By default, it keeps all labels that are transitive. The labels are &quot;compile&quot;, &quot;export&quot; and &quot;runtime&quot;. See &quot;Dependencies types&quot; section below --only-nodes - only shows the node names (no edges). Generally useful with the --sink flag --only-direct - the --label option will restrict itself to only direct dependencies instead of transitive ones --source - displays all files that the given source file references (directly or indirectly) --sink - displays all files that reference the given file (directly or indirectly) --min-cycle-size - controls the minimum cycle size on formats like stats and cycles --format - can be set to one of: pretty - prints the graph to the terminal using Unicode characters. Each prints each file followed by the files it depends on. This is the default except on Windows; plain - the same as pretty except ASCII characters are used instead of Unicode characters. This is the default on Windows; stats - prints general statistics about the graph; cycles - prints all cycles in the graph; dot - produces a DOT graph description in xref_graph.dot in the current directory. Warning: this will override any previously generated file The --source and --sink options are particularly useful when trying to understand how the modules in a particular file interact with the whole system. You can combine those options with --label and --only-nodes to get all files that exhibit a certain property, for example: # To get all files and their direct compile time dependencies mix xref graph -- label compile -- only - direct # To get the tree that depend on lib/foo.ex at compile time mix xref graph -- label compile -- sink lib / foo . ex # To get all files that depend on lib/foo.ex at compile time mix xref graph -- label compile -- sink lib / foo . ex -- only - nodes # To get all paths between two files mix xref graph -- source lib / foo . ex -- sink lib / bar . ex # To show general statistics about the graph mix xref graph -- format stats # To limit statistics only to certain labels mix xref graph -- format stats -- label compile Understanding the printed graph When mix xref graph runs, it will print a tree of the following format: lib / a . ex ` -- lib / b . ex ( compile ) ` -- lib / c . ex This tree means that lib/a.ex depends on lib/b.ex at compile time which then depends on lib/c.ex at runtime. This is often problematic because if lib/c.ex changes, lib/a.ex also has to recompile due to this indirect compile time dependency. The flags --source or --sink does not change how you read the graph. For example, if we use the --sink lib/c.ex flag, we would see the same tree: lib / a . ex ` -- lib / b . ex ( compile ) ` -- lib / c . ex If the --label compile flag is given with --sink , then lib/c.ex won't be shown, because no module has a compile time dependency on lib/c.ex but lib/a.ex still has an indirect compile time dependency on lib/c.ex via lib/b.ex : lib / a . ex ` -- lib / b . ex ( compile ) Therefore, using a combination of --sink with --label is useful to find all files that will change once the sink changes, alongside the transitive dependencies that will cause said recompilations. Dependencies types Elixir tracks three types of dependencies between modules: compile, exports, and runtime. If a module has a compile time dependency on another module, the caller module has to be recompiled whenever the callee changes. Compile-time dependencies are typically added when using macros or when invoking functions in the module body (outside of functions). Exports dependencies are compile time dependencies on the module API, namely structs and its public definitions. For example, if you import a module but only use its functions, it is an export dependency. If you use a struct, it is an export dependency too. Export dependencies are only recompiled if the module API changes. Note, however, that compile time dependencies have higher precedence than exports. Therefore if you import a module and use its macros, it is a compile time dependency. Runtime dependencies are added whenever you invoke another module inside a function. Modules with runtime dependencies do not have to be compiled when the callee changes, unless there is a transitive compile or export time dependency between them. Shared options Those options are shared across all modes: --include-siblings - includes dependencies that have :in_umbrella set to true in the current project in the reports. This can be used to find callers or to analyze graphs between projects --no-compile - does not compile even if files require compilation --no-deps-check - does not check dependencies --no-archives-check - does not check archives --no-elixir-version-check - does not check the Elixir version from mix.exs","ref":"Mix.Tasks.Xref.html","title":"Mix.Tasks.Xref","type":"task"},{"doc":"Returns a list of information of all the runtime function calls in the project. Each item in the list is a map with the following keys: :callee - a tuple containing the module, function, and arity of the call :line - an integer representing the line where the function is called :file - a binary representing the file where the function is called :caller_module - the module where the function is called This function returns an empty list when used at the root of an umbrella project because there is no compile manifest to extract the function call information from. To get the function calls of each child in an umbrella, execute the function at the root of each individual application.","ref":"Mix.Tasks.Xref.html#calls/1","title":"Mix.Tasks.Xref.calls/1","type":"function"},{"doc":"A simple configuration API and functions for managing config files. This module is deprecated, use the modules Config and Config.Reader from Elixir's standard library instead. Setting configuration Most commonly, this module is used to define your own configuration: use Mix.Config config :root_key , key1 : &quot;value1&quot; , key2 : &quot;value2&quot; import_config &quot; \#{ Mix . env ( ) } .exs&quot; use Mix.Config will import the functions config/2 , config/3 and import_config/1 to help you manage your configuration. Evaluating configuration Once a configuration is written to a file, the functions in this module can be used to read and merge said configuration. The eval!/2 function allows you to evaluate a given configuration file and the merge/2 function allows you to deep merge the results of multiple configurations. Those functions should not be invoked by users writing configurations but rather by library authors. Examples The most common use of Mix.Config is to define application configuration so that Application.get_env/3 and other Application functions can be used to retrieve or further change them. Application config files are typically placed in the config/ directory of your Mix projects. For example, the following config # config/config.exs config :my_app , :key , &quot;value&quot; will be automatically loaded by Mix and persisted into the :my_app 's application environment, which can be accessed in its source code as follows: &quot;value&quot; = Application . fetch_env! ( :my_app , :key1 )","ref":"Mix.Config.html","title":"Mix.Config","type":"module"},{"doc":"Configures the given root_key . Keyword lists are always deep merged. Examples The given opts are merged into the existing configuration for the given root_key . Conflicting keys are overridden by the ones specified in opts . For example, the application configuration below config :logger , level : :warn , backends : [ :console ] config :logger , level : :info , truncate : 1024 will have a final configuration for :logger of: [ level : :info , backends : [ :console ] , truncate : 1024 ]","ref":"Mix.Config.html#config/2","title":"Mix.Config.config/2","type":"function"},{"doc":"Configures the given key for the given root_key . Keyword lists are always deep merged. Examples The given opts are merged into the existing values for key in the given root_key . Conflicting keys are overridden by the ones specified in opts . For example, the application configuration below config :ecto , Repo , log_level : :warn , adapter : Ecto.Adapters.Postgres config :ecto , Repo , log_level : :info , pool_size : 10 will have a final value of the configuration for the Repo key in the :ecto application of: [ log_level : :info , pool_size : 10 , adapter : Ecto.Adapters.Postgres ]","ref":"Mix.Config.html#config/3","title":"Mix.Config.config/3","type":"function"},{"doc":"Evaluates the given configuration file. It accepts a list of imported_paths that should raise if attempted to be imported again (to avoid recursive imports). It returns a tuple with the configuration and the imported paths.","ref":"Mix.Config.html#eval!/2","title":"Mix.Config.eval!/2","type":"function"},{"doc":"Imports configuration from the given file or files. If path_or_wildcard is a wildcard, then all the files matching that wildcard will be imported; if no file matches the wildcard, no errors are raised. If path_or_wildcard is not a wildcard but a path to a single file, then that file is imported; in case the file doesn't exist, an error is raised. If path/wildcard is a relative path/wildcard, it will be expanded relatively to the directory the current configuration file is in. Examples This is often used to emulate configuration across environments: import_config &quot; \#{ Mix . env ( ) } .exs&quot; Or to import files from children in umbrella projects: import_config &quot;../apps/*/config/config.exs&quot;","ref":"Mix.Config.html#import_config/1","title":"Mix.Config.import_config/1","type":"macro"},{"doc":"Merges two configurations. The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them. Examples iex&gt; Mix.Config . merge ( [ app : [ k : :v1 ] ] , [ app : [ k : :v2 ] ] ) [ app : [ k : :v2 ] ] iex&gt; Mix.Config . merge ( [ app : [ k : [ v1 : 1 , v2 : 2 ] ] ] , [ app : [ k : [ v2 : :a , v3 : :b ] ] ] ) [ app : [ k : [ v1 : 1 , v2 : :a , v3 : :b ] ] ] iex&gt; Mix.Config . merge ( [ app1 : [ ] ] , [ app2 : [ ] ] ) [ app1 : [ ] , app2 : [ ] ]","ref":"Mix.Config.html#merge/2","title":"Mix.Config.merge/2","type":"function"},{"doc":"Persists the given configuration by modifying the configured applications environment. config should be a list of {app, app_config} tuples or a %{app =&gt; app_config} map where app are the applications to be configured and app_config are the configuration (as key-value pairs) for each of those applications. Returns the configured applications. Examples Mix.Config . persist ( logger : [ level : :error ] , my_app : [ my_config : 1 ] ) #=&gt; [:logger, :my_app]","ref":"Mix.Config.html#persist/1","title":"Mix.Config.persist/1","type":"function"},{"doc":"Reads the configuration file. The same as eval!/2 but only returns the configuration in the given file, without returning the imported paths. It exists for convenience purposes. For example, you could invoke it inside your mix.exs to read some external data you decided to move to a configuration file: subsystem : Mix.Config . read! ( &quot;rel/subsystem.exs&quot; )","ref":"Mix.Config.html#read!/2","title":"Mix.Config.read!/2","type":"function"},{"doc":"","ref":"Mix.ElixirVersionError.html","title":"Mix.ElixirVersionError","type":"exception"},{"doc":"","ref":"Mix.Error.html","title":"Mix.Error","type":"exception"},{"doc":"","ref":"Mix.InvalidTaskError.html","title":"Mix.InvalidTaskError","type":"exception"},{"doc":"","ref":"Mix.NoProjectError.html","title":"Mix.NoProjectError","type":"exception"},{"doc":"","ref":"Mix.NoTaskError.html","title":"Mix.NoTaskError","type":"exception"}]