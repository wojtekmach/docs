searchNodes=[{"doc":"Kernel is Elixir's default environment. It mainly consists of: basic language primitives, such as arithmetic operators, spawning of processes, data type handling, and others macros for control-flow and defining new functionality (modules, functions, and the like) guard checks for augmenting pattern matching You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call: iex&gt; is_number ( 13 ) true If you don't want to import a function or macro from Kernel , use the :except option and then list the function/macro by arity: import Kernel , except : [ if : 2 , unless : 2 ] See Kernel.SpecialForms.import/2 for more information on importing. Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms . The standard library Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries). Built-in types The following modules handle Elixir built-in data types: Atom - literal constants with a name ( true , false , and nil are atoms) Float - numbers with floating point precision Function - a reference to code chunk, created with the fn/1 special form Integer - whole numbers (not fractions) List - collections of a variable number of elements (linked lists) Map - collections of key-value pairs Process - light-weight threads of execution Port - mechanisms to interact with the external world Tuple - collections of a fixed number of elements There are two data types without an accompanying module: Bitstring - a sequence of bits, created with Kernel.SpecialForms.&lt;&lt;&gt;&gt;/1 . When the number of bits is divisible by 8, they are called binaries and can be manipulated with Erlang's :binary module Reference - a unique value in the runtime system, created with make_ref/0 Data types Elixir also provides other data types that are built on top of the types listed above. Some of them are: Date - year-month-day structs in a given calendar DateTime - date and time with time zone in a given calendar Exception - data raised from errors and unexpected scenarios MapSet - unordered collections of unique elements NaiveDateTime - date and time without time zone in a given calendar Keyword - lists of two-element tuples, often representing optional values Range - inclusive ranges between two integers Regex - regular expressions String - UTF-8 encoded binaries representing characters Time - hour:minute:second structs in a given calendar URI - representation of URIs that identify resources Version - representation of versions and requirements System modules Modules that interface with the underlying system, such as: IO - handles input and output File - interacts with the underlying file system Path - manipulates file system paths System - reads and writes system information Protocols Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library: Collectable - collects data into a data type Enumerable - handles collections in Elixir. The Enum module provides eager functions for working with collections, the Stream module provides lazy functions Inspect - converts data types into their programming language representation List.Chars - converts data types to their outside world representation as charlists (non-programming based) String.Chars - converts data types to their outside world representation as strings (non-programming based) Process-based and application-centric functionality The following modules build on top of processes to provide concurrency, fault-tolerance, and more. Agent - a process that encapsulates mutable state Application - functions for starting, stopping and configuring applications GenServer - a generic client-server API Registry - a key-value process-based storage Supervisor - a process that is responsible for starting, supervising and shutting down other processes Task - a process that performs computations Task.Supervisor - a supervisor for managing tasks exclusively Supporting documents Elixir documentation also includes supporting documents under the &quot;Pages&quot; section. Those are: Compatibility and deprecations - lists compatibility between every Elixir version and Erlang/OTP, release schema; lists all deprecated functions, when they were deprecated and alternatives Library guidelines - general guidelines, anti-patterns, and rules for those writing libraries Naming conventions - naming conventions for Elixir code Operators - lists all Elixir operators and their precedences Patterns and guards - an introduction to patterns, guards, and extensions Syntax reference - the language syntax reference Typespecs - types and function specifications, including list of types Unicode syntax - outlines Elixir support for Unicode Writing documentation - guidelines for writing documentation in Elixir Guards This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example: def drive ( % User { age : age } ) when age &gt;= 16 do ... end The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or . The whole guard is true if all guard expressions will evaluate to true . A more complete introduction to guards is available in the Patterns and guards page. Structural comparison The comparison functions in this module perform structural comparison. This means structures are compared based on their representation and not on their semantic value. This is specially important for functions that are meant to provide ordering, such as &gt;/2 , &lt;/2 , &gt;=/2 , &lt;=/2 , min/2 , and max/2 . For example: ~D[2017-03-31] &gt; ~D[2017-04-01] will return true because structural comparison compares the :day field before :month or :year . Therefore, when comparing structs, you often use the compare/2 function made available by the structs modules themselves: iex&gt; Date . compare ( ~D[2017-03-31] , ~D[2017-04-01] ) :lt Alternatively, you can use the functions in the Enum module to sort or compute a maximum/minimum: iex&gt; Enum . sort ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) [ ~D[2017-03-31] , ~D[2017-04-01] ] iex&gt; Enum . max ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-04-01] Truthy and falsy values Besides the booleans true and false , Elixir has the concept of a &quot;truthy&quot; or &quot;falsy&quot; value. a value is truthy when it is neither false nor nil a value is falsy when it is either false or nil Elixir has functions, like and/2 , that only work with booleans, but also functions that work with these truthy/falsy values, like &amp;&amp;/2 and !/1 . Examples We can check the truthiness of a value by using the !/1 function twice. Truthy values: iex&gt; ! ! true true iex&gt; ! ! 5 true iex&gt; ! ! [ 1 , 2 ] true iex&gt; ! ! &quot;foo&quot; true Falsy values (of which there are exactly two): iex&gt; ! ! false false iex&gt; ! ! nil false Inlining Some of the functions described in this module are inlined by the Elixir compiler into their Erlang counterparts in the :erlang module. Those functions are called BIFs (built-in internal functions) in Erlang-land and they exhibit interesting properties, as some of them are allowed in guards and others are used for compiler optimizations. Most of the inlined functions can be seen in effect when capturing the function: iex&gt; &amp; Kernel . is_atom / 1 &amp; :erlang . is_atom / 1 Those functions will be explicitly marked in their docs as &quot;inlined by the compiler&quot;.","ref":"Kernel.html","title":"Kernel","type":"module"},{"doc":"Boolean &quot;not&quot; operator. Receives any value (not just booleans) and returns true if value is false or nil ; returns false otherwise. Not allowed in guard clauses. Examples iex&gt; ! Enum . empty? ( [ ] ) false iex&gt; ! List . first ( [ ] ) true","ref":"Kernel.html#!/1","title":"Kernel.!/1","type":"macro"},{"doc":"Not equal to operator. Returns true if the two terms are not equal. This operator considers 1 and 1.0 to be equal. For match comparison, use !==/2 instead. All terms in Elixir can be compared with each other. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 != 2 true iex&gt; 1 != 1.0 false","ref":"Kernel.html#!=/2","title":"Kernel.!=/2","type":"function"},{"doc":"Strictly not equal to operator. Returns true if the two terms are not exactly equal. See ===/2 for a definition of what is considered &quot;exactly equal&quot;. All terms in Elixir can be compared with each other. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 !== 2 true iex&gt; 1 !== 1.0 true","ref":"Kernel.html#!==/2","title":"Kernel.!==/2","type":"function"},{"doc":"Boolean &quot;and&quot; operator. Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to a truthy value (neither false nor nil ). Returns the first expression otherwise. Not allowed in guard clauses. Examples iex&gt; Enum . empty? ( [ ] ) &amp;&amp; Enum . empty? ( [ ] ) true iex&gt; List . first ( [ ] ) &amp;&amp; true nil iex&gt; Enum . empty? ( [ ] ) &amp;&amp; List . first ( [ 1 ] ) 1 iex&gt; false &amp;&amp; throw ( :bad ) false Note that, unlike and/2 , this operator accepts any expression as the first argument, not only booleans.","ref":"Kernel.html#&&/2","title":"Kernel.&&/2","type":"macro"},{"doc":"Arithmetic multiplication operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 * 2 2","ref":"Kernel.html#*/2","title":"Kernel.*/2","type":"function"},{"doc":"Arithmetic positive unary operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; + 1 1","ref":"Kernel.html#+/1","title":"Kernel.+/1","type":"function"},{"doc":"Arithmetic addition operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 + 2 3","ref":"Kernel.html#+/2","title":"Kernel.+/2","type":"function"},{"doc":"List concatenation operator. Concatenates a proper list and a term, returning a list. The complexity of a ++ b is proportional to length(a) , so avoid repeatedly appending to lists of arbitrary length, for example, list ++ [element] . Instead, consider prepending via [element | rest] and then reversing. If the right operand is not a proper list, it returns an improper list. If the left operand is not a proper list, it raises ArgumentError . Inlined by the compiler. Examples iex&gt; [ 1 ] ++ [ 2 , 3 ] [ 1 , 2 , 3 ] iex&gt; &#39;foo&#39; ++ &#39;bar&#39; &#39;foobar&#39; # returns an improper list iex&gt; [ 1 ] ++ 2 [ 1 | 2 ] # returns a proper list iex&gt; [ 1 ] ++ [ 2 ] [ 1 , 2 ] # improper list on the right will return an improper list iex&gt; [ 1 ] ++ [ 2 | 3 ] [ 1 , 2 | 3 ]","ref":"Kernel.html#++/2","title":"Kernel.++/2","type":"function"},{"doc":"Arithmetic negative unary operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; - 2 - 2","ref":"Kernel.html#-/1","title":"Kernel.-/1","type":"function"},{"doc":"Arithmetic subtraction operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 - 2 - 1","ref":"Kernel.html#-/2","title":"Kernel.-/2","type":"function"},{"doc":"List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right. Before Erlang/OTP 22, the complexity of a -- b was proportional to length(a) * length(b) , meaning that it would be very slow if both a and b were long lists. In such cases, consider converting each list to a MapSet and using MapSet.difference/2 . As of Erlang/OTP 22, this operation is significantly faster even if both lists are very long, and using --/2 is usually faster and uses less memory than using the MapSet -based alternative mentioned above. See also the Erlang efficiency guide . Inlined by the compiler. Examples iex&gt; [ 1 , 2 , 3 ] -- [ 1 , 2 ] [ 3 ] iex&gt; [ 1 , 2 , 3 , 2 , 1 ] -- [ 1 , 2 , 2 ] [ 3 , 1 ] The --/2 operator is right associative, meaning: iex&gt; [ 1 , 2 , 3 ] -- [ 2 ] -- [ 3 ] [ 1 , 3 ] As it is equivalent to: iex&gt; [ 1 , 2 , 3 ] -- ( [ 2 ] -- [ 3 ] ) [ 1 , 3 ]","ref":"Kernel.html#--/2","title":"Kernel.--/2","type":"function"},{"doc":"Creates a range from first to last . If first is less than last, the range will be increasing from first to last. If first is equal to last, the range will contain one element, which is the number itself. If first is more than last, the range will be decreasing from first to last, albeit this behaviour is deprecated. Instead prefer to explicitly list the step with first..last//-1 . See the Range module for more information. Examples iex&gt; 0 in 1 . . 3 false iex&gt; 2 in 1 . . 3 true iex&gt; Enum . to_list ( 1 . . 3 ) [ 1 , 2 , 3 ]","ref":"Kernel.html#../2","title":"Kernel.../2","type":"macro"},{"doc":"Creates a range from first to last with step . See the Range module for more information. Examples iex&gt; 0 in 1 . . 3 / / 1 false iex&gt; 2 in 1 . . 3 / / 1 true iex&gt; 2 in 1 . . 3 / / 2 false iex&gt; Enum . to_list ( 1 . . 3 / / 1 ) [ 1 , 2 , 3 ] iex&gt; Enum . to_list ( 1 . . 3 / / 2 ) [ 1 , 3 ] iex&gt; Enum . to_list ( 3 . . 1 / / - 1 ) [ 3 , 2 , 1 ] iex&gt; Enum . to_list ( 1 . . 0 / / 1 ) [ ]","ref":"Kernel.html#..///3","title":"Kernel...///3","type":"macro"},{"doc":"Arithmetic division operator. The result is always a float. Use div/2 and rem/2 if you want an integer division or the remainder. Raises ArithmeticError if right is 0 or 0.0. Allowed in guard tests. Inlined by the compiler. Examples 1 / 2 #=&gt; 0.5 - 3.0 / 2.0 #=&gt; -1.5 5 / 1 #=&gt; 5.0 7 / 0 ** (ArithmeticError) bad argument in arithmetic expression","ref":"Kernel.html#//2","title":"Kernel.//2","type":"function"},{"doc":"Less-than operator. Returns true if left is less than right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &lt; 2 true","ref":"Kernel.html#%3C/2","title":"Kernel.</2","type":"function"},{"doc":"Less-than or equal to operator. Returns true if left is less than or equal to right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &lt;= 2 true","ref":"Kernel.html#%3C=/2","title":"Kernel.<=/2","type":"function"},{"doc":"Binary concatenation operator. Concatenates two binaries. Examples iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot; &quot;foobar&quot; The &lt;&gt;/2 operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary: iex&gt; &quot;foo&quot; &lt;&gt; x = &quot;foobar&quot; iex&gt; x &quot;bar&quot; x &lt;&gt; &quot;bar&quot; = &quot;foobar&quot; would have resulted in a CompileError exception.","ref":"Kernel.html#%3C%3E/2","title":"Kernel.<>/2","type":"macro"},{"doc":"Equal to operator. Returns true if the two terms are equal. This operator considers 1 and 1.0 to be equal. For stricter semantics, use ===/2 instead. All terms in Elixir can be compared with each other. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 == 2 false iex&gt; 1 == 1.0 true","ref":"Kernel.html#==/2","title":"Kernel.==/2","type":"function"},{"doc":"Strictly equal to operator. Returns true if the two terms are exactly equal. The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, 1 == 1.0 returns true , but since they are of different types, 1 === 1.0 returns false . All terms in Elixir can be compared with each other. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 === 2 false iex&gt; 1 === 1.0 false","ref":"Kernel.html#===/2","title":"Kernel.===/2","type":"function"},{"doc":"Text-based match operator. Matches the term on the left against the regular expression or string on the right . If right is a regular expression, returns true if left matches right. If right is a string, returns true if left contains right . Examples iex&gt; &quot;abcd&quot; =~ ~r/c(d)/ true iex&gt; &quot;abcd&quot; =~ ~r/e/ false iex&gt; &quot;abcd&quot; =~ ~r// true iex&gt; &quot;abcd&quot; =~ &quot;bc&quot; true iex&gt; &quot;abcd&quot; =~ &quot;ad&quot; false iex&gt; &quot;abcd&quot; =~ &quot;abcd&quot; true iex&gt; &quot;abcd&quot; =~ &quot;&quot; true","ref":"Kernel.html#=~/2","title":"Kernel.=~/2","type":"function"},{"doc":"Greater-than operator. Returns true if left is more than right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &gt; 2 false","ref":"Kernel.html#%3E/2","title":"Kernel.>/2","type":"function"},{"doc":"Greater-than or equal to operator. Returns true if left is more than or equal to right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &gt;= 2 false","ref":"Kernel.html#%3E=/2","title":"Kernel.>=/2","type":"function"},{"doc":"Module attribute unary operator. Reads and writes attributes in the current module. The canonical example for attributes is annotating that a module implements an OTP behaviour, such as GenServer : defmodule MyServer do @behaviour GenServer # ... callbacks ... end By default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well: defmodule MyServer do @my_data 13 IO . inspect ( @my_data ) #=&gt; 13 end Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using Module.register_attribute/3 . Finally, note that attributes can also be read inside functions: defmodule MyServer do @my_data 11 def first_data , do : @my_data @my_data 13 def second_data , do : @my_data end MyServer . first_data ( ) #=&gt; 11 MyServer . second_data ( ) #=&gt; 13 It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the Module module for other functions to manipulate module attributes. Compile-time considerations One thing to keep in mind is that references to other modules, even in module attributes, generate compile-time dependencies to said modules. For example, take this common pattern: @values [ :foo , :bar , :baz ] def handle_arg ( arg ) when arg in @values do ... end While the above is fine, imagine if instead you have actual module names in the module attribute, like this: @values [ Foo , Bar , Baz ] def handle_arg ( arg ) when arg in @values do ... end The code above will define a compile-time dependency on the modules Foo , Bar , and Baz , in a way that, if any of them change, the current module will have to recompile. In such cases, it may be preferred to avoid the module attribute altogether: def handle_arg ( arg ) when arg in [ Foo , Bar , Baz ] do ... end","ref":"Kernel.html#@/1","title":"Kernel.@/1","type":"macro"},{"doc":"Pipe operator. This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side. Examples iex&gt; [ 1 , [ 2 ] , 3 ] |&gt; List . flatten ( ) [ 1 , 2 , 3 ] The example above is the same as calling List.flatten([1, [2], 3]) . The |&gt; operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline: iex&gt; [ 1 , [ 2 ] , 3 ] |&gt; List . flatten ( ) |&gt; Enum . map ( fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] In the example above, the list [1, [2], 3] is passed as the first argument to the List.flatten/1 function, then the flattened list is passed as the first argument to the Enum.map/2 function which doubles each element of the list. In other words, the expression above simply translates to: Enum . map ( List . flatten ( [ 1 , [ 2 ] , 3 ] ) , fn x -&gt; x * 2 end ) Pitfalls There are two common pitfalls when using the pipe operator. The first one is related to operator precedence. For example, the following expression: String . graphemes &quot;Hello&quot; |&gt; Enum . reverse Translates to: String . graphemes ( &quot;Hello&quot; |&gt; Enum . reverse ( ) ) which results in an error as the Enumerable protocol is not defined for binaries. Adding explicit parentheses resolves the ambiguity: String . graphemes ( &quot;Hello&quot; ) |&gt; Enum . reverse ( ) Or, even better: &quot;Hello&quot; |&gt; String . graphemes ( ) |&gt; Enum . reverse ( ) The second limitation is that Elixir always pipes to a function call. Therefore, to pipe into an anonymous function, you need to invoke it: some_fun = &amp; Regex . replace ( ~r/l/ , &amp;1 , &quot;L&quot; ) &quot;Hello&quot; |&gt; some_fun . ( ) Alternatively, you can use then/2 for the same effect: some_fun = &amp; Regex . replace ( ~r/l/ , &amp;1 , &quot;L&quot; ) &quot;Hello&quot; |&gt; then ( some_fun ) then/2 is most commonly used when you want to pipe to a function but the value is expected outside of the first argument, such as above. By replacing some_fun by its value, we get: &quot;Hello&quot; |&gt; then ( &amp; Regex . replace ( ~r/l/ , &amp;1 , &quot;L&quot; ) )","ref":"Kernel.html#%7C%3E/2","title":"Kernel.|>/2","type":"macro"},{"doc":"Boolean &quot;or&quot; operator. Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either nil or false ). Returns the first expression otherwise. Not allowed in guard clauses. Examples iex&gt; Enum . empty? ( [ 1 ] ) || Enum . empty? ( [ 1 ] ) false iex&gt; List . first ( [ ] ) || true true iex&gt; Enum . empty? ( [ 1 ] ) || 1 1 iex&gt; Enum . empty? ( [ ] ) || throw ( :bad ) true Note that, unlike or/2 , this operator accepts any expression as the first argument, not only booleans.","ref":"Kernel.html#%7C%7C/2","title":"Kernel.||/2","type":"macro"},{"doc":"Returns an integer or float which is the arithmetical absolute value of number . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; abs ( - 3.33 ) 3.33 iex&gt; abs ( - 3 ) 3","ref":"Kernel.html#abs/1","title":"Kernel.abs/1","type":"function"},{"doc":"When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded. Check Kernel.SpecialForms.quote/2 for more information.","ref":"Kernel.html#alias!/1","title":"Kernel.alias!/1","type":"macro"},{"doc":"Strictly boolean &quot;and&quot; operator. If left is false , returns false ; otherwise returns right . Requires only the left operand to be a boolean since it short-circuits. If the left operand is not a boolean, a BadBooleanError exception is raised. Allowed in guard tests. Examples iex&gt; true and false false iex&gt; true and &quot;yay!&quot; &quot;yay!&quot; iex&gt; &quot;yay!&quot; and true ** (BadBooleanError) expected a boolean on left-side of &quot;and&quot;, got: &quot;yay!&quot;","ref":"Kernel.html#and/2","title":"Kernel.and/2","type":"macro"},{"doc":"Invokes the given anonymous function fun with the list of arguments args . If the number of arguments is known at compile time, prefer fun.(arg_1, arg_2, ..., arg_n) as it is clearer than apply(fun, [arg_1, arg_2, ..., arg_n]) . Inlined by the compiler. Examples iex&gt; apply ( fn x -&gt; x * 2 end , [ 2 ] ) 4","ref":"Kernel.html#apply/2","title":"Kernel.apply/2","type":"function"},{"doc":"Invokes the given function from module with the list of arguments args . apply/3 is used to invoke functions where the module, function name or arguments are defined dynamically at runtime. For this reason, you can't invoke macros using apply/3 , only functions. If the number of arguments and the function name are known at compile time, prefer module.function(arg_1, arg_2, ..., arg_n) as it is clearer than apply(module, :function, [arg_1, arg_2, ..., arg_n]) . Inlined by the compiler. Examples iex&gt; apply ( Enum , :reverse , [ [ 1 , 2 , 3 ] ] ) [ 3 , 2 , 1 ]","ref":"Kernel.html#apply/3","title":"Kernel.apply/3","type":"function"},{"doc":"Extracts the part of the binary starting at start with length length . Binaries are zero-indexed. If start or length reference in any way outside the binary, an ArgumentError exception is raised. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; binary_part ( &quot;foo&quot; , 1 , 2 ) &quot;oo&quot; A negative length can be used to extract bytes that come before the byte at start : iex&gt; binary_part ( &quot;Hello&quot; , 5 , - 3 ) &quot;llo&quot; An ArgumentError is raised when the length is outside of the binary: binary_part ( &quot;Hello&quot; , 0 , 10 ) ** (ArgumentError) argument error","ref":"Kernel.html#binary_part/3","title":"Kernel.binary_part/3","type":"function"},{"doc":"Returns the binding for the given context as a keyword list. In the returned result, keys are variable names and values are the corresponding variable values. If the given context is nil (by default it is), the binding for the current context is returned. Examples iex&gt; x = 1 iex&gt; binding ( ) [ x : 1 ] iex&gt; x = 2 iex&gt; binding ( ) [ x : 2 ] iex&gt; binding ( :foo ) [ ] iex&gt; var! ( x , :foo ) = 1 1 iex&gt; binding ( :foo ) [ x : 1 ]","ref":"Kernel.html#binding/1","title":"Kernel.binding/1","type":"macro"},{"doc":"Returns an integer which is the size in bits of bitstring . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bit_size ( &lt;&lt; 433 :: 16 , 3 :: 3 &gt;&gt; ) 19 iex&gt; bit_size ( &lt;&lt; 1 , 2 , 3 &gt;&gt; ) 24","ref":"Kernel.html#bit_size/1","title":"Kernel.bit_size/1","type":"function"},{"doc":"Returns the number of bytes needed to contain bitstring . That is, if the number of bits in bitstring is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; byte_size ( &lt;&lt; 433 :: 16 , 3 :: 3 &gt;&gt; ) 3 iex&gt; byte_size ( &lt;&lt; 1 , 2 , 3 &gt;&gt; ) 3","ref":"Kernel.html#byte_size/1","title":"Kernel.byte_size/1","type":"function"},{"doc":"Returns the smallest integer greater than or equal to number . If you want to perform ceil operation on other decimal places, use Float.ceil/2 instead. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#ceil/1","title":"Kernel.ceil/1","type":"function"},{"doc":"Defines a public function with the given name and body. Examples defmodule Foo do def bar , do : :baz end Foo . bar ( ) #=&gt; :baz A function that expects arguments can be defined as follows: defmodule Foo do def sum ( a , b ) do a + b end end In the example above, a sum/2 function is defined; this function receives two arguments and returns their sum. Default arguments \\\\ is used to specify a default value for a parameter of a function. For example: defmodule MyMath do def multiply_by ( number , factor \\\\ 2 ) do number * factor end end MyMath . multiply_by ( 4 , 3 ) #=&gt; 12 MyMath . multiply_by ( 4 ) #=&gt; 8 The compiler translates this into multiple functions with different arities, here MyMath.multiply_by/1 and MyMath.multiply_by/2 , that represent cases when arguments for parameters with default values are passed or not passed. When defining a function with default arguments as well as multiple explicitly declared clauses, you must write a function head that declares the defaults. For example: defmodule MyString do def join ( string1 , string2 \\\\ nil , separator \\\\ &quot; &quot; ) def join ( string1 , nil , _separator ) do string1 end def join ( string1 , string2 , separator ) do string1 &lt;&gt; separator &lt;&gt; string2 end end Note that \\\\ can't be used with anonymous functions because they can only have a sole arity. Keyword lists with default arguments Functions containing many arguments can benefit from using Keyword lists to group and pass attributes as a single value. defmodule MyConfiguration do @default_opts [ storage : &quot;local&quot; ] def configure ( resource , opts \\\\ [ ] ) do opts = Keyword . merge ( @default_opts , opts ) storage = opts [ :storage ] # ... end end The difference between using Map and Keyword to store many arguments is Keyword 's keys: must be atoms can be given more than once ordered, as specified by the developer Function and variable names Function and variable names have the following syntax: A lowercase ASCII letter or an underscore , followed by any number of lowercase or uppercase ASCII letters , numbers , or underscores . Optionally they can end in either an exclamation mark or a question mark . For variables, any identifier starting with an underscore should indicate an unused variable. For example: def foo ( bar ) do [ ] end #=&gt; warning: variable bar is unused def foo ( _bar ) do [ ] end #=&gt; no warning def foo ( _bar ) do _bar end #=&gt; warning: the underscored variable &quot;_bar&quot; is used after being set rescue / catch / after / else Function bodies support rescue , catch , after , and else as Kernel.SpecialForms.try/1 does (known as &quot;implicit try&quot;). For example, the following two functions are equivalent: def convert ( number ) do try do String . to_integer ( number ) rescue e in ArgumentError -&gt; { :error , e . message } end end def convert ( number ) do String . to_integer ( number ) rescue e in ArgumentError -&gt; { :error , e . message } end","ref":"Kernel.html#def/2","title":"Kernel.def/2","type":"macro"},{"doc":"Defines a function that delegates to another module. Functions defined with defdelegate/2 are public and can be invoked from outside the module they're defined in, as if they were defined using def/2 . Therefore, defdelegate/2 is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use alias/2 to shorten the module name or use import/2 to be able to invoke the function without the module name altogether. Delegation only works with functions; delegating macros is not supported. Check def/2 for rules on naming and default arguments. Options :to - the module to dispatch to. :as - the function to call on the target given in :to . This parameter is optional and defaults to the name being delegated ( funs ). Examples defmodule MyList do defdelegate reverse ( list ) , to : Enum defdelegate other_reverse ( list ) , to : Enum , as : :reverse end MyList . reverse ( [ 1 , 2 , 3 ] ) #=&gt; [3, 2, 1] MyList . other_reverse ( [ 1 , 2 , 3 ] ) #=&gt; [3, 2, 1]","ref":"Kernel.html#defdelegate/2","title":"Kernel.defdelegate/2","type":"macro"},{"doc":"Defines an exception. Exceptions are structs backed by a module that implements the Exception behaviour. The Exception behaviour requires two functions to be implemented: exception/1 - receives the arguments given to raise/2 and returns the exception struct. The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message. message/1 - receives the exception struct and must return its message. Most commonly exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented. Since exceptions are structs, the API supported by defstruct/1 is also available in defexception/1 . Raising exceptions The most common way to raise an exception is via raise/2 : defmodule MyAppError do defexception [ :message ] end value = [ :hello ] raise MyAppError , message : &quot;did not get what was expected, got: \#{ inspect ( value ) } &quot; In many cases it is more convenient to pass the expected value to raise/2 and generate the message in the Exception.exception/1 callback: defmodule MyAppError do defexception [ :message ] @impl true def exception ( value ) do msg = &quot;did not get what was expected, got: \#{ inspect ( value ) } &quot; % MyAppError { message : msg } end end raise MyAppError , value The example above shows the preferred strategy for customizing exception messages.","ref":"Kernel.html#defexception/1","title":"Kernel.defexception/1","type":"macro"},{"doc":"Generates a macro suitable for use in guard expressions. It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards. Note the convention in Elixir is to name functions/macros allowed in guards with the is_ prefix, such as is_list/1 . If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as Keyword.keyword?/1 . Example defmodule Integer.Guards do defguard is_even ( value ) when is_integer ( value ) and rem ( value , 2 ) == 0 end defmodule Collatz do @moduledoc &quot;Tools for working with the Collatz sequence.&quot; import Integer.Guards @doc &quot;Determines the number of steps `n` takes to reach `1`.&quot; # If this function never converges, please let me know what `n` you used. def converge ( n ) when n &gt; 0 , do : step ( n , 0 ) defp step ( 1 , step_count ) do step_count end defp step ( n , step_count ) when is_even ( n ) do step ( div ( n , 2 ) , step_count + 1 ) end defp step ( n , step_count ) do step ( 3 * n + 1 , step_count + 1 ) end end","ref":"Kernel.html#defguard/1","title":"Kernel.defguard/1","type":"macro"},{"doc":"Generates a private macro suitable for use in guard expressions. It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module. Similar to defmacrop/2 , defguardp/1 must be defined before its use in the current module.","ref":"Kernel.html#defguardp/1","title":"Kernel.defguardp/1","type":"macro"},{"doc":"Defines an implementation for the given protocol. See the Protocol module for more information.","ref":"Kernel.html#defimpl/3","title":"Kernel.defimpl/3","type":"macro"},{"doc":"Defines a public macro with the given name and body. Macros must be defined before its usage. Check def/2 for rules on naming and default arguments. Examples defmodule MyLogic do defmacro unless ( expr , opts ) do quote do if ! unquote ( expr ) , unquote ( opts ) end end end require MyLogic MyLogic . unless false do IO . puts ( &quot;It works&quot; ) end","ref":"Kernel.html#defmacro/2","title":"Kernel.defmacro/2","type":"macro"},{"doc":"Defines a private macro with the given name and body. Private macros are only accessible from the same module in which they are defined. Private macros must be defined before its usage. Check defmacro/2 for more information, and check def/2 for rules on naming and default arguments.","ref":"Kernel.html#defmacrop/2","title":"Kernel.defmacrop/2","type":"macro"},{"doc":"Defines a module given by name with the given contents. This macro defines a module with the given alias as its name and with the given contents. It returns a tuple with four elements: :module the module name the binary contents of the module the result of evaluating the contents block Examples defmodule Number do def one , do : 1 def two , do : 2 end #=&gt; {:module, Number, &lt;&lt;70, 79, 82, ...&gt;&gt;, {:two, 0}} Number . one ( ) #=&gt; 1 Number . two ( ) #=&gt; 2 Nesting Nesting a module inside another module affects the name of the nested module: defmodule Foo do defmodule Bar do end end In the example above, two modules - Foo and Foo.Bar - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module Foo.Bar to be accessed as Bar in the same lexical scope where it's defined (the Foo module). This only happens if the nested module is defined via an alias. If the Foo.Bar module is moved somewhere else, the references to Bar in the Foo module need to be updated to the fully-qualified name ( Foo.Bar ) or an alias has to be explicitly set in the Foo module with the help of Kernel.SpecialForms.alias/2 . defmodule Foo.Bar do # code end defmodule Foo do alias Foo.Bar # code here can refer to &quot;Foo.Bar&quot; as just &quot;Bar&quot; end Dynamic names Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write: defmodule String . to_atom ( &quot;Foo \#{ 1 } &quot; ) do # contents ... end Elixir will accept any module name as long as the expression passed as the first argument to defmodule/2 evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias. Reserved module names If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined. There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error: defmodule Any do # code end ** (CompileError) iex:1: module Any is reserved and cannot be defined Elixir reserves the following module names: Elixir , Any , BitString , PID , and Reference .","ref":"Kernel.html#defmodule/2","title":"Kernel.defmodule/2","type":"macro"},{"doc":"Makes the given functions in the current module overridable. An overridable function is lazily defined, allowing a developer to override it. Macros cannot be overridden as functions and vice-versa. Example defmodule DefaultMod do defmacro __using__ ( _opts ) do quote do def test ( x , y ) do x + y end defoverridable test : 2 end end end defmodule InheritMod do use DefaultMod def test ( x , y ) do x * y + super ( x , y ) end end As seen as in the example above, super can be used to call the default implementation. If @behaviour has been defined, defoverridable can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to defoverridable will be marked as overridable. Example defmodule Behaviour do @callback foo :: any end defmodule DefaultMod do defmacro __using__ ( _opts ) do quote do @behaviour Behaviour def foo do &quot;Override me&quot; end defoverridable Behaviour end end end defmodule InheritMod do use DefaultMod def foo do &quot;Overridden&quot; end end","ref":"Kernel.html#defoverridable/1","title":"Kernel.defoverridable/1","type":"macro"},{"doc":"Defines a private function with the given name and body. Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an UndefinedFunctionError exception. Check def/2 for more information. Examples defmodule Foo do def bar do sum ( 1 , 2 ) end defp sum ( a , b ) , do : a + b end Foo . bar ( ) #=&gt; 3 Foo . sum ( 1 , 2 ) ** (UndefinedFunctionError) undefined function Foo.sum/2","ref":"Kernel.html#defp/2","title":"Kernel.defp/2","type":"macro"},{"doc":"Defines a protocol. See the Protocol module for more information.","ref":"Kernel.html#defprotocol/2","title":"Kernel.defprotocol/2","type":"macro"},{"doc":"Defines a struct. A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions. To define a struct, a developer must define both __struct__/0 and __struct__/1 functions. defstruct/1 is a convenience macro which defines such functions with some conveniences. For more information about structs, please check Kernel.SpecialForms.%/2 . Examples defmodule User do defstruct name : nil , age : nil end Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, 10 + 11 is evaluated at compile-time and the age field is stored with value 21 : defmodule User do defstruct name : nil , age : 10 + 11 end The fields argument is usually a keyword list with field names as atom keys and default values as corresponding values. defstruct/1 also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to nil . defmodule Post do defstruct [ :title , :content , :author ] end Deriving Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the User struct leads to an error: john = % User { name : &quot;John&quot; } MyProtocol . call ( john ) ** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...} defstruct/1 , however, allows protocol implementations to be derived . This can be done by defining a @derive attribute as a list before invoking defstruct/1 : defmodule User do @derive [ MyProtocol ] defstruct name : nil , age : 10 + 11 end MyProtocol . call ( john ) # it works! For each protocol in the @derive list, Elixir will assert the protocol has been implemented for Any . If the Any implementation defines a __deriving__/3 callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the Any implementation is automatically derived. For more information on the __deriving__/3 callback, see Protocol.derive/3 . Enforcing keys When building a struct, Elixir will automatically guarantee all keys belongs to the struct: % User { name : &quot;john&quot; , unknown : :key } ** (KeyError) key :unknown not found in: %User{age: 21, name: nil} Elixir also allows developers to enforce certain keys must always be given when building the struct: defmodule User do @enforce_keys [ :name ] defstruct name : nil , age : 10 + 11 end Now trying to build a struct without the name key will fail: % User { age : 21 } ** (ArgumentError) the following keys must also be given when building struct User: [:name] Keep in mind @enforce_keys is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation. Types It is recommended to define types for structs. By convention such type is called t . To define a struct inside a type, the struct literal syntax is used: defmodule User do defstruct name : &quot;John&quot; , age : 25 @type t :: % __MODULE__ { name : String . t ( ) , age : non_neg_integer } end It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use User.t instead of %User{} . The types of the struct fields that are not included in %User{} default to term() (see term/0 ). Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the @opaque attribute. Structs whose internal structure is public should use @type .","ref":"Kernel.html#defstruct/1","title":"Kernel.defstruct/1","type":"macro"},{"doc":"Destructures two lists, assigning each term in the right one to the matching term in the left one. Unlike pattern matching via = , if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error. Examples iex&gt; destructure ( [ x , y , z ] , [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; { x , y , z } { 1 , 2 , 3 } In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to nil : iex&gt; destructure ( [ x , y , z ] , [ 1 ] ) iex&gt; { x , y , z } { 1 , nil , nil } The left-hand side supports any expression you would use on the left-hand side of a match: x = 1 destructure ( [ ^ x , y , z ] , [ 1 , 2 , 3 ] ) The example above will only work if x matches the first value in the right list. Otherwise, it will raise a MatchError (like the = operator would do).","ref":"Kernel.html#destructure/2","title":"Kernel.destructure/2","type":"macro"},{"doc":"Performs an integer division. Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . div/2 performs truncated integer division. This means that the result is always rounded towards zero. If you want to perform floored integer division (rounding towards negative infinity), use Integer.floor_div/2 instead. Allowed in guard tests. Inlined by the compiler. Examples div ( 5 , 2 ) #=&gt; 2 div ( 6 , - 4 ) #=&gt; -1 div ( - 99 , 2 ) #=&gt; -49 div ( 100 , 0 ) ** (ArithmeticError) bad argument in arithmetic expression","ref":"Kernel.html#div/2","title":"Kernel.div/2","type":"function"},{"doc":"Gets the element at the zero-based index in tuple . It raises ArgumentError when index is negative or it is out of range of the tuple elements. Allowed in guard tests. Inlined by the compiler. Examples tuple = { :foo , :bar , 3 } elem ( tuple , 1 ) #=&gt; :bar elem ( { } , 0 ) ** (ArgumentError) argument error elem ( { :foo , :bar } , 2 ) ** (ArgumentError) argument error","ref":"Kernel.html#elem/2","title":"Kernel.elem/2","type":"function"},{"doc":"Stops the execution of the calling process with the given reason. Since evaluating this function causes the process to terminate, it has no return value. Inlined by the compiler. Examples When a process reaches its end, by default it exits with reason :normal . You can also call exit/1 explicitly if you want to terminate a process but not signal any failure: exit ( :normal ) In case something goes wrong, you can also use exit/1 with a different reason: exit ( :seems_bad ) If the exit reason is not :normal , all the processes linked to the process that exited will crash (unless they are trapping exits). OTP exits Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered &quot;normal&quot;: exit(:normal) exit(:shutdown) exit({:shutdown, term}) Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, and so forth. This behaviour is relied on in many different places. For example, ExUnit uses exit(:shutdown) when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too. CLI exits Building on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0. It is, however, possible to customize the operating system exit signal by invoking: exit ( { :shutdown , integer } ) This will cause the operating system process to exit with the status given by integer while signaling all linked Erlang processes to politely shut down. Any other exit reason will cause the operating system process to exit with status 1 and linked Erlang processes to crash.","ref":"Kernel.html#exit/1","title":"Kernel.exit/1","type":"function"},{"doc":"Returns the largest integer smaller than or equal to number . If you want to perform floor operation on other decimal places, use Float.floor/2 instead. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#floor/1","title":"Kernel.floor/1","type":"function"},{"doc":"Returns true if module is loaded and contains a public function with the given arity , otherwise false . Note that this function does not load the module in case it is not loaded. Check Code.ensure_loaded/1 for more information. Inlined by the compiler. Examples iex&gt; function_exported? ( Enum , :map , 2 ) true iex&gt; function_exported? ( Enum , :map , 10 ) false iex&gt; function_exported? ( List , :to_string , 1 ) true","ref":"Kernel.html#function_exported?/3","title":"Kernel.function_exported?/3","type":"function"},{"doc":"Gets a value and updates a nested data structure via the given path . This is similar to get_and_update_in/3 , except the path is extracted via a macro rather than passing a list. For example: get_and_update_in ( opts [ :foo ] [ :bar ] , &amp; { &amp;1 , &amp;1 + 1 } ) Is equivalent to: get_and_update_in ( opts , [ :foo , :bar ] , &amp; { &amp;1 , &amp;1 + 1 } ) This also works with nested structs and the struct.path.to.value way to specify paths: get_and_update_in ( struct . foo . bar , &amp; { &amp;1 , &amp;1 + 1 } ) Note that in order for this macro to work, the complete path must always be visible by this macro. See the &quot;Paths&quot; section below. Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; get_and_update_in ( users [ &quot;john&quot; ] . age , &amp; { &amp;1 , &amp;1 + 1 } ) { 27 , %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } } Paths A path may start with a variable, local or remote call, and must be followed by one or more: foo[bar] - accesses the key bar in foo ; in case foo is nil, nil is returned foo.bar - accesses a map/struct field; in case the field is not present, an error is raised Here are some valid paths: users [ &quot;john&quot; ] [ :age ] users [ &quot;john&quot; ] . age User . all ( ) [ &quot;john&quot; ] . age all_users ( ) [ &quot;john&quot; ] . age Here are some invalid ones: # Does a remote call after the initial value users [ &quot;john&quot; ] . do_something ( arg1 , arg2 ) # Does not access any key or field users","ref":"Kernel.html#get_and_update_in/2","title":"Kernel.get_and_update_in/2","type":"macro"},{"doc":"Gets a value and updates a nested structure. data is a nested structure (that is, a map, keyword list, or struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present) and must return one of the following values: a two-element tuple {current_value, new_value} . In this case, current_value is the retrieved value which can possibly be operated on before being returned. new_value is the new value to be stored under key . :pop , which implies that the current value under key should be removed from the structure and returned. This function uses the Access module to traverse the structures according to the given keys , unless the key is a function, which is detailed in a later section. Examples This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass: iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; get_and_update_in ( users , [ &quot;john&quot; , :age ] , &amp; { &amp;1 , &amp;1 + 1 } ) { 27 , %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } } Functions as keys If a key is a function, the function will be invoked passing three arguments: the operation ( :get_and_update ) the data to be accessed a function to be invoked next This means get_and_update_in/3 can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures. When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list: iex&gt; users = [ %{ name : &quot;john&quot; , age : 27 } , %{ name : &quot;meg&quot; , age : 23 } ] iex&gt; all = fn :get_and_update , data , next -&gt; ...&gt; data |&gt; Enum . map ( next ) |&gt; Enum . unzip ( ) ...&gt; end iex&gt; get_and_update_in ( users , [ all , :age ] , &amp; { &amp;1 , &amp;1 + 1 } ) { [ 27 , 23 ] , [ %{ name : &quot;john&quot; , age : 28 } , %{ name : &quot;meg&quot; , age : 24 } ] } If the previous value before invoking the function is nil , the function will receive nil as a value and must handle it accordingly (be it by failing or providing a sane default). The Access module ships with many convenience accessor functions, like the all anonymous function defined above. See Access.all/0 , Access.key/2 , and others as examples.","ref":"Kernel.html#get_and_update_in/3","title":"Kernel.get_and_update_in/3","type":"function"},{"doc":"Gets a value from a nested structure. Uses the Access module to traverse the structures according to the given keys , unless the key is a function, which is detailed in a later section. Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; get_in ( users , [ &quot;john&quot; , :age ] ) 27 In case any of the keys returns nil , nil will be returned: iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; get_in ( users , [ &quot;unknown&quot; , :age ] ) nil Note that get_in exists mostly for convenience and parity with functionality found in put_in and update_in . Given Elixir provides pattern matching, it can often be more expressive for deep data traversal, for example: case users do %{ &quot;unknown&quot; = &gt; %{ age : age } } -&gt; age _ -&gt; default_value end Functions as keys If a key is a function, the function will be invoked passing three arguments: the operation ( :get ) the data to be accessed a function to be invoked next This means get_in/2 can be extended to provide custom lookups. In the example below, we use a function to get all the maps inside a list: iex&gt; users = [ %{ name : &quot;john&quot; , age : 27 } , %{ name : &quot;meg&quot; , age : 23 } ] iex&gt; all = fn :get , data , next -&gt; Enum . map ( data , next ) end iex&gt; get_in ( users , [ all , :age ] ) [ 27 , 23 ] If the previous value before invoking the function is nil , the function will receive nil as a value and must handle it accordingly. The Access module ships with many convenience accessor functions, like the all anonymous function defined above. See Access.all/0 , Access.key/2 , and others as examples. Working with structs By default, structs do not implement the Access behaviour required by this function. Therefore, you can't do this: get_in ( some_struct , [ :some_key , :nested_key ] ) The good news is that structs have predefined shape. Therefore, you can write instead: some_struct . some_key . nested_key If, by any chance, some_key can return nil, you can always fallback to pattern matching to provide nested struct handling: case some_struct do %{ some_key : %{ nested_key : value } } -&gt; value %{ } -&gt; nil end","ref":"Kernel.html#get_in/2","title":"Kernel.get_in/2","type":"function"},{"doc":"Returns the head of a list. Raises ArgumentError if the list is empty. It works with improper lists. Allowed in guard tests. Inlined by the compiler. Examples hd ( [ 1 , 2 , 3 , 4 ] ) #=&gt; 1 hd ( [ 1 | 2 ] ) #=&gt; 1 Giving it an empty list raises: tl ( [ ] ) #=&gt; ** (ArgumentError) argument error","ref":"Kernel.html#hd/1","title":"Kernel.hd/1","type":"function"},{"doc":"Provides an if/2 macro. This macro expects the first argument to be a condition and the second argument to be a keyword list. One-liner examples if ( foo , do : bar ) In the example above, bar will be returned if foo evaluates to a truthy value (neither false nor nil ). Otherwise, nil will be returned. An else option can be given to specify the opposite: if ( foo , do : bar , else : baz ) Blocks examples It's also possible to pass a block to the if/2 macro. The first example above would be translated to: if foo do bar end Note that do/end become delimiters. The second example would translate to: if foo do bar else baz end In order to compare more than two clauses, the cond/1 macro has to be used.","ref":"Kernel.html#if/2","title":"Kernel.if/2","type":"macro"},{"doc":"Membership operator. Checks if the element on the left-hand side is a member of the collection on the right-hand side. Examples iex&gt; x = 1 iex&gt; x in [ 1 , 2 , 3 ] true This operator (which is a macro) simply translates to a call to Enum.member?/2 . The example above would translate to: Enum . member? ( [ 1 , 2 , 3 ] , x ) Elixir also supports left not in right , which evaluates to not(left in right) : iex&gt; x = 1 iex&gt; x not in [ 1 , 2 , 3 ] false Guards The in/2 operator (as well as not in ) can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example: when x in [ 1 , 2 , 3 ] translates to: when x === 1 or x === 2 or x === 3 When using ranges: when x in 1 . . 3 translates to: when is_integer ( x ) and x &gt;= 1 and x &lt;= 3 Note that only integers can be considered inside a range by in . AST considerations left not in right is parsed by the compiler into the AST: { :not , _ , [ { :in , _ , [ left , right ] } ] } This is the same AST as not(left in right) . Additionally, Macro.to_string/2 and Code.format_string!/2 will translate all occurrences of this AST to left not in right .","ref":"Kernel.html#in/2","title":"Kernel.in/2","type":"macro"},{"doc":"Inspects the given argument according to the Inspect protocol. The second argument is a keyword list with options to control inspection. Options inspect/2 accepts a list of options that are internally translated to an Inspect.Opts struct. Check the docs for Inspect.Opts to see the supported options. Examples iex&gt; inspect ( :foo ) &quot;:foo&quot; iex&gt; inspect ( [ 1 , 2 , 3 , 4 , 5 ] , limit : 3 ) &quot;[1, 2, 3, ...]&quot; iex&gt; inspect ( [ 1 , 2 , 3 ] , pretty : true , width : 0 ) &quot;[1, \\n 2, \\n 3]&quot; iex&gt; inspect ( &quot;olá&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; ) &quot;&lt;&lt;111, 108, 195, 161, 0&gt;&gt;&quot; iex&gt; inspect ( &quot;olá&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; , binaries : :as_strings ) &quot; \\&quot; olá \\\\ 0 \\&quot; &quot; iex&gt; inspect ( &quot;olá&quot; , binaries : :as_binaries ) &quot;&lt;&lt;111, 108, 195, 161&gt;&gt;&quot; iex&gt; inspect ( &#39;bar&#39; ) &quot;&#39;bar&#39;&quot; iex&gt; inspect ( [ 0 | &#39;bar&#39; ] ) &quot;[0, 98, 97, 114]&quot; iex&gt; inspect ( 100 , base : :octal ) &quot;0o144&quot; iex&gt; inspect ( 100 , base : :hex ) &quot;0x64&quot; Note that the Inspect protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with # . For example, inspecting a function will return: inspect ( fn a , b -&gt; a + b end ) #=&gt; #Function&lt;...&gt; The Inspect protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the Inspect protocol for more information.","ref":"Kernel.html#inspect/2","title":"Kernel.inspect/2","type":"function"},{"doc":"Returns true if term is an atom; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_atom/1","title":"Kernel.is_atom/1","type":"function"},{"doc":"Returns true if term is a binary; otherwise returns false . A binary always contains a complete number of bytes. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_binary ( &quot;foo&quot; ) true iex&gt; is_binary ( &lt;&lt; 1 :: 3 &gt;&gt; ) false","ref":"Kernel.html#is_binary/1","title":"Kernel.is_binary/1","type":"function"},{"doc":"Returns true if term is a bitstring (including a binary); otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_bitstring ( &quot;foo&quot; ) true iex&gt; is_bitstring ( &lt;&lt; 1 :: 3 &gt;&gt; ) true","ref":"Kernel.html#is_bitstring/1","title":"Kernel.is_bitstring/1","type":"function"},{"doc":"Returns true if term is either the atom true or the atom false (i.e., a boolean); otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_boolean/1","title":"Kernel.is_boolean/1","type":"function"},{"doc":"Returns true if term is an exception; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_exception ( % RuntimeError { } ) true iex&gt; is_exception ( %{ } ) false","ref":"Kernel.html#is_exception/1","title":"Kernel.is_exception/1","type":"macro"},{"doc":"Returns true if term is an exception of name ; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_exception ( % RuntimeError { } , RuntimeError ) true iex&gt; is_exception ( % RuntimeError { } , Macro.Env ) false","ref":"Kernel.html#is_exception/2","title":"Kernel.is_exception/2","type":"macro"},{"doc":"Returns true if term is a floating-point number; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_float/1","title":"Kernel.is_float/1","type":"function"},{"doc":"Returns true if term is a function; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_function/1","title":"Kernel.is_function/1","type":"function"},{"doc":"Returns true if term is a function that can be applied with arity number of arguments; otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_function ( fn x -&gt; x * 2 end , 1 ) true iex&gt; is_function ( fn x -&gt; x * 2 end , 2 ) false","ref":"Kernel.html#is_function/2","title":"Kernel.is_function/2","type":"function"},{"doc":"Returns true if term is an integer; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_integer/1","title":"Kernel.is_integer/1","type":"function"},{"doc":"Returns true if term is a list with zero or more elements; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_list/1","title":"Kernel.is_list/1","type":"function"},{"doc":"Returns true if term is a map; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_map/1","title":"Kernel.is_map/1","type":"function"},{"doc":"Returns true if key is a key in map ; otherwise returns false . It raises BadMapError if the first element is not a map. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_map_key/2","title":"Kernel.is_map_key/2","type":"function"},{"doc":"Returns true if term is nil , false otherwise. Allowed in guard clauses. Examples iex&gt; is_nil ( 1 ) false iex&gt; is_nil ( nil ) true","ref":"Kernel.html#is_nil/1","title":"Kernel.is_nil/1","type":"macro"},{"doc":"Returns true if term is either an integer or a floating-point number; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_number/1","title":"Kernel.is_number/1","type":"function"},{"doc":"Returns true if term is a PID (process identifier); otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_pid/1","title":"Kernel.is_pid/1","type":"function"},{"doc":"Returns true if term is a port identifier; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_port/1","title":"Kernel.is_port/1","type":"function"},{"doc":"Returns true if term is a reference; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_reference/1","title":"Kernel.is_reference/1","type":"function"},{"doc":"Returns true if term is a struct; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_struct ( URI . parse ( &quot;/&quot; ) ) true iex&gt; is_struct ( %{ } ) false","ref":"Kernel.html#is_struct/1","title":"Kernel.is_struct/1","type":"macro"},{"doc":"Returns true if term is a struct of name ; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_struct ( URI . parse ( &quot;/&quot; ) , URI ) true iex&gt; is_struct ( URI . parse ( &quot;/&quot; ) , Macro.Env ) false","ref":"Kernel.html#is_struct/2","title":"Kernel.is_struct/2","type":"macro"},{"doc":"Returns true if term is a tuple; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_tuple/1","title":"Kernel.is_tuple/1","type":"function"},{"doc":"Returns the length of list . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; length ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) 9","ref":"Kernel.html#length/1","title":"Kernel.length/1","type":"function"},{"doc":"Returns true if module is loaded and contains a public macro with the given arity , otherwise false . Note that this function does not load the module in case it is not loaded. Check Code.ensure_loaded/1 for more information. If module is an Erlang module (as opposed to an Elixir module), this function always returns false . Examples iex&gt; macro_exported? ( Kernel , :use , 2 ) true iex&gt; macro_exported? ( :erlang , :abs , 1 ) false","ref":"Kernel.html#macro_exported?/3","title":"Kernel.macro_exported?/3","type":"function"},{"doc":"Returns an almost unique reference. The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes. Inlined by the compiler. Examples make_ref ( ) #=&gt; #Reference&lt;0.0.0.135&gt;","ref":"Kernel.html#make_ref/0","title":"Kernel.make_ref/0","type":"function"},{"doc":"Returns the size of a map. The size of a map is the number of key-value pairs that the map contains. This operation happens in constant time. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; map_size ( %{ a : &quot;foo&quot; , b : &quot;bar&quot; } ) 2","ref":"Kernel.html#map_size/1","title":"Kernel.map_size/1","type":"function"},{"doc":"A convenience macro that checks if the right side (an expression) matches the left side (a pattern). Examples iex&gt; match? ( 1 , 1 ) true iex&gt; match? ( { 1 , _ } , { 1 , 2 } ) true iex&gt; map = %{ a : 1 , b : 2 } iex&gt; match? ( %{ a : _ } , map ) true iex&gt; a = 1 iex&gt; match? ( ^ a , 1 ) true match?/2 is very useful when filtering or finding a value in an enumerable: iex&gt; list = [ a : 1 , b : 2 , a : 3 ] iex&gt; Enum . filter ( list , &amp; match? ( { :a , _ } , &amp;1 ) ) [ a : 1 , a : 3 ] Guard clauses can also be given to the match: iex&gt; list = [ a : 1 , b : 2 , a : 3 ] iex&gt; Enum . filter ( list , &amp; match? ( { :a , x } when x &lt; 2 , &amp;1 ) ) [ a : 1 ] However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the = operator): iex&gt; match? ( _x , 1 ) true iex&gt; binding ( ) [ ]","ref":"Kernel.html#match?/2","title":"Kernel.match?/2","type":"macro"},{"doc":"Returns the biggest of the two given terms according to their structural comparison. If the terms compare equal, the first one is returned. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Inlined by the compiler. Examples iex&gt; max ( 1 , 2 ) 2 iex&gt; max ( :a , :b ) :b","ref":"Kernel.html#max/2","title":"Kernel.max/2","type":"function"},{"doc":"Returns the smallest of the two given terms according to their structural comparison. If the terms compare equal, the first one is returned. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Inlined by the compiler. Examples iex&gt; min ( 1 , 2 ) 1 iex&gt; min ( &quot;foo&quot; , &quot;bar&quot; ) &quot;bar&quot;","ref":"Kernel.html#min/2","title":"Kernel.min/2","type":"function"},{"doc":"Returns an atom representing the name of the local node. If the node is not alive, :nonode@nohost is returned instead. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#node/0","title":"Kernel.node/0","type":"function"},{"doc":"Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, :nonode@nohost is returned. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#node/1","title":"Kernel.node/1","type":"function"},{"doc":"Strictly boolean &quot;not&quot; operator. value must be a boolean; if it's not, an ArgumentError exception is raised. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; not false true","ref":"Kernel.html#not/1","title":"Kernel.not/1","type":"function"},{"doc":"Strictly boolean &quot;or&quot; operator. If left is true , returns true ; otherwise returns right . Requires only the left operand to be a boolean since it short-circuits. If the left operand is not a boolean, a BadBooleanError exception is raised. Allowed in guard tests. Examples iex&gt; true or false true iex&gt; false or 42 42 iex&gt; 42 or false ** (BadBooleanError) expected a boolean on left-side of &quot;or&quot;, got: 42","ref":"Kernel.html#or/2","title":"Kernel.or/2","type":"macro"},{"doc":"Pops a key from the nested structure via the given path . This is similar to pop_in/2 , except the path is extracted via a macro rather than passing a list. For example: pop_in ( opts [ :foo ] [ :bar ] ) Is equivalent to: pop_in ( opts , [ :foo , :bar ] ) Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs. Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; pop_in ( users [ &quot;john&quot; ] [ :age ] ) { 27 , %{ &quot;john&quot; = &gt; %{ } , &quot;meg&quot; = &gt; %{ age : 23 } } } iex&gt; users = %{ john : %{ age : 27 } , meg : %{ age : 23 } } iex&gt; pop_in ( users . john [ :age ] ) { 27 , %{ john : %{ } , meg : %{ age : 23 } } } In case any entry returns nil , its key will be removed and the deletion will be considered a success.","ref":"Kernel.html#pop_in/1","title":"Kernel.pop_in/1","type":"macro"},{"doc":"Pops a key from the given nested structure. Uses the Access protocol to traverse the structures according to the given keys , unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3 . Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; pop_in ( users , [ &quot;john&quot; , :age ] ) { 27 , %{ &quot;john&quot; = &gt; %{ } , &quot;meg&quot; = &gt; %{ age : 23 } } } In case any entry returns nil , its key will be removed and the deletion will be considered a success. iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; pop_in ( users , [ &quot;jane&quot; , :age ] ) { nil , %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } }","ref":"Kernel.html#pop_in/2","title":"Kernel.pop_in/2","type":"function"},{"doc":"Puts value at the given zero-based index in tuple . Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar , 3 } iex&gt; put_elem ( tuple , 0 , :baz ) { :baz , :bar , 3 }","ref":"Kernel.html#put_elem/3","title":"Kernel.put_elem/3","type":"function"},{"doc":"Puts a value in a nested structure via the given path . This is similar to put_in/3 , except the path is extracted via a macro rather than passing a list. For example: put_in ( opts [ :foo ] [ :bar ] , :baz ) Is equivalent to: put_in ( opts , [ :foo , :bar ] , :baz ) This also works with nested structs and the struct.path.to.value way to specify paths: put_in ( struct . foo . bar , :baz ) Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs. Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] [ :age ] , 28 ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] . age , 28 ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } }","ref":"Kernel.html#put_in/2","title":"Kernel.put_in/2","type":"macro"},{"doc":"Puts a value in a nested structure. Uses the Access module to traverse the structures according to the given keys , unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3 . Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; put_in ( users , [ &quot;john&quot; , :age ] , 28 ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } In case any of the entries in the middle returns nil , an error will be raised when trying to access it next.","ref":"Kernel.html#put_in/3","title":"Kernel.put_in/3","type":"function"},{"doc":"Raises an exception. If message is a string, it raises a RuntimeError exception with it. If message is an atom, it just calls raise/2 with the atom as the first argument and [] as the second one. If message is an exception struct, it is raised as is. If message is anything else, raise will fail with an ArgumentError exception. Examples iex&gt; raise &quot;oops&quot; ** (RuntimeError) oops try do 1 + :foo rescue x in [ ArithmeticError ] -&gt; IO . puts ( &quot;that was expected&quot; ) raise x end","ref":"Kernel.html#raise/1","title":"Kernel.raise/1","type":"macro"},{"doc":"Raises an exception. Calls the exception/1 function on the given argument (which has to be a module name like ArgumentError or RuntimeError ) passing attributes in order to retrieve the exception struct. Any module that contains a call to the defexception/1 macro automatically implements the Exception.exception/1 callback expected by raise/2 . For more information, see defexception/1 . Examples iex&gt; raise ( ArgumentError , &quot;Sample&quot; ) ** (ArgumentError) Sample","ref":"Kernel.html#raise/2","title":"Kernel.raise/2","type":"macro"},{"doc":"Computes the remainder of an integer division. rem/2 uses truncated division, which means that the result will always have the sign of the dividend . Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; rem ( 5 , 2 ) 1 iex&gt; rem ( 6 , - 4 ) 2","ref":"Kernel.html#rem/2","title":"Kernel.rem/2","type":"function"},{"doc":"Raises an exception preserving a previous stacktrace. Works like raise/1 but does not generate a new stacktrace. Note that __STACKTRACE__ can be used inside catch/rescue to retrieve the current stacktrace. Examples try do raise &quot;oops&quot; rescue exception -&gt; reraise exception , __STACKTRACE__ end","ref":"Kernel.html#reraise/2","title":"Kernel.reraise/2","type":"macro"},{"doc":"Raises an exception preserving a previous stacktrace. reraise/3 works like reraise/2 , except it passes arguments to the exception/1 function as explained in raise/2 . Examples try do raise &quot;oops&quot; rescue exception -&gt; reraise WrapperError , [ exception : exception ] , __STACKTRACE__ end","ref":"Kernel.html#reraise/3","title":"Kernel.reraise/3","type":"macro"},{"doc":"Rounds a number to the nearest integer. If the number is equidistant to the two nearest integers, rounds away from zero. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; round ( 5.6 ) 6 iex&gt; round ( 5.2 ) 5 iex&gt; round ( - 9.9 ) - 10 iex&gt; round ( - 9 ) - 9 iex&gt; round ( 2.5 ) 3 iex&gt; round ( - 2.5 ) - 3","ref":"Kernel.html#round/1","title":"Kernel.round/1","type":"function"},{"doc":"Returns the PID (process identifier) of the calling process. Allowed in guard clauses. Inlined by the compiler.","ref":"Kernel.html#self/0","title":"Kernel.self/0","type":"function"},{"doc":"Sends a message to the given dest and returns the message. dest may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node. Inlined by the compiler. Examples iex&gt; send ( self ( ) , :hello ) :hello","ref":"Kernel.html#send/2","title":"Kernel.send/2","type":"function"},{"doc":"Handles the sigil ~C for charlists. It returns a charlist without interpolations and without escape characters, except for the escaping of the closing sigil character itself. Examples iex&gt; ~C(foo) &#39;foo&#39; iex&gt; ~C(f\#{o}o) &#39;f \\# {o}o&#39;","ref":"Kernel.html#sigil_C/2","title":"Kernel.sigil_C/2","type":"macro"},{"doc":"Handles the sigil ~D for dates. By default, this sigil uses the built-in Calendar.ISO , which requires dates to be written in the ISO8601 format: ~D[yyyy-mm-dd] such as: ~D[2015-01-13] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~D[SOME-REPRESENTATION My.Alternative.Calendar] The lower case ~d variant does not exist as interpolation and escape characters are not useful for date sigils. More information on dates can be found in the Date module. Examples iex&gt; ~D[2015-01-13] ~D[2015-01-13]","ref":"Kernel.html#sigil_D/2","title":"Kernel.sigil_D/2","type":"macro"},{"doc":"Handles the sigil ~N for naive date times. By default, this sigil uses the built-in Calendar.ISO , which requires naive date times to be written in the ISO8601 format: ~N[yyyy-mm-dd hh:mm:ss] ~N[yyyy-mm-dd hh:mm:ss.ssssss] ~N[yyyy-mm-ddThh:mm:ss.ssssss] such as: ~N[2015-01-13 13:00:07] ~N[2015-01-13T13:00:07.123] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~N[SOME-REPRESENTATION My.Alternative.Calendar] The lower case ~n variant does not exist as interpolation and escape characters are not useful for date time sigils. More information on naive date times can be found in the NaiveDateTime module. Examples iex&gt; ~N[2015-01-13 13:00:07] ~N[2015-01-13 13:00:07] iex&gt; ~N[2015-01-13T13:00:07.001] ~N[2015-01-13 13:00:07.001]","ref":"Kernel.html#sigil_N/2","title":"Kernel.sigil_N/2","type":"macro"},{"doc":"Handles the sigil ~R for regular expressions. It returns a regular expression pattern without interpolations and without escape characters. Note it still supports escape of Regex tokens (such as escaping + or ? ) and it also requires you to escape the closing sigil character itself if it appears on the Regex. More information on regexes can be found in the Regex module. Examples iex&gt; Regex . match? ( ~R(f\#{1,3}o) , &quot;f#o&quot; ) true","ref":"Kernel.html#sigil_R/2","title":"Kernel.sigil_R/2","type":"macro"},{"doc":"Handles the sigil ~S for strings. It returns a string without interpolations and without escape characters, except for the escaping of the closing sigil character itself. Examples iex&gt; ~S(foo) &quot;foo&quot; iex&gt; ~S(f\#{o}o) &quot;f \\# {o}o&quot; iex&gt; ~S(\\o/) &quot; \\\\ o/&quot; However, if you want to re-use the sigil character itself on the string, you need to escape it: iex&gt; ~S((\\)) &quot;()&quot;","ref":"Kernel.html#sigil_S/2","title":"Kernel.sigil_S/2","type":"macro"},{"doc":"Handles the sigil ~T for times. By default, this sigil uses the built-in Calendar.ISO , which requires times to be written in the ISO8601 format: ~T[hh:mm:ss] ~T[hh:mm:ss.ssssss] such as: ~T[13:00:07] ~T[13:00:07.123] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~T[SOME-REPRESENTATION My.Alternative.Calendar] The lower case ~t variant does not exist as interpolation and escape characters are not useful for time sigils. More information on times can be found in the Time module. Examples iex&gt; ~T[13:00:07] ~T[13:00:07] iex&gt; ~T[13:00:07.001] ~T[13:00:07.001]","ref":"Kernel.html#sigil_T/2","title":"Kernel.sigil_T/2","type":"macro"},{"doc":"Handles the sigil ~U to create a UTC DateTime . By default, this sigil uses the built-in Calendar.ISO , which requires UTC date times to be written in the ISO8601 format: ~U[yyyy-mm-dd hh:mm:ssZ] ~U[yyyy-mm-dd hh:mm:ss.ssssssZ] ~U[yyyy-mm-ddThh:mm:ss.ssssss+00:00] such as: ~U[2015-01-13 13:00:07Z] ~U[2015-01-13T13:00:07.123+00:00] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~U[SOME-REPRESENTATION My.Alternative.Calendar] The given datetime_string must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised. The lower case ~u variant does not exist as interpolation and escape characters are not useful for date time sigils. More information on date times can be found in the DateTime module. Examples iex&gt; ~U[2015-01-13 13:00:07Z] ~U[2015-01-13 13:00:07Z] iex&gt; ~U[2015-01-13T13:00:07.001+00:00] ~U[2015-01-13 13:00:07.001Z]","ref":"Kernel.html#sigil_U/2","title":"Kernel.sigil_U/2","type":"macro"},{"doc":"Handles the sigil ~W for list of words. It returns a list of &quot;words&quot; split by whitespace without interpolations and without escape characters, except for the escaping of the closing sigil character itself. Modifiers s : words in the list are strings (default) a : words in the list are atoms c : words in the list are charlists Examples iex&gt; ~W(foo \#{bar} baz) [ &quot;foo&quot; , &quot; \\# {bar}&quot; , &quot;baz&quot; ]","ref":"Kernel.html#sigil_W/2","title":"Kernel.sigil_W/2","type":"macro"},{"doc":"Handles the sigil ~c for charlists. It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations. Examples iex&gt; ~c(foo) &#39;foo&#39; iex&gt; ~c(f \#{ :o } o) &#39;foo&#39; iex&gt; ~c(f \\# {:o}o) &#39;f \\# {:o}o&#39;","ref":"Kernel.html#sigil_c/2","title":"Kernel.sigil_c/2","type":"macro"},{"doc":"Handles the sigil ~r for regular expressions. It returns a regular expression pattern, unescaping characters and replacing interpolations. More information on regular expressions can be found in the Regex module. Examples iex&gt; Regex . match? ( ~r(foo) , &quot;foo&quot; ) true iex&gt; Regex . match? ( ~r/abc/ , &quot;abc&quot; ) true","ref":"Kernel.html#sigil_r/2","title":"Kernel.sigil_r/2","type":"macro"},{"doc":"Handles the sigil ~s for strings. It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations. Examples iex&gt; ~s(foo) &quot;foo&quot; iex&gt; ~s(f \#{ :o } o) &quot;foo&quot; iex&gt; ~s(f \\# {:o}o) &quot;f \\# {:o}o&quot;","ref":"Kernel.html#sigil_s/2","title":"Kernel.sigil_s/2","type":"macro"},{"doc":"Handles the sigil ~w for list of words. It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word. Modifiers s : words in the list are strings (default) a : words in the list are atoms c : words in the list are charlists Examples iex&gt; ~w(foo \#{ :bar } baz) [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] iex&gt; ~w(foo \#{ &quot; bar baz &quot; } ) [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] iex&gt; ~w(--source test/enum_test.exs) [ &quot;--source&quot; , &quot;test/enum_test.exs&quot; ] iex&gt; ~w(foo bar baz)a [ :foo , :bar , :baz ]","ref":"Kernel.html#sigil_w/2","title":"Kernel.sigil_w/2","type":"macro"},{"doc":"Spawns the given function and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. The anonymous function receives 0 arguments, and may return any value. Inlined by the compiler. Examples current = self ( ) child = spawn ( fn -&gt; send ( current , { self ( ) , 1 + 2 } ) end ) receive do { ^ child , 3 } -&gt; IO . puts ( &quot;Received 3 back&quot; ) end","ref":"Kernel.html#spawn/1","title":"Kernel.spawn/1","type":"function"},{"doc":"Spawns the given function fun from the given module passing it the given args and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. Inlined by the compiler. Examples spawn ( SomeModule , :function , [ 1 , 2 , 3 ] )","ref":"Kernel.html#spawn/3","title":"Kernel.spawn/3","type":"function"},{"doc":"Spawns the given function, links it to the current process, and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. For more information on linking, check Process.link/1 . The anonymous function receives 0 arguments, and may return any value. Inlined by the compiler. Examples current = self ( ) child = spawn_link ( fn -&gt; send ( current , { self ( ) , 1 + 2 } ) end ) receive do { ^ child , 3 } -&gt; IO . puts ( &quot;Received 3 back&quot; ) end","ref":"Kernel.html#spawn_link/1","title":"Kernel.spawn_link/1","type":"function"},{"doc":"Spawns the given function fun from the given module passing it the given args , links it to the current process, and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. For more information on linking, check Process.link/1 . Inlined by the compiler. Examples spawn_link ( SomeModule , :function , [ 1 , 2 , 3 ] )","ref":"Kernel.html#spawn_link/3","title":"Kernel.spawn_link/3","type":"function"},{"doc":"Spawns the given function, monitors it and returns its PID and monitoring reference. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. The anonymous function receives 0 arguments, and may return any value. Inlined by the compiler. Examples current = self ( ) spawn_monitor ( fn -&gt; send ( current , { self ( ) , 1 + 2 } ) end )","ref":"Kernel.html#spawn_monitor/1","title":"Kernel.spawn_monitor/1","type":"function"},{"doc":"Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. Inlined by the compiler. Examples spawn_monitor ( SomeModule , :function , [ 1 , 2 , 3 ] )","ref":"Kernel.html#spawn_monitor/3","title":"Kernel.spawn_monitor/3","type":"function"},{"doc":"Creates and updates a struct. The struct argument may be an atom (which defines defstruct ) or a struct itself. The second argument is any Enumerable that emits two-element tuples (key-value pairs) during enumeration. Keys in the Enumerable that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct. If keys in the Enumerable are duplicated, the last entry will be taken (same behaviour as Map.new/1 ). This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate :__struct__ field into the map may not be enough and struct/2 should be used instead. Examples defmodule User do defstruct name : &quot;john&quot; end struct ( User ) #=&gt; %User{name: &quot;john&quot;} opts = [ name : &quot;meg&quot; ] user = struct ( User , opts ) #=&gt; %User{name: &quot;meg&quot;} struct ( user , unknown : &quot;value&quot; ) #=&gt; %User{name: &quot;meg&quot;} struct ( User , %{ name : &quot;meg&quot; } ) #=&gt; %User{name: &quot;meg&quot;} # String keys are ignored struct ( User , %{ &quot;name&quot; = &gt; &quot;meg&quot; } ) #=&gt; %User{name: &quot;john&quot;}","ref":"Kernel.html#struct/2","title":"Kernel.struct/2","type":"function"},{"doc":"Similar to struct/2 but checks for key validity. The function struct!/2 emulates the compile time behaviour of structs. This means that: when building a struct, as in struct!(SomeStruct, key: :value) , it is equivalent to %SomeStruct{key: :value} and therefore this function will check if every given key-value belongs to the struct. If the struct is enforcing any key via @enforce_keys , those will be enforced as well; when updating a struct, as in struct!(%SomeStruct{}, key: :value) , it is equivalent to %SomeStruct{struct | key: :value} and therefore this function will check if every given key-value belongs to the struct. However, updating structs does not enforce keys, as keys are enforced only when building;","ref":"Kernel.html#struct!/2","title":"Kernel.struct!/2","type":"function"},{"doc":"Pipes value to the given fun and returns the value itself. Useful for running synchronous side effects in a pipeline. Examples iex&gt; tap ( 1 , fn x -&gt; x + 1 end ) 1 Most commonly, this is used in pipelines. For example, let's suppose you want to inspect part of a data structure. You could write: %{ a : 1 } |&gt; Map . update! ( :a , &amp; &amp;1 + 2 ) |&gt; tap ( &amp; IO . inspect ( &amp;1 . a ) ) |&gt; Map . update! ( :a , &amp; &amp;1 * 2 )","ref":"Kernel.html#tap/2","title":"Kernel.tap/2","type":"macro"},{"doc":"Pipes value into the given fun . In other words, it invokes fun with value as argument. This is most commonly used in pipelines, allowing you to pipe a value to a function outside of its first argument. Examples iex&gt; 1 |&gt; then ( fn x -&gt; x * 2 end ) 2","ref":"Kernel.html#then/2","title":"Kernel.then/2","type":"macro"},{"doc":"A non-local return from a function. Check Kernel.SpecialForms.try/1 for more information. Inlined by the compiler.","ref":"Kernel.html#throw/1","title":"Kernel.throw/1","type":"function"},{"doc":"Returns the tail of a list. Raises ArgumentError if the list is empty. It works with improper lists. Allowed in guard tests. Inlined by the compiler. Examples tl ( [ 1 , 2 , 3 , :go ] ) #=&gt; [2, 3, :go] tl ( [ :one ] ) #=&gt; [] tl ( [ :a , :b | :c ] ) #=&gt; [:b | :c] tl ( [ :a | %{ b : 1 } ] ) #=&gt; %{b: 1} Giving it an empty list raises: tl ( [ ] ) #=&gt; ** (ArgumentError) argument error","ref":"Kernel.html#tl/1","title":"Kernel.tl/1","type":"function"},{"doc":"Converts the given term to a charlist according to the List.Chars protocol. Examples iex&gt; to_charlist ( :foo ) &#39;foo&#39;","ref":"Kernel.html#to_charlist/1","title":"Kernel.to_charlist/1","type":"macro"},{"doc":"Converts the argument to a string according to the String.Chars protocol. This is the function invoked when there is string interpolation. Examples iex&gt; to_string ( :foo ) &quot;foo&quot;","ref":"Kernel.html#to_string/1","title":"Kernel.to_string/1","type":"macro"},{"doc":"Returns the integer part of number . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; trunc ( 5.4 ) 5 iex&gt; trunc ( - 5.99 ) - 5 iex&gt; trunc ( - 5 ) - 5","ref":"Kernel.html#trunc/1","title":"Kernel.trunc/1","type":"function"},{"doc":"Returns the size of a tuple. This operation happens in constant time. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; tuple_size ( { :a , :b , :c } ) 3","ref":"Kernel.html#tuple_size/1","title":"Kernel.tuple_size/1","type":"function"},{"doc":"Provides an unless macro. This macro evaluates and returns the do block passed in as the second argument if condition evaluates to a falsy value ( false or nil ). Otherwise, it returns the value of the else block if present or nil if not. See also if/2 . Examples iex&gt; unless ( Enum . empty? ( [ ] ) , do : &quot;Hello&quot; ) nil iex&gt; unless ( Enum . empty? ( [ 1 , 2 , 3 ] ) , do : &quot;Hello&quot; ) &quot;Hello&quot; iex&gt; unless Enum . sum ( [ 2 , 2 ] ) == 5 do ...&gt; &quot;Math still works&quot; ...&gt; else ...&gt; &quot;Math is broken&quot; ...&gt; end &quot;Math still works&quot;","ref":"Kernel.html#unless/2","title":"Kernel.unless/2","type":"macro"},{"doc":"Updates a nested structure via the given path . This is similar to update_in/3 , except the path is extracted via a macro rather than passing a list. For example: update_in ( opts [ :foo ] [ :bar ] , &amp; ( &amp;1 + 1 ) ) Is equivalent to: update_in ( opts , [ :foo , :bar ] , &amp; ( &amp;1 + 1 ) ) This also works with nested structs and the struct.path.to.value way to specify paths: update_in ( struct . foo . bar , &amp; ( &amp;1 + 1 ) ) Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs. Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; update_in ( users [ &quot;john&quot; ] [ :age ] , &amp; ( &amp;1 + 1 ) ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; update_in ( users [ &quot;john&quot; ] . age , &amp; ( &amp;1 + 1 ) ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } }","ref":"Kernel.html#update_in/2","title":"Kernel.update_in/2","type":"macro"},{"doc":"Updates a key in a nested structure. Uses the Access module to traverse the structures according to the given keys , unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3 . data is a nested structure (that is, a map, keyword list, or struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present) and the result replaces the value in the structure. Examples iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; update_in ( users , [ &quot;john&quot; , :age ] , &amp; ( &amp;1 + 1 ) ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } In case any of the entries in the middle returns nil , an error will be raised when trying to access it next.","ref":"Kernel.html#update_in/3","title":"Kernel.update_in/3","type":"function"},{"doc":"Uses the given module in the current context. When calling: use MyModule , some : :options the __using__/1 macro from the MyModule module is invoked with the second argument passed to use as its argument. Since __using__/1 is a macro, all the usual macro rules apply, and its return value should be quoted code that is then inserted where use/2 is called. Examples For example, to write test cases using the ExUnit framework provided with Elixir, a developer should use the ExUnit.Case module: defmodule AssertionTest do use ExUnit.Case , async : true test &quot;always pass&quot; do assert true end end In this example, Elixir will call the __using__/1 macro in the ExUnit.Case module with the keyword list [async: true] as its argument. In other words, use/2 translates to: defmodule AssertionTest do require ExUnit.Case ExUnit.Case . __using__ ( async : true ) test &quot;always pass&quot; do assert true end end where ExUnit.Case defines the __using__/1 macro: defmodule ExUnit.Case do defmacro __using__ ( opts ) do # do something with opts quote do # return some code to inject in the caller end end end Best practices __using__/1 is typically used when there is a need to set some state (via module attributes) or callbacks (like @before_compile , see the documentation for Module for more information) into the caller. __using__/1 may also be used to alias, require, or import functionality from different modules: defmodule MyModule do defmacro __using__ ( _opts ) do quote do import MyModule.Foo import MyModule.Bar import MyModule.Baz alias MyModule.Repo end end end However, do not provide __using__/1 if all it does is to import, alias or require the module itself. For example, avoid this: defmodule MyModule do defmacro __using__ ( _opts ) do quote do import MyModule end end end In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind use/2 . Finally, developers should also avoid defining functions inside the __using__/1 callback, unless those functions are the default implementation of a previously defined @callback or are functions meant to be overridden (see defoverridable/1 ). Even in these cases, defining functions should be seen as a &quot;last resort&quot;. In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, ExUnit.Case doesn't define the test/3 macro in the module that calls use ExUnit.Case , but it defines ExUnit.Case.test/3 and just imports that into the caller when used.","ref":"Kernel.html#use/2","title":"Kernel.use/2","type":"macro"},{"doc":"Marks that the given variable should not be hygienized. This macro expects a variable and it is typically invoked inside Kernel.SpecialForms.quote/2 to mark that a variable should not be hygienized. See Kernel.SpecialForms.quote/2 for more information. Examples iex&gt; Kernel . var! ( example ) = 1 1 iex&gt; Kernel . var! ( example ) 1","ref":"Kernel.html#var!/2","title":"Kernel.var!/2","type":"macro"},{"doc":"Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer. The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module. These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2 ). The macros {}/1 and &lt;&lt;&gt;&gt;/1 are also special forms used to define tuple and binary data structures respectively. This module also documents macros that return information about Elixir's compilation environment, such as ( __ENV__/0 , __MODULE__/0 , __DIR__/0 , __STACKTRACE__/0 , and __CALLER__/0 ). Additionally, it documents two special forms, __block__/1 and __aliases__/1 , which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.","ref":"Kernel.SpecialForms.html","title":"Kernel.SpecialForms","type":"module"},{"doc":"Matches on or builds a struct. A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions. Structs are usually defined with the Kernel.defstruct/1 macro: defmodule User do defstruct name : &quot;john&quot; , age : 27 end Now a struct can be created as follows: % User { } Underneath a struct is just a map with a :__struct__ key pointing to the User module: % User { } == %{ __struct__ : User , name : &quot;john&quot; , age : 27 } The struct fields can be given when building the struct: % User { age : 31 } #=&gt; %{__struct__: User, name: &quot;john&quot;, age: 31} Or also on pattern matching to extract values out: % User { age : age } = user An update operation specific for structs is also available: % User { user | age : 28 } The advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key :full_name in the User struct: % User { full_name : &quot;john doe&quot; } The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with BadStructError otherwise. Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check Kernel.defprotocol/2 for more information on how structs can be used with protocols for polymorphic dispatch. Also see Kernel.struct/2 and Kernel.struct!/2 for examples on how to create and update structs dynamically. Pattern matching on struct names Besides allowing pattern matching on struct fields, such as: % User { age : age } = user Structs also allow pattern matching on the struct name: % struct_name { } = user struct_name #=&gt; User You can also assign the struct name to _ when you want to check if something is a struct but you are not interested in its name: % _ { } = user","ref":"Kernel.SpecialForms.html#%25/2","title":"Kernel.SpecialForms.%/2","type":"macro"},{"doc":"Creates a map. See the Map module for more information about maps, their syntax, and ways to access and manipulate them. AST representation Regardless of whether =&gt; or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity: iex&gt; quote do ...&gt; %{ &quot;a&quot; = &gt; :b , c : :d } ...&gt; end { :%{} , [ ] , [ { &quot;a&quot; , :b } , { :c , :d } ] }","ref":"Kernel.SpecialForms.html#%25%7B%7D/1","title":"Kernel.SpecialForms.%{}/1","type":"macro"},{"doc":"Capture operator. Captures or creates an anonymous function. Capture The capture operator is most commonly used to capture a function with given name and arity from a module: iex&gt; fun = &amp; Kernel . is_atom / 1 iex&gt; fun . ( :atom ) true iex&gt; fun . ( &quot;string&quot; ) false In the example above, we captured Kernel.is_atom/1 as an anonymous function and then invoked it. The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name: &amp; local_function / 1 See also Function.capture/3 . Anonymous functions The capture operator can also be used to partially apply functions, where &amp;1 , &amp;2 and so on can be used as value placeholders. For example: iex&gt; double = &amp; ( &amp;1 * 2 ) iex&gt; double . ( 2 ) 4 In other words, &amp;(&amp;1 * 2) is equivalent to fn x -&gt; x * 2 end . We can partially apply a remote function with placeholder: iex&gt; take_five = &amp; Enum . take ( &amp;1 , 5 ) iex&gt; take_five . ( 1 . . 10 ) [ 1 , 2 , 3 , 4 , 5 ] Another example while using an imported or local function: iex&gt; first_elem = &amp; elem ( &amp;1 , 0 ) iex&gt; first_elem . ( { 0 , 1 } ) 0 The &amp; operator can be used with more complex expressions: iex&gt; fun = &amp; ( &amp;1 + &amp;2 + &amp;3 ) iex&gt; fun . ( 1 , 2 , 3 ) 6 As well as with lists and tuples: iex&gt; fun = &amp; { &amp;1 , &amp;2 } iex&gt; fun . ( 1 , 2 ) { 1 , 2 } iex&gt; fun = &amp; [ &amp;1 | &amp;2 ] iex&gt; fun . ( 1 , [ 2 , 3 ] ) [ 1 , 2 , 3 ] The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &amp;1 , and that block expressions are not supported: # No placeholder, fails to compile. &amp; ( :foo ) # Block expression, fails to compile. &amp; ( &amp;1 ; &amp;2 )","ref":"Kernel.SpecialForms.html#&/1","title":"Kernel.SpecialForms.&/1","type":"macro"},{"doc":"Dot operator. Defines a remote call, a call to an anonymous function, or an alias. The dot ( . ) in Elixir can be used for remote calls: iex&gt; String . downcase ( &quot;FOO&quot; ) &quot;foo&quot; In this example above, we have used . to invoke downcase in the String module, passing &quot;FOO&quot; as argument. The dot may be used to invoke anonymous functions too: iex&gt; ( fn n -&gt; n end ) . ( 7 ) 7 in which case there is a function on the left hand side. We can also use the dot for creating aliases: iex&gt; Hello.World Hello.World This time, we have joined two aliases, defining the final alias Hello.World . Syntax The right side of . may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples: iex&gt; Kernel.Sample Kernel.Sample iex&gt; Kernel . length ( [ 1 , 2 , 3 ] ) 3 iex&gt; Kernel . + ( 1 , 2 ) 3 iex&gt; Kernel . &quot;+&quot; ( 1 , 2 ) 3 Wrapping the function name in single- or double-quotes is always a remote call. Therefore Kernel.&quot;Foo&quot; will attempt to call the function &quot;Foo&quot; and not return the alias Kernel.Foo . This is done by design as module names are more strict than function names. When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation: iex&gt; negate = fn n -&gt; - n end iex&gt; negate . ( 7 ) - 7 Quoted expression When . is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore): iex&gt; quote do ...&gt; String . downcase ( &quot;FOO&quot; ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , :downcase ] } , [ ] , [ &quot;FOO&quot; ] } Note that we have an inner tuple, containing the atom :. representing the dot as first element: { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , :downcase ] } This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias String and the atom :downcase . The second argument in a remote call is always an atom. In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary: iex&gt; quote do ...&gt; negate . ( 0 ) ...&gt; end { { :. , [ ] , [ { :negate , [ ] , __MODULE__ } ] } , [ ] , [ 0 ] } When the right side is an alias (i.e. starts with uppercase), we get instead: iex&gt; quote do ...&gt; Hello.World ...&gt; end { :__aliases__ , [ alias : false ] , [ :Hello , :World ] } We go into more details about aliases in the __aliases__/1 special form documentation. Unquoting We can also use unquote to generate a remote call in a quoted expression: iex&gt; x = :downcase iex&gt; quote do ...&gt; String . unquote ( x ) ( &quot;FOO&quot; ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , :downcase ] } , [ ] , [ &quot;FOO&quot; ] } Similar to Kernel.&quot;FUNCTION_NAME&quot; , unquote(x) will always generate a remote call, independent of the value of x . To generate an alias via the quoted expression, one needs to rely on Module.concat/2 : iex&gt; x = Sample iex&gt; quote do ...&gt; Module . concat ( String , unquote ( x ) ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :Module ] } , :concat ] } , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , Sample ] }","ref":"Kernel.SpecialForms.html#./2","title":"Kernel.SpecialForms../2","type":"macro"},{"doc":"Type operator. Used by types and bitstrings to specify types. This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself: @type number :: integer | float @spec add ( number , number ) :: number It may also be used in bit strings to specify the type of a given bit segment: &lt;&lt; int :: integer - little , rest :: bits &gt;&gt; = bits Read the documentation on the Typespec page and &lt;&lt;&gt;&gt;/1 for more information on typespecs and bitstrings respectively.","ref":"Kernel.SpecialForms.html#::/2","title":"Kernel.SpecialForms.::/2","type":"macro"},{"doc":"Defines a new bitstring. Examples iex&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; Types A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings: integer float bits (alias for bitstring ) bitstring binary bytes (alias for binary ) utf8 utf16 utf32 When no type is specified, the default is integer : iex&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; Elixir also accepts by default the segment to be a literal string or a literal charlist, which are by default expanded to integers: iex&gt; &lt;&lt; 0 , &quot;foo&quot; &gt;&gt; &lt;&lt; 0 , 102 , 111 , 111 &gt;&gt; Binaries need to be explicitly tagged as binary : iex&gt; rest = &quot;oo&quot; iex&gt; &lt;&lt; 102 , rest :: binary &gt;&gt; &quot;foo&quot; The utf8 , utf16 , and utf32 types are for Unicode code points. They can also be applied to literal strings and charlists: iex&gt; &lt;&lt; &quot;foo&quot; :: utf16 &gt;&gt; &lt;&lt; 0 , 102 , 0 , 111 , 0 , 111 &gt;&gt; iex&gt; &lt;&lt; &quot;foo&quot; :: utf32 &gt;&gt; &lt;&lt; 0 , 0 , 0 , 102 , 0 , 0 , 0 , 111 , 0 , 0 , 0 , 111 &gt;&gt; Otherwise we get an ArgumentError when constructing the binary: rest = &quot;oo&quot; &lt;&lt; 102 , rest &gt;&gt; ** (ArgumentError) argument error Options Many options can be given by using - as separator. Order is arbitrary, so the following are all equivalent: &lt;&lt; 102 :: integer - native , rest :: binary &gt;&gt; &lt;&lt; 102 :: native - integer , rest :: binary &gt;&gt; &lt;&lt; 102 :: unsigned - big - integer , rest :: binary &gt;&gt; &lt;&lt; 102 :: unsigned - big - integer - size ( 8 ) , rest :: binary &gt;&gt; &lt;&lt; 102 :: unsigned - big - integer - 8 , rest :: binary &gt;&gt; &lt;&lt; 102 :: 8 - integer - big - unsigned , rest :: binary &gt;&gt; &lt;&lt; 102 , rest :: binary &gt;&gt; Unit and Size The length of the match is equal to the unit (a number of bits) times the size (the number of repeated segments of length unit ). Type Default Unit integer 1 bit float 1 bit binary 8 bits Sizes for types are a bit more nuanced. The default size for integers is 8. For floats, it is 64. For floats, size * unit must result in 16, 32, or 64, corresponding to IEEE 754 binary16, binary32, and binary64, respectively. For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example: iex&gt; &lt;&lt; name :: binary - size ( 5 ) , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; &quot;Frank the Walrus&quot; iex&gt; { name , species } { &quot;Frank&quot; , &quot;Walrus&quot; } The size can be a variable: iex&gt; name_size = 5 iex&gt; &lt;&lt; name :: binary - size ( name_size ) , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; iex&gt; { name , species } { &quot;Frank&quot; , &quot;Walrus&quot; } And the variable can be defined in the match itself (prior to its use): iex&gt; &lt;&lt; name_size :: size ( 8 ) , name :: binary - size ( name_size ) , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; 5 , &quot;Frank the Walrus&quot; &gt;&gt; iex&gt; { name , species } { &quot;Frank&quot; , &quot;Walrus&quot; } However, the size cannot be defined in the match outside the binary/bitstring match: { name_size , &lt;&lt; name :: binary - size ( name_size ) , _rest :: binary &gt;&gt; } = { 5 , &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; } ** (CompileError): undefined variable &quot;name_size&quot; in bitstring segment Failing to specify the size for the non-last causes compilation to fail: &lt;&lt; name :: binary , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; ** (CompileError): a binary field without size is only allowed at the end of a binary pattern Shortcut Syntax Size and unit can also be specified using a syntax shortcut when passing integer values: iex&gt; x = 1 iex&gt; &lt;&lt; x :: 8 &gt;&gt; == &lt;&lt; x :: size ( 8 ) &gt;&gt; true iex&gt; &lt;&lt; x :: 8 * 4 &gt;&gt; == &lt;&lt; x :: size ( 8 ) - unit ( 4 ) &gt;&gt; true This syntax reflects the fact the effective size is given by multiplying the size by the unit. Modifiers Some types have associated modifiers to clear up ambiguity in byte representation. Modifier Relevant Type(s) signed integer unsigned (default) integer little integer , float , utf16 , utf32 big (default) integer , float , utf16 , utf32 native integer , utf16 , utf32 Sign Integers can be signed or unsigned , defaulting to unsigned . iex&gt; &lt;&lt; int :: integer &gt;&gt; = &lt;&lt; - 100 &gt;&gt; &lt;&lt; 156 &gt;&gt; iex&gt; int 156 iex&gt; &lt;&lt; int :: integer - signed &gt;&gt; = &lt;&lt; - 100 &gt;&gt; &lt;&lt; 156 &gt;&gt; iex&gt; int - 100 signed and unsigned are only used for matching binaries (see below) and are only used for integers. iex&gt; &lt;&lt; - 100 :: signed , _rest :: binary &gt;&gt; = &lt;&lt; - 100 , &quot;foo&quot; &gt;&gt; &lt;&lt; 156 , 102 , 111 , 111 &gt;&gt; Endianness Elixir has three options for endianness: big , little , and native . The default is big : iex&gt; &lt;&lt; number :: little - integer - size ( 16 ) &gt;&gt; = &lt;&lt; 0 , 1 &gt;&gt; &lt;&lt; 0 , 1 &gt;&gt; iex&gt; number 256 iex&gt; &lt;&lt; number :: big - integer - size ( 16 ) &gt;&gt; = &lt;&lt; 0 , 1 &gt;&gt; &lt;&lt; 0 , 1 &gt;&gt; iex&gt; number 1 native is determined by the VM at startup and will depend on the host operating system. Binary/Bitstring Matching Binary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching. Binary matching can be used by itself to extract information from binaries: iex&gt; &lt;&lt; &quot;Hello, &quot; , place :: binary &gt;&gt; = &quot;Hello, World&quot; &quot;Hello, World&quot; iex&gt; place &quot;World&quot; Or as a part of function definitions to pattern match: defmodule ImageTyper do @png_signature &lt;&lt; 137 :: size ( 8 ) , 80 :: size ( 8 ) , 78 :: size ( 8 ) , 71 :: size ( 8 ) , 13 :: size ( 8 ) , 10 :: size ( 8 ) , 26 :: size ( 8 ) , 10 :: size ( 8 ) &gt;&gt; @jpg_signature &lt;&lt; 255 :: size ( 8 ) , 216 :: size ( 8 ) &gt;&gt; def type ( &lt;&lt; @png_signature , _rest :: binary &gt;&gt; ) , do : :png def type ( &lt;&lt; @jpg_signature , _rest :: binary &gt;&gt; ) , do : :jpg def type ( _ ) , do : :unknown end Performance &amp; Optimizations The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the bin_opt_info compiler option: ERL_COMPILER_OPTIONS = bin_opt_info mix compile To learn more about specific optimizations and performance considerations, check out the &quot;Constructing and matching binaries&quot; chapter of the Erlang's Efficiency Guide .","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1","title":"Kernel.SpecialForms.<<>>/1","type":"macro"},{"doc":"Match operator. Matches the value on the right against the pattern on the left.","ref":"Kernel.SpecialForms.html#=/2","title":"Kernel.SpecialForms.=/2","type":"macro"},{"doc":"Pin operator. Accesses an already bound variable in match clauses. Examples Elixir allows variables to be rebound via static single assignment: iex&gt; x = 1 iex&gt; x = x + 1 iex&gt; x 2 However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the ^ special form, colloquially known as the pin operator: iex&gt; x = 1 iex&gt; ^ x = List . first ( [ 1 ] ) iex&gt; ^ x = List . first ( [ 2 ] ) ** (MatchError) no match of right hand side value: 2 Note that ^x always refers to the value of x prior to the match. The following example will match: iex&gt; x = 0 iex&gt; { x , ^ x } = { 1 , 0 } iex&gt; x 1","ref":"Kernel.SpecialForms.html#%5E/1","title":"Kernel.SpecialForms.^/1","type":"macro"},{"doc":"Returns the current calling environment as a Macro.Env struct. In the environment you can access the filename, line numbers, set up aliases, the function and others.","ref":"Kernel.SpecialForms.html#__CALLER__/0","title":"Kernel.SpecialForms.__CALLER__/0","type":"macro"},{"doc":"Returns the absolute path of the directory of the current file as a binary. Although the directory can be accessed as Path.dirname(__ENV__.file) , this macro is a convenient shortcut.","ref":"Kernel.SpecialForms.html#__DIR__/0","title":"Kernel.SpecialForms.__DIR__/0","type":"macro"},{"doc":"Returns the current environment information as a Macro.Env struct. In the environment you can access the current filename, line numbers, set up aliases, the current function and others.","ref":"Kernel.SpecialForms.html#__ENV__/0","title":"Kernel.SpecialForms.__ENV__/0","type":"macro"},{"doc":"Returns the current module name as an atom or nil otherwise. Although the module can be accessed in the __ENV__/0 , this macro is a convenient shortcut.","ref":"Kernel.SpecialForms.html#__MODULE__/0","title":"Kernel.SpecialForms.__MODULE__/0","type":"macro"},{"doc":"Returns the stacktrace for the currently handled exception. It is available only in the catch and rescue clauses of try/1 expressions. To retrieve the stacktrace of the current process, use Process.info(self(), :current_stacktrace) instead.","ref":"Kernel.SpecialForms.html#__STACKTRACE__/0","title":"Kernel.SpecialForms.__STACKTRACE__/0","type":"macro"},{"doc":"Internal special form to hold aliases information. It is usually compiled to an atom: iex&gt; quote do ...&gt; Foo.Bar ...&gt; end { :__aliases__ , [ alias : false ] , [ :Foo , :Bar ] } Elixir represents Foo.Bar as __aliases__ so calls can be unambiguously identified by the operator :. . For example: iex&gt; quote do ...&gt; Foo . bar ( ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :Foo ] } , :bar ] } , [ ] , [ ] } Whenever an expression iterator sees a :. as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom. On the other hand, aliases hold some properties: The head element of aliases can be any term that must expand to an atom at compilation time. The tail elements of aliases are guaranteed to always be atoms. When the head element of aliases is the atom :Elixir , no expansion happens.","ref":"Kernel.SpecialForms.html#__aliases__/1","title":"Kernel.SpecialForms.__aliases__/1","type":"macro"},{"doc":"Internal special form for block expressions. This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly: iex&gt; quote do ...&gt; 1 ...&gt; 2 ...&gt; 3 ...&gt; end { :__block__ , [ ] , [ 1 , 2 , 3 ] }","ref":"Kernel.SpecialForms.html#__block__/1","title":"Kernel.SpecialForms.__block__/1","type":"macro"},{"doc":"Creates a tuple. More information about the tuple data type and about functions to manipulate tuples can be found in the Tuple module; some functions for working with tuples are also available in Kernel (such as Kernel.elem/2 or Kernel.tuple_size/1 ). AST representation Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the :{} special form. iex&gt; quote do ...&gt; { 1 , 2 } ...&gt; end { 1 , 2 } iex&gt; quote do ...&gt; { 1 , 2 , 3 } ...&gt; end { :{} , [ ] , [ 1 , 2 , 3 ] }","ref":"Kernel.SpecialForms.html#%7B%7D/1","title":"Kernel.SpecialForms.{}/1","type":"macro"},{"doc":"alias/2 is used to set up aliases, often useful with modules' names. Examples alias/2 can be used to set up an alias for any module: defmodule Math do alias MyKeyword , as : Keyword end In the example above, we have set up MyKeyword to be aliased as Keyword . So now, any reference to Keyword will be automatically replaced by MyKeyword . In case one wants to access the original Keyword , it can be done by accessing Elixir : Keyword . values #=&gt; uses MyKeyword.values Elixir.Keyword . values #=&gt; uses Keyword.values Note that calling alias without the :as option automatically sets an alias based on the last part of the module. For example: alias Foo.Bar.Baz Is the same as: alias Foo.Bar.Baz , as : Baz We can also alias multiple modules in one line: alias Foo . { Bar , Baz , Biz } Is the same as: alias Foo.Bar alias Foo.Baz alias Foo.Biz Lexical scope import/2 , require/2 and alias/2 are called directives and all have lexical scope. This means you can set up aliases inside specific functions and it won't affect the overall scope. Warnings If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used. In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined. Both warning behaviours could be changed by explicitly setting the :warn option to true or false .","ref":"Kernel.SpecialForms.html#alias/2","title":"Kernel.SpecialForms.alias/2","type":"macro"},{"doc":"Matches the given expression against the given clauses. Examples case File . read ( file ) do { :ok , contents } when is_binary ( contents ) -&gt; String . split ( contents , &quot; \\n &quot; ) { :error , _reason } -&gt; Logger . warning &quot;could not find \#{ file } , assuming empty...&quot; [ ] end In the example above, we match the result of File.read/1 against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches. If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like _ ) which will always match. x = 10 case x do 0 -&gt; &quot;This clause won&#39;t match&quot; _ -&gt; &quot;This clause would match any value (x = \#{ x } )&quot; end #=&gt; &quot;This clause would match any value (x = 10)&quot; Variable handling Note that variables bound in a clause do not leak to the outer context: case data do { :ok , value } -&gt; value :error -&gt; nil end value #=&gt; unbound variable value Variables in the outer context cannot be overridden either: value = 7 case lucky? do false -&gt; value = 13 true -&gt; true end value #=&gt; 7 In the example above, value is going to be 7 regardless of the value of lucky? . The variable value bound in the clause and the variable value bound in the outer context are two entirely separate variables. If you want to pattern match against an existing variable, you need to use the ^/1 operator: x = 1 case 10 do ^ x -&gt; &quot;Won&#39;t match&quot; _ -&gt; &quot;Will match&quot; end #=&gt; &quot;Will match&quot; Using guards to match against multiple values While it is not possible to match against multiple patterns in a single clause, it's possible to match against multiple values by using guards: case data do value when value in [ :one , :two ] -&gt; &quot; \#{ value } has been matched&quot; :three -&gt; &quot;three has been matched&quot; end","ref":"Kernel.SpecialForms.html#case/2","title":"Kernel.SpecialForms.case/2","type":"macro"},{"doc":"Evaluates the expression corresponding to the first clause that evaluates to a truthy value. cond do hd ( [ 1 , 2 , 3 ] ) -&gt; &quot;1 is considered as true&quot; end #=&gt; &quot;1 is considered as true&quot; Raises an error if all conditions evaluate to nil or false . For this reason, it may be necessary to add a final always-truthy condition (anything non- false and non- nil ), which will always match. Examples cond do 1 + 1 == 1 -&gt; &quot;This will never match&quot; 2 * 2 != 4 -&gt; &quot;Nor this&quot; true -&gt; &quot;This will&quot; end #=&gt; &quot;This will&quot;","ref":"Kernel.SpecialForms.html#cond/1","title":"Kernel.SpecialForms.cond/1","type":"macro"},{"doc":"Defines an anonymous function. See Function for more information. Examples iex&gt; add = fn a , b -&gt; a + b end iex&gt; add . ( 1 , 2 ) 3 Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments: iex&gt; negate = fn ...&gt; true -&gt; false ...&gt; false -&gt; true ...&gt; end iex&gt; negate . ( false ) true","ref":"Kernel.SpecialForms.html#fn/1","title":"Kernel.SpecialForms.fn/1","type":"macro"},{"doc":"Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring. Let's start with an example: iex&gt; for n &lt;- [ 1 , 2 , 3 , 4 ] , do : n * 2 [ 2 , 4 , 6 , 8 ] A comprehension accepts many generators and filters. Enumerable generators are defined using &lt;- : # A list generator: iex&gt; for n &lt;- [ 1 , 2 , 3 , 4 ] , do : n * 2 [ 2 , 4 , 6 , 8 ] # A comprehension with two generators iex&gt; for x &lt;- [ 1 , 2 ] , y &lt;- [ 2 , 3 ] , do : x * y [ 2 , 3 , 4 , 6 ] Filters can also be given: # A comprehension with a generator and a filter iex&gt; for n &lt;- [ 1 , 2 , 3 , 4 , 5 , 6 ] , rem ( n , 2 ) == 0 , do : n [ 2 , 4 , 6 ] Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;- : iex&gt; users = [ user : &quot;john&quot; , admin : &quot;meg&quot; , guest : &quot;barbara&quot; ] iex&gt; for { type , name } when type != :guest &lt;- users do ...&gt; String . upcase ( name ) ...&gt; end [ &quot;JOHN&quot; , &quot;MEG&quot; ] Bitstring generators are also supported and are very useful when you need to organize bitstring streams: iex&gt; pixels = &lt;&lt; 213 , 45 , 132 , 64 , 76 , 32 , 76 , 0 , 0 , 234 , 32 , 15 &gt;&gt; iex&gt; for &lt;&lt; r :: 8 , g :: 8 , b :: 8 &lt;- pixels &gt;&gt; , do : { r , g , b } [ { 213 , 45 , 132 } , { 64 , 76 , 32 } , { 76 , 0 , 0 } , { 234 , 32 , 15 } ] Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension. The :into and :uniq options In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an :into option, that accepts any structure as long as it implements the Collectable protocol. For example, we can use bitstring generators with the :into option to easily remove all spaces in a string: iex&gt; for &lt;&lt; c &lt;- &quot; hello world &quot; &gt;&gt; , c != ?\\s , into : &quot;&quot; , do : &lt;&lt; c &gt;&gt; &quot;helloworld&quot; The IO module provides streams, that are both Enumerable and Collectable , here is an upcase echo server using comprehensions: for line &lt;- IO . stream ( :stdio , :line ) , into : IO . stream ( :stdio , :line ) do String . upcase ( line ) end Similarly, uniq: true can also be given to comprehensions to guarantee the results are only added to the collection if they were not returned before. For example: iex&gt; for x &lt;- [ 1 , 1 , 2 , 3 ] , uniq : true , do : x * 2 [ 2 , 4 , 6 ] iex&gt; for &lt;&lt; x &lt;- &quot;abcabc&quot; &gt;&gt; , uniq : true , into : &quot;&quot; , do : &lt;&lt; x - 32 &gt;&gt; &quot;ABC&quot; The :reduce option While the :into option allows us to customize the comprehension behaviour to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough. For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string &quot;AbCabCABc&quot; , we want to return the map %{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 1} . If we were to use :into , we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself. A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke Enum.reduce/3 to build a map, for example: iex&gt; letters = for &lt;&lt; x &lt;- &quot;AbCabCABc&quot; &gt;&gt; , x in ?a . . ?z , do : &lt;&lt; x &gt;&gt; iex&gt; Enum . reduce ( letters , %{ } , fn x , acc -&gt; Map . update ( acc , x , 1 , &amp; &amp;1 + 1 ) end ) %{ &quot;a&quot; = &gt; 1 , &quot;b&quot; = &gt; 2 , &quot;c&quot; = &gt; 1 } While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive. Luckily, comprehensions also support the :reduce option, which would allow us to fuse both steps above into a single step: iex&gt; for &lt;&lt; x &lt;- &quot;AbCabCABc&quot; &gt;&gt; , x in ?a . . ?z , reduce : %{ } do ...&gt; acc -&gt; Map . update ( acc , &lt;&lt; x &gt;&gt; , 1 , &amp; &amp;1 + 1 ) ...&gt; end %{ &quot;a&quot; = &gt; 1 , &quot;b&quot; = &gt; 2 , &quot;c&quot; = &gt; 1 } When the :reduce key is given, its value is used as the initial accumulator and the do block must be changed to use -&gt; clauses, where the left side of -&gt; receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned.","ref":"Kernel.SpecialForms.html#for/1","title":"Kernel.SpecialForms.for/1","type":"macro"},{"doc":"Imports functions and macros from other modules. import/2 allows one to easily access functions or macros from other modules without using the qualified name. Examples If you are using several functions from a given module, you can import those functions and reference them as local functions, for example: iex&gt; import List iex&gt; flatten ( [ 1 , [ 2 ] , 3 ] ) [ 1 , 2 , 3 ] Selector By default, Elixir imports functions and macros from the given module, except the ones starting with an underscore (which are usually callbacks): import List A developer can filter to import only macros or functions via the only option: import List , only : :functions import List , only : :macros Alternatively, Elixir allows a developer to pass pairs of name/arities to :only or :except as a fine grained control on what to import (or not): import List , only : [ flatten : 1 ] import String , except : [ split : 2 ] Importing the same module again will erase the previous imports, except when the except option is used, which is always exclusive on a previously declared import/2 . If there is no previous import, then it applies to all functions and macros in the module. For example: import List , only : [ flatten : 1 , keyfind : 4 ] import List , except : [ flatten : 1 ] After the two import calls above, only List.keyfind/4 will be imported. Underscore functions By default functions starting with _ are not imported. If you really want to import a function starting with _ you must explicitly include it in the :only selector. import File.Stream , only : [ __build__ : 3 ] Lexical scope It is important to note that import/2 is lexical. This means you can import specific macros inside specific functions: defmodule Math do def some_function do # 1) Disable &quot;if/2&quot; from Kernel import Kernel , except : [ if : 2 ] # 2) Require the new &quot;if/2&quot; macro from MyMacros import MyMacros # 3) Use the new macro if do_something , it_works end end In the example above, we imported macros from MyMacros , replacing the original if/2 implementation by our own within that specific function. All other functions in that module will still be able to use the original one. Warnings If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used. In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined. Both warning behaviours could be changed by explicitly setting the :warn option to true or false . Ambiguous function/macro names If two modules A and B are imported and they both contain a foo function with an arity of 1 , an error is only emitted if an ambiguous call to foo/1 is actually made; that is, the errors are emitted lazily, not eagerly.","ref":"Kernel.SpecialForms.html#import/2","title":"Kernel.SpecialForms.import/2","type":"macro"},{"doc":"Gets the representation of any expression. Examples iex&gt; quote do ...&gt; sum ( 1 , 2 , 3 ) ...&gt; end { :sum , [ ] , [ 1 , 2 , 3 ] } Elixir's AST (Abstract Syntax Tree) Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example: { :sum , [ ] , [ 1 , 2 , 3 ] } The tuple above represents a function call to sum passing 1, 2 and 3 as arguments. The tuple elements are: The first element of the tuple is always an atom or another tuple in the same representation. The second element of the tuple represents metadata . The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call). Besides the tuple described above, Elixir has a few literals that are also part of its AST. Those literals return themselves when quoted. They are: :sum #=&gt; Atoms 1 #=&gt; Integers 2.0 #=&gt; Floats [ 1 , 2 ] #=&gt; Lists &quot;strings&quot; #=&gt; Strings { key , value } #=&gt; Tuples with two elements Any other value, such as a map or a four-element tuple, must be escaped ( Macro.escape/1 ) before being introduced into an AST. Options :bind_quoted - passes a binding to the macro. Whenever a binding is given, unquote/1 is automatically disabled. :context - sets the resolution context. :generated - marks the given chunk as generated so it does not emit warnings. Currently it only works on special forms (for example, you can annotate a case but not an if ). :file - sets the quoted expressions to have the given file. :line - sets the quoted expressions to have the given line. :location - when set to :keep , keeps the current line and file from quote. Read the &quot;Stacktrace information&quot; section below for more information. :unquote - when false , disables unquoting. This means any unquote call will be kept as is in the AST, instead of replaced by the unquote arguments. For example: iex&gt; quote do ...&gt; unquote ( &quot;hello&quot; ) ...&gt; end &quot;hello&quot; iex&gt; quote unquote : false do ...&gt; unquote ( &quot;hello&quot; ) ...&gt; end { :unquote , [ ] , [ &quot;hello&quot; ] } Quote and macros quote/2 is commonly used with macros for code generation. As an exercise, let's define a macro that multiplies a number by itself (squared). In practice, there is no reason to define such a macro (and it would actually be seen as a bad practice), but it is simple enough that it allows us to focus on the important aspects of quotes and macros: defmodule Math do defmacro squared ( x ) do quote do unquote ( x ) * unquote ( x ) end end end We can invoke it as: import Math IO . puts ( &quot;Got \#{ squared ( 5 ) } &quot; ) At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, squared(5) becomes 5 * 5 . The argument 5 is duplicated in the produced code, we can see this behaviour in practice though because our macro actually has a bug: import Math my_number = fn -&gt; IO . puts ( &quot;Returning 5&quot; ) 5 end IO . puts ( &quot;Got \#{ squared ( my_number . ( ) ) } &quot; ) The example above will print: Returning 5 Returning 5 Got 25 Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that: squared ( my_number . ( ) ) Actually expands to: my_number . ( ) * my_number . ( ) Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behaviour, and that's why one of the first things you need to keep in mind when it comes to macros is to not unquote the same value more than once . Let's fix our macro: defmodule Math do defmacro squared ( x ) do quote do x = unquote ( x ) x * x end end end Now invoking squared(my_number.()) as before will print the value just once. In fact, this pattern is so common that most of the times you will want to use the bind_quoted option with quote/2 : defmodule Math do defmacro squared ( x ) do quote bind_quoted : [ x : x ] do x * x end end end :bind_quoted will translate to the same code as the example above. :bind_quoted can be used in many cases and is seen as good practice, not only because it helps prevent us from running into common mistakes, but also because it allows us to leverage other tools exposed by macros, such as unquote fragments discussed in some sections below. Before we finish this brief introduction, you will notice that, even though we defined a variable x inside our quote: quote do x = unquote ( x ) x * x end When we call: import Math squared ( 5 ) x ** (CompileError) undefined variable x or undefined function x/0 We can see that x did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well. Hygiene in variables Consider the following example: defmodule Hygiene do defmacro no_interference do quote do a = 1 end end end require Hygiene a = 10 Hygiene . no_interference ( ) a #=&gt; 10 In the example above, a returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the var! macro: defmodule NoHygiene do defmacro interference do quote do var! ( a ) = 1 end end end require NoHygiene a = 10 NoHygiene . interference ( ) a #=&gt; 1 You cannot even access variables defined in the same module unless you explicitly give it a context: defmodule Hygiene do defmacro write do quote do a = 1 end end defmacro read do quote do a end end end Hygiene . write ( ) Hygiene . read ( ) ** (RuntimeError) undefined variable a or undefined function a/0 For such, you can explicitly pass the current module scope as argument: defmodule ContextHygiene do defmacro write do quote do var! ( a , ContextHygiene ) = 1 end end defmacro read do quote do var! ( a , ContextHygiene ) end end end ContextHygiene . write ( ) ContextHygiene . read ( ) #=&gt; 1 Hygiene in aliases Aliases inside quote are hygienic by default. Consider the following example: defmodule Hygiene do alias Map , as : M defmacro no_interference do quote do M . new ( ) end end end require Hygiene Hygiene . no_interference ( ) #=&gt; %{} Note that, even though the alias M is not available in the context the macro is expanded, the code above works because M still expands to Map . Similarly, even if we defined an alias with the same name before invoking a macro, it won't affect the macro's result: defmodule Hygiene do alias Map , as : M defmacro no_interference do quote do M . new ( ) end end end require Hygiene alias SomethingElse , as : M Hygiene . no_interference ( ) #=&gt; %{} In some cases, you want to access an alias or a module defined in the caller. For such, you can use the alias! macro: defmodule Hygiene do # This will expand to Elixir.Nested.hello() defmacro no_interference do quote do Nested . hello ( ) end end # This will expand to Nested.hello() for # whatever is Nested in the caller defmacro interference do quote do alias! ( Nested ) . hello ( ) end end end defmodule Parent do defmodule Nested do def hello , do : &quot;world&quot; end require Hygiene Hygiene . no_interference ( ) ** (UndefinedFunctionError) ... Hygiene . interference ( ) #=&gt; &quot;world&quot; end Hygiene in imports Similar to aliases, imports in Elixir are hygienic. Consider the following code: defmodule Hygiene do defmacrop get_length do quote do length ( [ 1 , 2 , 3 ] ) end end def return_length do import Kernel , except : [ length : 1 ] get_length end end Hygiene . return_length ( ) #=&gt; 3 Notice how Hygiene.return_length/0 returns 3 even though the Kernel.length/1 function is not imported. In fact, even if return_length/0 imported a function with the same name and arity from another module, it wouldn't affect the function result: def return_length do import String , only : [ length : 1 ] get_length end Calling this new return_length/0 will still return 3 as result. Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call length([1, 2, 3]) inside quote, but no length/1 function is available, it is then expanded in the caller: defmodule Lazy do defmacrop get_length do import Kernel , except : [ length : 1 ] quote do length ( &quot;hello&quot; ) end end def return_length do import Kernel , except : [ length : 1 ] import String , only : [ length : 1 ] get_length end end Lazy . return_length ( ) #=&gt; 5 Stacktrace information When defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example: # adder.ex defmodule Adder do @doc &quot;Defines a function that adds two numbers&quot; defmacro defadd do quote location : :keep do def add ( a , b ) , do : a + b end end end # sample.ex defmodule Sample do import Adder defadd end require Sample Sample . add ( :one , :two ) ** (ArithmeticError) bad argument in arithmetic expression adder.ex:5: Sample.add/2 When using location: :keep and invalid arguments are given to Sample.add/2 , the stacktrace information will point to the file and line inside the quote. Without location: :keep , the error is reported to where defadd was invoked. location: :keep affects only definitions inside the quote. Binding and unquote fragments Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example: kv = [ foo : 1 , bar : 2 ] Enum . each ( kv , fn { k , v } -&gt; def unquote ( k ) ( ) , do : unquote ( v ) end ) In the example above, we have generated the functions foo/0 and bar/0 dynamically. Now, imagine that we want to convert this functionality into a macro: defmacro defkv ( kv ) do Enum . map ( kv , fn { k , v } -&gt; quote do def unquote ( k ) ( ) , do : unquote ( v ) end end ) end We can invoke this macro as: defkv [ foo : 1 , bar : 2 ] However, we can't invoke it as follows: kv = [ foo : 1 , bar : 2 ] defkv kv This is because the macro is expecting its arguments to be a keyword list at compilation time. Since in the example above we are passing the representation of the variable kv , our code fails. This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression: defmacro defkv ( kv ) do quote do Enum . each ( unquote ( kv ) , fn { k , v } -&gt; def unquote ( k ) ( ) , do : unquote ( v ) end ) end end If you try to run our new macro, you will notice it won't even compile, complaining that the variables k and v do not exist. This is because of the ambiguity: unquote(k) can either be an unquote fragment, as previously, or a regular unquote as in unquote(kv) . One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the kv representation into the tree. That's when the :bind_quoted option comes to the rescue (again!). By using :bind_quoted , we can automatically disable unquoting while still injecting the desired variables into the tree: defmacro defkv ( kv ) do quote bind_quoted : [ kv : kv ] do Enum . each ( kv , fn { k , v } -&gt; def unquote ( k ) ( ) , do : unquote ( v ) end ) end end In fact, the :bind_quoted option is recommended every time one desires to inject a value into the quote.","ref":"Kernel.SpecialForms.html#quote/2","title":"Kernel.SpecialForms.quote/2","type":"macro"},{"doc":"Checks if there is a message matching the given clauses in the current process mailbox. In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value. Examples receive do { :selector , number , name } when is_integer ( number ) -&gt; name name when is_atom ( name ) -&gt; name _ -&gt; IO . puts ( :stderr , &quot;Unexpected message received&quot; ) end An optional after clause can be given in case the message was not received after the given timeout period, specified in milliseconds: receive do { :selector , number , name } when is_integer ( number ) -&gt; name name when is_atom ( name ) -&gt; name _ -&gt; IO . puts ( :stderr , &quot;Unexpected message received&quot; ) after 5000 -&gt; IO . puts ( :stderr , &quot;No message in 5 seconds&quot; ) end The after clause can be specified even if there are no match clauses. The timeout value given to after can be any expression evaluating to one of the allowed values: :infinity - the process should wait indefinitely for a matching message, this is the same as not using the after clause 0 - if there is no matching message in the mailbox, the timeout will occur immediately positive integer smaller than or equal to 4_294_967_295 ( 0xFFFFFFFF in hexadecimal notation) - it should be possible to represent the timeout value as an unsigned 32-bit integer. Variable handling The receive/1 special form handles variables exactly as the case/2 special macro. For more information, check the docs for case/2 .","ref":"Kernel.SpecialForms.html#receive/1","title":"Kernel.SpecialForms.receive/1","type":"macro"},{"doc":"Requires a module in order to use its macros. Examples Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in. Let's suppose you created your own if/2 implementation in the module MyMacros . If you want to invoke it, you need to first explicitly require the MyMacros : defmodule Math do require MyMacros MyMacros . if do_something , it_works end An attempt to call a macro that was not loaded will raise an error. Alias shortcut require/2 also accepts :as as an option so it automatically sets up an alias. Please check alias/2 for more information.","ref":"Kernel.SpecialForms.html#require/2","title":"Kernel.SpecialForms.require/2","type":"macro"},{"doc":"Calls the overridden function when overriding it with Kernel.defoverridable/1 . See Kernel.defoverridable/1 for more information and documentation.","ref":"Kernel.SpecialForms.html#super/1","title":"Kernel.SpecialForms.super/1","type":"macro"},{"doc":"Evaluates the given expressions and handles any error, exit, or throw that may have happened. Examples try do do_something_that_may_fail ( some_arg ) rescue ArgumentError -&gt; IO . puts ( &quot;Invalid argument given&quot; ) catch value -&gt; IO . puts ( &quot;Caught \#{ inspect ( value ) } &quot; ) else value -&gt; IO . puts ( &quot;Success! The result was \#{ inspect ( value ) } &quot; ) after IO . puts ( &quot;This is printed regardless if it failed or succeeded&quot; ) end The rescue clause is used to handle exceptions while the catch clause can be used to catch thrown values and exits. The else clause can be used to control flow based on the result of the expression. catch , rescue , and else clauses work based on pattern matching (similar to the case special form). Calls inside try/1 are not tail recursive since the VM needs to keep the stacktrace in case an exception happens. To retrieve the stacktrace, access __STACKTRACE__/0 inside the rescue or catch clause. rescue clauses Besides relying on pattern matching, rescue clauses provide some conveniences around exceptions that allow one to rescue an exception by its name. All the following formats are valid patterns in rescue clauses: # Rescue a single exception without binding the exception # to a variable try do UndefinedModule . undefined_function rescue UndefinedFunctionError -&gt; nil end # Rescue any of the given exception without binding try do UndefinedModule . undefined_function rescue [ UndefinedFunctionError , ArgumentError ] -&gt; nil end # Rescue and bind the exception to the variable &quot;x&quot; try do UndefinedModule . undefined_function rescue x in [ UndefinedFunctionError ] -&gt; nil end # Rescue all kinds of exceptions and bind the rescued exception # to the variable &quot;x&quot; try do UndefinedModule . undefined_function rescue x -&gt; nil end Erlang errors Erlang errors are transformed into Elixir ones when rescuing: try do :erlang . error ( :badarg ) rescue ArgumentError -&gt; :ok end #=&gt; :ok The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic ErlangError : try do :erlang . error ( :unknown ) rescue ErlangError -&gt; :ok end #=&gt; :ok In fact, ErlangError can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier :badarg error too, prior to transformation: try do :erlang . error ( :badarg ) rescue ErlangError -&gt; :ok end #=&gt; :ok catch clauses The catch clause can be used to catch thrown values, exits, and errors. Catching thrown values catch can be used to catch values thrown by Kernel.throw/1 : try do throw ( :some_value ) catch thrown_value -&gt; IO . puts ( &quot;A value was thrown: \#{ inspect ( thrown_value ) } &quot; ) end Catching values of any kind The catch clause also supports catching exits and errors. To do that, it allows matching on both the kind of the caught value as well as the value itself: try do exit ( :shutdown ) catch :exit , value -&gt; IO . puts ( &quot;Exited with value \#{ inspect ( value ) } &quot; ) end try do exit ( :shutdown ) catch kind , value when kind in [ :exit , :throw ] -&gt; IO . puts ( &quot;Caught exit or throw with value \#{ inspect ( value ) } &quot; ) end The catch clause also supports :error alongside :exit and :throw as in Erlang, although this is commonly avoided in favor of raise / rescue control mechanisms. One reason for this is that when catching :error , the error is not automatically transformed into an Elixir error: try do :erlang . error ( :badarg ) catch :error , :badarg -&gt; :ok end #=&gt; :ok after clauses An after clause allows you to define cleanup logic that will be invoked both when the block of code passed to try/1 succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the after clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits. File . write! ( &quot;tmp/story.txt&quot; , &quot;Hello, World&quot; ) try do do_something_with ( &quot;tmp/story.txt&quot; ) after File . rm ( &quot;tmp/story.txt&quot; ) end else clauses else clauses allow the result of the body passed to try/1 to be pattern matched on: x = 2 try do 1 / x rescue ArithmeticError -&gt; :infinity else y when y &lt; 1 and y &gt; - 1 -&gt; :small _ -&gt; :large end If an else clause is not present and no exceptions are raised, the result of the expression will be returned: x = 1 ^ x = try do 1 / x rescue ArithmeticError -&gt; :infinity end However, when an else clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a catch or rescue in the same try : x = 1 try do try do 1 / x rescue # The TryClauseError cannot be rescued here: TryClauseError -&gt; :error_a else 0 -&gt; :small end rescue # The TryClauseError is rescued here: TryClauseError -&gt; :error_b end Similarly, an exception inside an else clause is not caught or rescued inside the same try : try do try do nil catch # The exit(1) call below can not be caught here: :exit , _ -&gt; :exit_a else _ -&gt; exit ( 1 ) end catch # The exit is caught here: :exit , _ -&gt; :exit_b end This means the VM no longer needs to keep the stacktrace once inside an else clause and so tail recursion is possible when using a try with a tail call as the final call inside an else clause. The same is true for rescue and catch clauses. Only the result of the tried expression falls down to the else clause. If the try ends up in the rescue or catch clauses, their result will not fall down to else : try do throw ( :catch_this ) catch :throw , :catch_this -&gt; :it_was_caught else # :it_was_caught will not fall down to this &quot;else&quot; clause. other -&gt; { :else , other } end Variable handling Since an expression inside try may not have been evaluated due to an exception, any variable created inside try cannot be accessed externally. For instance: try do x = 1 do_something_that_may_fail ( same_arg ) :ok catch _ , _ -&gt; :failed end x #=&gt; unbound variable &quot;x&quot; In the example above, x cannot be accessed since it was defined inside the try clause. A common practice to address this issue is to return the variables defined inside try : x = try do x = 1 do_something_that_may_fail ( same_arg ) x catch _ , _ -&gt; :failed end","ref":"Kernel.SpecialForms.html#try/1","title":"Kernel.SpecialForms.try/1","type":"macro"},{"doc":"Unquotes the given expression inside a quoted expression. This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to unquote any value, such as a map or a four-element tuple, you should call Macro.escape/1 before unquoting. Examples Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be: value = quote do 13 end quote do sum ( 1 , value , 3 ) end Which would then return: { :sum , [ ] , [ 1 , { :value , [ ] , Elixir } , 3 ] } Which is not the expected result. For this, we use unquote : iex&gt; value = ...&gt; quote do ...&gt; 13 ...&gt; end iex&gt; quote do ...&gt; sum ( 1 , unquote ( value ) , 3 ) ...&gt; end { :sum , [ ] , [ 1 , 13 , 3 ] } If you want to unquote a value that is not a quoted expression, such as a map, you need to call Macro.escape/1 before: iex&gt; value = %{ foo : :bar } iex&gt; quote do ...&gt; process_map ( unquote ( Macro . escape ( value ) ) ) ...&gt; end { :process_map , [ ] , [ { :%{} , [ ] , [ foo : :bar ] } ] } If you forget to escape it, Elixir will raise an error when compiling the code.","ref":"Kernel.SpecialForms.html#unquote/1","title":"Kernel.SpecialForms.unquote/1","type":"macro"},{"doc":"Unquotes the given list expanding its arguments. Similar to unquote/1 . Examples iex&gt; values = [ 2 , 3 , 4 ] iex&gt; quote do ...&gt; sum ( 1 , unquote_splicing ( values ) , 5 ) ...&gt; end { :sum , [ ] , [ 1 , 2 , 3 , 4 , 5 ] }","ref":"Kernel.SpecialForms.html#unquote_splicing/1","title":"Kernel.SpecialForms.unquote_splicing/1","type":"macro"},{"doc":"Used to combine matching clauses. Let's start with an example: iex&gt; opts = %{ width : 10 , height : 15 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , width * height } ...&gt; end { :ok , 150 } If all clauses match, the do block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned: iex&gt; opts = %{ width : 10 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , width * height } ...&gt; end :error Guards can be used in patterns as well: iex&gt; users = %{ &quot;melany&quot; = &gt; &quot;guest&quot; , &quot;bob&quot; = &gt; :admin } iex&gt; with { :ok , role } when not is_binary ( role ) &lt;- Map . fetch ( users , &quot;bob&quot; ) do ...&gt; { :ok , to_string ( role ) } ...&gt; end { :ok , &quot;admin&quot; } As in for/1 , variables bound inside with/1 won't leak. Expressions without &lt;- may also be used in clauses. For instance, you can perform regular matches with the = operator: iex&gt; width = nil iex&gt; opts = %{ width : 10 , height : 15 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; double_width = width * 2 , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , double_width * height } ...&gt; end { :ok , 300 } iex&gt; width nil The behaviour of any expression in a clause is the same as outside. For example, = will raise a MatchError instead of returning the non-matched value: with :foo = :bar , do : :ok ** (MatchError) no match of right hand side value: :bar As with any other function or macro call in Elixir, explicit parens can also be used around the arguments before the do / end block: iex&gt; opts = %{ width : 10 , height : 15 } iex&gt; with ( ...&gt; { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) ...&gt; ) do ...&gt; { :ok , width * height } ...&gt; end { :ok , 150 } The choice between parens and no parens is a matter of preference. An else option can be given to modify what is being returned from with in the case of a failed match: iex&gt; opts = %{ width : 10 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , width * height } ...&gt; else ...&gt; :error -&gt; ...&gt; { :error , :wrong_data } ...&gt; ...&gt; _other_error -&gt; ...&gt; :unexpected_error ...&gt; end { :error , :wrong_data } The else block works like a case clause: it can have multiple clauses, and the first match will be used. Variables bound inside with (such as width in this example) are not available in the else block. If an else block is used and there are no matching clauses, a WithClauseError exception is raised.","ref":"Kernel.SpecialForms.html#with/1","title":"Kernel.SpecialForms.with/1","type":"macro"},{"doc":"Atoms are constants whose values are their own name. They are often useful to enumerate over distinct values, such as: iex&gt; :apple :apple iex&gt; :orange :orange iex&gt; :watermelon :watermelon Atoms are equal if their names are equal. iex&gt; :apple == :apple true iex&gt; :apple == :orange false Often they are used to express the state of an operation, by using values such as :ok and :error . The booleans true and false are also atoms: iex&gt; true == :true true iex&gt; is_atom ( false ) true iex&gt; is_boolean ( :false ) true Elixir allows you to skip the leading : for the atoms false , true , and nil . Atoms must be composed of Unicode characters such as letters, numbers, underscore, and @ . If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes: iex&gt; :&quot;this is an atom with spaces&quot; :&quot;this is an atom with spaces&quot;","ref":"Atom.html","title":"Atom","type":"module"},{"doc":"Converts an atom to a charlist. Inlined by the compiler. Examples iex&gt; Atom . to_charlist ( :&quot;An atom&quot; ) &#39;An atom&#39;","ref":"Atom.html#to_charlist/1","title":"Atom.to_charlist/1","type":"function"},{"doc":"Converts an atom to a string. Inlined by the compiler. Examples iex&gt; Atom . to_string ( :foo ) &quot;foo&quot;","ref":"Atom.html#to_string/1","title":"Atom.to_string/1","type":"function"},{"doc":"This module provides data encoding and decoding functions according to RFC 4648 . This document defines the commonly used base 16, base 32, and base 64 encoding schemes. Base 16 alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 0 4 4 8 8 12 C 1 1 5 5 9 9 13 D 2 2 6 6 10 A 14 E 3 3 7 7 11 B 15 F Base 32 alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 9 J 18 S 27 3 1 B 10 K 19 T 28 4 2 C 11 L 20 U 29 5 3 D 12 M 21 V 30 6 4 E 13 N 22 W 31 7 5 F 14 O 23 X 6 G 15 P 24 Y (pad) = 7 H 16 Q 25 Z 8 I 17 R 26 2 Base 32 (extended hex) alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 0 9 9 18 I 27 R 1 1 10 A 19 J 28 S 2 2 11 B 20 K 29 T 3 3 12 C 21 L 30 U 4 4 13 D 22 M 31 V 5 5 14 E 23 N 6 6 15 F 24 O (pad) = 7 7 16 G 25 P 8 8 17 H 26 Q Base 64 alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y Base 64 (URL and filename safe) alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 - 12 M 29 d 46 u 63 _ 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y","ref":"Base.html","title":"Base","type":"module"},{"doc":"Decodes a base 16 encoded string into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters Examples iex&gt; Base . decode16 ( &quot;666F6F626172&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode16 ( &quot;666f6f626172&quot; , case : :lower ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode16 ( &quot;666f6F626172&quot; , case : :mixed ) { :ok , &quot;foobar&quot; }","ref":"Base.html#decode16/2","title":"Base.decode16/2","type":"function"},{"doc":"Decodes a base 16 encoded string into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Examples iex&gt; Base . decode16! ( &quot;666F6F626172&quot; ) &quot;foobar&quot; iex&gt; Base . decode16! ( &quot;666f6f626172&quot; , case : :lower ) &quot;foobar&quot; iex&gt; Base . decode16! ( &quot;666f6F626172&quot; , case : :mixed ) &quot;foobar&quot;","ref":"Base.html#decode16!/2","title":"Base.decode16!/2","type":"function"},{"doc":"Decodes a base 32 encoded string into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . decode32 ( &quot;MZXW6YTBOI======&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode32 ( &quot;mzxw6ytboi======&quot; , case : :lower ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode32 ( &quot;mzXW6ytBOi======&quot; , case : :mixed ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode32 ( &quot;MZXW6YTBOI&quot; , padding : false ) { :ok , &quot;foobar&quot; }","ref":"Base.html#decode32/2","title":"Base.decode32/2","type":"function"},{"doc":"Decodes a base 32 encoded string into a binary string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . decode32! ( &quot;MZXW6YTBOI======&quot; ) &quot;foobar&quot; iex&gt; Base . decode32! ( &quot;mzxw6ytboi======&quot; , case : :lower ) &quot;foobar&quot; iex&gt; Base . decode32! ( &quot;mzXW6ytBOi======&quot; , case : :mixed ) &quot;foobar&quot; iex&gt; Base . decode32! ( &quot;MZXW6YTBOI&quot; , padding : false ) &quot;foobar&quot;","ref":"Base.html#decode32!/2","title":"Base.decode32!/2","type":"function"},{"doc":"Decodes a base 64 encoded string into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. Examples iex&gt; Base . decode64 ( &quot;Zm9vYmFy&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode64 ( &quot;Zm9vYmFy \\n &quot; , ignore : :whitespace ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode64 ( &quot;Zm9vYg==&quot; ) { :ok , &quot;foob&quot; } iex&gt; Base . decode64 ( &quot;Zm9vYg&quot; , padding : false ) { :ok , &quot;foob&quot; }","ref":"Base.html#decode64/2","title":"Base.decode64/2","type":"function"},{"doc":"Decodes a base 64 encoded string into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Examples iex&gt; Base . decode64! ( &quot;Zm9vYmFy&quot; ) &quot;foobar&quot; iex&gt; Base . decode64! ( &quot;Zm9vYmFy \\n &quot; , ignore : :whitespace ) &quot;foobar&quot; iex&gt; Base . decode64! ( &quot;Zm9vYg==&quot; ) &quot;foob&quot; iex&gt; Base . decode64! ( &quot;Zm9vYg&quot; , padding : false ) &quot;foob&quot;","ref":"Base.html#decode64!/2","title":"Base.decode64!/2","type":"function"},{"doc":"Encodes a binary string into a base 16 encoded string. Options The accepted options are: :case - specifies the character case to use when encoding The values for :case can be: :upper - uses upper case characters (default) :lower - uses lower case characters Examples iex&gt; Base . encode16 ( &quot;foobar&quot; ) &quot;666F6F626172&quot; iex&gt; Base . encode16 ( &quot;foobar&quot; , case : :lower ) &quot;666f6f626172&quot;","ref":"Base.html#encode16/2","title":"Base.encode16/2","type":"function"},{"doc":"Encodes a binary string into a base 32 encoded string. Options The accepted options are: :case - specifies the character case to use when encoding :padding - specifies whether to apply padding The values for :case can be: :upper - uses upper case characters (default) :lower - uses lower case characters The values for :padding can be: true - pad the output string to the nearest multiple of 8 (default) false - omit padding from the output string Examples iex&gt; Base . encode32 ( &quot;foobar&quot; ) &quot;MZXW6YTBOI======&quot; iex&gt; Base . encode32 ( &quot;foobar&quot; , case : :lower ) &quot;mzxw6ytboi======&quot; iex&gt; Base . encode32 ( &quot;foobar&quot; , padding : false ) &quot;MZXW6YTBOI&quot;","ref":"Base.html#encode32/2","title":"Base.encode32/2","type":"function"},{"doc":"Encodes a binary string into a base 64 encoded string. Accepts padding: false option which will omit padding from the output string. Examples iex&gt; Base . encode64 ( &quot;foobar&quot; ) &quot;Zm9vYmFy&quot; iex&gt; Base . encode64 ( &quot;foob&quot; ) &quot;Zm9vYg==&quot; iex&gt; Base . encode64 ( &quot;foob&quot; , padding : false ) &quot;Zm9vYg&quot;","ref":"Base.html#encode64/2","title":"Base.encode64/2","type":"function"},{"doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . hex_decode32 ( &quot;CPNMUOJ1E8======&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . hex_decode32 ( &quot;cpnmuoj1e8======&quot; , case : :lower ) { :ok , &quot;foobar&quot; } iex&gt; Base . hex_decode32 ( &quot;cpnMuOJ1E8======&quot; , case : :mixed ) { :ok , &quot;foobar&quot; } iex&gt; Base . hex_decode32 ( &quot;CPNMUOJ1E8&quot; , padding : false ) { :ok , &quot;foobar&quot; }","ref":"Base.html#hex_decode32/2","title":"Base.hex_decode32/2","type":"function"},{"doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . hex_decode32! ( &quot;CPNMUOJ1E8======&quot; ) &quot;foobar&quot; iex&gt; Base . hex_decode32! ( &quot;cpnmuoj1e8======&quot; , case : :lower ) &quot;foobar&quot; iex&gt; Base . hex_decode32! ( &quot;cpnMuOJ1E8======&quot; , case : :mixed ) &quot;foobar&quot; iex&gt; Base . hex_decode32! ( &quot;CPNMUOJ1E8&quot; , padding : false ) &quot;foobar&quot;","ref":"Base.html#hex_decode32!/2","title":"Base.hex_decode32!/2","type":"function"},{"doc":"Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet. Options The accepted options are: :case - specifies the character case to use when encoding :padding - specifies whether to apply padding The values for :case can be: :upper - uses upper case characters (default) :lower - uses lower case characters The values for :padding can be: true - pad the output string to the nearest multiple of 8 (default) false - omit padding from the output string Examples iex&gt; Base . hex_encode32 ( &quot;foobar&quot; ) &quot;CPNMUOJ1E8======&quot; iex&gt; Base . hex_encode32 ( &quot;foobar&quot; , case : :lower ) &quot;cpnmuoj1e8======&quot; iex&gt; Base . hex_encode32 ( &quot;foobar&quot; , padding : false ) &quot;CPNMUOJ1E8&quot;","ref":"Base.html#hex_encode32/2","title":"Base.hex_encode32/2","type":"function"},{"doc":"Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. Examples iex&gt; Base . url_decode64 ( &quot;_3_-_A==&quot; ) { :ok , &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; } iex&gt; Base . url_decode64 ( &quot;_3_-_A== \\n &quot; , ignore : :whitespace ) { :ok , &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; } iex&gt; Base . url_decode64 ( &quot;_3_-_A&quot; , padding : false ) { :ok , &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; }","ref":"Base.html#url_decode64/2","title":"Base.url_decode64/2","type":"function"},{"doc":"Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Examples iex&gt; Base . url_decode64! ( &quot;_3_-_A==&quot; ) &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; iex&gt; Base . url_decode64! ( &quot;_3_-_A== \\n &quot; , ignore : :whitespace ) &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; iex&gt; Base . url_decode64! ( &quot;_3_-_A&quot; , padding : false ) &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt;","ref":"Base.html#url_decode64!/2","title":"Base.url_decode64!/2","type":"function"},{"doc":"Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet. Accepts padding: false option which will omit padding from the output string. Examples iex&gt; Base . url_encode64 ( &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; ) &quot;_3_-_A==&quot; iex&gt; Base . url_encode64 ( &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; , padding : false ) &quot;_3_-_A&quot;","ref":"Base.html#url_encode64/2","title":"Base.url_encode64/2","type":"function"},{"doc":"A set of functions that perform calculations on bits. All bitwise functions work only on integers; otherwise an ArithmeticError is raised. The functions in this module come in two flavors: named or operators. For example: iex&gt; use Bitwise iex&gt; bnot ( 1 ) # named - 2 iex&gt; 1 &amp;&amp;&amp; 1 # operator 1 If you prefer to use only operators or skip them, you can pass the following options: :only_operators - includes only operators :skip_operators - skips operators For example: iex&gt; use Bitwise , only_operators : true iex&gt; 1 &amp;&amp;&amp; 1 1 When invoked with no options, use Bitwise is equivalent to import Bitwise . All bitwise functions can be used in guards: iex&gt; odd? = fn ...&gt; int when Bitwise . band ( int , 1 ) == 1 -&gt; true ...&gt; _ -&gt; false ...&gt; end iex&gt; odd? . ( 1 ) true All functions in this module are inlined by the compiler.","ref":"Bitwise.html","title":"Bitwise","type":"module"},{"doc":"Bitwise AND operator. Calculates the bitwise AND of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 9 &amp;&amp;&amp; 3 1","ref":"Bitwise.html#&&&/2","title":"Bitwise.&&&/2","type":"function"},{"doc":"Arithmetic left bitshift operator. Calculates the result of an arithmetic left bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &lt;&lt;&lt; 2 4 iex&gt; 1 &lt;&lt;&lt; - 2 0 iex&gt; - 1 &lt;&lt;&lt; 2 - 4 iex&gt; - 1 &lt;&lt;&lt; - 2 - 1","ref":"Bitwise.html#%3C%3C%3C/2","title":"Bitwise.<<</2","type":"function"},{"doc":"Arithmetic right bitshift operator. Calculates the result of an arithmetic right bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &gt;&gt;&gt; 2 0 iex&gt; 1 &gt;&gt;&gt; - 2 4 iex&gt; - 1 &gt;&gt;&gt; 2 - 1 iex&gt; - 1 &gt;&gt;&gt; - 2 - 4","ref":"Bitwise.html#%3E%3E%3E/2","title":"Bitwise.>>>/2","type":"function"},{"doc":"Bitwise OR operator. Calculates the bitwise OR of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 9 ||| 3 11","ref":"Bitwise.html#%7C%7C%7C/2","title":"Bitwise.|||/2","type":"function"},{"doc":"Bitwise NOT unary operator. Calculates the bitwise NOT of the argument. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; ~~~ 2 - 3 iex&gt; ~~~ 2 &amp;&amp;&amp; 3 1","ref":"Bitwise.html#~~~/1","title":"Bitwise.~~~/1","type":"function"},{"doc":"Calculates the bitwise AND of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; band ( 9 , 3 ) 1","ref":"Bitwise.html#band/2","title":"Bitwise.band/2","type":"function"},{"doc":"Calculates the bitwise NOT of the argument. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bnot ( 2 ) - 3 iex&gt; bnot ( 2 ) &amp;&amp;&amp; 3 1","ref":"Bitwise.html#bnot/1","title":"Bitwise.bnot/1","type":"function"},{"doc":"Calculates the bitwise OR of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bor ( 9 , 3 ) 11","ref":"Bitwise.html#bor/2","title":"Bitwise.bor/2","type":"function"},{"doc":"Calculates the result of an arithmetic left bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bsl ( 1 , 2 ) 4 iex&gt; bsl ( 1 , - 2 ) 0 iex&gt; bsl ( - 1 , 2 ) - 4 iex&gt; bsl ( - 1 , - 2 ) - 1","ref":"Bitwise.html#bsl/2","title":"Bitwise.bsl/2","type":"function"},{"doc":"Calculates the result of an arithmetic right bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bsr ( 1 , 2 ) 0 iex&gt; bsr ( 1 , - 2 ) 4 iex&gt; bsr ( - 1 , 2 ) - 1 iex&gt; bsr ( - 1 , - 2 ) - 4","ref":"Bitwise.html#bsr/2","title":"Bitwise.bsr/2","type":"function"},{"doc":"Calculates the bitwise XOR of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bxor ( 9 , 3 ) 10","ref":"Bitwise.html#bxor/2","title":"Bitwise.bxor/2","type":"function"},{"doc":"A Date struct and functions. The Date struct contains the fields year, month, day and calendar. New dates can be built with the new/3 function or using the ~D (see Kernel.sigil_D/2 ) sigil: iex&gt; ~D[2000-01-01] ~D[2000-01-01] Both new/3 and sigil return a struct where the date fields can be accessed directly: iex&gt; date = ~D[2000-01-01] iex&gt; date . year 2000 iex&gt; date . month 1 The functions on this module work with the Date struct as well as any struct that contains the same fields as the Date struct, such as NaiveDateTime and DateTime . Such functions expect Calendar.date/0 in their typespecs (instead of t/0 ). Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries. Comparing dates Comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and similar are structural and based on the Date struct fields. For proper comparison between dates, use the compare/2 function. Using epochs The add/2 and diff/2 functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01): iex&gt; Date . diff ( ~D[2010-04-17] , ~D[1970-01-01] ) 14716 iex&gt; Date . add ( ~D[1970-01-01] , 14716 ) ~D[2010-04-17] Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).","ref":"Date.html","title":"Date","type":"module"},{"doc":"Adds the number of days to the given date . The days are counted as Gregorian days. The date is returned in the same calendar as it was given in. Examples iex&gt; Date . add ( ~D[2000-01-03] , - 2 ) ~D[2000-01-01] iex&gt; Date . add ( ~D[2000-01-01] , 2 ) ~D[2000-01-03] iex&gt; Date . add ( ~N[2000-01-01 09:00:00] , 2 ) ~D[2000-01-03] iex&gt; Date . add ( ~D[-0010-01-01] , - 2 ) ~D[-0011-12-30]","ref":"Date.html#add/2","title":"Date.add/2","type":"function"},{"doc":"Calculates a date that is the first day of the month for the given date . Examples iex&gt; Date . beginning_of_month ( ~D[2000-01-31] ) ~D[2000-01-01] iex&gt; Date . beginning_of_month ( ~D[2000-01-01] ) ~D[2000-01-01] iex&gt; Date . beginning_of_month ( ~N[2000-01-31 01:23:45] ) ~D[2000-01-01]","ref":"Date.html#beginning_of_month/1","title":"Date.beginning_of_month/1","type":"function"},{"doc":"Calculates a date that is the first day of the week for the given date . If the day is already the first day of the week, it returns the day itself. For the built-in ISO calendar, the week starts on Monday. A weekday rather than :default can be given as starting_on . Examples iex&gt; Date . beginning_of_week ( ~D[2020-07-11] ) ~D[2020-07-06] iex&gt; Date . beginning_of_week ( ~D[2020-07-06] ) ~D[2020-07-06] iex&gt; Date . beginning_of_week ( ~D[2020-07-11] , :sunday ) ~D[2020-07-05] iex&gt; Date . beginning_of_week ( ~D[2020-07-11] , :saturday ) ~D[2020-07-11] iex&gt; Date . beginning_of_week ( ~N[2020-07-11 01:23:45] ) ~D[2020-07-06]","ref":"Date.html#beginning_of_week/2","title":"Date.beginning_of_week/2","type":"function"},{"doc":"Compares two date structs. Returns :gt if first date is later than the second and :lt for vice versa. If the two dates are equal :eq is returned. Examples iex&gt; Date . compare ( ~D[2016-04-16] , ~D[2016-04-28] ) :lt This function can also be used to compare across more complex calendar types by considering only the date fields: iex&gt; Date . compare ( ~D[2016-04-16] , ~N[2016-04-28 01:23:45] ) :lt iex&gt; Date . compare ( ~D[2016-04-16] , ~N[2016-04-16 01:23:45] ) :eq iex&gt; Date . compare ( ~N[2016-04-16 12:34:56] , ~N[2016-04-16 01:23:45] ) :eq","ref":"Date.html#compare/2","title":"Date.compare/2","type":"function"},{"doc":"Converts the given date from its calendar to the given calendar . Returns {:ok, date} if the calendars are compatible, or {:error, :incompatible_calendars} if they are not. See also Calendar.compatible_calendars?/2 . Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Date . convert ( ~D[2000-01-01] , Calendar.Holocene ) { :ok , % Date { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 } }","ref":"Date.html#convert/2","title":"Date.convert/2","type":"function"},{"doc":"Similar to Date.convert/2 , but raises an ArgumentError if the conversion between the two calendars is not possible. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Date . convert! ( ~D[2000-01-01] , Calendar.Holocene ) % Date { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 }","ref":"Date.html#convert!/2","title":"Date.convert!/2","type":"function"},{"doc":"Calculates the day-of-era and era for a given calendar date . Returns a tuple {day, era} representing the day within the era and the era number. Examples iex&gt; Date . day_of_era ( ~D[0001-01-01] ) { 1 , 1 } iex&gt; Date . day_of_era ( ~D[0000-12-31] ) { 1 , 0 }","ref":"Date.html#day_of_era/1","title":"Date.day_of_era/1","type":"function"},{"doc":"Calculates the day of the week of a given date . Returns the day of the week as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 7, where 1 is Monday and 7 is Sunday. An optional starting_on value may be supplied, which configures the weekday the week starts on. The default value for it is :default , which translates to :monday for the built-in ISO calendar. Any other weekday may be given to. Examples iex&gt; Date . day_of_week ( ~D[2016-10-31] ) 1 iex&gt; Date . day_of_week ( ~D[2016-11-01] ) 2 iex&gt; Date . day_of_week ( ~N[2016-11-01 01:23:45] ) 2 iex&gt; Date . day_of_week ( ~D[-0015-10-30] ) 3 iex&gt; Date . day_of_week ( ~D[2016-10-31] , :sunday ) 2 iex&gt; Date . day_of_week ( ~D[2016-11-01] , :sunday ) 3 iex&gt; Date . day_of_week ( ~N[2016-11-01 01:23:45] , :sunday ) 3 iex&gt; Date . day_of_week ( ~D[-0015-10-30] , :sunday ) 4","ref":"Date.html#day_of_week/2","title":"Date.day_of_week/2","type":"function"},{"doc":"Calculates the day of the year of a given date . Returns the day of the year as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 366. Examples iex&gt; Date . day_of_year ( ~D[2016-01-01] ) 1 iex&gt; Date . day_of_year ( ~D[2016-11-01] ) 306 iex&gt; Date . day_of_year ( ~D[-0015-10-30] ) 303 iex&gt; Date . day_of_year ( ~D[2004-12-31] ) 366","ref":"Date.html#day_of_year/1","title":"Date.day_of_year/1","type":"function"},{"doc":"Returns the number of days in the given date month. Examples iex&gt; Date . days_in_month ( ~D[1900-01-13] ) 31 iex&gt; Date . days_in_month ( ~D[1900-02-09] ) 28 iex&gt; Date . days_in_month ( ~N[2000-02-20 01:23:45] ) 29","ref":"Date.html#days_in_month/1","title":"Date.days_in_month/1","type":"function"},{"doc":"Calculates the difference between two dates, in a full number of days. It returns the number of Gregorian days between the dates. Only Date structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise. Examples iex&gt; Date . diff ( ~D[2000-01-03] , ~D[2000-01-01] ) 2 iex&gt; Date . diff ( ~D[2000-01-01] , ~D[2000-01-03] ) - 2 iex&gt; Date . diff ( ~D[0000-01-02] , ~D[-0001-12-30] ) 3 iex&gt; Date . diff ( ~D[2000-01-01] , ~N[2000-01-03 09:00:00] ) - 2","ref":"Date.html#diff/2","title":"Date.diff/2","type":"function"},{"doc":"Calculates a date that is the last day of the month for the given date . Examples iex&gt; Date . end_of_month ( ~D[2000-01-01] ) ~D[2000-01-31] iex&gt; Date . end_of_month ( ~D[2000-01-31] ) ~D[2000-01-31] iex&gt; Date . end_of_month ( ~N[2000-01-01 01:23:45] ) ~D[2000-01-31]","ref":"Date.html#end_of_month/1","title":"Date.end_of_month/1","type":"function"},{"doc":"Calculates a date that is the last day of the week for the given date . If the day is already the last day of the week, it returns the day itself. For the built-in ISO calendar, the week ends on Sunday. A weekday rather than :default can be given as starting_on . Examples iex&gt; Date . end_of_week ( ~D[2020-07-11] ) ~D[2020-07-12] iex&gt; Date . end_of_week ( ~D[2020-07-05] ) ~D[2020-07-05] iex&gt; Date . end_of_week ( ~D[2020-07-06] , :sunday ) ~D[2020-07-11] iex&gt; Date . end_of_week ( ~D[2020-07-06] , :sunday ) ~D[2020-07-11] iex&gt; Date . end_of_week ( ~D[2020-07-06] , :saturday ) ~D[2020-07-10] iex&gt; Date . end_of_week ( ~N[2020-07-11 01:23:45] ) ~D[2020-07-12]","ref":"Date.html#end_of_week/2","title":"Date.end_of_week/2","type":"function"},{"doc":"Converts an Erlang date tuple to a Date struct. Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple. Examples iex&gt; Date . from_erl ( { 2000 , 1 , 1 } ) { :ok , ~D[2000-01-01] } iex&gt; Date . from_erl ( { 2000 , 13 , 1 } ) { :error , :invalid_date }","ref":"Date.html#from_erl/2","title":"Date.from_erl/2","type":"function"},{"doc":"Converts an Erlang date tuple but raises for invalid dates. Examples iex&gt; Date . from_erl! ( { 2000 , 1 , 1 } ) ~D[2000-01-01] iex&gt; Date . from_erl! ( { 2000 , 13 , 1 } ) ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date","ref":"Date.html#from_erl!/2","title":"Date.from_erl!/2","type":"function"},{"doc":"Converts a number of gregorian days to a Date struct. Examples iex&gt; Date . from_gregorian_days ( 1 ) ~D[0000-01-02] iex&gt; Date . from_gregorian_days ( 730_485 ) ~D[2000-01-01] iex&gt; Date . from_gregorian_days ( - 1 ) ~D[-0001-12-31]","ref":"Date.html#from_gregorian_days/2","title":"Date.from_gregorian_days/2","type":"function"},{"doc":"Parses the extended &quot;Dates&quot; format described by ISO 8601:2019 . The year parsed by this function is limited to four digits. Examples iex&gt; Date . from_iso8601 ( &quot;2015-01-23&quot; ) { :ok , ~D[2015-01-23] } iex&gt; Date . from_iso8601 ( &quot;2015:01:23&quot; ) { :error , :invalid_format } iex&gt; Date . from_iso8601 ( &quot;2015-01-32&quot; ) { :error , :invalid_date }","ref":"Date.html#from_iso8601/2","title":"Date.from_iso8601/2","type":"function"},{"doc":"Parses the extended &quot;Dates&quot; format described by ISO 8601:2019 . Raises if the format is invalid. Examples iex&gt; Date . from_iso8601! ( &quot;2015-01-23&quot; ) ~D[2015-01-23] iex&gt; Date . from_iso8601! ( &quot;2015:01:23&quot; ) ** (ArgumentError) cannot parse &quot;2015:01:23&quot; as date, reason: :invalid_format","ref":"Date.html#from_iso8601!/2","title":"Date.from_iso8601!/2","type":"function"},{"doc":"Returns true if the year in the given date is a leap year. Examples iex&gt; Date . leap_year? ( ~D[2000-01-01] ) true iex&gt; Date . leap_year? ( ~D[2001-01-01] ) false iex&gt; Date . leap_year? ( ~D[2004-01-01] ) true iex&gt; Date . leap_year? ( ~D[1900-01-01] ) false iex&gt; Date . leap_year? ( ~N[2004-01-01 01:23:45] ) true","ref":"Date.html#leap_year?/1","title":"Date.leap_year?/1","type":"function"},{"doc":"Returns the number of months in the given date year. Example iex&gt; Date . months_in_year ( ~D[1900-01-13] ) 12","ref":"Date.html#months_in_year/1","title":"Date.months_in_year/1","type":"function"},{"doc":"Builds a new ISO date. Expects all values to be integers. Returns {:ok, date} if each entry fits its appropriate range, returns {:error, reason} otherwise. Examples iex&gt; Date . new ( 2000 , 1 , 1 ) { :ok , ~D[2000-01-01] } iex&gt; Date . new ( 2000 , 13 , 1 ) { :error , :invalid_date } iex&gt; Date . new ( 2000 , 2 , 29 ) { :ok , ~D[2000-02-29] } iex&gt; Date . new ( 2000 , 2 , 30 ) { :error , :invalid_date } iex&gt; Date . new ( 2001 , 2 , 29 ) { :error , :invalid_date }","ref":"Date.html#new/4","title":"Date.new/4","type":"function"},{"doc":"Builds a new ISO date. Expects all values to be integers. Returns date if each entry fits its appropriate range, raises if the date is invalid. Examples iex&gt; Date . new! ( 2000 , 1 , 1 ) ~D[2000-01-01] iex&gt; Date . new! ( 2000 , 13 , 1 ) ** (ArgumentError) cannot build date, reason: :invalid_date iex&gt; Date . new! ( 2000 , 2 , 29 ) ~D[2000-02-29]","ref":"Date.html#new!/4","title":"Date.new!/4","type":"function"},{"doc":"Calculates the quarter of the year of a given date . Returns the day of the year as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 4. Examples iex&gt; Date . quarter_of_year ( ~D[2016-10-31] ) 4 iex&gt; Date . quarter_of_year ( ~D[2016-01-01] ) 1 iex&gt; Date . quarter_of_year ( ~N[2016-04-01 01:23:45] ) 2 iex&gt; Date . quarter_of_year ( ~D[-0015-09-30] ) 3","ref":"Date.html#quarter_of_year/1","title":"Date.quarter_of_year/1","type":"function"},{"doc":"Returns a range of dates. A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars. Ranges of dates can be either increasing ( first &lt;= last ) or decreasing ( first &gt; last ). They are also always inclusive. Examples iex&gt; Date . range ( ~D[1999-01-01] , ~D[2000-01-01] ) # DateRange &lt; ~D[1999-01-01] , ~D[2000-01-01] &gt; A range of dates implements the Enumerable protocol, which means functions in the Enum module can be used to work with ranges: iex&gt; range = Date . range ( ~D[2001-01-01] , ~D[2002-01-01] ) iex&gt; Enum . count ( range ) 366 iex&gt; Enum . member? ( range , ~D[2001-02-01] ) true iex&gt; Enum . take ( range , 3 ) [ ~D[2001-01-01] , ~D[2001-01-02] , ~D[2001-01-03] ]","ref":"Date.html#range/2","title":"Date.range/2","type":"function"},{"doc":"Returns a range of dates with a step. Examples iex&gt; range = Date . range ( ~D[2001-01-01] , ~D[2002-01-01] , 2 ) iex&gt; range # DateRange &lt; ~D[2001-01-01] , ~D[2002-01-01] , 2 &gt; iex&gt; Enum . count ( range ) 183 iex&gt; Enum . member? ( range , ~D[2001-01-03] ) true iex&gt; Enum . take ( range , 3 ) [ ~D[2001-01-01] , ~D[2001-01-03] , ~D[2001-01-05] ]","ref":"Date.html#range/3","title":"Date.range/3","type":"function"},{"doc":"Converts the given date to an Erlang date tuple. Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise. Examples iex&gt; Date . to_erl ( ~D[2000-01-01] ) { 2000 , 1 , 1 } iex&gt; Date . to_erl ( ~N[2000-01-01 00:00:00] ) { 2000 , 1 , 1 }","ref":"Date.html#to_erl/1","title":"Date.to_erl/1","type":"function"},{"doc":"Converts a date struct to a number of gregorian days. Examples iex&gt; Date . to_gregorian_days ( ~D[0000-01-02] ) 1 iex&gt; Date . to_gregorian_days ( ~D[2000-01-01] ) 730_485 iex&gt; Date . to_gregorian_days ( ~N[2000-01-01 00:00:00] ) 730_485","ref":"Date.html#to_gregorian_days/1","title":"Date.to_gregorian_days/1","type":"function"},{"doc":"Converts the given date to ISO 8601:2019 . By default, Date.to_iso8601/2 returns dates formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an ArgumentError . Examples iex&gt; Date . to_iso8601 ( ~D[2000-02-28] ) &quot;2000-02-28&quot; iex&gt; Date . to_iso8601 ( ~D[2000-02-28] , :basic ) &quot;20000228&quot; iex&gt; Date . to_iso8601 ( ~N[2000-02-28 00:00:00] ) &quot;2000-02-28&quot;","ref":"Date.html#to_iso8601/2","title":"Date.to_iso8601/2","type":"function"},{"doc":"Converts the given date to a string according to its calendar. Examples iex&gt; Date . to_string ( ~D[2000-02-28] ) &quot;2000-02-28&quot; iex&gt; Date . to_string ( ~N[2000-02-28 01:23:45] ) &quot;2000-02-28&quot; iex&gt; Date . to_string ( ~D[-0100-12-15] ) &quot;-0100-12-15&quot;","ref":"Date.html#to_string/1","title":"Date.to_string/1","type":"function"},{"doc":"Returns the current date in UTC. Examples iex&gt; date = Date . utc_today ( ) iex&gt; date . year &gt;= 2016 true","ref":"Date.html#utc_today/1","title":"Date.utc_today/1","type":"function"},{"doc":"Calculates the year-of-era and era for a given calendar year. Returns a tuple {year, era} representing the year within the era and the era number. Examples iex&gt; Date . year_of_era ( ~D[0001-01-01] ) { 1 , 1 } iex&gt; Date . year_of_era ( ~D[0000-12-31] ) { 1 , 0 } iex&gt; Date . year_of_era ( ~D[-0001-01-01] ) { 2 , 0 }","ref":"Date.html#year_of_era/1","title":"Date.year_of_era/1","type":"function"},{"doc":"","ref":"Date.html#t:t/0","title":"Date.t/0","type":"type"},{"doc":"A datetime implementation with a time zone. This datetime can be seen as an ephemeral snapshot of a datetime at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes. Remember, comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the compare/2 function. Developers should avoid creating the DateTime struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries. Time zone database Many functions in this module require a time zone database. By default, it uses the default time zone database returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes and returns {:error, :utc_only_time_zone_database} for any other time zone. Other time zone databases can also be configured. For example, two of the available options are: tz tzdata To use them, first make sure it is added as a dependency in mix.exs . It can then be configured either via configuration: config :elixir , :time_zone_database , Tzdata.TimeZoneDatabase or by calling Calendar.put_time_zone_database/1 : Calendar . put_time_zone_database ( Tzdata.TimeZoneDatabase ) See the proper names in the library installation instructions.","ref":"DateTime.html","title":"DateTime","type":"module"},{"doc":"Adds a specified amount of time to a DateTime . Accepts an amount_to_add in any unit available from System.time_unit/0 . Negative values will move backwards in time. Takes changes such as summer time/DST into account. This means that adding time can cause the wall time to &quot;go backwards&quot; during &quot;fall back&quot; during autumn. Adding just a few seconds to a datetime just before &quot;spring forward&quot; can cause wall time to increase by more than an hour. Fractional second precision stays the same in a similar way to NaiveDateTime.add/2 . Examples iex&gt; dt = DateTime . from_naive! ( ~N[2018-11-15 10:00:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; dt |&gt; DateTime . add ( 3600 , :second , FakeTimeZoneDatabase ) # DateTime &lt; 2018 - 11 - 15 11 : 00 : 00 + 01 : 00 CET Europe / Copenhagen &gt; iex&gt; DateTime . add ( ~U[2018-11-15 10:00:00Z] , 3600 , :second ) ~U[2018-11-15 11:00:00Z] When adding 3 seconds just before &quot;spring forward&quot; we go from 1:59:59 to 3:00:02 iex&gt; dt = DateTime . from_naive! ( ~N[2019-03-31 01:59:59.123] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; dt |&gt; DateTime . add ( 3 , :second , FakeTimeZoneDatabase ) # DateTime &lt; 2019 - 03 - 31 03 : 00 : 02.123 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#add/4","title":"DateTime.add/4","type":"function"},{"doc":"Compares two datetime structs. Returns :gt if the first datetime is later than the second and :lt for vice versa. If the two datetimes are equal :eq is returned. Note that both UTC and Standard offsets will be taken into account when comparison is done. Examples iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; dt2 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . compare ( dt1 , dt2 ) :gt","ref":"DateTime.html#compare/2","title":"DateTime.compare/2","type":"function"},{"doc":"Converts a given datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an {:error, :incompatible_calendars} tuple is returned. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . convert ( dt1 , Calendar.Holocene ) { :ok , % DateTime { calendar : Calendar.Holocene , day : 29 , hour : 23 , microsecond : { 0 , 0 } , minute : 0 , month : 2 , second : 7 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; , utc_offset : - 14400 , year : 12000 , zone_abbr : &quot;AMT&quot; } }","ref":"DateTime.html#convert/2","title":"DateTime.convert/2","type":"function"},{"doc":"Converts a given datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an ArgumentError is raised. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . convert! ( dt1 , Calendar.Holocene ) % DateTime { calendar : Calendar.Holocene , day : 29 , hour : 23 , microsecond : { 0 , 0 } , minute : 0 , month : 2 , second : 7 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; , utc_offset : - 14400 , year : 12000 , zone_abbr : &quot;AMT&quot; }","ref":"DateTime.html#convert!/2","title":"DateTime.convert!/2","type":"function"},{"doc":"Subtracts datetime2 from datetime1 . The answer can be returned in any unit available from System.time_unit/0 . Leap seconds are not taken into account. This function returns the difference in seconds where seconds are measured according to Calendar.ISO . Examples iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; dt2 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . diff ( dt1 , dt2 ) 18000 iex&gt; DateTime . diff ( dt2 , dt1 ) - 18000","ref":"DateTime.html#diff/3","title":"DateTime.diff/3","type":"function"},{"doc":"Converts a number of gregorian seconds to a DateTime struct. The returned DateTime will have UTC timezone, if you want other timezone, please use DateTime.shift_zone/3 . Examples iex&gt; DateTime . from_gregorian_seconds ( 1 ) ~U[0000-01-01 00:00:01Z] iex&gt; DateTime . from_gregorian_seconds ( 63_755_511_991 , { 5000 , 3 } ) ~U[2020-05-01 00:26:31.005Z] iex&gt; DateTime . from_gregorian_seconds ( - 1 ) ~U[-0001-12-31 23:59:59Z]","ref":"DateTime.html#from_gregorian_seconds/3","title":"DateTime.from_gregorian_seconds/3","type":"function"},{"doc":"Parses the extended &quot;Date and time of day&quot; format described by ISO 8601:2019 . Since ISO 8601 does not include the proper time zone, the given string will be converted to UTC and its offset in seconds will be returned as part of this function. Therefore offset information must be present in the string. As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function. Note leap seconds are not supported by the built-in Calendar.ISO. Examples iex&gt; { :ok , datetime , 0 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07Z&quot; ) iex&gt; datetime ~U[2015-01-23 23:50:07Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123+02:30&quot; ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07,123+02:30&quot; ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z] iex&gt; { :ok , datetime , 0 } = DateTime . from_iso8601 ( &quot;-2015-01-23T23:50:07Z&quot; ) iex&gt; datetime ~U[-2015-01-23 23:50:07Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;-2015-01-23T23:50:07,123+02:30&quot; ) iex&gt; datetime ~U[-2015-01-23 21:20:07.123Z] iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23P23:50:07&quot; ) { :error , :invalid_format } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07&quot; ) { :error , :missing_offset } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23 23:50:61&quot; ) { :error , :invalid_time } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-32 23:50:07&quot; ) { :error , :invalid_date } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-00:00&quot; ) { :error , :invalid_format }","ref":"DateTime.html#from_iso8601/2","title":"DateTime.from_iso8601/2","type":"function"},{"doc":"Converts the given NaiveDateTime to DateTime . It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . from_naive ( ~N[2016-05-24 13:26:08.003] , &quot;Etc/UTC&quot; ) { :ok , ~U[2016-05-24 13:26:08.003Z] } When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned in a tuple. The first datetime is also the one which comes first chronologically, while the second one comes last. iex&gt; { :ambiguous , first_dt , second_dt } = DateTime . from_naive ( ~N[2018-10-28 02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; first_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; iex&gt; second_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 01 : 00 CET Europe / Copenhagen &gt; When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap. iex&gt; { :gap , just_before , just_after } = DateTime . from_naive ( ~N[2019-03-31 02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; just_before # DateTime &lt; 2019 - 03 - 31 01 : 59 : 59.999999 + 01 : 00 CET Europe / Copenhagen &gt; iex&gt; just_after # DateTime &lt; 2019 - 03 - 31 03 : 00 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone. iex&gt; { :ok , datetime } = DateTime . from_naive ( ~N[2018-07-28 12:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; datetime # DateTime &lt; 2018 - 07 - 28 12 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; This function accepts any map or struct that contains at least the same fields as a NaiveDateTime struct. The most common example of that is a DateTime . In this case the information about the time zone of that DateTime is completely ignored. This is the same principle as passing a DateTime to Date.to_iso8601/2 . Date.to_iso8601/2 extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others. This way if you have a DateTime in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a DateTime for 2018-08-24 10:00:00 in UTC you can do: iex&gt; cph_datetime = DateTime . from_naive! ( ~N[2018-08-24 10:00:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; { :ok , utc_datetime } = DateTime . from_naive ( cph_datetime , &quot;Etc/UTC&quot; , FakeTimeZoneDatabase ) iex&gt; utc_datetime ~U[2018-08-24 10:00:00Z] If instead you want a DateTime for the same point time in a different time zone see the DateTime.shift_zone/3 function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.","ref":"DateTime.html#from_naive/3","title":"DateTime.from_naive/3","type":"function"},{"doc":"Converts the given NaiveDateTime to DateTime . It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . from_naive! ( ~N[2016-05-24 13:26:08.003] , &quot;Etc/UTC&quot; ) ~U[2016-05-24 13:26:08.003Z] iex&gt; DateTime . from_naive! ( ~N[2018-05-24 13:26:08.003] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) # DateTime &lt; 2018 - 05 - 24 13 : 26 : 08.003 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#from_naive!/3","title":"DateTime.from_naive!/3","type":"function"},{"doc":"Converts the given Unix time to DateTime . The integer can be given in different unit according to System.convert_time_unit/3 and it will be converted to microseconds internally. Up to 253402300799 seconds is supported. Unix times are always in UTC and therefore the DateTime will be returned in UTC. Examples iex&gt; { :ok , datetime } = DateTime . from_unix ( 1_464_096_368 ) iex&gt; datetime ~U[2016-05-24 13:26:08Z] iex&gt; { :ok , datetime } = DateTime . from_unix ( 1_432_560_368_868_569 , :microsecond ) iex&gt; datetime ~U[2015-05-25 13:26:08.868569Z] iex&gt; { :ok , datetime } = DateTime . from_unix ( 253_402_300_799 ) iex&gt; datetime ~U[9999-12-31 23:59:59Z] iex&gt; { :error , :invalid_unix_time } = DateTime . from_unix ( 253_402_300_800 ) The unit can also be an integer as in System.time_unit/0 : iex&gt; { :ok , datetime } = DateTime . from_unix ( 143_256_036_886_856 , 1024 ) iex&gt; datetime ~U[6403-03-17 07:05:22.320312Z] Negative Unix times are supported up to -377705116800 seconds: iex&gt; { :ok , datetime } = DateTime . from_unix ( - 377_705_116_800 ) iex&gt; datetime ~U[-9999-01-01 00:00:00Z] iex&gt; { :error , :invalid_unix_time } = DateTime . from_unix ( - 377_705_116_801 )","ref":"DateTime.html#from_unix/3","title":"DateTime.from_unix/3","type":"function"},{"doc":"Converts the given Unix time to DateTime . The integer can be given in different unit according to System.convert_time_unit/3 and it will be converted to microseconds internally. Unix times are always in UTC and therefore the DateTime will be returned in UTC. Examples # An easy way to get the Unix epoch is passing 0 to this function iex&gt; DateTime . from_unix! ( 0 ) ~U[1970-01-01 00:00:00Z] iex&gt; DateTime . from_unix! ( 1_464_096_368 ) ~U[2016-05-24 13:26:08Z] iex&gt; DateTime . from_unix! ( 1_432_560_368_868_569 , :microsecond ) ~U[2015-05-25 13:26:08.868569Z] iex&gt; DateTime . from_unix! ( 143_256_036_886_856 , 1024 ) ~U[6403-03-17 07:05:22.320312Z]","ref":"DateTime.html#from_unix!/3","title":"DateTime.from_unix!/3","type":"function"},{"doc":"Builds a datetime from date and time structs. It expects a time zone to put the DateTime in. If the time zone is not passed it will default to &quot;Etc/UTC&quot; , which always succeeds. Otherwise, the DateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . new ( ~D[2016-05-24] , ~T[13:26:08.003] , &quot;Etc/UTC&quot; ) { :ok , ~U[2016-05-24 13:26:08.003Z] } When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned in a tuple. The first datetime is also the one which comes first chronologically, while the second one comes last. iex&gt; { :ambiguous , first_dt , second_dt } = DateTime . new ( ~D[2018-10-28] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; first_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; iex&gt; second_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 01 : 00 CET Europe / Copenhagen &gt; When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap. iex&gt; { :gap , just_before , just_after } = DateTime . new ( ~D[2019-03-31] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; just_before # DateTime &lt; 2019 - 03 - 31 01 : 59 : 59.999999 + 01 : 00 CET Europe / Copenhagen &gt; iex&gt; just_after # DateTime &lt; 2019 - 03 - 31 03 : 00 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone. iex&gt; { :ok , datetime } = DateTime . new ( ~D[2018-07-28] , ~T[12:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; datetime # DateTime &lt; 2018 - 07 - 28 12 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#new/4","title":"DateTime.new/4","type":"function"},{"doc":"Builds a datetime from date and time structs, raising on errors. It expects a time zone to put the DateTime in. If the time zone is not passed it will default to &quot;Etc/UTC&quot; , which always succeeds. Otherwise, the DateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . new! ( ~D[2016-05-24] , ~T[13:26:08.003] , &quot;Etc/UTC&quot; ) ~U[2016-05-24 13:26:08.003Z] When the datetime is ambiguous - for instance during changing from summer to winter time - an error will be raised. iex&gt; DateTime . new! ( ~D[2018-10-28] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime&lt;2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen&gt; and #DateTime&lt;2018-10-28 02:30:00+01:00 CET Europe/Copenhagen&gt; When there is a gap in wall time - for instance in spring when the clocks are turned forward - an error will be raised. iex&gt; DateTime . new! ( ~D[2019-03-31] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime&lt;2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen&gt; and #DateTime&lt;2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen&gt; Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone. iex&gt; datetime = DateTime . new! ( ~D[2018-07-28] , ~T[12:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; datetime # DateTime &lt; 2018 - 07 - 28 12 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#new!/4","title":"DateTime.new!/4","type":"function"},{"doc":"Returns the current datetime in the provided time zone. By default, it uses the default time_zone returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes. Other time zone databases can be passed as argument or set globally. See the &quot;Time zone database&quot; section in the module docs. Examples iex&gt; { :ok , datetime } = DateTime . now ( &quot;Etc/UTC&quot; ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot; iex&gt; DateTime . now ( &quot;Europe/Copenhagen&quot; ) { :error , :utc_only_time_zone_database } iex&gt; DateTime . now ( &quot;bad timezone&quot; , FakeTimeZoneDatabase ) { :error , :time_zone_not_found }","ref":"DateTime.html#now/2","title":"DateTime.now/2","type":"function"},{"doc":"Returns the current datetime in the provided time zone or raises on errors See now/2 for more information. Examples iex&gt; datetime = DateTime . now! ( &quot;Etc/UTC&quot; ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot; iex&gt; DateTime . now! ( &quot;Europe/Copenhagen&quot; ) ** (ArgumentError) cannot get current datetime in &quot;Europe/Copenhagen&quot; time zone, reason: :utc_only_time_zone_database iex&gt; DateTime . now! ( &quot;bad timezone&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot get current datetime in &quot;bad timezone&quot; time zone, reason: :time_zone_not_found","ref":"DateTime.html#now!/2","title":"DateTime.now!/2","type":"function"},{"doc":"Changes the time zone of a DateTime . Returns a DateTime for the same point in time, but instead at the time zone provided. It assumes that DateTime is valid and exists in the given time zone and calendar. By default, it uses the default time zone database returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes. Other time zone databases can be passed as argument or set globally. See the &quot;Time zone database&quot; section in the module docs. Examples iex&gt; { :ok , pacific_datetime } = DateTime . shift_zone ( ~U[2018-07-16 10:00:00Z] , &quot;America/Los_Angeles&quot; , FakeTimeZoneDatabase ) iex&gt; pacific_datetime # DateTime &lt; 2018 - 07 - 16 03 : 00 : 00 - 07 : 00 PDT America / Los_Angeles &gt; iex&gt; DateTime . shift_zone ( ~U[2018-07-16 10:00:00Z] , &quot;bad timezone&quot; , FakeTimeZoneDatabase ) { :error , :time_zone_not_found }","ref":"DateTime.html#shift_zone/3","title":"DateTime.shift_zone/3","type":"function"},{"doc":"Changes the time zone of a DateTime or raises on errors. See shift_zone/3 for more information. Examples iex&gt; DateTime . shift_zone! ( ~U[2018-07-16 10:00:00Z] , &quot;America/Los_Angeles&quot; , FakeTimeZoneDatabase ) # DateTime &lt; 2018 - 07 - 16 03 : 00 : 00 - 07 : 00 PDT America / Los_Angeles &gt; iex&gt; DateTime . shift_zone! ( ~U[2018-07-16 10:00:00Z] , &quot;bad timezone&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to &quot;bad timezone&quot; time zone, reason: :time_zone_not_found","ref":"DateTime.html#shift_zone!/3","title":"DateTime.shift_zone!/3","type":"function"},{"doc":"Converts a DateTime into a Date . Because Date does not hold time nor time zone information, data will be lost during the conversion. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_date ( dt ) ~D[2000-02-29]","ref":"DateTime.html#to_date/1","title":"DateTime.to_date/1","type":"function"},{"doc":"Converts a DateTime struct to a number of gregorian seconds and microseconds. Examples iex&gt; dt = % DateTime { year : 0000 , month : 1 , day : 1 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 0 , minute : 0 , second : 1 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_gregorian_seconds ( dt ) { 1 , 0 } iex&gt; dt = % DateTime { year : 2020 , month : 5 , day : 1 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 0 , minute : 26 , second : 31 , microsecond : { 5000 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_gregorian_seconds ( dt ) { 63_755_511_991 , 5000 } iex&gt; dt = % DateTime { year : 2020 , month : 5 , day : 1 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 1 , minute : 26 , second : 31 , microsecond : { 5000 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_gregorian_seconds ( dt ) { 63_755_511_991 , 5000 }","ref":"DateTime.html#to_gregorian_seconds/1","title":"DateTime.to_gregorian_seconds/1","type":"function"},{"doc":"Converts the given datetime to ISO 8601:2019 format. By default, DateTime.to_iso8601/2 returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise. You can also optionally specify an offset for the formatted string. WARNING: the ISO 8601 datetime format does not contain the time zone nor its abbreviation, which means information is lost when converting to such format. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_iso8601 ( dt ) &quot;2000-02-29T23:00:07+01:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_iso8601 ( dt ) &quot;2000-02-29T23:00:07Z&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended ) &quot;2000-02-29T23:00:07-04:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :basic ) &quot;20000229T230007-0400&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended , 3600 ) &quot;2000-03-01T04:00:07+01:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended , 0 ) &quot;2000-03-01T03:00:07+00:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 3 , day : 01 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 03 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended , 0 ) &quot;2000-03-01T03:00:07Z&quot; iex&gt; { :ok , dt , offset } = DateTime . from_iso8601 ( &quot;2000-03-01T03:00:07Z&quot; ) iex&gt; &quot;2000-03-01T03:00:07Z&quot; = DateTime . to_iso8601 ( dt , :extended , offset )","ref":"DateTime.html#to_iso8601/3","title":"DateTime.to_iso8601/3","type":"function"},{"doc":"Converts the given datetime into a NaiveDateTime . Because NaiveDateTime does not hold time zone information, any time zone related data will be lost during the conversion. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 1 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_naive ( dt ) ~N[2000-02-29 23:00:07.0]","ref":"DateTime.html#to_naive/1","title":"DateTime.to_naive/1","type":"function"},{"doc":"Converts the given datetime to a string according to its calendar. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_string ( dt ) &quot;2000-02-29 23:00:07+01:00 CET Europe/Warsaw&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_string ( dt ) &quot;2000-02-29 23:00:07Z&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_string ( dt ) &quot;2000-02-29 23:00:07-04:00 AMT America/Manaus&quot; iex&gt; dt = % DateTime { year : - 100 , month : 12 , day : 19 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 3 , minute : 20 , second : 31 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Stockholm&quot; } iex&gt; DateTime . to_string ( dt ) &quot;-0100-12-19 03:20:31+01:00 CET Europe/Stockholm&quot;","ref":"DateTime.html#to_string/1","title":"DateTime.to_string/1","type":"function"},{"doc":"Converts a DateTime into Time . Because Time does not hold date nor time zone information, data will be lost during the conversion. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 1 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_time ( dt ) ~T[23:00:07.0]","ref":"DateTime.html#to_time/1","title":"DateTime.to_time/1","type":"function"},{"doc":"Converts the given datetime to Unix time. The datetime is expected to be using the ISO calendar with a year greater than or equal to 0. It will return the integer with the given unit, according to System.convert_time_unit/3 . If you want to get the current time in Unix seconds, do not do DateTime.utc_now() |&gt; DateTime.to_unix() . Simply call System.os_time(:second) instead. Examples iex&gt; 1_464_096_368 |&gt; DateTime . from_unix! ( ) |&gt; DateTime . to_unix ( ) 1464096368 iex&gt; dt = % DateTime { calendar : Calendar.ISO , day : 20 , hour : 18 , microsecond : { 273806 , 6 } , ...&gt; minute : 58 , month : 11 , second : 19 , time_zone : &quot;America/Montevideo&quot; , ...&gt; utc_offset : - 10800 , std_offset : 3600 , year : 2014 , zone_abbr : &quot;UYST&quot; } iex&gt; DateTime . to_unix ( dt ) 1416517099 iex&gt; flamel = % DateTime { calendar : Calendar.ISO , day : 22 , hour : 8 , microsecond : { 527771 , 6 } , ...&gt; minute : 2 , month : 3 , second : 25 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; , ...&gt; utc_offset : 0 , year : 1418 , zone_abbr : &quot;UTC&quot; } iex&gt; DateTime . to_unix ( flamel ) - 17412508655","ref":"DateTime.html#to_unix/2","title":"DateTime.to_unix/2","type":"function"},{"doc":"Returns the given datetime with the microsecond field truncated to the given precision ( :microsecond , :millisecond or :second ). The given datetime is returned unchanged if it already has lower precision than the given precision. Examples iex&gt; dt1 = % DateTime { year : 2017 , month : 11 , day : 7 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 11 , minute : 45 , second : 18 , microsecond : { 123456 , 6 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Paris&quot; } iex&gt; DateTime . truncate ( dt1 , :microsecond ) # DateTime &lt; 2017 - 11 - 07 11 : 45 : 18.123456 + 01 : 00 CET Europe / Paris &gt; iex&gt; dt2 = % DateTime { year : 2017 , month : 11 , day : 7 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 11 , minute : 45 , second : 18 , microsecond : { 123456 , 6 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Paris&quot; } iex&gt; DateTime . truncate ( dt2 , :millisecond ) # DateTime &lt; 2017 - 11 - 07 11 : 45 : 18.123 + 01 : 00 CET Europe / Paris &gt; iex&gt; dt3 = % DateTime { year : 2017 , month : 11 , day : 7 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 11 , minute : 45 , second : 18 , microsecond : { 123456 , 6 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Paris&quot; } iex&gt; DateTime . truncate ( dt3 , :second ) # DateTime &lt; 2017 - 11 - 07 11 : 45 : 18 + 01 : 00 CET Europe / Paris &gt;","ref":"DateTime.html#truncate/2","title":"DateTime.truncate/2","type":"function"},{"doc":"Returns the current datetime in UTC. Examples iex&gt; datetime = DateTime . utc_now ( ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot;","ref":"DateTime.html#utc_now/1","title":"DateTime.utc_now/1","type":"function"},{"doc":"","ref":"DateTime.html#t:t/0","title":"DateTime.t/0","type":"type"},{"doc":"Functions to format throw/catch/exit and exceptions. Note that stacktraces in Elixir are only available inside catch and rescue by using the __STACKTRACE__/0 variable. Do not rely on the particular format returned by the format* functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.","ref":"Exception.html","title":"Exception","type":"behaviour"},{"doc":"Called from Exception.blame/3 to augment the exception struct. Can be used to collect additional information about the exception or do some additional expensive computation.","ref":"Exception.html#c:blame/2","title":"Exception.blame/2","type":"callback"},{"doc":"Attaches information to exceptions for extra debugging. This operation is potentially expensive, as it reads data from the file system, parses beam files, evaluates code and so on. If the exception module implements the optional blame/2 callback, it will be invoked to perform the computation.","ref":"Exception.html#blame/3","title":"Exception.blame/3","type":"function"},{"doc":"Blames the invocation of the given module, function and arguments. This function will retrieve the available clauses from bytecode and evaluate them against the given arguments. The clauses are returned as a list of {args, guards} pairs where each argument and each top-level condition in a guard separated by and / or is wrapped in a tuple with blame metadata. This function returns either {:ok, definition, clauses} or :error . Where definition is :def , :defp , :defmacro or :defmacrop .","ref":"Exception.html#blame_mfa/3","title":"Exception.blame_mfa/3","type":"function"},{"doc":"","ref":"Exception.html#c:exception/1","title":"Exception.exception/1","type":"callback"},{"doc":"Returns true if the given term is an exception.","ref":"Exception.html#exception?/1","title":"Exception.exception?/1","type":"function"},{"doc":"Normalizes and formats throw/errors/exits and stacktraces. It relies on format_banner/3 and format_stacktrace/1 to generate the final format. If kind is {:EXIT, pid} , it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.","ref":"Exception.html#format/3","title":"Exception.format/3","type":"function"},{"doc":"Normalizes and formats any throw/error/exit. The message is formatted and displayed in the same format as used by Elixir's CLI. The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.","ref":"Exception.html#format_banner/3","title":"Exception.format_banner/3","type":"function"},{"doc":"Formats an exit. It returns a string. Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.","ref":"Exception.html#format_exit/1","title":"Exception.format_exit/1","type":"function"},{"doc":"Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments. Examples Exception . format_fa ( fn -&gt; nil end , 1 ) #=&gt; &quot;#Function&lt;...&gt;/1&quot;","ref":"Exception.html#format_fa/2","title":"Exception.format_fa/2","type":"function"},{"doc":"Formats the given file and line as shown in stacktraces. If any of the values are nil , they are omitted. Examples iex&gt; Exception . format_file_line ( &quot;foo&quot; , 1 ) &quot;foo:1:&quot; iex&gt; Exception . format_file_line ( &quot;foo&quot; , nil ) &quot;foo:&quot; iex&gt; Exception . format_file_line ( nil , nil ) &quot;&quot;","ref":"Exception.html#format_file_line/3","title":"Exception.format_file_line/3","type":"function"},{"doc":"Formats the given file , line , and column as shown in stacktraces. If any of the values are nil , they are omitted. Examples iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , 1 , 2 ) &quot;foo:1:2:&quot; iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , 1 , nil ) &quot;foo:1:&quot; iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , nil , nil ) &quot;foo:&quot; iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , nil , 2 ) &quot;foo:&quot; iex&gt; Exception . format_file_line_column ( nil , nil , nil ) &quot;&quot;","ref":"Exception.html#format_file_line_column/4","title":"Exception.format_file_line_column/4","type":"function"},{"doc":"Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments. Examples iex&gt; Exception . format_mfa ( Foo , :bar , 1 ) &quot;Foo.bar/1&quot; iex&gt; Exception . format_mfa ( Foo , :bar , [ ] ) &quot;Foo.bar()&quot; iex&gt; Exception . format_mfa ( nil , :bar , [ ] ) &quot;nil.bar()&quot; Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to &quot;anonymous fn in func/arity&quot;","ref":"Exception.html#format_mfa/3","title":"Exception.format_mfa/3","type":"function"},{"doc":"Formats the stacktrace. A stacktrace must be given as an argument. If not, the stacktrace is retrieved from Process.info/2 .","ref":"Exception.html#format_stacktrace/1","title":"Exception.format_stacktrace/1","type":"function"},{"doc":"Receives a stacktrace entry and formats it into a string.","ref":"Exception.html#format_stacktrace_entry/1","title":"Exception.format_stacktrace_entry/1","type":"function"},{"doc":"Gets the message for an exception .","ref":"Exception.html#message/1","title":"Exception.message/1","type":"function"},{"doc":"","ref":"Exception.html#c:message/1","title":"Exception.message/1","type":"callback"},{"doc":"Normalizes an exception, converting Erlang exceptions to Elixir exceptions. It takes the kind spilled by catch as an argument and normalizes only :error , returning the untouched payload for others. The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.","ref":"Exception.html#normalize/3","title":"Exception.normalize/3","type":"function"},{"doc":"","ref":"Exception.html#t:arity_or_args/0","title":"Exception.arity_or_args/0","type":"type"},{"doc":"The kind handled by formatting functions","ref":"Exception.html#t:kind/0","title":"Exception.kind/0","type":"type"},{"doc":"","ref":"Exception.html#t:location/0","title":"Exception.location/0","type":"type"},{"doc":"","ref":"Exception.html#t:non_error_kind/0","title":"Exception.non_error_kind/0","type":"type"},{"doc":"","ref":"Exception.html#t:stacktrace/0","title":"Exception.stacktrace/0","type":"type"},{"doc":"","ref":"Exception.html#t:stacktrace_entry/0","title":"Exception.stacktrace_entry/0","type":"type"},{"doc":"The exception type","ref":"Exception.html#t:t/0","title":"Exception.t/0","type":"type"},{"doc":"Functions for working with floating-point numbers. Kernel functions There are functions related to floating-point numbers on the Kernel module too. Here is a list of them: Kernel.round/1 : rounds a number to the nearest integer. Kernel.trunc/1 : returns the integer part of a number. Known issues There are some very well known problems with floating-point numbers and arithmetics due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself. For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case: The closest representable number to 0.1 is 0.1000000014 The closest representable number to 0.01 is 0.0099999997 Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014, the result is 0.010000000000000002, and because this is not the closest representable number to 0.01, you'll get the wrong result for this operation There are also other known problems like flooring or rounding numbers. See round/2 and floor/2 for more details about them. To learn more about floating-point arithmetic visit: 0.30000000000000004.com What Every Programmer Should Know About Floating-Point Arithmetic","ref":"Float.html","title":"Float","type":"module"},{"doc":"Rounds a float to the smallest integer greater than or equal to num . ceil/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15). The operation is performed on the binary floating point, without a conversion to decimal. The behaviour of ceil/2 for floats can be surprising. For example: iex&gt; Float . ceil ( - 12.52 , 2 ) - 12.51 One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behaviour above. This function always returns floats. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards. Examples iex&gt; Float . ceil ( 34.25 ) 35.0 iex&gt; Float . ceil ( - 56.5 ) - 56.0 iex&gt; Float . ceil ( 34.251 , 2 ) 34.26","ref":"Float.html#ceil/2","title":"Float.ceil/2","type":"function"},{"doc":"Rounds a float to the largest number less than or equal to num . floor/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15). The operation is performed on the binary floating point, without a conversion to decimal. This function always returns a float. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards. Known issues The behaviour of floor/2 for floats can be surprising. For example: iex&gt; Float . floor ( 12.52 , 2 ) 12.51 One may have expected it to floor to 12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 12.51999999, which explains the behaviour above. Examples iex&gt; Float . floor ( 34.25 ) 34.0 iex&gt; Float . floor ( - 56.5 ) - 57.0 iex&gt; Float . floor ( 34.259 , 2 ) 34.25","ref":"Float.html#floor/2","title":"Float.floor/2","type":"function"},{"doc":"Parses a binary into a float. If successful, returns a tuple in the form of {float, remainder_of_binary} ; when the binary cannot be coerced into a valid float, the atom :error is returned. If the size of float exceeds the maximum size of 1.7976931348623157e+308 , the ArgumentError exception is raised. If you want to convert a string-formatted float directly to a float, String.to_float/1 can be used instead. Examples iex&gt; Float . parse ( &quot;34&quot; ) { 34.0 , &quot;&quot; } iex&gt; Float . parse ( &quot;34.25&quot; ) { 34.25 , &quot;&quot; } iex&gt; Float . parse ( &quot;56.5xyz&quot; ) { 56.5 , &quot;xyz&quot; } iex&gt; Float . parse ( &quot;pi&quot; ) :error","ref":"Float.html#parse/1","title":"Float.parse/1","type":"function"},{"doc":"Computes base raised to power of exponent . base must be a float and exponent can be any number. However, if a negative base and a fractional exponent are given, it raises ArithmeticError . It always returns a float. See Integer.pow/2 for exponentiation that returns integers. Examples iex&gt; Float . pow ( 2.0 , 0 ) 1.0 iex&gt; Float . pow ( 2.0 , 1 ) 2.0 iex&gt; Float . pow ( 2.0 , 10 ) 1024.0 iex&gt; Float . pow ( 2.0 , - 1 ) 0.5 iex&gt; Float . pow ( 2.0 , - 3 ) 0.125 iex&gt; Float . pow ( 3.0 , 1.5 ) 5.196152422706632 iex&gt; Float . pow ( - 2.0 , 3 ) - 8.0 iex&gt; Float . pow ( - 2.0 , 4 ) 16.0 iex&gt; Float . pow ( - 1.0 , 0.5 ) ** (ArithmeticError) bad argument in arithmetic expression","ref":"Float.html#pow/2","title":"Float.pow/2","type":"function"},{"doc":"Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Examples iex&gt; Float . ratio ( 0.0 ) { 0 , 1 } iex&gt; Float . ratio ( 3.14 ) { 7070651414971679 , 2251799813685248 } iex&gt; Float . ratio ( - 3.14 ) { - 7070651414971679 , 2251799813685248 } iex&gt; Float . ratio ( 1.5 ) { 3 , 2 } iex&gt; Float . ratio ( - 1.5 ) { - 3 , 2 } iex&gt; Float . ratio ( 16.0 ) { 16 , 1 } iex&gt; Float . ratio ( - 16.0 ) { - 16 , 1 }","ref":"Float.html#ratio/1","title":"Float.ratio/1","type":"function"},{"doc":"Rounds a floating-point value to an arbitrary number of fractional digits (between 0 and 15). The rounding direction always ties to half up. The operation is performed on the binary floating point, without a conversion to decimal. This function only accepts floats and always returns a float. Use Kernel.round/1 if you want a function that accepts both floats and integers and always returns an integer. Known issues The behaviour of round/2 for floats can be surprising. For example: iex&gt; Float . round ( 5.5675 , 3 ) 5.567 One may have expected it to round to the half up 5.568. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 5.567499999, which explains the behaviour above. If you want exact rounding for decimals, you must use a decimal library. The behaviour above is also in accordance to reference implementations, such as &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot; by David M. Gay. Examples iex&gt; Float . round ( 12.5 ) 13.0 iex&gt; Float . round ( 5.5674 , 3 ) 5.567 iex&gt; Float . round ( 5.5675 , 3 ) 5.567 iex&gt; Float . round ( - 5.5674 , 3 ) - 5.567 iex&gt; Float . round ( - 5.5675 ) - 6.0 iex&gt; Float . round ( 12.341444444444441 , 15 ) 12.341444444444441","ref":"Float.html#round/2","title":"Float.round/2","type":"function"},{"doc":"Returns a charlist which corresponds to the text representation of the given float. It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation. Examples iex&gt; Float . to_charlist ( 7.0 ) &#39;7.0&#39;","ref":"Float.html#to_charlist/1","title":"Float.to_charlist/1","type":"function"},{"doc":"Returns a binary which corresponds to the text representation of the given float. It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation. Examples iex&gt; Float . to_string ( 7.0 ) &quot;7.0&quot;","ref":"Float.html#to_string/1","title":"Float.to_string/1","type":"function"},{"doc":"","ref":"Float.html#t:precision_range/0","title":"Float.precision_range/0","type":"type"},{"doc":"A set of functions for working with functions. Anonymous functions are typically created by using fn : iex&gt; add = fn a , b -&gt; a + b end iex&gt; add . ( 1 , 2 ) 3 Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments: iex&gt; negate = fn ...&gt; true -&gt; false ...&gt; false -&gt; true ...&gt; end iex&gt; negate . ( false ) true The capture operator It is also possible to capture public module functions and pass them around as if they were anonymous functions by using the capture operator Kernel.SpecialForms.&amp;/1 : iex&gt; add = &amp; Kernel . + / 2 iex&gt; add . ( 1 , 2 ) 3 iex&gt; length = &amp; String . length / 1 iex&gt; length . ( &quot;hello&quot; ) 5 To capture a definition within the current module, you can skip the module prefix, such as &amp;my_fun/2 . In those cases, the captured function can be public ( def ) or private ( defp ). The capture operator can also be used to create anonymous functions that expect at least one argument: iex&gt; add = &amp; ( &amp;1 + &amp;2 ) iex&gt; add . ( 1 , 2 ) 3 In such cases, using the capture operator is no different than using fn . Internal and external functions We say that functions that point to definitions residing in modules, such as &amp;String.length/1 , are external functions. All other functions are local and they are always bound to the file or module that defined them. Besides the functions in this module to work with functions, Kernel also has an apply/2 function that invokes a function with a dynamic number of arguments, as well as is_function/1 and is_function/2 , to check respectively if a given value is a function or a function of a given arity.","ref":"Function.html","title":"Function","type":"module"},{"doc":"Captures the given function. Inlined by the compiler. Examples iex&gt; Function . capture ( String , :length , 1 ) &amp; String . length / 1","ref":"Function.html#capture/3","title":"Function.capture/3","type":"function"},{"doc":"Returns its input value . This function can be passed as an anonymous function to transformation functions. Examples iex&gt; Function . identity ( &quot;Hello world!&quot; ) &quot;Hello world!&quot; iex&gt; &#39;abcdaabccc&#39; |&gt; Enum . sort ( ) |&gt; Enum . chunk_by ( &amp; Function . identity / 1 ) [ &#39;aaa&#39; , &#39;bb&#39; , &#39;cccc&#39; , &#39;d&#39; ] iex&gt; Enum . group_by ( &#39;abracadabra&#39; , &amp; Function . identity / 1 ) %{ 97 = &gt; &#39;aaaaa&#39; , 98 = &gt; &#39;bb&#39; , 99 = &gt; &#39;c&#39; , 100 = &gt; &#39;d&#39; , 114 = &gt; &#39;rr&#39; } iex&gt; Enum . map ( [ 1 , 2 , 3 , 4 ] , &amp; Function . identity / 1 ) [ 1 , 2 , 3 , 4 ]","ref":"Function.html#identity/1","title":"Function.identity/1","type":"function"},{"doc":"Returns a keyword list with information about a function. The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following: :type - :local (for anonymous functions) or :external (for named functions). :module - an atom which is the module where the function is defined when anonymous or the module which the function refers to when it's a named function. :arity - (integer) the number of arguments the function is to be called with. :name - (atom) the name of the function. :env - a list of the environment or free variables. For named functions, the returned list is always empty. When fun is an anonymous function (that is, the type is :local ), the following additional keys are returned: :pid - PID of the process that originally created the function. :index - (integer) an index into the module function table. :new_index - (integer) an index into the module function table. :new_uniq - (binary) a unique value for this function. It's calculated from the compiled code for the entire module. :uniq - (integer) a unique value for this function. This integer is calculated from the compiled code for the entire module. Note : this function must be used only for debugging purposes. Inlined by the compiler. Examples iex&gt; fun = fn x -&gt; x end iex&gt; info = Function . info ( fun ) iex&gt; Keyword . get ( info , :arity ) 1 iex&gt; Keyword . get ( info , :type ) :local iex&gt; fun = &amp; String . length / 1 iex&gt; info = Function . info ( fun ) iex&gt; Keyword . get ( info , :type ) :external iex&gt; Keyword . get ( info , :name ) :length","ref":"Function.html#info/1","title":"Function.info/1","type":"function"},{"doc":"Returns a specific information about the function. The returned information is a two-element tuple in the shape of {info, value} . For any function, the information asked for can be any of the atoms :module , :name , :arity , :env , or :type . For anonymous functions, there is also information about any of the atoms :index , :new_index , :new_uniq , :uniq , and :pid . For a named function, the value of any of these items is always the atom :undefined . For more information on each of the possible returned values, see info/1 . Inlined by the compiler. Examples iex&gt; f = fn x -&gt; x end iex&gt; Function . info ( f , :arity ) { :arity , 1 } iex&gt; Function . info ( f , :type ) { :type , :local } iex&gt; fun = &amp; String . length / 1 iex&gt; Function . info ( fun , :name ) { :name , :length } iex&gt; Function . info ( fun , :pid ) { :pid , :undefined }","ref":"Function.html#info/2","title":"Function.info/2","type":"function"},{"doc":"","ref":"Function.html#t:information/0","title":"Function.information/0","type":"type"},{"doc":"Functions for working with integers. Some functions that work on integers are found in Kernel : abs/1 div/2 max/2 min/2 rem/2","ref":"Integer.html","title":"Integer","type":"module"},{"doc":"Returns the ordered digits for the given integer . An optional base value may be provided representing the radix for the returned digits. This one must be an integer &gt;= 2. Examples iex&gt; Integer . digits ( 123 ) [ 1 , 2 , 3 ] iex&gt; Integer . digits ( 170 , 2 ) [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] iex&gt; Integer . digits ( - 170 , 2 ) [ - 1 , 0 , - 1 , 0 , - 1 , 0 , - 1 , 0 ]","ref":"Integer.html#digits/2","title":"Integer.digits/2","type":"function"},{"doc":"Returns the extended greatest common divisor of the two given integers. It uses the Extended Euclidean algorithm to return a three-element tuple with the gcd and the coefficients m and n of Bézout's identity such that: gcd ( a , b ) = m * a + n * b By convention, extended_gcd(0, 0) returns {0, 0, 0} . Examples iex&gt; Integer . extended_gcd ( 240 , 46 ) { 2 , - 9 , 47 } iex&gt; Integer . extended_gcd ( 46 , 240 ) { 2 , 47 , - 9 } iex&gt; Integer . extended_gcd ( - 46 , 240 ) { 2 , - 47 , - 9 } iex&gt; Integer . extended_gcd ( - 46 , - 240 ) { 2 , - 47 , 9 } iex&gt; Integer . extended_gcd ( 14 , 21 ) { 7 , - 1 , 1 } iex&gt; Integer . extended_gcd ( 10 , 0 ) { 10 , 1 , 0 } iex&gt; Integer . extended_gcd ( 0 , 10 ) { 10 , 0 , 1 } iex&gt; Integer . extended_gcd ( 0 , 0 ) { 0 , 0 , 0 }","ref":"Integer.html#extended_gcd/2","title":"Integer.extended_gcd/2","type":"function"},{"doc":"Performs a floored integer division. Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . Integer.floor_div/2 performs floored integer division. This means that the result is always rounded towards negative infinity. If you want to perform truncated integer division (rounding towards zero), use Kernel.div/2 instead. Examples iex&gt; Integer . floor_div ( 5 , 2 ) 2 iex&gt; Integer . floor_div ( 6 , - 4 ) - 2 iex&gt; Integer . floor_div ( - 99 , 2 ) - 50","ref":"Integer.html#floor_div/2","title":"Integer.floor_div/2","type":"function"},{"doc":"Returns the greatest common divisor of the two given integers. The greatest common divisor (GCD) of integer1 and integer2 is the largest positive integer that divides both integer1 and integer2 without leaving a remainder. By convention, gcd(0, 0) returns 0 . Examples iex&gt; Integer . gcd ( 2 , 3 ) 1 iex&gt; Integer . gcd ( 8 , 12 ) 4 iex&gt; Integer . gcd ( 8 , - 12 ) 4 iex&gt; Integer . gcd ( 10 , 0 ) 10 iex&gt; Integer . gcd ( 7 , 7 ) 7 iex&gt; Integer . gcd ( 0 , 0 ) 0","ref":"Integer.html#gcd/2","title":"Integer.gcd/2","type":"function"},{"doc":"Determines if an integer is even. Returns true if the given integer is an even number, otherwise it returns false . Allowed in guard clauses. Examples iex&gt; Integer . is_even ( 10 ) true iex&gt; Integer . is_even ( 5 ) false iex&gt; Integer . is_even ( - 10 ) true iex&gt; Integer . is_even ( 0 ) true","ref":"Integer.html#is_even/1","title":"Integer.is_even/1","type":"macro"},{"doc":"Determines if integer is odd. Returns true if the given integer is an odd number, otherwise it returns false . Allowed in guard clauses. Examples iex&gt; Integer . is_odd ( 5 ) true iex&gt; Integer . is_odd ( 6 ) false iex&gt; Integer . is_odd ( - 5 ) true iex&gt; Integer . is_odd ( 0 ) false","ref":"Integer.html#is_odd/1","title":"Integer.is_odd/1","type":"macro"},{"doc":"Computes the modulo remainder of an integer division. Integer.mod/2 uses floored division, which means that the result will always have the sign of the divisor . Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . Examples iex&gt; Integer . mod ( 5 , 2 ) 1 iex&gt; Integer . mod ( 6 , - 4 ) - 2","ref":"Integer.html#mod/2","title":"Integer.mod/2","type":"function"},{"doc":"Parses a text representation of an integer. An optional base to the corresponding integer can be provided. If base is not given, 10 will be used. If successful, returns a tuple in the form of {integer, remainder_of_binary} . Otherwise :error . Raises an error if base is less than 2 or more than 36. If you want to convert a string-formatted integer directly to an integer, String.to_integer/1 or String.to_integer/2 can be used instead. Examples iex&gt; Integer . parse ( &quot;34&quot; ) { 34 , &quot;&quot; } iex&gt; Integer . parse ( &quot;34.5&quot; ) { 34 , &quot;.5&quot; } iex&gt; Integer . parse ( &quot;three&quot; ) :error iex&gt; Integer . parse ( &quot;34&quot; , 10 ) { 34 , &quot;&quot; } iex&gt; Integer . parse ( &quot;f4&quot; , 16 ) { 244 , &quot;&quot; } iex&gt; Integer . parse ( &quot;Awww++&quot; , 36 ) { 509216 , &quot;++&quot; } iex&gt; Integer . parse ( &quot;fab&quot; , 10 ) :error iex&gt; Integer . parse ( &quot;a2&quot; , 38 ) ** (ArgumentError) invalid base 38","ref":"Integer.html#parse/2","title":"Integer.parse/2","type":"function"},{"doc":"Computes base raised to power of exponent . Both base and exponent must be integers. The exponent must be zero or positive. See Float.pow/2 for exponentiation of negative exponents as well as floats. Examples iex&gt; Integer . pow ( 2 , 0 ) 1 iex&gt; Integer . pow ( 2 , 1 ) 2 iex&gt; Integer . pow ( 2 , 10 ) 1024 iex&gt; Integer . pow ( 2 , 11 ) 2048 iex&gt; Integer . pow ( 2 , 64 ) 0x10000000000000000 iex&gt; Integer . pow ( 3 , 4 ) 81 iex&gt; Integer . pow ( 4 , 3 ) 64 iex&gt; Integer . pow ( - 2 , 3 ) - 8 iex&gt; Integer . pow ( - 2 , 4 ) 16 iex&gt; Integer . pow ( 2 , - 2 ) ** (ArithmeticError) bad argument in arithmetic expression","ref":"Integer.html#pow/2","title":"Integer.pow/2","type":"function"},{"doc":"Returns a charlist which corresponds to the text representation of the given integer . Inlined by the compiler. Examples iex&gt; Integer . to_charlist ( 123 ) &#39;123&#39; iex&gt; Integer . to_charlist ( + 456 ) &#39;456&#39; iex&gt; Integer . to_charlist ( - 789 ) &#39;-789&#39; iex&gt; Integer . to_charlist ( 0123 ) &#39;123&#39;","ref":"Integer.html#to_charlist/1","title":"Integer.to_charlist/1","type":"function"},{"doc":"Returns a charlist which corresponds to the text representation of integer in the given base . base can be an integer between 2 and 36. Inlined by the compiler. Examples iex&gt; Integer . to_charlist ( 100 , 16 ) &#39;64&#39; iex&gt; Integer . to_charlist ( - 100 , 16 ) &#39;-64&#39; iex&gt; Integer . to_charlist ( 882_681_651 , 36 ) &#39;ELIXIR&#39;","ref":"Integer.html#to_charlist/2","title":"Integer.to_charlist/2","type":"function"},{"doc":"Returns a binary which corresponds to the text representation of integer . Inlined by the compiler. Examples iex&gt; Integer . to_string ( 123 ) &quot;123&quot; iex&gt; Integer . to_string ( + 456 ) &quot;456&quot; iex&gt; Integer . to_string ( - 789 ) &quot;-789&quot; iex&gt; Integer . to_string ( 0123 ) &quot;123&quot;","ref":"Integer.html#to_string/1","title":"Integer.to_string/1","type":"function"},{"doc":"Returns a binary which corresponds to the text representation of integer in the given base . base can be an integer between 2 and 36. Inlined by the compiler. Examples iex&gt; Integer . to_string ( 100 , 16 ) &quot;64&quot; iex&gt; Integer . to_string ( - 100 , 16 ) &quot;-64&quot; iex&gt; Integer . to_string ( 882_681_651 , 36 ) &quot;ELIXIR&quot;","ref":"Integer.html#to_string/2","title":"Integer.to_string/2","type":"function"},{"doc":"Returns the integer represented by the ordered digits . An optional base value may be provided representing the radix for the digits . Base has to be an integer greater than or equal to 2 . Examples iex&gt; Integer . undigits ( [ 1 , 2 , 3 ] ) 123 iex&gt; Integer . undigits ( [ 1 , 4 ] , 16 ) 20 iex&gt; Integer . undigits ( [ ] ) 0","ref":"Integer.html#undigits/2","title":"Integer.undigits/2","type":"function"},{"doc":"Provides functions to deal with modules during compilation time. It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth. After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the __info__/1 function attached to each compiled module. Module attributes Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir: @after_compile A hook that will be invoked right after the current module is compiled. Accepts a module or a {module, function_name} . See the &quot;Compile callbacks&quot; section below. @before_compile A hook that will be invoked before the module is compiled. Accepts a module or a {module, function_or_macro_name} tuple. See the &quot;Compile callbacks&quot; section below. @behaviour Note the British spelling! Behaviours can be referenced by modules to ensure they implement required specific function signatures defined by @callback . For example, you could specify a URI.Parser behaviour as follows: defmodule URI.Parser do @doc &quot;Defines a default port&quot; @callback default_port ( ) :: integer @doc &quot;Parses the given URL&quot; @callback parse ( uri_info :: URI . t ( ) ) :: URI . t ( ) end And then a module may use it as: defmodule URI.HTTP do @behaviour URI.Parser def default_port ( ) , do : 80 def parse ( info ) , do : info end If the behaviour changes or URI.HTTP does not implement one of the callbacks, a warning will be raised. For detailed documentation, see the behaviour typespec documentation . @impl To aid in the correct implementation of behaviours, you may optionally declare @impl for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases: if you mark a function with @impl when that function is not a callback. if you don't mark a function with @impl when other functions are marked with @impl . If you mark one function with @impl , you must mark all other callbacks for that behaviour as @impl . @impl works on a per-context basis. If you generate a function through a macro and mark it with @impl , that won't affect the module where that function is generated in. @impl also helps with maintainability by making it clear to other developers that the function is implementing a callback. Using @impl , the example above can be rewritten as: defmodule URI.HTTP do @behaviour URI.Parser @impl true def default_port ( ) , do : 80 @impl true def parse ( info ) , do : info end You may pass either false , true , or a specific behaviour to @impl . defmodule Foo do @behaviour Bar @behaviour Baz # Will warn if neither Bar nor Baz specify a callback named bar/0. @impl true def bar ( ) , do : :ok # Will warn if Baz does not specify a callback named baz/0. @impl Baz def baz ( ) , do : :ok end The code is now more readable, as it is now clear which functions are part of your API and which ones are callback implementations. To reinforce this idea, @impl true automatically marks the function as @doc false , disabling documentation unless @doc is explicitly set. @compile Defines options for module compilation. This is used to configure both Elixir and Erlang compilers, as any other compilation pass added by external tools. For example: defmodule MyModule do @compile { :inline , my_fun : 1 } def my_fun ( arg ) do to_string ( arg ) end end Multiple uses of @compile will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below. @deprecated Provides the deprecation reason for a function. For example: defmodule Keyword do @deprecated &quot;Use Kernel.length/1 instead&quot; def size ( keyword ) do length ( keyword ) end end The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation. Using the @deprecated attribute will also be reflected in the documentation of the given function and macro. You can choose between the @deprecated attribute and the documentation metadata to provide hard-deprecations (with warnings) and soft-deprecations (without warnings): This is a soft-deprecation as it simply annotates the documentation as deprecated: @doc deprecated : &quot;Use Kernel.length/1 instead&quot; def size ( keyword ) This is a hard-deprecation as it emits warnings and annotates the documentation as deprecated: @deprecated &quot;Use Kernel.length/1 instead&quot; def size ( keyword ) Currently @deprecated only supports functions and macros. However you can use the :deprecated key in the annotation metadata to annotate the docs of modules, types and callbacks too. We recommend using this feature with care, especially library authors. Deprecating code always pushes the burden towards library users. We also recommend for deprecated functionality to be maintained for long periods of time, even after deprecation, giving developers plenty of time to update (except for cases where keeping the deprecated API is undesired, such as in the presence of security issues). @doc and @typedoc Provides documentation for the entity that follows the attribute. @doc is to be used with a function, macro, callback, or macrocallback, while @typedoc with a type (public or opaque). Accepts a string (often a heredoc) or false where @doc false will make the entity invisible to documentation extraction tools like ExDoc . For example: defmodule MyModule do @typedoc &quot;This type&quot; @typedoc since : &quot;1.1.0&quot; @type t :: term @doc &quot;Hello world&quot; @doc since : &quot;1.1.0&quot; def hello do &quot;world&quot; end @doc &quot;&quot;&quot; Sums `a` to `b`. &quot;&quot;&quot; def sum ( a , b ) do a + b end end As can be seen in the example above, @doc and @typedoc also accept a keyword list that serves as a way to provide arbitrary metadata about the entity. Tools like ExDoc and IEx may use this information to display annotations. A common use case is since that may be used to annotate in which version the function was introduced. As illustrated in the example, it is possible to use these attributes more than once before an entity. However, the compiler will warn if used twice with binaries as that replaces the documentation text from the preceding use. Multiple uses with keyword lists will merge the lists into one. Note that since the compiler also defines some additional metadata, there are a few reserved keys that will be ignored and warned if used. Currently these are: :opaque and :defaults . Once this module is compiled, this information becomes available via the Code.fetch_docs/1 function. @dialyzer Defines warnings to request or suppress when using a version of :dialyzer that supports module attributes. Accepts an atom, a tuple, or a list of atoms and tuples. For example: defmodule MyModule do @dialyzer { :nowarn_function , my_fun : 1 } def my_fun ( arg ) do M . not_a_function ( arg ) end end For the list of supported warnings, see :dialyzer module . Multiple uses of @dialyzer will accumulate instead of overriding previous ones. @external_resource Specifies an external resource for the current module. Sometimes a module embeds information from an external file. This attribute allows the module to annotate which external resources have been used. Tools may use this information to ensure the module is recompiled in case any of the external resources change, see for example: mix compile.elixir . If the external resource does not exist, the module still has a dependency on it, causing the module to be recompiled as soon as the file is added. @file Changes the filename used in stacktraces for the function or macro that follows the attribute, such as: defmodule MyModule do @doc &quot;Hello world&quot; @file &quot;hello.ex&quot; def hello do &quot;world&quot; end end @moduledoc Provides documentation for the current module. defmodule MyModule do @moduledoc &quot;&quot;&quot; A very useful module. &quot;&quot;&quot; @moduledoc authors : [ &quot;Alice&quot; , &quot;Bob&quot; ] end Accepts a string (often a heredoc) or false where @moduledoc false will make the module invisible to documentation extraction tools like ExDoc . Similarly to @doc also accepts a keyword list to provide metadata about the module. For more details, see the documentation of @doc above. Once this module is compiled, this information becomes available via the Code.fetch_docs/1 function. @on_definition A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions. Accepts a module or a {module, function_name} tuple. See the &quot;Compile callbacks&quot; section below. @on_load A hook that will be invoked whenever the module is loaded. Accepts the function name (as an atom) of a function in the current module or {function_name, 0} tuple where function_name is the name of a function in the current module. The function must have an arity of 0 (no arguments). If the function does not return :ok , the loading of the module will be aborted. For example: defmodule MyModule do @on_load :load_check def load_check do if some_condition ( ) do :ok else :abort end end def some_condition do false end end Modules compiled with HiPE would not call this hook. @vsn Specify the module version. Accepts any valid Elixir value, for example: defmodule MyModule do @vsn &quot;1.0&quot; end Typespec attributes The following attributes are part of typespecs and are also built-in in Elixir: @type - defines a type to be used in @spec @typep - defines a private type to be used in @spec @opaque - defines an opaque type to be used in @spec @spec - provides a specification for a function @callback - provides a specification for a behaviour callback @macrocallback - provides a specification for a macro behaviour callback @optional_callbacks - specifies which behaviour callbacks and macro behaviour callbacks are optional @impl - declares an implementation of a callback function or macro For detailed documentation, see the typespec documentation . Custom attributes In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the @/1 operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value: defmodule MyModule do @custom_attr [ some : &quot;stuff&quot; ] end For more advanced options available when defining custom attributes, see register_attribute/3 . Compile callbacks There are three callbacks that are invoked when functions are defined, as well as before and immediately after the module bytecode is generated. @after_compile A hook that will be invoked right after the current module is compiled. Accepts a module or a {module, function_name} tuple. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be __after_compile__/2 . Callbacks will run in the order they are registered. Example defmodule MyModule do @after_compile __MODULE__ def __after_compile__ ( env , _bytecode ) do IO . inspect ( env ) end end @before_compile A hook that will be invoked before the module is compiled. Accepts a module or a {module, function_or_macro_name} tuple. The function/macro must take one argument: the module environment. If it's a macro, its returned value will be injected at the end of the module definition before the compilation starts. When just a module is provided, the function/macro is assumed to be __before_compile__/1 . Callbacks will run in the order they are registered. Any overridable definition will be made concrete before the first callback runs. A definition may be made overridable again in another before compile callback and it will be made concrete one last time after all callbacks run. Note : unlike @after_compile , the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist). Example defmodule A do defmacro __before_compile__ ( _env ) do quote do def hello , do : &quot;world&quot; end end end defmodule B do @before_compile A end B . hello ( ) #=&gt; &quot;world&quot; @on_definition A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions. Accepts a module or a {module, function_name} tuple. The function must take 6 arguments: the module environment the kind of the function/macro: :def , :defp , :defmacro , or :defmacrop the function/macro name the list of quoted arguments the list of quoted guards the quoted function body If the function/macro being defined has multiple clauses, the hook will be called for each clause. Unlike other hooks, @on_definition will only invoke functions and never macros. This is to avoid @on_definition callbacks from redefining functions that have just been defined in favor of more explicit approaches. When just a module is provided, the function is assumed to be __on_definition__/6 . Example defmodule Hooks do def on_def ( _env , kind , name , args , guards , body ) do IO . puts ( &quot;Defining \#{ kind } named \#{ name } with args:&quot; ) IO . inspect ( args ) IO . puts ( &quot;and guards&quot; ) IO . inspect ( guards ) IO . puts ( &quot;and body&quot; ) IO . puts ( Macro . to_string ( body ) ) end end defmodule MyModule do @on_definition { Hooks , :on_def } def hello ( arg ) when is_binary ( arg ) or is_list ( arg ) do &quot;Hello&quot; &lt;&gt; to_string ( arg ) end def hello ( _ ) do :ok end end Compile options The @compile attribute accepts different options that are used by both Elixir and Erlang compilers. Some of the common use cases are documented below: @compile :debug_info - includes :debug_info regardless of the corresponding setting in Code.get_compiler_option/1 @compile {:debug_info, false} - disables :debug_info regardless of the corresponding setting in Code.get_compiler_option/1 @compile {:inline, some_fun: 2, other_fun: 3} - inlines the given name/arity pairs. Inlining is applied locally, calls from another module are not affected by this option @compile {:autoload, false} - disables automatic loading of modules after compilation. Instead, the module will be loaded after it is dispatched to @compile {:no_warn_undefined, Mod} or @compile {:no_warn_undefined, {Mod, fun, arity}} - does not warn if the given module or the given Mod.fun/arity are not defined","ref":"Module.html","title":"Module","type":"behaviour"},{"doc":"Provides runtime information about functions, macros, and other information defined by the module. Each module gets an __info__/1 function when it's compiled. The function takes one of the following items: :attributes - a keyword list with all persisted attributes :compile - a list with compiler metadata :functions - a keyword list of public functions and their arities :macros - a keyword list of public macros and their arities :md5 - the MD5 of the module :module - the module atom name","ref":"Module.html#c:__info__/1","title":"Module.__info__/1","type":"callback"},{"doc":"Concatenates a list of aliases and returns a new alias. Examples iex&gt; Module . concat ( [ Foo , Bar ] ) Foo.Bar iex&gt; Module . concat ( [ Foo , &quot;Bar&quot; ] ) Foo.Bar","ref":"Module.html#concat/1","title":"Module.concat/1","type":"function"},{"doc":"Concatenates two aliases and returns a new alias. Examples iex&gt; Module . concat ( Foo , Bar ) Foo.Bar iex&gt; Module . concat ( Foo , &quot;Bar&quot; ) Foo.Bar","ref":"Module.html#concat/2","title":"Module.concat/2","type":"function"},{"doc":"Creates a module with the given name and defined by the given quoted expressions. The line where the module is defined and its file must be passed as options. It returns a tuple of shape {:module, module, binary, term} where module is the module name, binary is the module bytecode and term is the result of the last expression in quoted . Similar to Kernel.defmodule/2 , the binary will only be written to disk as a .beam file if Module.create/3 is invoked in a file that is currently being compiled. Examples contents = quote do def world , do : true end Module . create ( Hello , contents , Macro.Env . location ( __ENV__ ) ) Hello . world ( ) #=&gt; true Differences from defmodule Module.create/3 works similarly to Kernel.defmodule/2 and return the same results. While one could also use defmodule to define modules dynamically, this function is preferred when the module body is given by a quoted expression. Another important distinction is that Module.create/3 allows you to control the environment variables used when defining the module, while Kernel.defmodule/2 automatically uses the environment it is invoked at.","ref":"Module.html#create/3","title":"Module.create/3","type":"function"},{"doc":"Checks if the module defines the given function or macro. Use defines?/3 to assert for a specific type. This function can only be used on modules that have not yet been compiled. Use Kernel.function_exported?/3 and Kernel.macro_exported?/3 to check for public functions and macros respectively in compiled modules. Note that defines? returns false for functions and macros that have been defined but then marked as overridable and no other implementation has been provided. You can check the overridable status by calling overridable?/2 . Examples defmodule Example do Module . defines? ( __MODULE__ , { :version , 0 } ) #=&gt; false def version , do : 1 Module . defines? ( __MODULE__ , { :version , 0 } ) #=&gt; true end","ref":"Module.html#defines?/2","title":"Module.defines?/2","type":"function"},{"doc":"Checks if the module defines a function or macro of the given kind . kind can be any of :def , :defp , :defmacro , or :defmacrop . This function can only be used on modules that have not yet been compiled. Use Kernel.function_exported?/3 and Kernel.macro_exported?/3 to check for public functions and macros respectively in compiled modules. Examples defmodule Example do Module . defines? ( __MODULE__ , { :version , 0 } , :def ) #=&gt; false def version , do : 1 Module . defines? ( __MODULE__ , { :version , 0 } , :def ) #=&gt; true end","ref":"Module.html#defines?/3","title":"Module.defines?/3","type":"function"},{"doc":"Checks if the current module defines the given type (private, opaque or not). This function is only available for modules being compiled.","ref":"Module.html#defines_type?/2","title":"Module.defines_type?/2","type":"function"},{"doc":"Returns all functions and macros defined in module . It returns a list with all defined functions and macros, public and private, in the shape of [{name, arity}, ...] . This function can only be used on modules that have not yet been compiled. Use the Module.__info__/1 callback to get the public functions and macros in compiled modules. Examples defmodule Example do def version , do : 1 defmacrop test ( arg ) , do : arg Module . definitions_in ( __MODULE__ ) #=&gt; [{:version, 0}, {:test, 1}] end","ref":"Module.html#definitions_in/1","title":"Module.definitions_in/1","type":"function"},{"doc":"Returns all functions defined in module , according to its kind. This function can only be used on modules that have not yet been compiled. Use the Module.__info__/1 callback to get the public functions and macros in compiled modules. Examples defmodule Example do def version , do : 1 Module . definitions_in ( __MODULE__ , :def ) #=&gt; [{:version, 0}] Module . definitions_in ( __MODULE__ , :defp ) #=&gt; [] end","ref":"Module.html#definitions_in/2","title":"Module.definitions_in/2","type":"function"},{"doc":"Deletes the module attribute that matches the given key. It returns the deleted attribute value (or nil if nothing was set). Examples defmodule MyModule do Module . put_attribute ( __MODULE__ , :custom_threshold_for_lib , 10 ) Module . delete_attribute ( __MODULE__ , :custom_threshold_for_lib ) end","ref":"Module.html#delete_attribute/2","title":"Module.delete_attribute/2","type":"function"},{"doc":"Deletes a definition from a module. It returns true if the definition exists and it was removed, otherwise it returns false.","ref":"Module.html#delete_definition/2","title":"Module.delete_definition/2","type":"function"},{"doc":"Evaluates the quoted contents in the given module's context. A list of environment options can also be given as argument. See Code.eval_string/3 for more information. Raises an error if the module was already compiled. Examples defmodule Foo do contents = quote do def sum ( a , b ) , do : a + b end Module . eval_quoted ( __MODULE__ , contents ) end Foo . sum ( 1 , 2 ) #=&gt; 3 For convenience, you can pass any Macro.Env struct, such as __ENV__/0 , as the first argument or as options. Both the module and all options will be automatically extracted from the environment: defmodule Foo do contents = quote do def sum ( a , b ) , do : a + b end Module . eval_quoted ( __ENV__ , contents ) end Foo . sum ( 1 , 2 ) #=&gt; 3 Note that if you pass a Macro.Env struct as first argument while also passing opts , they will be merged with opts having precedence.","ref":"Module.html#eval_quoted/4","title":"Module.eval_quoted/4","type":"function"},{"doc":"Gets the given attribute from a module. If the attribute was marked with accumulate with Module.register_attribute/3 , a list is always returned. nil is returned if the attribute has not been marked with accumulate and has not been set to any value. The @ macro compiles to a call to this function. For example, the following code: @foo Expands to something akin to: Module . get_attribute ( __MODULE__ , :foo ) This function can only be used on modules that have not yet been compiled. Use the Module.__info__/1 callback to get all persisted attributes, or Code.fetch_docs/1 to retrieve all documentation related attributes in compiled modules. Examples defmodule Foo do Module . put_attribute ( __MODULE__ , :value , 1 ) Module . get_attribute ( __MODULE__ , :value ) #=&gt; 1 Module . get_attribute ( __MODULE__ , :value , :default ) #=&gt; 1 Module . get_attribute ( __MODULE__ , :not_found , :default ) #=&gt; :default Module . register_attribute ( __MODULE__ , :value , accumulate : true ) Module . put_attribute ( __MODULE__ , :value , 1 ) Module . get_attribute ( __MODULE__ , :value ) #=&gt; [1] end","ref":"Module.html#get_attribute/3","title":"Module.get_attribute/3","type":"function"},{"doc":"Returns the definition for the given name-arity pair. It returns a tuple with the version , the kind , the definition metadata , and a list with each clause. Each clause is a four-element tuple with metadata, the arguments, the guards, and the clause AST. The clauses are returned in the Elixir AST but a subset that has already been expanded and normalized. This makes it useful for analyzing code but it cannot be reinjected into the module as it will have lost some of its original context. Given this AST representation is mostly internal, it is versioned and it may change at any time. Therefore, use this API with caution .","ref":"Module.html#get_definition/2","title":"Module.get_definition/2","type":"function"},{"doc":"Checks if the given attribute has been defined. An attribute is defined if it has been registered with register_attribute/3 or assigned a value. If an attribute has been deleted with delete_attribute/2 it is no longer considered defined. This function can only be used on modules that have not yet been compiled. Examples defmodule MyModule do @value 1 Module . register_attribute ( __MODULE__ , :other_value ) Module . put_attribute ( __MODULE__ , :another_value , 1 ) Module . has_attribute? ( __MODULE__ , :value ) #=&gt; true Module . has_attribute? ( __MODULE__ , :other_value ) #=&gt; true Module . has_attribute? ( __MODULE__ , :another_value ) #=&gt; true Module . has_attribute? ( __MODULE__ , :undefined ) #=&gt; false Module . delete_attribute ( __MODULE__ , :value ) Module . has_attribute? ( __MODULE__ , :value ) #=&gt; false end","ref":"Module.html#has_attribute?/2","title":"Module.has_attribute?/2","type":"function"},{"doc":"Makes the given functions in module overridable. An overridable function is lazily defined, allowing a developer to customize it. See Kernel.defoverridable/1 for more information and documentation. Once a function or a macro is marked as overridable, it will no longer be listed under definitions_in/1 or return true when given to defines?/2 until another implementation is given.","ref":"Module.html#make_overridable/2","title":"Module.make_overridable/2","type":"function"},{"doc":"Checks if a module is open. A module is &quot;open&quot; if it is currently being defined and its attributes and functions can be modified.","ref":"Module.html#open?/1","title":"Module.open?/1","type":"function"},{"doc":"Returns true if tuple in module is marked as overridable.","ref":"Module.html#overridable?/2","title":"Module.overridable?/2","type":"function"},{"doc":"Puts a module attribute with key and value in the given module . Examples defmodule MyModule do Module . put_attribute ( __MODULE__ , :custom_threshold_for_lib , 10 ) end","ref":"Module.html#put_attribute/3","title":"Module.put_attribute/3","type":"function"},{"doc":"Registers an attribute. By registering an attribute, a developer is able to customize how Elixir will store and accumulate the attribute values. Options When registering an attribute, two options can be given: :accumulate - several calls to the same attribute will accumulate instead of overriding the previous one. New attributes are always added to the top of the accumulated list. :persist - the attribute will be persisted in the Erlang Abstract Format. Useful when interfacing with Erlang libraries. By default, both options are false . Examples defmodule MyModule do Module . register_attribute ( __MODULE__ , :custom_threshold_for_lib , accumulate : true ) @custom_threshold_for_lib 10 @custom_threshold_for_lib 20 @custom_threshold_for_lib #=&gt; [20, 10] end","ref":"Module.html#register_attribute/3","title":"Module.register_attribute/3","type":"function"},{"doc":"Concatenates a list of aliases and returns a new alias only if the alias was already referenced. If the alias was not referenced yet, fails with ArgumentError . It handles charlists, binaries and atoms. Examples iex&gt; Module . safe_concat ( [ List , Chars ] ) List.Chars","ref":"Module.html#safe_concat/1","title":"Module.safe_concat/1","type":"function"},{"doc":"Concatenates two aliases and returns a new alias only if the alias was already referenced. If the alias was not referenced yet, fails with ArgumentError . It handles charlists, binaries and atoms. Examples iex&gt; Module . safe_concat ( List , Chars ) List.Chars","ref":"Module.html#safe_concat/2","title":"Module.safe_concat/2","type":"function"},{"doc":"Copies the given spec as a callback. Returns true if there is such a spec and it was copied as a callback. If the function associated to the spec has documentation defined prior to invoking this function, the docs are copied too.","ref":"Module.html#spec_to_callback/2","title":"Module.spec_to_callback/2","type":"function"},{"doc":"Splits the given module name into binary parts. module has to be an Elixir module, as split/1 won't work with Erlang-style modules (for example, split(:lists) raises an error). split/1 also supports splitting the string representation of Elixir modules (that is, the result of calling Atom.to_string/1 with the module name). Examples iex&gt; Module . split ( Very.Long.Module.Name.And.Even.Longer ) [ &quot;Very&quot; , &quot;Long&quot; , &quot;Module&quot; , &quot;Name&quot; , &quot;And&quot; , &quot;Even&quot; , &quot;Longer&quot; ] iex&gt; Module . split ( &quot;Elixir.String.Chars&quot; ) [ &quot;String&quot; , &quot;Chars&quot; ]","ref":"Module.html#split/1","title":"Module.split/1","type":"function"},{"doc":"A NaiveDateTime struct (without a time zone) and functions. The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the new/2 and new/8 functions or using the ~N (see Kernel.sigil_N/2 ) sigil: iex&gt; ~N[2000-01-01 23:00:07] ~N[2000-01-01 23:00:07] The date and time fields in the struct can be accessed directly: iex&gt; naive = ~N[2000-01-01 23:00:07] iex&gt; naive . year 2000 iex&gt; naive . second 7 We call them &quot;naive&quot; because this datetime representation does not have a time zone. This means the datetime may not actually exist in certain areas in the world even though it is valid. For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since NaiveDateTime is not validated against a time zone, such errors would go unnoticed. Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries. Comparing naive date times Comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and similar are structural and based on the NaiveDateTime struct fields. For proper comparison between naive datetimes, use the compare/2 function. Using epochs The add/3 and diff/3 functions can be used for computing with date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00): iex&gt; NaiveDateTime . diff ( ~N[2010-04-17 14:00:00] , ~N[1970-01-01 00:00:00] ) 1271512800 iex&gt; NaiveDateTime . add ( ~N[1970-01-01 00:00:00] , 1_271_512_800 ) ~N[2010-04-17 14:00:00] Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).","ref":"NaiveDateTime.html","title":"NaiveDateTime","type":"module"},{"doc":"Adds a specified amount of time to a NaiveDateTime . Accepts an amount_to_add in any unit available from System.time_unit/0 . Negative values will move backwards in time. Examples # adds seconds by default iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , 2 ) ~N[2014-10-02 00:29:12] # accepts negative offsets iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , - 2 ) ~N[2014-10-02 00:29:08] # can work with other units iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , 2_000 , :millisecond ) ~N[2014-10-02 00:29:12] # keeps the same precision iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10.021] , 21 , :second ) ~N[2014-10-02 00:29:31.021] # changes below the precision will not be visible iex&gt; hidden = NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , 21 , :millisecond ) iex&gt; hidden . microsecond # ~N[2014-10-02 00:29:10] { 21000 , 0 } # from Gregorian seconds iex&gt; NaiveDateTime . add ( ~N[0000-01-01 00:00:00] , 63_579_428_950 ) ~N[2014-10-02 00:29:10] Passing a DateTime automatically converts it to NaiveDateTime , discarding the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . add ( dt , 21 , :second ) ~N[2000-02-29 23:00:28]","ref":"NaiveDateTime.html#add/3","title":"NaiveDateTime.add/3","type":"function"},{"doc":"Compares two NaiveDateTime structs. Returns :gt if first is later than the second and :lt for vice versa. If the two NaiveDateTime are equal :eq is returned. Examples iex&gt; NaiveDateTime . compare ( ~N[2016-04-16 13:30:15] , ~N[2016-04-28 16:19:25] ) :lt iex&gt; NaiveDateTime . compare ( ~N[2016-04-16 13:30:15.1] , ~N[2016-04-16 13:30:15.01] ) :gt This function can also be used to compare a DateTime without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . compare ( dt , ~N[2000-02-29 23:00:07] ) :eq iex&gt; NaiveDateTime . compare ( dt , ~N[2000-01-29 23:00:07] ) :gt iex&gt; NaiveDateTime . compare ( dt , ~N[2000-03-29 23:00:07] ) :lt","ref":"NaiveDateTime.html#compare/2","title":"NaiveDateTime.compare/2","type":"function"},{"doc":"Converts the given naive_datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an {:error, :incompatible_calendars} tuple is returned. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; NaiveDateTime . convert ( ~N[2000-01-01 13:30:15] , Calendar.Holocene ) { :ok , % NaiveDateTime { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } } }","ref":"NaiveDateTime.html#convert/2","title":"NaiveDateTime.convert/2","type":"function"},{"doc":"Converts the given naive_datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an ArgumentError is raised. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; NaiveDateTime . convert! ( ~N[2000-01-01 13:30:15] , Calendar.Holocene ) % NaiveDateTime { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } }","ref":"NaiveDateTime.html#convert!/2","title":"NaiveDateTime.convert!/2","type":"function"},{"doc":"Subtracts naive_datetime2 from naive_datetime1 . The answer can be returned in any unit available from System.time_unit/0 . This function returns the difference in seconds where seconds are measured according to Calendar.ISO . Examples iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:12] , ~N[2014-10-02 00:29:10] ) 2 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:12] , ~N[2014-10-02 00:29:10] , :microsecond ) 2_000_000 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:10.042] , ~N[2014-10-02 00:29:10.021] , :millisecond ) 21 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:10] , ~N[2014-10-02 00:29:12] ) - 2 iex&gt; NaiveDateTime . diff ( ~N[-0001-10-02 00:29:10] , ~N[-0001-10-02 00:29:12] ) - 2 # to Gregorian seconds iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:10] , ~N[0000-01-01 00:00:00] ) 63579428950","ref":"NaiveDateTime.html#diff/3","title":"NaiveDateTime.diff/3","type":"function"},{"doc":"Converts an Erlang datetime tuple to a NaiveDateTime struct. Attempting to convert an invalid ISO calendar date will produce an error tuple. Examples iex&gt; NaiveDateTime . from_erl ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } ) { :ok , ~N[2000-01-01 13:30:15] } iex&gt; NaiveDateTime . from_erl ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } , { 5000 , 3 } ) { :ok , ~N[2000-01-01 13:30:15.005] } iex&gt; NaiveDateTime . from_erl ( { { 2000 , 13 , 1 } , { 13 , 30 , 15 } } ) { :error , :invalid_date } iex&gt; NaiveDateTime . from_erl ( { { 2000 , 13 , 1 } , { 13 , 30 , 15 } } ) { :error , :invalid_date }","ref":"NaiveDateTime.html#from_erl/3","title":"NaiveDateTime.from_erl/3","type":"function"},{"doc":"Converts an Erlang datetime tuple to a NaiveDateTime struct. Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple. Examples iex&gt; NaiveDateTime . from_erl! ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } ) ~N[2000-01-01 13:30:15] iex&gt; NaiveDateTime . from_erl! ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } , { 5000 , 3 } ) ~N[2000-01-01 13:30:15.005] iex&gt; NaiveDateTime . from_erl! ( { { 2000 , 13 , 1 } , { 13 , 30 , 15 } } ) ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date","ref":"NaiveDateTime.html#from_erl!/3","title":"NaiveDateTime.from_erl!/3","type":"function"},{"doc":"Converts a number of gregorian seconds to a NaiveDateTime struct. Examples iex&gt; NaiveDateTime . from_gregorian_seconds ( 1 ) ~N[0000-01-01 00:00:01] iex&gt; NaiveDateTime . from_gregorian_seconds ( 63_755_511_991 , { 5000 , 3 } ) ~N[2020-05-01 00:26:31.005] iex&gt; NaiveDateTime . from_gregorian_seconds ( - 1 ) ~N[-0001-12-31 23:59:59]","ref":"NaiveDateTime.html#from_gregorian_seconds/3","title":"NaiveDateTime.from_gregorian_seconds/3","type":"function"},{"doc":"Parses the extended &quot;Date and time of day&quot; format described by ISO 8601:2019 . Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times. As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function. Note leap seconds are not supported by the built-in Calendar.ISO. Examples iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07&quot; ) { :ok , ~N[2015-01-23 23:50:07] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07&quot; ) { :ok , ~N[2015-01-23 23:50:07] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07Z&quot; ) { :ok , ~N[2015-01-23 23:50:07] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07.0&quot; ) { :ok , ~N[2015-01-23 23:50:07.0] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07,0123456&quot; ) { :ok , ~N[2015-01-23 23:50:07.012345] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07.0123456&quot; ) { :ok , ~N[2015-01-23 23:50:07.012345] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123Z&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23P23:50:07&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015:01:23 23-50-07&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07A&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:61&quot; ) { :error , :invalid_time } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-32 23:50:07&quot; ) { :error , :invalid_date } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123+02:30&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123+00:00&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-02:30&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-00:00&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-00:60&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-24:00&quot; ) { :error , :invalid_format }","ref":"NaiveDateTime.html#from_iso8601/2","title":"NaiveDateTime.from_iso8601/2","type":"function"},{"doc":"Parses the extended &quot;Date and time of day&quot; format described by ISO 8601:2019 . Raises if the format is invalid. Examples iex&gt; NaiveDateTime . from_iso8601! ( &quot;2015-01-23T23:50:07.123Z&quot; ) ~N[2015-01-23 23:50:07.123] iex&gt; NaiveDateTime . from_iso8601! ( &quot;2015-01-23T23:50:07,123Z&quot; ) ~N[2015-01-23 23:50:07.123] iex&gt; NaiveDateTime . from_iso8601! ( &quot;2015-01-23P23:50:07&quot; ) ** (ArgumentError) cannot parse &quot;2015-01-23P23:50:07&quot; as naive datetime, reason: :invalid_format","ref":"NaiveDateTime.html#from_iso8601!/2","title":"NaiveDateTime.from_iso8601!/2","type":"function"},{"doc":"Returns the &quot;local time&quot; for the machine the Elixir program is running on. WARNING: This function can cause insidious bugs. It depends on the time zone configuration at run time. This can changed and be set to a time zone that has daylight saving jumps (spring forward or fall back). This function can be used to display what the time is right now for the time zone configuration that the machine happens to have. An example would be a desktop program displaying a clock to the user. For any other uses it is probably a bad idea to use this function. For most cases, use DateTime.now/2 or DateTime.utc_now/1 instead. Does not include fractional seconds. Examples iex&gt; naive_datetime = NaiveDateTime . local_now ( ) iex&gt; naive_datetime . year &gt;= 2019 true","ref":"NaiveDateTime.html#local_now/1","title":"NaiveDateTime.local_now/1","type":"function"},{"doc":"Builds a naive datetime from date and time structs. Examples iex&gt; NaiveDateTime . new ( ~D[2010-01-13] , ~T[23:00:07.005] ) { :ok , ~N[2010-01-13 23:00:07.005] }","ref":"NaiveDateTime.html#new/2","title":"NaiveDateTime.new/2","type":"function"},{"doc":"Builds a new ISO naive datetime. Expects all values to be integers. Returns {:ok, naive_datetime} if each entry fits its appropriate range, returns {:error, reason} otherwise. Examples iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 0 , 0 , 0 ) { :ok , ~N[2000-01-01 00:00:00] } iex&gt; NaiveDateTime . new ( 2000 , 13 , 1 , 0 , 0 , 0 ) { :error , :invalid_date } iex&gt; NaiveDateTime . new ( 2000 , 2 , 29 , 0 , 0 , 0 ) { :ok , ~N[2000-02-29 00:00:00] } iex&gt; NaiveDateTime . new ( 2000 , 2 , 30 , 0 , 0 , 0 ) { :error , :invalid_date } iex&gt; NaiveDateTime . new ( 2001 , 2 , 29 , 0 , 0 , 0 ) { :error , :invalid_date } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } ) { :ok , ~N[2000-01-01 23:59:59.0] } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , 999_999 ) { :ok , ~N[2000-01-01 23:59:59.999999] } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 24 , 59 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 60 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 60 , 999_999 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , 1_000_000 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } , Calendar.ISO ) { :ok , ~N[2000-01-01 23:59:59.0] }","ref":"NaiveDateTime.html#new/8","title":"NaiveDateTime.new/8","type":"function"},{"doc":"Builds a naive datetime from date and time structs. Examples iex&gt; NaiveDateTime . new! ( ~D[2010-01-13] , ~T[23:00:07.005] ) ~N[2010-01-13 23:00:07.005]","ref":"NaiveDateTime.html#new!/2","title":"NaiveDateTime.new!/2","type":"function"},{"doc":"Builds a new ISO naive datetime. Expects all values to be integers. Returns naive_datetime if each entry fits its appropriate range, raises if time or date is invalid. Examples iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 0 , 0 , 0 ) ~N[2000-01-01 00:00:00] iex&gt; NaiveDateTime . new! ( 2000 , 2 , 29 , 0 , 0 , 0 ) ~N[2000-02-29 00:00:00] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } ) ~N[2000-01-01 23:59:59.0] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 23 , 59 , 59 , 999_999 ) ~N[2000-01-01 23:59:59.999999] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } , Calendar.ISO ) ~N[2000-01-01 23:59:59.0] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 24 , 59 , 59 , 999_999 ) ** (ArgumentError) cannot build naive datetime, reason: :invalid_time","ref":"NaiveDateTime.html#new!/8","title":"NaiveDateTime.new!/8","type":"function"},{"doc":"Converts a NaiveDateTime into a Date . Because Date does not hold time information, data will be lost during the conversion. Examples iex&gt; NaiveDateTime . to_date ( ~N[2002-01-13 23:00:07] ) ~D[2002-01-13]","ref":"NaiveDateTime.html#to_date/1","title":"NaiveDateTime.to_date/1","type":"function"},{"doc":"Converts a NaiveDateTime struct to an Erlang datetime tuple. Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise. WARNING: Loss of precision may occur, as Erlang time tuples only store hour/minute/second. Examples iex&gt; NaiveDateTime . to_erl ( ~N[2000-01-01 13:30:15] ) { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } This function can also be used to convert a DateTime to an Erlang datetime tuple without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . to_erl ( dt ) { { 2000 , 2 , 29 } , { 23 , 00 , 07 } }","ref":"NaiveDateTime.html#to_erl/1","title":"NaiveDateTime.to_erl/1","type":"function"},{"doc":"Converts a NaiveDateTime struct to a number of gregorian seconds and microseconds. Examples iex&gt; NaiveDateTime . to_gregorian_seconds ( ~N[0000-01-01 00:00:01] ) { 1 , 0 } iex&gt; NaiveDateTime . to_gregorian_seconds ( ~N[2020-05-01 00:26:31.005] ) { 63_755_511_991 , 5000 }","ref":"NaiveDateTime.html#to_gregorian_seconds/1","title":"NaiveDateTime.to_gregorian_seconds/1","type":"function"},{"doc":"Converts the given naive datetime to ISO 8601:2019 . By default, NaiveDateTime.to_iso8601/2 returns naive datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise. Examples iex&gt; NaiveDateTime . to_iso8601 ( ~N[2000-02-28 23:00:13] ) &quot;2000-02-28T23:00:13&quot; iex&gt; NaiveDateTime . to_iso8601 ( ~N[2000-02-28 23:00:13.001] ) &quot;2000-02-28T23:00:13.001&quot; iex&gt; NaiveDateTime . to_iso8601 ( ~N[2000-02-28 23:00:13.001] , :basic ) &quot;20000228T230013.001&quot; This function can also be used to convert a DateTime to ISO 8601 without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . to_iso8601 ( dt ) &quot;2000-02-29T23:00:07&quot;","ref":"NaiveDateTime.html#to_iso8601/2","title":"NaiveDateTime.to_iso8601/2","type":"function"},{"doc":"Converts the given naive datetime to a string according to its calendar. Examples iex&gt; NaiveDateTime . to_string ( ~N[2000-02-28 23:00:13] ) &quot;2000-02-28 23:00:13&quot; iex&gt; NaiveDateTime . to_string ( ~N[2000-02-28 23:00:13.001] ) &quot;2000-02-28 23:00:13.001&quot; iex&gt; NaiveDateTime . to_string ( ~N[-0100-12-15 03:20:31] ) &quot;-0100-12-15 03:20:31&quot; This function can also be used to convert a DateTime to a string without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . to_string ( dt ) &quot;2000-02-29 23:00:07&quot;","ref":"NaiveDateTime.html#to_string/1","title":"NaiveDateTime.to_string/1","type":"function"},{"doc":"Converts a NaiveDateTime into Time . Because Time does not hold date information, data will be lost during the conversion. Examples iex&gt; NaiveDateTime . to_time ( ~N[2002-01-13 23:00:07] ) ~T[23:00:07]","ref":"NaiveDateTime.html#to_time/1","title":"NaiveDateTime.to_time/1","type":"function"},{"doc":"Returns the given naive datetime with the microsecond field truncated to the given precision ( :microsecond , :millisecond or :second ). The given naive datetime is returned unchanged if it already has lower precision than the given precision. Examples iex&gt; NaiveDateTime . truncate ( ~N[2017-11-06 00:23:51.123456] , :microsecond ) ~N[2017-11-06 00:23:51.123456] iex&gt; NaiveDateTime . truncate ( ~N[2017-11-06 00:23:51.123456] , :millisecond ) ~N[2017-11-06 00:23:51.123] iex&gt; NaiveDateTime . truncate ( ~N[2017-11-06 00:23:51.123456] , :second ) ~N[2017-11-06 00:23:51]","ref":"NaiveDateTime.html#truncate/2","title":"NaiveDateTime.truncate/2","type":"function"},{"doc":"Returns the current naive datetime in UTC. Prefer using DateTime.utc_now/0 when possible as, opposite to NaiveDateTime , it will keep the time zone information. Examples iex&gt; naive_datetime = NaiveDateTime . utc_now ( ) iex&gt; naive_datetime . year &gt;= 2016 true","ref":"NaiveDateTime.html#utc_now/1","title":"NaiveDateTime.utc_now/1","type":"function"},{"doc":"","ref":"NaiveDateTime.html#t:t/0","title":"NaiveDateTime.t/0","type":"type"},{"doc":"Module to work with, define, and import records. Records are simply tuples where the first element is an atom: iex&gt; Record . is_record ( { User , &quot;john&quot; , 27 } ) true This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples' compact structure. In Elixir, records are used mostly in two situations: to work with short, internal data to interface with Erlang records The macros defrecord/3 and defrecordp/3 can be used to create records while extract/2 and extract_all/1 can be used to extract records from Erlang files. Types Types can be defined for tuples with the record/2 macro (only available in typespecs). This macro will expand to a tuple as seen in the example below: defmodule MyModule do require Record Record . defrecord ( :user , name : &quot;john&quot; , age : 25 ) @type user :: record ( :user , name : String . t ( ) , age : integer ) # expands to: &quot;@type user :: {:user, String.t(), integer}&quot; end","ref":"Record.html","title":"Record","type":"module"},{"doc":"Defines a set of macros to create, access, and pattern match on a record. The name of the generated macros will be name (which has to be an atom). tag is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if nil ), it's the same as name . kv is a keyword list of name: default_value fields for the new record. The following macros are generated: name/0 to create a new record with default values for all fields name/1 to create a new record with the given fields and values, to get the zero-based index of the given field in a record or to convert the given record to a keyword list name/2 to update an existing record with the given fields and values or to access a given field in a given record All these macros are public macros (as defined by defmacro ). See the &quot;Examples&quot; section for examples on how to use these macros. Examples defmodule User do require Record Record . defrecord ( :user , name : &quot;meg&quot; , age : &quot;25&quot; ) end In the example above, a set of macros named user but with different arities will be defined to manipulate the underlying record. # Import the module to make the user macros locally available import User # To create records record = user ( ) #=&gt; {:user, &quot;meg&quot;, 25} record = user ( age : 26 ) #=&gt; {:user, &quot;meg&quot;, 26} # To get a field from the record user ( record , :name ) #=&gt; &quot;meg&quot; # To update the record user ( record , age : 26 ) #=&gt; {:user, &quot;meg&quot;, 26} # To get the zero-based index of the field in record tuple # (index 0 is occupied by the record &quot;tag&quot;) user ( :name ) #=&gt; 1 # Convert a record to a keyword list user ( record ) #=&gt; [name: &quot;meg&quot;, age: 26] The generated macros can also be used in order to pattern match on records and to bind variables during the match: record = user ( ) #=&gt; {:user, &quot;meg&quot;, 25} user ( name : name ) = record name #=&gt; &quot;meg&quot; By default, Elixir uses the record name as the first element of the tuple (the &quot;tag&quot;). However, a different tag can be specified when defining a record, as in the following example, in which we use Customer as the second argument of defrecord/3 : defmodule User do require Record Record . defrecord ( :user , Customer , name : nil ) end require User User . user ( ) #=&gt; {Customer, nil} Defining extracted records with anonymous functions in the values If a record defines an anonymous function in the default values, an ArgumentError will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults. Record . defrecord ( :my_rec , Record . extract ( ... ) ) ** (ArgumentError) invalid value for record field fun_field, cannot escape #Function&lt;12.90072148/2 in :erl_eval.expr/5&gt;. To work around this error, redefine the field with your own &amp;M.f/a function, like so: defmodule MyRec do require Record Record . defrecord ( :my_rec , Record . extract ( ... ) |&gt; Keyword . merge ( fun_field : &amp; __MODULE__ . foo / 2 ) ) def foo ( bar , baz ) , do : IO . inspect ( { bar , baz } ) end","ref":"Record.html#defrecord/3","title":"Record.defrecord/3","type":"macro"},{"doc":"Same as defrecord/3 but generates private macros.","ref":"Record.html#defrecordp/3","title":"Record.defrecordp/3","type":"macro"},{"doc":"Extracts record information from an Erlang file. Returns a quoted expression containing the fields as a list of tuples. name , which is the name of the extracted record, is expected to be an atom at compile time . Options This function accepts the following options, which are exclusive to each other (i.e., only one of them can be used in the same call): :from - (binary representing a path to a file) path to the Erlang file that contains the record definition to extract; with this option, this function uses the same path lookup used by the -include attribute used in Erlang modules. :from_lib - (binary representing a path to a file) path to the Erlang file that contains the record definition to extract; with this option, this function uses the same path lookup used by the -include_lib attribute used in Erlang modules. :includes - (a list of directories as binaries) if the record being extracted depends on relative includes, this option allows developers to specify the directory where those relative includes exist. :macros - (keyword list of macro names and values) if the record being extracted depends on the values of macros, this option allows the value of those macros to be set. These options are expected to be literals (including the binary values) at compile time. Examples iex&gt; Record . extract ( :file_info , from_lib : &quot;kernel/include/file.hrl&quot; ) [ size : :undefined , type : :undefined , access : :undefined , atime : :undefined , mtime : :undefined , ctime : :undefined , mode : :undefined , links : :undefined , major_device : :undefined , minor_device : :undefined , inode : :undefined , uid : :undefined , gid : :undefined ]","ref":"Record.html#extract/2","title":"Record.extract/2","type":"function"},{"doc":"Extracts all records information from an Erlang file. Returns a keyword list of {record_name, fields} tuples where record_name is the name of an extracted record and fields is a list of {field, value} tuples representing the fields for that record. Options This function accepts the following options, which are exclusive to each other (i.e., only one of them can be used in the same call): :from - (binary representing a path to a file) path to the Erlang file that contains the record definitions to extract; with this option, this function uses the same path lookup used by the -include attribute used in Erlang modules. :from_lib - (binary representing a path to a file) path to the Erlang file that contains the record definitions to extract; with this option, this function uses the same path lookup used by the -include_lib attribute used in Erlang modules. These options are expected to be literals (including the binary values) at compile time.","ref":"Record.html#extract_all/1","title":"Record.extract_all/1","type":"function"},{"doc":"Checks if the given data is a record. This is implemented as a macro so it can be used in guard clauses. Examples Record . is_record ( { User , &quot;john&quot; , 27 } ) #=&gt; true Record . is_record ( { } ) #=&gt; false","ref":"Record.html#is_record/1","title":"Record.is_record/1","type":"macro"},{"doc":"Checks if the given data is a record of kind kind . This is implemented as a macro so it can be used in guard clauses. Examples iex&gt; record = { User , &quot;john&quot; , 27 } iex&gt; Record . is_record ( record , User ) true","ref":"Record.html#is_record/2","title":"Record.is_record/2","type":"macro"},{"doc":"Provides regular expressions for Elixir. Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's :re module. More information can be found in the :re module documentation . Regular expressions in Elixir can be created using the sigils ~r (see Kernel.sigil_r/2 ) or ~R (see Kernel.sigil_R/2 ): # A simple regular expression that matches foo anywhere in the string ~r/foo/ # A regular expression with case insensitive and Unicode options ~r/foo/iu Regular expressions created via sigils are pre-compiled and stored in the .beam file. Note that this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information. A Regex is represented internally as the Regex struct. Therefore, %Regex{} can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. There is also not guarantee two regular expressions from the same source are equal, for example: ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ == ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ may return true or false depending on your machine, endianness, available optimizations and others. You can, however, retrieve the source of a compiled regular expression by accessing the source field, and then compare those directly: ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ . source == ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ . source Modifiers The modifiers available when creating a Regex are: unicode (u) - enables Unicode specific patterns like \\p and causes character classes like \\w , \\W , \\s , etc. to also match on Unicode (see examples below in &quot;Character classes&quot;). It expects valid Unicode strings to be given on match caseless (i) - adds case insensitivity dotall (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting (*CR) or (*LF) or (*CRLF) or (*ANY) according to :re documentation multiline (m) - causes ^ and $ to mark the beginning and end of each line; use \\A and \\z to match the end or beginning of the string extended (x) - whitespace characters are ignored except when escaped and allow # to delimit comments firstline (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline ungreedy (U) - inverts the &quot;greediness&quot; of the regexp (the previous r option is deprecated in favor of U ) The options not available are: anchored - not available, use ^ or \\A instead dollar_endonly - not available, use \\z instead no_auto_capture - not available, use ?: instead newline - not available, use (*CR) or (*LF) or (*CRLF) or (*ANYCRLF) or (*ANY) at the beginning of the regexp according to the :re documentation Captures Many functions in this module handle what to capture in a regex match via the :capture option. The supported values are: :all - all captured subpatterns including the complete matching string (this is the default) :first - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded :all_but_first - all but the first matching subpattern, i.e. all explicitly captured subpatterns, but not the complete matching part of the string :none - does not return matching subpatterns at all :all_names - captures all named subpattern matches in the Regex as a list ordered alphabetically by the names of the subpatterns list(binary) - a list of named captures to capture Character classes Regex supports several built in named character classes. These are used by enclosing the class name in [: :] inside a group. For example: iex&gt; String . match? ( &quot;123&quot; , ~r/^[[:alnum:]]+$/ ) true iex&gt; String . match? ( &quot;123 456&quot; , ~r/^[[:alnum:][:blank:]]+$/ ) true The supported class names are: alnum - Letters and digits alpha - Letters blank - Space or tab only cntrl - Control characters digit - Decimal digits (same as \\d) graph - Printing characters, excluding space lower - Lowercase letters print - Printing characters, including space punct - Printing characters, excluding letters, digits, and space space - Whitespace (the same as \\s from PCRE 8.34) upper - Uppercase letters word - &quot;Word&quot; characters (same as \\w) xdigit - Hexadecimal digits There is another character class, ascii , that erroneously matches Latin-1 characters instead of the 0-127 range specified by POSIX. This cannot be fixed without altering the behaviour of other classes, so we recommend matching the range with [\\\\0-\\x7f] instead. Note the behaviour of those classes may change according to the Unicode and other modifiers: iex&gt; String . match? ( &quot;josé&quot; , ~r/^[[:lower:]]+$/ ) false iex&gt; String . match? ( &quot;josé&quot; , ~r/^[[:lower:]]+$/u ) true iex&gt; Regex . replace ( ~r/ \\s / , &quot;Unicode \\u00A0 spaces&quot; , &quot;-&quot; ) &quot;Unicode spaces&quot; iex&gt; Regex . replace ( ~r/ \\s /u , &quot;Unicode \\u00A0 spaces&quot; , &quot;-&quot; ) &quot;Unicode-spaces&quot; Precompilation Regular expressions built with sigil are precompiled and stored in .beam files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via mix compile or similar) or released on the host (via mix releases or similar) with a matching OTP, operating system and architecture as the target. If you know you are running on a different system than the current one and you are doing multiple matches with the regex, you can manually invoke Regex.recompile/1 or Regex.recompile!/1 to perform a runtime version check and recompile the regex if necessary.","ref":"Regex.html","title":"Regex","type":"module"},{"doc":"Compiles the regular expression. The given options can either be a binary with the characters representing the same regex options given to the ~r (see Kernel.sigil_r/2 ) sigil, or a list of options, as expected by the Erlang's :re module. It returns {:ok, regex} in case of success, {:error, reason} otherwise. Examples iex&gt; Regex . compile ( &quot;foo&quot; ) { :ok , ~r/foo/ } iex&gt; Regex . compile ( &quot;*foo&quot; ) { :error , { &#39;nothing to repeat&#39; , 0 } }","ref":"Regex.html#compile/2","title":"Regex.compile/2","type":"function"},{"doc":"Compiles the regular expression and raises Regex.CompileError in case of errors.","ref":"Regex.html#compile!/2","title":"Regex.compile!/2","type":"function"},{"doc":"Escapes a string to be literally matched in a regex. Examples iex&gt; Regex . escape ( &quot;.&quot; ) &quot; \\\\ .&quot; iex&gt; Regex . escape ( &quot; \\\\ what if&quot; ) &quot; \\\\ \\\\ what \\\\ if&quot;","ref":"Regex.html#escape/1","title":"Regex.escape/1","type":"function"},{"doc":"Returns a boolean indicating whether there was a match or not. Examples iex&gt; Regex . match? ( ~r/foo/ , &quot;foo&quot; ) true iex&gt; Regex . match? ( ~r/foo/ , &quot;bar&quot; ) false","ref":"Regex.html#match?/2","title":"Regex.match?/2","type":"function"},{"doc":"Returns the given captures as a map or nil if no captures are found. Options :return - when set to :index , returns byte index and match length. Defaults to :binary . Examples iex&gt; Regex . named_captures ( ~r/c(?&lt;foo&gt;d)/ , &quot;abcd&quot; ) %{ &quot;foo&quot; = &gt; &quot;d&quot; } iex&gt; Regex . named_captures ( ~r/a(?&lt;foo&gt;b)c(?&lt;bar&gt;d)/ , &quot;abcd&quot; ) %{ &quot;bar&quot; = &gt; &quot;d&quot; , &quot;foo&quot; = &gt; &quot;b&quot; } iex&gt; Regex . named_captures ( ~r/a(?&lt;foo&gt;b)c(?&lt;bar&gt;d)/ , &quot;efgh&quot; ) nil","ref":"Regex.html#named_captures/3","title":"Regex.named_captures/3","type":"function"},{"doc":"Returns a list of names in the regex. Examples iex&gt; Regex . names ( ~r/(?&lt;foo&gt;bar)/ ) [ &quot;foo&quot; ]","ref":"Regex.html#names/1","title":"Regex.names/1","type":"function"},{"doc":"Returns the regex options as a string. Examples iex&gt; Regex . opts ( ~r(foo)m ) &quot;m&quot;","ref":"Regex.html#opts/1","title":"Regex.opts/1","type":"function"},{"doc":"Returns the underlying re_pattern in the regular expression.","ref":"Regex.html#re_pattern/1","title":"Regex.re_pattern/1","type":"function"},{"doc":"Recompiles the existing regular expression if necessary. This checks the version stored in the regular expression and recompiles the regex in case of version mismatch.","ref":"Regex.html#recompile/1","title":"Regex.recompile/1","type":"function"},{"doc":"Recompiles the existing regular expression and raises Regex.CompileError in case of errors.","ref":"Regex.html#recompile!/1","title":"Regex.recompile!/1","type":"function"},{"doc":"Returns true if the given term is a regex. Otherwise returns false .","ref":"Regex.html#regex?/1","title":"Regex.regex?/1","type":"function"},{"doc":"Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement. The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via \\N or \\g{N} , where N is the capture. In case \\0 is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use \\\\N and \\\\g{N} . When the replacement is a function, the function may have arity N where each argument maps to a capture, with the first argument being the whole match. If the function expects more arguments than captures found, the remaining arguments will receive &quot;&quot; . Options :global - when false , replaces only the first occurrence (defaults to true ) Examples iex&gt; Regex . replace ( ~r/d/ , &quot;abc&quot; , &quot;d&quot; ) &quot;abc&quot; iex&gt; Regex . replace ( ~r/b/ , &quot;abc&quot; , &quot;d&quot; ) &quot;adc&quot; iex&gt; Regex . replace ( ~r/b/ , &quot;abc&quot; , &quot;[ \\\\ 0]&quot; ) &quot;a[b]c&quot; iex&gt; Regex . replace ( ~r/a(b|d)c/ , &quot;abcadc&quot; , &quot;[ \\\\ 1]&quot; ) &quot;[b][d]&quot; iex&gt; Regex . replace ( ~r/ \\. ( \\d )$/ , &quot;500.5&quot; , &quot;. \\\\ g{1}0&quot; ) &quot;500.50&quot; iex&gt; Regex . replace ( ~r/a(b|d)c/ , &quot;abcadc&quot; , fn _ , x -&gt; &quot;[ \#{ x } ]&quot; end ) &quot;[b][d]&quot; iex&gt; Regex . replace ( ~r/a/ , &quot;abcadc&quot; , &quot;A&quot; , global : false ) &quot;Abcadc&quot;","ref":"Regex.html#replace/4","title":"Regex.replace/4","type":"function"},{"doc":"Runs the regular expression against the given string until the first match. It returns a list with all captures or nil if no match occurred. Options :return - when set to :index , returns byte index and match length. Defaults to :binary . :capture - what to capture in the result. Check the moduledoc for Regex to see the possible capture values. :offset - (since v1.12.0) specifies the starting offset to match in the given string. Defaults to zero. Examples iex&gt; Regex . run ( ~r/c(d)/ , &quot;abcd&quot; ) [ &quot;cd&quot; , &quot;d&quot; ] iex&gt; Regex . run ( ~r/e/ , &quot;abcd&quot; ) nil iex&gt; Regex . run ( ~r/c(d)/ , &quot;abcd&quot; , return : :index ) [ { 2 , 2 } , { 3 , 1 } ]","ref":"Regex.html#run/3","title":"Regex.run/3","type":"function"},{"doc":"Same as run/3 , but scans the target several times collecting all matches of the regular expression. A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents. Options :return - when set to :index , returns byte index and match length. Defaults to :binary . :capture - what to capture in the result. Check the moduledoc for Regex to see the possible capture values. :offset - (since v1.12.0) specifies the starting offset to match in the given string. Defaults to zero. Examples iex&gt; Regex . scan ( ~r/c(d|e)/ , &quot;abcd abce&quot; ) [ [ &quot;cd&quot; , &quot;d&quot; ] , [ &quot;ce&quot; , &quot;e&quot; ] ] iex&gt; Regex . scan ( ~r/c(?:d|e)/ , &quot;abcd abce&quot; ) [ [ &quot;cd&quot; ] , [ &quot;ce&quot; ] ] iex&gt; Regex . scan ( ~r/e/ , &quot;abcd&quot; ) [ ] iex&gt; Regex . scan ( ~r/ \\p {Sc}/u , &quot;$, £, and €&quot; ) [ [ &quot;$&quot; ] , [ &quot;£&quot; ] , [ &quot;€&quot; ] ] iex&gt; Regex . scan ( ~r/=+/ , &quot;=ü†ƒ8===&quot; , return : :index ) [ [ { 0 , 1 } ] , [ { 9 , 3 } ] ]","ref":"Regex.html#scan/3","title":"Regex.scan/3","type":"function"},{"doc":"Returns the regex source as a binary. Examples iex&gt; Regex . source ( ~r(foo) ) &quot;foo&quot;","ref":"Regex.html#source/1","title":"Regex.source/1","type":"function"},{"doc":"Splits the given target based on the given pattern and in the given number of parts. Options :parts - when specified, splits the string into the given number of parts. If not specified, :parts defaults to :infinity , which will split the string into the maximum number of parts possible based on the given pattern. :trim - when true , removes empty strings ( &quot;&quot; ) from the result. Defaults to false . :on - specifies which captures to split the string on, and in what order. Defaults to :first which means captures inside the regex do not affect the splitting process. :include_captures - when true , includes in the result the matches of the regular expression. The matches are not counted towards the maximum number of parts if combined with the :parts option. Defaults to false . Examples iex&gt; Regex . split ( ~r{-} , &quot;a-b-c&quot; ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; Regex . split ( ~r{-} , &quot;a-b-c&quot; , parts : 2 ) [ &quot;a&quot; , &quot;b-c&quot; ] iex&gt; Regex . split ( ~r{-} , &quot;abc&quot; ) [ &quot;abc&quot; ] iex&gt; Regex . split ( ~r{} , &quot;abc&quot; ) [ &quot;&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;&quot; ] iex&gt; Regex . split ( ~r{a(?&lt;second&gt;b)c} , &quot;abc&quot; ) [ &quot;&quot; , &quot;&quot; ] iex&gt; Regex . split ( ~r{a(?&lt;second&gt;b)c} , &quot;abc&quot; , on : [ :second ] ) [ &quot;a&quot; , &quot;c&quot; ] iex&gt; Regex . split ( ~r{(x)} , &quot;Elixir&quot; , include_captures : true ) [ &quot;Eli&quot; , &quot;x&quot; , &quot;ir&quot; ] iex&gt; Regex . split ( ~r{a(?&lt;second&gt;b)c} , &quot;abc&quot; , on : [ :second ] , include_captures : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ]","ref":"Regex.html#split/3","title":"Regex.split/3","type":"function"},{"doc":"Returns the version of the underlying Regex engine.","ref":"Regex.html#version/0","title":"Regex.version/0","type":"function"},{"doc":"","ref":"Regex.html#t:t/0","title":"Regex.t/0","type":"type"},{"doc":"Strings in Elixir are UTF-8 encoded binaries. Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as &quot;hello&quot; and &quot;héllò&quot; . In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: &quot;this is a string with \\&quot;double quotes\\&quot;&quot; . You can concatenate two strings with the &lt;&gt;/2 operator: iex&gt; &quot;hello&quot; &lt;&gt; &quot; &quot; &lt;&gt; &quot;world&quot; &quot;hello world&quot; Interpolation Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the \#{} syntax: iex&gt; name = &quot;joe&quot; iex&gt; &quot;hello \#{ name } &quot; &quot;hello joe&quot; Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation: iex&gt; &quot;2 + 2 = \#{ 2 + 2 } &quot; &quot;2 + 2 = 4&quot; In case the value you want to interpolate cannot be converted to a string, because it doesn't have an human textual representation, a protocol error will be raised. Escape characters Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters: \\a - Bell \\b - Backspace \\t - Horizontal tab \\n - Line feed (New lines) \\v - Vertical tab \\f - Form feed \\r - Carriage return \\e - Command Escape \\# - Returns the # character itself, skipping interpolation \\xNN - A byte represented by the hexadecimal NN \\uNNNN - A Unicode code point represented by NNNN Note it is generally not advised to use \\xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \\uNNNN . In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next. Code points and grapheme cluster The functions in this module act according to the Unicode Standard, version 13.0.0. As per the standard, a code point is a single Unicode Character, which may be represented by one or more bytes. For example, although the code point &quot;é&quot; is a single character, its underlying representation uses two bytes: iex&gt; String . length ( &quot;é&quot; ) 1 iex&gt; byte_size ( &quot;é&quot; ) 2 Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;é&quot; can be represented either as a single &quot;e with acute&quot; code point or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points): iex&gt; string = &quot; \\u0065 \\u0301 &quot; iex&gt; byte_size ( string ) 3 iex&gt; String . length ( string ) 1 iex&gt; String . codepoints ( string ) [ &quot;e&quot; , &quot;́&quot; ] iex&gt; String . graphemes ( string ) [ &quot;é&quot; ] Although the example above is made of two characters, it is perceived by users as one. Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module. In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour. More information about graphemes can be found in the Unicode Standard Annex #29 . For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's :unicode module. String and binary operations To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points. For example, String.length/1 will take longer as the input grows. On the other hand, Kernel.byte_size/1 always runs in constant time (i.e. regardless of the input size). This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries: Kernel.binary_part/3 - retrieves part of the binary Kernel.bit_size/1 and Kernel.byte_size/1 - size related functions Kernel.is_bitstring/1 and Kernel.is_binary/1 - type-check function Plus a number of functions for working with binaries (bytes) in the :binary module There are many situations where using the String module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string prefix and you want to remove this prefix from another string named full . One may be tempted to write: iex&gt; take_prefix = fn full , prefix -&gt; ...&gt; base = String . length ( prefix ) ...&gt; String . slice ( full , base , String . length ( full ) - base ) ...&gt; end iex&gt; take_prefix . ( &quot;Mr. John&quot; , &quot;Mr. &quot; ) &quot;John&quot; Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both prefix and full strings, then slice the full one, traversing it again. A first attempt at improving it could be with ranges: iex&gt; take_prefix = fn full , prefix -&gt; ...&gt; base = String . length ( prefix ) ...&gt; String . slice ( full , base . . - 1 ) ...&gt; end iex&gt; take_prefix . ( &quot;Mr. John&quot; , &quot;Mr. &quot; ) &quot;John&quot; While this is much better (we don't traverse full twice), it could still be improved. In this case, since we want to extract a substring from a string, we can use Kernel.byte_size/1 and Kernel.binary_part/3 as there is no chance we will slice in the middle of a code point made of more than one byte: iex&gt; take_prefix = fn full , prefix -&gt; ...&gt; base = byte_size ( prefix ) ...&gt; binary_part ( full , base , byte_size ( full ) - base ) ...&gt; end iex&gt; take_prefix . ( &quot;Mr. John&quot; , &quot;Mr. &quot; ) &quot;John&quot; Or simply use pattern matching: iex&gt; take_prefix = fn full , prefix -&gt; ...&gt; base = byte_size ( prefix ) ...&gt; &lt;&lt; _ :: binary - size ( base ) , rest :: binary &gt;&gt; = full ...&gt; rest ...&gt; end iex&gt; take_prefix . ( &quot;Mr. John&quot; , &quot;Mr. &quot; ) &quot;John&quot; On the other hand, if you want to dynamically slice a string based on an integer value, then using String.slice/3 is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes. Integer code points Although code points are represented as integers, this module represents code points in their encoded format as strings. For example: iex&gt; String . codepoints ( &quot;olá&quot; ) [ &quot;o&quot; , &quot;l&quot; , &quot;á&quot; ] There are a couple of ways to retrieve the character code point. One may use the ? construct: iex&gt; ?o 111 iex&gt; ?á 225 Or also via pattern matching: iex&gt; &lt;&lt; aacute :: utf8 &gt;&gt; = &quot;á&quot; iex&gt; aacute 225 As we have seen above, code points can be inserted into a string by their hexadecimal code: iex&gt; &quot;ol \\u00E1 &quot; &quot;olá&quot; Finally, to convert a String into a list of integer code points, known as &quot;charlists&quot; in Elixir, you can call String.to_charlist : iex&gt; String . to_charlist ( &quot;olá&quot; ) [ 111 , 108 , 225 ] Self-synchronization The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected. This module relies on this behaviour to ignore such invalid characters. For example, length/1 will return a correct result even if an invalid code point is fed into it. In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. String.chunk/2 can be used for breaking a string into valid and invalid parts. Compile binary patterns Many functions in this module work with patterns. For example, String.split/3 can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern: iex&gt; String . split ( &quot;foo bar&quot; , &quot; &quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot;foo bar!&quot; , [ &quot; &quot; , &quot;!&quot; ] ) [ &quot;foo&quot; , &quot;bar&quot; , &quot;&quot; ] iex&gt; pattern = :binary . compile_pattern ( [ &quot; &quot; , &quot;!&quot; ] ) iex&gt; String . split ( &quot;foo bar!&quot; , pattern ) [ &quot;foo&quot; , &quot;bar&quot; , &quot;&quot; ] The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.","ref":"String.html","title":"String","type":"module"},{"doc":"Returns the grapheme at the position of the given UTF-8 string . If position is greater than string length, then it returns nil . Examples iex&gt; String . at ( &quot;elixir&quot; , 0 ) &quot;e&quot; iex&gt; String . at ( &quot;elixir&quot; , 1 ) &quot;l&quot; iex&gt; String . at ( &quot;elixir&quot; , 10 ) nil iex&gt; String . at ( &quot;elixir&quot; , - 1 ) &quot;r&quot; iex&gt; String . at ( &quot;elixir&quot; , - 10 ) nil","ref":"String.html#at/2","title":"String.at/2","type":"function"},{"doc":"Computes the bag distance between two strings. Returns a float value between 0 and 1 representing the bag distance between string1 and string2 . The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different. The algorithm is outlined in the &quot;String Matching with Metric Trees Using an Approximate Distance&quot; paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella. Examples iex&gt; String . bag_distance ( &quot;abc&quot; , &quot;&quot; ) 0.0 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;a&quot; ) 0.25 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;ab&quot; ) 0.5 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;abc&quot; ) 0.75 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;abcd&quot; ) 1.0","ref":"String.html#bag_distance/2","title":"String.bag_distance/2","type":"function"},{"doc":"Converts the first character in the given string to uppercase and the remainder to lowercase according to mode . mode may be :default , :ascii , :greek or :turkic . The :default mode considers all non-conditional transformations outlined in the Unicode standard. :ascii capitalizes only the letters A to Z. :greek includes the context sensitive mappings found in Greek. :turkic properly handles the letter i with the dotless variant. Examples iex&gt; String . capitalize ( &quot;abcd&quot; ) &quot;Abcd&quot; iex&gt; String . capitalize ( &quot;ﬁn&quot; ) &quot;Fin&quot; iex&gt; String . capitalize ( &quot;olá&quot; ) &quot;Olá&quot;","ref":"String.html#capitalize/2","title":"String.capitalize/2","type":"function"},{"doc":"Splits the string into chunks of characters that share a common trait. The trait can be one of two options: :valid - the string is split into chunks of valid and invalid character sequences :printable - the string is split into chunks of printable and non-printable character sequences Returns a list of binaries each of which contains only one kind of characters. If the given string is empty, an empty list is returned. Examples iex&gt; String . chunk ( &lt;&lt; ?a , ?b , ?c , 0 &gt;&gt; , :valid ) [ &quot;abc \\0 &quot; ] iex&gt; String . chunk ( &lt;&lt; ?a , ?b , ?c , 0 , 0xFFFF :: utf16 &gt;&gt; , :valid ) [ &quot;abc \\0 &quot; , &lt;&lt; 0xFFFF :: utf16 &gt;&gt; ] iex&gt; String . chunk ( &lt;&lt; ?a , ?b , ?c , 0 , 0x0FFFF :: utf8 &gt;&gt; , :printable ) [ &quot;abc&quot; , &lt;&lt; 0 , 0x0FFFF :: utf8 &gt;&gt; ]","ref":"String.html#chunk/2","title":"String.chunk/2","type":"function"},{"doc":"Returns a list of code points encoded as strings. To retrieve code points in their natural integer representation, see to_charlist/1 . For details about code points and graphemes, see the String module documentation. Examples iex&gt; String . codepoints ( &quot;olá&quot; ) [ &quot;o&quot; , &quot;l&quot; , &quot;á&quot; ] iex&gt; String . codepoints ( &quot;оптими зации&quot; ) [ &quot;о&quot; , &quot;п&quot; , &quot;т&quot; , &quot;и&quot; , &quot;м&quot; , &quot;и&quot; , &quot; &quot; , &quot;з&quot; , &quot;а&quot; , &quot;ц&quot; , &quot;и&quot; , &quot;и&quot; ] iex&gt; String . codepoints ( &quot;ἅἪῼ&quot; ) [ &quot;ἅ&quot; , &quot;Ἢ&quot; , &quot;ῼ&quot; ] iex&gt; String . codepoints ( &quot; \\u00e9 &quot; ) [ &quot;é&quot; ] iex&gt; String . codepoints ( &quot; \\u0065 \\u0301 &quot; ) [ &quot;e&quot; , &quot;́&quot; ]","ref":"String.html#codepoints/1","title":"String.codepoints/1","type":"function"},{"doc":"Checks if string contains any of the given contents . contents can be either a string, a list of strings, or a compiled pattern. Examples iex&gt; String . contains? ( &quot;elixir of life&quot; , &quot;of&quot; ) true iex&gt; String . contains? ( &quot;elixir of life&quot; , [ &quot;life&quot; , &quot;death&quot; ] ) true iex&gt; String . contains? ( &quot;elixir of life&quot; , [ &quot;death&quot; , &quot;mercury&quot; ] ) false The argument can also be a compiled pattern: iex&gt; pattern = :binary . compile_pattern ( [ &quot;life&quot; , &quot;death&quot; ] ) iex&gt; String . contains? ( &quot;elixir of life&quot; , pattern ) true An empty string will always match: iex&gt; String . contains? ( &quot;elixir of life&quot; , &quot;&quot; ) true iex&gt; String . contains? ( &quot;elixir of life&quot; , [ &quot;&quot; , &quot;other&quot; ] ) true Be aware that this function can match within or across grapheme boundaries. For example, take the grapheme &quot;é&quot; which is made of the characters &quot;e&quot; and the acute accent. The following returns true : iex&gt; String . contains? ( String . normalize ( &quot;é&quot; , :nfd ) , &quot;e&quot; ) true However, if &quot;é&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return false : iex&gt; String . contains? ( String . normalize ( &quot;é&quot; , :nfc ) , &quot;e&quot; ) false","ref":"String.html#contains?/2","title":"String.contains?/2","type":"function"},{"doc":"Converts all characters in the given string to lowercase according to mode . mode may be :default , :ascii , :greek or :turkic . The :default mode considers all non-conditional transformations outlined in the Unicode standard. :ascii lowercases only the letters A to Z. :greek includes the context sensitive mappings found in Greek. :turkic properly handles the letter i with the dotless variant. Examples iex&gt; String . downcase ( &quot;ABCD&quot; ) &quot;abcd&quot; iex&gt; String . downcase ( &quot;AB 123 XPTO&quot; ) &quot;ab 123 xpto&quot; iex&gt; String . downcase ( &quot;OLÁ&quot; ) &quot;olá&quot; The :ascii mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters: iex&gt; String . downcase ( &quot;OLÁ&quot; , :ascii ) &quot;olÁ&quot; The :greek mode properly handles the context sensitive sigma in Greek: iex&gt; String . downcase ( &quot;ΣΣ&quot; ) &quot;σσ&quot; iex&gt; String . downcase ( &quot;ΣΣ&quot; , :greek ) &quot;σς&quot; And :turkic properly handles the letter i with the dotless variant: iex&gt; String . downcase ( &quot;Iİ&quot; ) &quot;ii̇&quot; iex&gt; String . downcase ( &quot;Iİ&quot; , :turkic ) &quot;ıi&quot;","ref":"String.html#downcase/2","title":"String.downcase/2","type":"function"},{"doc":"Returns a string subject repeated n times. Inlined by the compiler. Examples iex&gt; String . duplicate ( &quot;abc&quot; , 0 ) &quot;&quot; iex&gt; String . duplicate ( &quot;abc&quot; , 1 ) &quot;abc&quot; iex&gt; String . duplicate ( &quot;abc&quot; , 2 ) &quot;abcabc&quot;","ref":"String.html#duplicate/2","title":"String.duplicate/2","type":"function"},{"doc":"Returns true if string ends with any of the suffixes given. suffixes can be either a single suffix or a list of suffixes. Examples iex&gt; String . ends_with? ( &quot;language&quot; , &quot;age&quot; ) true iex&gt; String . ends_with? ( &quot;language&quot; , [ &quot;youth&quot; , &quot;age&quot; ] ) true iex&gt; String . ends_with? ( &quot;language&quot; , [ &quot;youth&quot; , &quot;elixir&quot; ] ) false An empty suffix will always match: iex&gt; String . ends_with? ( &quot;language&quot; , &quot;&quot; ) true iex&gt; String . ends_with? ( &quot;language&quot; , [ &quot;&quot; , &quot;other&quot; ] ) true","ref":"String.html#ends_with?/2","title":"String.ends_with?/2","type":"function"},{"doc":"Returns true if string1 is canonically equivalent to string2 . It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to: String . normalize ( string1 , :nfd ) == String . normalize ( string2 , :nfd ) If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes. Examples iex&gt; String . equivalent? ( &quot;abc&quot; , &quot;abc&quot; ) true iex&gt; String . equivalent? ( &quot;man \\u0303 ana&quot; , &quot;mañana&quot; ) true iex&gt; String . equivalent? ( &quot;abc&quot; , &quot;ABC&quot; ) false iex&gt; String . equivalent? ( &quot;nø&quot; , &quot;nó&quot; ) false","ref":"String.html#equivalent?/2","title":"String.equivalent?/2","type":"function"},{"doc":"Returns the first grapheme from a UTF-8 string, nil if the string is empty. Examples iex&gt; String . first ( &quot;elixir&quot; ) &quot;e&quot; iex&gt; String . first ( &quot;եոգլի&quot; ) &quot;ե&quot; iex&gt; String . first ( &quot;&quot; ) nil","ref":"String.html#first/1","title":"String.first/1","type":"function"},{"doc":"Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm. The algorithm is outlined in the Unicode Standard Annex #29, Unicode Text Segmentation . For details about code points and graphemes, see the String module documentation. Examples iex&gt; String . graphemes ( &quot;Ńaïve&quot; ) [ &quot;Ń&quot; , &quot;a&quot; , &quot;ï&quot; , &quot;v&quot; , &quot;e&quot; ] iex&gt; String . graphemes ( &quot; \\u00e9 &quot; ) [ &quot;é&quot; ] iex&gt; String . graphemes ( &quot; \\u0065 \\u0301 &quot; ) [ &quot;é&quot; ]","ref":"String.html#graphemes/1","title":"String.graphemes/1","type":"function"},{"doc":"Computes the Jaro distance (similarity) between two strings. Returns a float value between 0.0 (equates to no similarity) and 1.0 (is an exact match) representing Jaro distance between string1 and string2 . The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the &quot;did you mean?&quot; functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the jaro_distance/2 score. Examples iex&gt; String . jaro_distance ( &quot;Dwayne&quot; , &quot;Duane&quot; ) 0.8222222222222223 iex&gt; String . jaro_distance ( &quot;even&quot; , &quot;odd&quot; ) 0.0 iex&gt; String . jaro_distance ( &quot;same&quot; , &quot;same&quot; ) 1.0","ref":"String.html#jaro_distance/2","title":"String.jaro_distance/2","type":"function"},{"doc":"Returns the last grapheme from a UTF-8 string, nil if the string is empty. Examples iex&gt; String . last ( &quot;elixir&quot; ) &quot;r&quot; iex&gt; String . last ( &quot;եոգլի&quot; ) &quot;ի&quot;","ref":"String.html#last/1","title":"String.last/1","type":"function"},{"doc":"Returns the number of Unicode graphemes in a UTF-8 string. Examples iex&gt; String . length ( &quot;elixir&quot; ) 6 iex&gt; String . length ( &quot;եոգլի&quot; ) 5","ref":"String.html#length/1","title":"String.length/1","type":"function"},{"doc":"Checks if string matches the given regular expression. Examples iex&gt; String . match? ( &quot;foo&quot; , ~r/foo/ ) true iex&gt; String . match? ( &quot;bar&quot; , ~r/foo/ ) false","ref":"String.html#match?/2","title":"String.match?/2","type":"function"},{"doc":"Returns a keyword list that represents an edit script. Check List.myers_difference/2 for more information. Examples iex&gt; string1 = &quot;fox hops over the dog&quot; iex&gt; string2 = &quot;fox jumps over the lazy cat&quot; iex&gt; String . myers_difference ( string1 , string2 ) [ eq : &quot;fox &quot; , del : &quot;ho&quot; , ins : &quot;jum&quot; , eq : &quot;ps over the &quot; , del : &quot;dog&quot; , ins : &quot;lazy cat&quot; ]","ref":"String.html#myers_difference/2","title":"String.myers_difference/2","type":"function"},{"doc":"Returns the next code point in a string. The result is a tuple with the code point and the remainder of the string or nil in case the string reached its end. As with other functions in the String module, next_codepoint/1 works with binaries that are invalid UTF-8. If the string starts with a sequence of bytes that is not valid in UTF-8 encoding, the first element of the returned tuple is a binary with the first byte. Examples iex&gt; String . next_codepoint ( &quot;olá&quot; ) { &quot;o&quot; , &quot;lá&quot; } iex&gt; invalid = &quot; \\x 80 \\x 80OK&quot; # first two bytes are invalid in UTF-8 iex&gt; { _ , rest } = String . next_codepoint ( invalid ) { &lt;&lt; 128 &gt;&gt; , &lt;&lt; 128 , 79 , 75 &gt;&gt; } iex&gt; String . next_codepoint ( rest ) { &lt;&lt; 128 &gt;&gt; , &quot;OK&quot; } Comparison with binary pattern matching Binary pattern matching provides a similar way to decompose a string: iex&gt; &lt;&lt; codepoint :: utf8 , rest :: binary &gt;&gt; = &quot;Elixir&quot; &quot;Elixir&quot; iex&gt; codepoint 69 iex&gt; rest &quot;lixir&quot; though not entirely equivalent because codepoint comes as an integer, and the pattern won't match invalid UTF-8. Binary pattern matching, however, is simpler and more efficient, so pick the option that better suits your use case.","ref":"String.html#next_codepoint/1","title":"String.next_codepoint/1","type":"function"},{"doc":"Returns the next grapheme in a string. The result is a tuple with the grapheme and the remainder of the string or nil in case the String reached its end. Examples iex&gt; String . next_grapheme ( &quot;olá&quot; ) { &quot;o&quot; , &quot;lá&quot; } iex&gt; String . next_grapheme ( &quot;&quot; ) nil","ref":"String.html#next_grapheme/1","title":"String.next_grapheme/1","type":"function"},{"doc":"Returns the size (in bytes) of the next grapheme. The result is a tuple with the next grapheme size in bytes and the remainder of the string or nil in case the string reached its end. Examples iex&gt; String . next_grapheme_size ( &quot;olá&quot; ) { 1 , &quot;lá&quot; } iex&gt; String . next_grapheme_size ( &quot;&quot; ) nil","ref":"String.html#next_grapheme_size/1","title":"String.next_grapheme_size/1","type":"function"},{"doc":"Converts all characters in string to Unicode normalization form identified by form . Invalid Unicode codepoints are skipped and the remaining of the string is converted. If you want the algorithm to stop and return on invalid codepoint, use :unicode.characters_to_nfd_binary/1 , :unicode.characters_to_nfc_binary/1 , :unicode.characters_to_nfkd_binary/1 , and :unicode.characters_to_nfkc_binary/1 instead. Normalization forms :nfkc and :nfkd should not be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets. Forms The supported forms are: :nfd - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order. :nfc - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence. :nfkd - Normalization Form Compatibility Decomposition. Characters are decomposed by compatibility equivalence, and multiple combining characters are arranged in a specific order. :nfkc - Normalization Form Compatibility Composition. Characters are decomposed and then recomposed by compatibility equivalence. Examples iex&gt; String . normalize ( &quot;yêṩ&quot; , :nfd ) &quot;yêṩ&quot; iex&gt; String . normalize ( &quot;leña&quot; , :nfc ) &quot;leña&quot; iex&gt; String . normalize ( &quot;ﬁ&quot; , :nfkd ) &quot;fi&quot; iex&gt; String . normalize ( &quot;fi&quot; , :nfkc ) &quot;fi&quot;","ref":"String.html#normalize/2","title":"String.normalize/2","type":"function"},{"doc":"Returns a new string padded with a leading filler which is made of elements from the padding . Passing a list of strings as padding will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string padding is equivalent to passing the list of graphemes in it. If no padding is given, it defaults to whitespace. When count is less than or equal to the length of string , given string is returned. Raises ArgumentError if the given padding contains a non-string element. Examples iex&gt; String . pad_leading ( &quot;abc&quot; , 5 ) &quot; abc&quot; iex&gt; String . pad_leading ( &quot;abc&quot; , 4 , &quot;12&quot; ) &quot;1abc&quot; iex&gt; String . pad_leading ( &quot;abc&quot; , 6 , &quot;12&quot; ) &quot;121abc&quot; iex&gt; String . pad_leading ( &quot;abc&quot; , 5 , [ &quot;1&quot; , &quot;23&quot; ] ) &quot;123abc&quot;","ref":"String.html#pad_leading/3","title":"String.pad_leading/3","type":"function"},{"doc":"Returns a new string padded with a trailing filler which is made of elements from the padding . Passing a list of strings as padding will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string padding is equivalent to passing the list of graphemes in it. If no padding is given, it defaults to whitespace. When count is less than or equal to the length of string , given string is returned. Raises ArgumentError if the given padding contains a non-string element. Examples iex&gt; String . pad_trailing ( &quot;abc&quot; , 5 ) &quot;abc &quot; iex&gt; String . pad_trailing ( &quot;abc&quot; , 4 , &quot;12&quot; ) &quot;abc1&quot; iex&gt; String . pad_trailing ( &quot;abc&quot; , 6 , &quot;12&quot; ) &quot;abc121&quot; iex&gt; String . pad_trailing ( &quot;abc&quot; , 5 , [ &quot;1&quot; , &quot;23&quot; ] ) &quot;abc123&quot;","ref":"String.html#pad_trailing/3","title":"String.pad_trailing/3","type":"function"},{"doc":"Checks if a string contains only printable characters up to character_limit . Takes an optional character_limit as a second argument. If character_limit is 0 , this function will return true . Examples iex&gt; String . printable? ( &quot;abc&quot; ) true iex&gt; String . printable? ( &quot;abc&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; ) false iex&gt; String . printable? ( &quot;abc&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; , 2 ) true iex&gt; String . printable? ( &quot;abc&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; , 0 ) true","ref":"String.html#printable?/2","title":"String.printable?/2","type":"function"},{"doc":"Returns a new string created by replacing occurrences of pattern in subject with replacement . The subject is always a string. The pattern may be a string, a list of strings, a regular expression, or a compiled pattern. The replacement may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata. By default it replaces all occurrences but this behaviour can be controlled through the :global option; see the &quot;Options&quot; section below. Options :global - (boolean) if true , all occurrences of pattern are replaced with replacement , otherwise only the first occurrence is replaced. Defaults to true Examples iex&gt; String . replace ( &quot;a,b,c&quot; , &quot;,&quot; , &quot;-&quot; ) &quot;a-b-c&quot; iex&gt; String . replace ( &quot;a,b,c&quot; , &quot;,&quot; , &quot;-&quot; , global : false ) &quot;a-b,c&quot; The pattern may also be a list of strings and the replacement may also be a function that receives the matches: iex&gt; String . replace ( &quot;a,b,c&quot; , [ &quot;a&quot; , &quot;c&quot; ] , fn &lt;&lt; char &gt;&gt; -&gt; &lt;&lt; char + 1 &gt;&gt; end ) &quot;b,b,d&quot; When the pattern is a regular expression, one can give \\N or \\g{N} in the replacement string to access a specific capture in the regular expression: iex&gt; String . replace ( &quot;a,b,c&quot; , ~r/,(.)/ , &quot;, \\\\ 1 \\\\ g{1}&quot; ) &quot;a,bb,cc&quot; Note that we had to escape the backslash escape character (i.e., we used \\\\N instead of just \\N to escape the backslash; same thing for \\\\g{N} ). By giving \\0 , one can inject the whole match in the replacement string. A compiled pattern can also be given: iex&gt; pattern = :binary . compile_pattern ( &quot;,&quot; ) iex&gt; String . replace ( &quot;a,b,c&quot; , pattern , &quot;[]&quot; ) &quot;a[]b[]c&quot; When an empty string is provided as a pattern , the function will treat it as an implicit empty string between each grapheme and the string will be interspersed. If an empty string is provided as replacement the subject will be returned: iex&gt; String . replace ( &quot;ELIXIR&quot; , &quot;&quot; , &quot;.&quot; ) &quot;.E.L.I.X.I.R.&quot; iex&gt; String . replace ( &quot;ELIXIR&quot; , &quot;&quot; , &quot;&quot; ) &quot;ELIXIR&quot;","ref":"String.html#replace/4","title":"String.replace/4","type":"function"},{"doc":"Replaces all leading occurrences of match by replacement of match in string . Returns the string untouched if there are no occurrences. If match is &quot;&quot; , this function raises an ArgumentError exception: this happens because this function replaces all the occurrences of match at the beginning of string , and it's impossible to replace &quot;multiple&quot; occurrences of &quot;&quot; . Examples iex&gt; String . replace_leading ( &quot;hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_leading ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_leading ( &quot;hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola world&quot; iex&gt; String . replace_leading ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola ola world&quot;","ref":"String.html#replace_leading/3","title":"String.replace_leading/3","type":"function"},{"doc":"Replaces prefix in string by replacement if it matches match . Returns the string untouched if there is no match. If match is an empty string ( &quot;&quot; ), replacement is just prepended to string . Examples iex&gt; String . replace_prefix ( &quot;world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_prefix ( &quot;hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_prefix ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;hello world&quot; iex&gt; String . replace_prefix ( &quot;world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;world&quot; iex&gt; String . replace_prefix ( &quot;hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola world&quot; iex&gt; String . replace_prefix ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola hello world&quot; iex&gt; String . replace_prefix ( &quot;world&quot; , &quot;&quot; , &quot;hello &quot; ) &quot;hello world&quot;","ref":"String.html#replace_prefix/3","title":"String.replace_prefix/3","type":"function"},{"doc":"Replaces suffix in string by replacement if it matches match . Returns the string untouched if there is no match. If match is an empty string ( &quot;&quot; ), replacement is just appended to string . Examples iex&gt; String . replace_suffix ( &quot;hello&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_suffix ( &quot;hello world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_suffix ( &quot;hello world world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello world&quot; iex&gt; String . replace_suffix ( &quot;hello&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello&quot; iex&gt; String . replace_suffix ( &quot;hello world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello mundo&quot; iex&gt; String . replace_suffix ( &quot;hello world world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello world mundo&quot; iex&gt; String . replace_suffix ( &quot;hello&quot; , &quot;&quot; , &quot; world&quot; ) &quot;hello world&quot;","ref":"String.html#replace_suffix/3","title":"String.replace_suffix/3","type":"function"},{"doc":"Replaces all trailing occurrences of match by replacement in string . Returns the string untouched if there are no occurrences. If match is &quot;&quot; , this function raises an ArgumentError exception: this happens because this function replaces all the occurrences of match at the end of string , and it's impossible to replace &quot;multiple&quot; occurrences of &quot;&quot; . Examples iex&gt; String . replace_trailing ( &quot;hello world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_trailing ( &quot;hello world world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_trailing ( &quot;hello world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello mundo&quot; iex&gt; String . replace_trailing ( &quot;hello world world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello mundo mundo&quot;","ref":"String.html#replace_trailing/3","title":"String.replace_trailing/3","type":"function"},{"doc":"Reverses the graphemes in given string. Examples iex&gt; String . reverse ( &quot;abcd&quot; ) &quot;dcba&quot; iex&gt; String . reverse ( &quot;hello world&quot; ) &quot;dlrow olleh&quot; iex&gt; String . reverse ( &quot;hello ∂og&quot; ) &quot;go∂ olleh&quot; Keep in mind reversing the same string twice does not necessarily yield the original string: iex&gt; &quot;̀e&quot; &quot;̀e&quot; iex&gt; String . reverse ( &quot;̀e&quot; ) &quot;è&quot; iex&gt; String . reverse ( String . reverse ( &quot;̀e&quot; ) ) &quot;è&quot; In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.","ref":"String.html#reverse/1","title":"String.reverse/1","type":"function"},{"doc":"Returns a substring from the offset given by the start of the range to the offset given by the end of the range. If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &quot;&quot; . If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones. Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check Kernel.binary_part/3 instead. Examples iex&gt; String . slice ( &quot;elixir&quot; , 1 . . 3 ) &quot;lix&quot; iex&gt; String . slice ( &quot;elixir&quot; , 1 . . 10 ) &quot;lixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 4 . . - 1 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 4 . . 6 ) &quot;ixir&quot; For ranges where start &gt; stop , you need to explicit mark them as increasing: iex&gt; String . slice ( &quot;elixir&quot; , 2 . . - 1 / / 1 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , 1 . . - 2 / / 1 ) &quot;lixi&quot; If values are out of bounds, it returns an empty string: iex&gt; String . slice ( &quot;elixir&quot; , 10 . . 3 ) &quot;&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 10 . . - 7 ) &quot;&quot; iex&gt; String . slice ( &quot;a&quot; , 0 . . 1500 ) &quot;a&quot; iex&gt; String . slice ( &quot;a&quot; , 1 . . 1500 ) &quot;&quot;","ref":"String.html#slice/2","title":"String.slice/2","type":"function"},{"doc":"Returns a substring starting at the offset start , and of the given length . If the offset is greater than string length, then it returns &quot;&quot; . Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check Kernel.binary_part/3 instead. Examples iex&gt; String . slice ( &quot;elixir&quot; , 1 , 3 ) &quot;lix&quot; iex&gt; String . slice ( &quot;elixir&quot; , 1 , 10 ) &quot;lixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , 10 , 3 ) &quot;&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 4 , 4 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 10 , 3 ) &quot;&quot; iex&gt; String . slice ( &quot;a&quot; , 0 , 1500 ) &quot;a&quot; iex&gt; String . slice ( &quot;a&quot; , 1 , 1500 ) &quot;&quot; iex&gt; String . slice ( &quot;a&quot; , 2 , 1500 ) &quot;&quot;","ref":"String.html#slice/3","title":"String.slice/3","type":"function"},{"doc":"Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace. Examples iex&gt; String . split ( &quot;foo bar&quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot;foo&quot; &lt;&gt; &lt;&lt; 194 , 133 &gt;&gt; &lt;&gt; &quot;bar&quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot; foo bar &quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot;no \\u00a0 break&quot; ) [ &quot;no \\u00a0 break&quot; ]","ref":"String.html#split/1","title":"String.split/1","type":"function"},{"doc":"Divides a string into parts based on a pattern. Returns a list of these parts. The pattern may be a string, a list of strings, a regular expression, or a compiled pattern. The string is split into as many parts as possible by default, but can be controlled via the :parts option. Empty strings are only removed from the result if the :trim option is set to true . When the pattern used is a regular expression, the string is split using Regex.split/3 . Options :parts (positive integer or :infinity ) - the string is split into at most as many parts as this option specifies. If :infinity , the string will be split into all possible parts. Defaults to :infinity . :trim (boolean) - if true , empty strings are removed from the resulting list. This function also accepts all options accepted by Regex.split/3 if pattern is a regular expression. Examples Splitting with a string pattern: iex&gt; String . split ( &quot;a,b,c&quot; , &quot;,&quot; ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;a,b,c&quot; , &quot;,&quot; , parts : 2 ) [ &quot;a&quot; , &quot;b,c&quot; ] iex&gt; String . split ( &quot; a b c &quot; , &quot; &quot; , trim : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] A list of patterns: iex&gt; String . split ( &quot;1,2 3,4&quot; , [ &quot; &quot; , &quot;,&quot; ] ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ] A regular expression: iex&gt; String . split ( &quot;a,b,c&quot; , ~r{,} ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;a,b,c&quot; , ~r{,} , parts : 2 ) [ &quot;a&quot; , &quot;b,c&quot; ] iex&gt; String . split ( &quot; a b c &quot; , ~r{ \\s } , trim : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;abc&quot; , ~r{b} , include_captures : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] A compiled pattern: iex&gt; pattern = :binary . compile_pattern ( [ &quot; &quot; , &quot;,&quot; ] ) iex&gt; String . split ( &quot;1,2 3,4&quot; , pattern ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ] Splitting on empty string returns graphemes: iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; ) [ &quot;&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;&quot; ] iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; , trim : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; , parts : 1 ) [ &quot;abc&quot; ] iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; , parts : 3 ) [ &quot;&quot; , &quot;a&quot; , &quot;bc&quot; ] Be aware that this function can split within or across grapheme boundaries. For example, take the grapheme &quot;é&quot; which is made of the characters &quot;e&quot; and the acute accent. The following will split the string into two parts: iex&gt; String . split ( String . normalize ( &quot;é&quot; , :nfd ) , &quot;e&quot; ) [ &quot;&quot; , &quot;́&quot; ] However, if &quot;é&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part: iex&gt; String . split ( String . normalize ( &quot;é&quot; , :nfc ) , &quot;e&quot; ) [ &quot;é&quot; ]","ref":"String.html#split/3","title":"String.split/3","type":"function"},{"doc":"Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string. The offset is capped to the length of the string. Returns a tuple with two elements. Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use Kernel.binary_part/3 instead. Examples iex&gt; String . split_at ( &quot;sweetelixir&quot; , 5 ) { &quot;sweet&quot; , &quot;elixir&quot; } iex&gt; String . split_at ( &quot;sweetelixir&quot; , - 6 ) { &quot;sweet&quot; , &quot;elixir&quot; } iex&gt; String . split_at ( &quot;abc&quot; , 0 ) { &quot;&quot; , &quot;abc&quot; } iex&gt; String . split_at ( &quot;abc&quot; , 1000 ) { &quot;abc&quot; , &quot;&quot; } iex&gt; String . split_at ( &quot;abc&quot; , - 1000 ) { &quot;&quot; , &quot;abc&quot; }","ref":"String.html#split_at/2","title":"String.split_at/2","type":"function"},{"doc":"Returns an enumerable that splits a string on demand. This is in contrast to split/3 which splits the entire string upfront. This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does. Options :trim - when true , does not emit empty patterns Examples iex&gt; String . splitter ( &quot;1,2 3,4 5,6 7,8,...,99999&quot; , [ &quot; &quot; , &quot;,&quot; ] ) |&gt; Enum . take ( 4 ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ] iex&gt; String . splitter ( &quot;abcd&quot; , &quot;&quot; ) |&gt; Enum . take ( 10 ) [ &quot;&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;&quot; ] iex&gt; String . splitter ( &quot;abcd&quot; , &quot;&quot; , trim : true ) |&gt; Enum . take ( 10 ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] A compiled pattern can also be given: iex&gt; pattern = :binary . compile_pattern ( [ &quot; &quot; , &quot;,&quot; ] ) iex&gt; String . splitter ( &quot;1,2 3,4 5,6 7,8,...,99999&quot; , pattern ) |&gt; Enum . take ( 4 ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ]","ref":"String.html#splitter/3","title":"String.splitter/3","type":"function"},{"doc":"Returns true if string starts with any of the prefixes given. prefix can be either a string, a list of strings, or a compiled pattern. Examples iex&gt; String . starts_with? ( &quot;elixir&quot; , &quot;eli&quot; ) true iex&gt; String . starts_with? ( &quot;elixir&quot; , [ &quot;erlang&quot; , &quot;elixir&quot; ] ) true iex&gt; String . starts_with? ( &quot;elixir&quot; , [ &quot;erlang&quot; , &quot;ruby&quot; ] ) false A compiled pattern can also be given: iex&gt; pattern = :binary . compile_pattern ( [ &quot;erlang&quot; , &quot;elixir&quot; ] ) iex&gt; String . starts_with? ( &quot;elixir&quot; , pattern ) true An empty string will always match: iex&gt; String . starts_with? ( &quot;elixir&quot; , &quot;&quot; ) true iex&gt; String . starts_with? ( &quot;elixir&quot; , [ &quot;&quot; , &quot;other&quot; ] ) true","ref":"String.html#starts_with?/2","title":"String.starts_with?/2","type":"function"},{"doc":"Converts a string to an atom. Warning: this function creates atoms dynamically and atoms are not garbage-collected. Therefore, string should not be an untrusted value, such as input received from a socket or during a web request. Consider using to_existing_atom/1 instead. By default, the maximum number of atoms is 1_048_576 . This limit can be raised or lowered using the VM option +t . The maximum atom size is of 255 Unicode code points. Inlined by the compiler. Examples iex&gt; String . to_atom ( &quot;my_atom&quot; ) :my_atom","ref":"String.html#to_atom/1","title":"String.to_atom/1","type":"function"},{"doc":"Converts a string into a charlist. Specifically, this function takes a UTF-8 encoded binary and returns a list of its integer code points. It is similar to codepoints/1 except that the latter returns a list of code points as strings. In case you need to work with bytes, take a look at the :binary module . Examples iex&gt; String . to_charlist ( &quot;æß&quot; ) &#39;æß&#39;","ref":"String.html#to_charlist/1","title":"String.to_charlist/1","type":"function"},{"doc":"Converts a string to an existing atom. The maximum atom size is of 255 Unicode code points. Inlined by the compiler. Examples iex&gt; _ = :my_atom iex&gt; String . to_existing_atom ( &quot;my_atom&quot; ) :my_atom","ref":"String.html#to_existing_atom/1","title":"String.to_existing_atom/1","type":"function"},{"doc":"Returns a float whose text representation is string . string must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then Float.parse/1 should be used. Otherwise, an ArgumentError will be raised. Inlined by the compiler. Examples iex&gt; String . to_float ( &quot;2.2017764e+0&quot; ) 2.2017764 iex&gt; String . to_float ( &quot;3.0&quot; ) 3.0 String . to_float ( &quot;3&quot; ) ** (ArgumentError) argument error","ref":"String.html#to_float/1","title":"String.to_float/1","type":"function"},{"doc":"Returns an integer whose text representation is string . string must be the string representation of an integer. Otherwise, an ArgumentError will be raised. If you want to parse a string that may contain an ill-formatted integer, use Integer.parse/1 . Inlined by the compiler. Examples iex&gt; String . to_integer ( &quot;123&quot; ) 123 Passing a string that does not represent an integer leads to an error: String . to_integer ( &quot;invalid data&quot; ) ** (ArgumentError) argument error","ref":"String.html#to_integer/1","title":"String.to_integer/1","type":"function"},{"doc":"Returns an integer whose text representation is string in base base . Inlined by the compiler. Examples iex&gt; String . to_integer ( &quot;3FF&quot; , 16 ) 1023","ref":"String.html#to_integer/2","title":"String.to_integer/2","type":"function"},{"doc":"Returns a string where all leading and trailing Unicode whitespaces have been removed. Examples iex&gt; String . trim ( &quot; \\n abc \\n &quot; ) &quot;abc&quot;","ref":"String.html#trim/1","title":"String.trim/1","type":"function"},{"doc":"Returns a string where all leading and trailing to_trim characters have been removed. Examples iex&gt; String . trim ( &quot;a abc a&quot; , &quot;a&quot; ) &quot; abc &quot;","ref":"String.html#trim/2","title":"String.trim/2","type":"function"},{"doc":"Returns a string where all leading Unicode whitespaces have been removed. Examples iex&gt; String . trim_leading ( &quot; \\n abc &quot; ) &quot;abc &quot;","ref":"String.html#trim_leading/1","title":"String.trim_leading/1","type":"function"},{"doc":"Returns a string where all leading to_trim characters have been removed. Examples iex&gt; String . trim_leading ( &quot;__ abc _&quot; , &quot;_&quot; ) &quot; abc _&quot; iex&gt; String . trim_leading ( &quot;1 abc&quot; , &quot;11&quot; ) &quot;1 abc&quot;","ref":"String.html#trim_leading/2","title":"String.trim_leading/2","type":"function"},{"doc":"Returns a string where all trailing Unicode whitespaces has been removed. Examples iex&gt; String . trim_trailing ( &quot; abc \\n &quot; ) &quot; abc&quot;","ref":"String.html#trim_trailing/1","title":"String.trim_trailing/1","type":"function"},{"doc":"Returns a string where all trailing to_trim characters have been removed. Examples iex&gt; String . trim_trailing ( &quot;_ abc __&quot; , &quot;_&quot; ) &quot;_ abc &quot; iex&gt; String . trim_trailing ( &quot;abc 1&quot; , &quot;11&quot; ) &quot;abc 1&quot;","ref":"String.html#trim_trailing/2","title":"String.trim_trailing/2","type":"function"},{"doc":"Converts all characters in the given string to uppercase according to mode . mode may be :default , :ascii , :greek or :turkic . The :default mode considers all non-conditional transformations outlined in the Unicode standard. :ascii uppercases only the letters a to z. :greek includes the context sensitive mappings found in Greek. :turkic properly handles the letter i with the dotless variant. Examples iex&gt; String . upcase ( &quot;abcd&quot; ) &quot;ABCD&quot; iex&gt; String . upcase ( &quot;ab 123 xpto&quot; ) &quot;AB 123 XPTO&quot; iex&gt; String . upcase ( &quot;olá&quot; ) &quot;OLÁ&quot; The :ascii mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters: iex&gt; String . upcase ( &quot;olá&quot; , :ascii ) &quot;OLá&quot; And :turkic properly handles the letter i with the dotless variant: iex&gt; String . upcase ( &quot;ıi&quot; ) &quot;II&quot; iex&gt; String . upcase ( &quot;ıi&quot; , :turkic ) &quot;Iİ&quot;","ref":"String.html#upcase/2","title":"String.upcase/2","type":"function"},{"doc":"Checks whether string contains only valid characters. Examples iex&gt; String . valid? ( &quot;a&quot; ) true iex&gt; String . valid? ( &quot;ø&quot; ) true iex&gt; String . valid? ( &lt;&lt; 0xFFFF :: 16 &gt;&gt; ) false iex&gt; String . valid? ( &lt;&lt; 0xEF , 0xB7 , 0x90 &gt;&gt; ) true iex&gt; String . valid? ( &quot;asd&quot; &lt;&gt; &lt;&lt; 0xFFFF :: 16 &gt;&gt; ) false","ref":"String.html#valid?/1","title":"String.valid?/1","type":"function"},{"doc":"A single Unicode code point encoded in UTF-8. It may be one or more bytes.","ref":"String.html#t:codepoint/0","title":"String.codepoint/0","type":"type"},{"doc":"Multiple code points that may be perceived as a single character by readers","ref":"String.html#t:grapheme/0","title":"String.grapheme/0","type":"type"},{"doc":"Pattern used in functions like replace/4 and split/3","ref":"String.html#t:pattern/0","title":"String.pattern/0","type":"type"},{"doc":"A UTF-8 encoded binary. The types String.t() and binary() are equivalent to analysis tools. Although, for those reading the documentation, String.t() implies it is a UTF-8 encoded binary.","ref":"String.html#t:t/0","title":"String.t/0","type":"type"},{"doc":"A Time struct and functions. The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the new/4 function or using the ~T (see Kernel.sigil_T/2 ) sigil: iex&gt; ~T[23:00:07.001] ~T[23:00:07.001] Both new/4 and sigil return a struct where the time fields can be accessed directly: iex&gt; time = ~T[23:00:07.001] iex&gt; time . hour 23 iex&gt; time . microsecond { 1000 , 3 } The functions on this module work with the Time struct as well as any struct that contains the same fields as the Time struct, such as NaiveDateTime and DateTime . Such functions expect Calendar.time/0 in their typespecs (instead of t/0 ). Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries. Comparing times Comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and similar are structural and based on the Time struct fields. For proper comparison between times, use the compare/2 function.","ref":"Time.html","title":"Time","type":"module"},{"doc":"Adds the number of unit s to the given time . This function accepts the number measured according to Calendar.ISO . The time is returned in the same calendar as it was given in. Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar. Examples iex&gt; Time . add ( ~T[10:00:00] , 27000 ) ~T[17:30:00.000000] iex&gt; Time . add ( ~T[11:00:00.005] , 2400 ) ~T[11:40:00.005000] iex&gt; Time . add ( ~T[00:00:00] , 86_399_999 , :millisecond ) ~T[23:59:59.999000] iex&gt; Time . add ( ~T[17:10:05] , 86400 ) ~T[17:10:05.000000] iex&gt; Time . add ( ~T[23:00:00] , - 60 ) ~T[22:59:00.000000]","ref":"Time.html#add/3","title":"Time.add/3","type":"function"},{"doc":"Compares two time structs. Returns :gt if first time is later than the second and :lt for vice versa. If the two times are equal :eq is returned. Examples iex&gt; Time . compare ( ~T[16:04:16] , ~T[16:04:28] ) :lt iex&gt; Time . compare ( ~T[16:04:16] , ~T[16:04:16] ) :eq iex&gt; Time . compare ( ~T[16:04:16.01] , ~T[16:04:16.001] ) :gt This function can also be used to compare across more complex calendar types by considering only the time fields: iex&gt; Time . compare ( ~N[1900-01-01 16:04:16] , ~N[2015-01-01 16:04:16] ) :eq iex&gt; Time . compare ( ~N[2015-01-01 16:04:16] , ~N[2015-01-01 16:04:28] ) :lt iex&gt; Time . compare ( ~N[2015-01-01 16:04:16.01] , ~N[2000-01-01 16:04:16.001] ) :gt","ref":"Time.html#compare/2","title":"Time.compare/2","type":"function"},{"doc":"Converts given time to a different calendar. Returns {:ok, time} if the conversion was successful, or {:error, reason} if it was not, for some reason. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Time . convert ( ~T[13:30:15] , Calendar.Holocene ) { :ok , % Time { calendar : Calendar.Holocene , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } } }","ref":"Time.html#convert/2","title":"Time.convert/2","type":"function"},{"doc":"Similar to Time.convert/2 , but raises an ArgumentError if the conversion between the two calendars is not possible. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Time . convert! ( ~T[13:30:15] , Calendar.Holocene ) % Time { calendar : Calendar.Holocene , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } }","ref":"Time.html#convert!/2","title":"Time.convert!/2","type":"function"},{"doc":"Returns the difference between two times, considering only the hour, minute, second and microsecond. As with the compare/2 function both Time structs and other structures containing time can be used. If for instance a NaiveDateTime or DateTime is passed, only the hour, minute, second, and microsecond is considered. Any additional information about a date or time zone is ignored when calculating the difference. The answer can be returned in any unit available from System.time_unit/0 . If the first time value is earlier than the second, a negative number is returned. This function returns the difference in seconds where seconds are measured according to Calendar.ISO . Examples iex&gt; Time . diff ( ~T[00:29:12] , ~T[00:29:10] ) 2 # When passing a `NaiveDateTime` the date part is ignored. iex&gt; Time . diff ( ~N[2017-01-01 00:29:12] , ~T[00:29:10] ) 2 # Two `NaiveDateTime` structs could have big differences in the date # but only the time part is considered. iex&gt; Time . diff ( ~N[2017-01-01 00:29:12] , ~N[1900-02-03 00:29:10] ) 2 iex&gt; Time . diff ( ~T[00:29:12] , ~T[00:29:10] , :microsecond ) 2_000_000 iex&gt; Time . diff ( ~T[00:29:10] , ~T[00:29:12] , :microsecond ) - 2_000_000","ref":"Time.html#diff/3","title":"Time.diff/3","type":"function"},{"doc":"Converts an Erlang time tuple to a Time struct. Examples iex&gt; Time . from_erl ( { 23 , 30 , 15 } , { 5000 , 3 } ) { :ok , ~T[23:30:15.005] } iex&gt; Time . from_erl ( { 24 , 30 , 15 } ) { :error , :invalid_time }","ref":"Time.html#from_erl/3","title":"Time.from_erl/3","type":"function"},{"doc":"Converts an Erlang time tuple to a Time struct. Examples iex&gt; Time . from_erl! ( { 23 , 30 , 15 } ) ~T[23:30:15] iex&gt; Time . from_erl! ( { 23 , 30 , 15 } , { 5000 , 3 } ) ~T[23:30:15.005] iex&gt; Time . from_erl! ( { 24 , 30 , 15 } ) ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time","ref":"Time.html#from_erl!/3","title":"Time.from_erl!/3","type":"function"},{"doc":"Parses the extended &quot;Local time&quot; format described by ISO 8601:2019 . Time zone offset may be included in the string but they will be simply discarded as such information is not included in times. As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function. Examples iex&gt; Time . from_iso8601 ( &quot;23:50:07&quot; ) { :ok , ~T[23:50:07] } iex&gt; Time . from_iso8601 ( &quot;23:50:07Z&quot; ) { :ok , ~T[23:50:07] } iex&gt; Time . from_iso8601 ( &quot;T23:50:07Z&quot; ) { :ok , ~T[23:50:07] } iex&gt; Time . from_iso8601 ( &quot;23:50:07,0123456&quot; ) { :ok , ~T[23:50:07.012345] } iex&gt; Time . from_iso8601 ( &quot;23:50:07.0123456&quot; ) { :ok , ~T[23:50:07.012345] } iex&gt; Time . from_iso8601 ( &quot;23:50:07.123Z&quot; ) { :ok , ~T[23:50:07.123] } iex&gt; Time . from_iso8601 ( &quot;2015:01:23 23-50-07&quot; ) { :error , :invalid_format } iex&gt; Time . from_iso8601 ( &quot;23:50:07A&quot; ) { :error , :invalid_format } iex&gt; Time . from_iso8601 ( &quot;23:50:07.&quot; ) { :error , :invalid_format } iex&gt; Time . from_iso8601 ( &quot;23:50:61&quot; ) { :error , :invalid_time }","ref":"Time.html#from_iso8601/2","title":"Time.from_iso8601/2","type":"function"},{"doc":"Parses the extended &quot;Local time&quot; format described by ISO 8601:2019 . Raises if the format is invalid. Examples iex&gt; Time . from_iso8601! ( &quot;23:50:07,123Z&quot; ) ~T[23:50:07.123] iex&gt; Time . from_iso8601! ( &quot;23:50:07.123Z&quot; ) ~T[23:50:07.123] iex&gt; Time . from_iso8601! ( &quot;2015:01:23 23-50-07&quot; ) ** (ArgumentError) cannot parse &quot;2015:01:23 23-50-07&quot; as time, reason: :invalid_format","ref":"Time.html#from_iso8601!/2","title":"Time.from_iso8601!/2","type":"function"},{"doc":"Converts a number of seconds after midnight to a Time struct. Examples iex&gt; Time . from_seconds_after_midnight ( 10_000 ) ~T[02:46:40] iex&gt; Time . from_seconds_after_midnight ( 30_000 , { 5000 , 3 } ) ~T[08:20:00.005] iex&gt; Time . from_seconds_after_midnight ( - 1 ) ~T[23:59:59] iex&gt; Time . from_seconds_after_midnight ( 100_000 ) ~T[03:46:40]","ref":"Time.html#from_seconds_after_midnight/3","title":"Time.from_seconds_after_midnight/3","type":"function"},{"doc":"Builds a new time. Expects all values to be integers. Returns {:ok, time} if each entry fits its appropriate range, returns {:error, reason} otherwise. Microseconds can also be given with a precision, which must be an integer between 0 and 6. The built-in calendar does not support leap seconds. Examples iex&gt; Time . new ( 0 , 0 , 0 , 0 ) { :ok , ~T[00:00:00.000000] } iex&gt; Time . new ( 23 , 59 , 59 , 999_999 ) { :ok , ~T[23:59:59.999999] } iex&gt; Time . new ( 24 , 59 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; Time . new ( 23 , 60 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; Time . new ( 23 , 59 , 60 , 999_999 ) { :error , :invalid_time } iex&gt; Time . new ( 23 , 59 , 59 , 1_000_000 ) { :error , :invalid_time } # Invalid precision Time . new ( 23 , 59 , 59 , { 999_999 , 10 } ) { :error , :invalid_time }","ref":"Time.html#new/5","title":"Time.new/5","type":"function"},{"doc":"Builds a new time. Expects all values to be integers. Returns time if each entry fits its appropriate range, raises if the time is invalid. Microseconds can also be given with a precision, which must be an integer between 0 and 6. The built-in calendar does not support leap seconds. Examples iex&gt; Time . new! ( 0 , 0 , 0 , 0 ) ~T[00:00:00.000000] iex&gt; Time . new! ( 23 , 59 , 59 , 999_999 ) ~T[23:59:59.999999] iex&gt; Time . new! ( 24 , 59 , 59 , 999_999 ) ** (ArgumentError) cannot build time, reason: :invalid_time","ref":"Time.html#new!/5","title":"Time.new!/5","type":"function"},{"doc":"Converts given time to an Erlang time tuple. WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds. Examples iex&gt; Time . to_erl ( ~T[23:30:15.999] ) { 23 , 30 , 15 } iex&gt; Time . to_erl ( ~N[2010-04-17 23:30:15.999] ) { 23 , 30 , 15 }","ref":"Time.html#to_erl/1","title":"Time.to_erl/1","type":"function"},{"doc":"Converts the given time to ISO 8601:2019 . By default, Time.to_iso8601/2 returns times formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Examples iex&gt; Time . to_iso8601 ( ~T[23:00:13] ) &quot;23:00:13&quot; iex&gt; Time . to_iso8601 ( ~T[23:00:13.001] ) &quot;23:00:13.001&quot; iex&gt; Time . to_iso8601 ( ~T[23:00:13.001] , :basic ) &quot;230013.001&quot; iex&gt; Time . to_iso8601 ( ~N[2010-04-17 23:00:13] ) &quot;23:00:13&quot;","ref":"Time.html#to_iso8601/2","title":"Time.to_iso8601/2","type":"function"},{"doc":"Converts a Time struct to a number of seconds after midnight. The returned value is a two-element tuple with the number of seconds and microseconds. Examples iex&gt; Time . to_seconds_after_midnight ( ~T[23:30:15] ) { 84615 , 0 } iex&gt; Time . to_seconds_after_midnight ( ~N[2010-04-17 23:30:15.999] ) { 84615 , 999000 }","ref":"Time.html#to_seconds_after_midnight/1","title":"Time.to_seconds_after_midnight/1","type":"function"},{"doc":"Converts the given time to a string. Examples iex&gt; Time . to_string ( ~T[23:00:00] ) &quot;23:00:00&quot; iex&gt; Time . to_string ( ~T[23:00:00.001] ) &quot;23:00:00.001&quot; iex&gt; Time . to_string ( ~T[23:00:00.123456] ) &quot;23:00:00.123456&quot; iex&gt; Time . to_string ( ~N[2015-01-01 23:00:00.001] ) &quot;23:00:00.001&quot; iex&gt; Time . to_string ( ~N[2015-01-01 23:00:00.123456] ) &quot;23:00:00.123456&quot;","ref":"Time.html#to_string/1","title":"Time.to_string/1","type":"function"},{"doc":"Returns the given time with the microsecond field truncated to the given precision ( :microsecond , millisecond or :second ). The given time is returned unchanged if it already has lower precision than the given precision. Examples iex&gt; Time . truncate ( ~T[01:01:01.123456] , :microsecond ) ~T[01:01:01.123456] iex&gt; Time . truncate ( ~T[01:01:01.123456] , :millisecond ) ~T[01:01:01.123] iex&gt; Time . truncate ( ~T[01:01:01.123456] , :second ) ~T[01:01:01]","ref":"Time.html#truncate/2","title":"Time.truncate/2","type":"function"},{"doc":"Returns the current time in UTC. Examples iex&gt; time = Time . utc_now ( ) iex&gt; time . hour &gt;= 0 true","ref":"Time.html#utc_now/1","title":"Time.utc_now/1","type":"function"},{"doc":"","ref":"Time.html#t:t/0","title":"Time.t/0","type":"type"},{"doc":"Functions for working with tuples. Please note the following functions for tuples are found in Kernel : elem/2 - accesses a tuple by index put_elem/3 - inserts a value into a tuple by index tuple_size/1 - gets the number of elements in a tuple Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. Enum functions do not work on tuples. Tuples are denoted with curly braces: iex&gt; { } { } iex&gt; { 1 , :two , &quot;three&quot; } { 1 , :two , &quot;three&quot; } A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals. Tuples are typically used either when a function has multiple return values or for error handling. File.read/1 returns {:ok, contents} if reading the given file is successful, or else {:error, reason} such as when the file does not exist. The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple: tuple = { :ok , :example } # Avoid result = Tuple . insert_at ( tuple , 2 , %{ } ) # Prefer { :ok , atom } = tuple result = { :ok , atom , %{ } }","ref":"Tuple.html","title":"Tuple","type":"module"},{"doc":"Inserts an element at the end of a tuple. Returns a new tuple with the element appended at the end, and contains the elements in tuple followed by value as the last element. Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar } iex&gt; Tuple . append ( tuple , :baz ) { :foo , :bar , :baz }","ref":"Tuple.html#append/2","title":"Tuple.append/2","type":"function"},{"doc":"Removes an element from a tuple. Deletes the element at the given index from tuple . Raises an ArgumentError if index is negative or greater than or equal to the length of tuple . Index is zero-based. Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar , :baz } iex&gt; Tuple . delete_at ( tuple , 0 ) { :bar , :baz }","ref":"Tuple.html#delete_at/2","title":"Tuple.delete_at/2","type":"function"},{"doc":"Creates a new tuple. Creates a tuple of size containing the given data at every position. Inlined by the compiler. Examples iex&gt; Tuple . duplicate ( :hello , 3 ) { :hello , :hello , :hello }","ref":"Tuple.html#duplicate/2","title":"Tuple.duplicate/2","type":"function"},{"doc":"Inserts an element into a tuple. Inserts value into tuple at the given index . Raises an ArgumentError if index is negative or greater than the length of tuple . Index is zero-based. Inlined by the compiler. Examples iex&gt; tuple = { :bar , :baz } iex&gt; Tuple . insert_at ( tuple , 0 , :foo ) { :foo , :bar , :baz } iex&gt; Tuple . insert_at ( tuple , 2 , :bong ) { :bar , :baz , :bong }","ref":"Tuple.html#insert_at/3","title":"Tuple.insert_at/3","type":"function"},{"doc":"Computes a product of tuple elements. Examples iex&gt; Tuple . product ( { 255 , 255 } ) 65025 iex&gt; Tuple . product ( { 255 , 1.0 } ) 255.0 iex&gt; Tuple . product ( { } ) 1","ref":"Tuple.html#product/1","title":"Tuple.product/1","type":"function"},{"doc":"Computes a sum of tuple elements. Examples iex&gt; Tuple . sum ( { 255 , 255 } ) 510 iex&gt; Tuple . sum ( { 255 , 0.0 } ) 255.0 iex&gt; Tuple . sum ( { } ) 0","ref":"Tuple.html#sum/1","title":"Tuple.sum/1","type":"function"},{"doc":"Converts a tuple to a list. Returns a new list with all the tuple elements. Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar , :baz } iex&gt; Tuple . to_list ( tuple ) [ :foo , :bar , :baz ]","ref":"Tuple.html#to_list/1","title":"Tuple.to_list/1","type":"function"},{"doc":"Utilities for working with URIs. This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to RFC 3986 .","ref":"URI.html","title":"URI","type":"module"},{"doc":"Checks if character is a reserved one in a URI. As specified in RFC 3986, section 2.2 , the following characters are reserved: : , / , ? , # , [ , ] , @ , ! , $ , &amp; , ' , ( , ) , * , + , , , ; , = Examples iex&gt; URI . char_reserved? ( ?+ ) true","ref":"URI.html#char_reserved?/1","title":"URI.char_reserved?/1","type":"function"},{"doc":"Checks if character is allowed unescaped in a URI. This is the default used by URI.encode/2 where both reserved and unreserved characters are kept unescaped. Examples iex&gt; URI . char_unescaped? ( ?{ ) false","ref":"URI.html#char_unescaped?/1","title":"URI.char_unescaped?/1","type":"function"},{"doc":"Checks if character is an unreserved one in a URI. As specified in RFC 3986, section 2.3 , the following characters are unreserved: Alphanumeric characters: A-Z , a-z , 0-9 ~ , _ , - , . Examples iex&gt; URI . char_unreserved? ( ?_ ) true","ref":"URI.html#char_unreserved?/1","title":"URI.char_unreserved?/1","type":"function"},{"doc":"Percent-unescapes a URI. Examples iex&gt; URI . decode ( &quot;https%3A%2F%2Felixir-lang.org&quot; ) &quot;https://elixir-lang.org&quot;","ref":"URI.html#decode/1","title":"URI.decode/1","type":"function"},{"doc":"Decodes query into a map. Given a query string in the form of key1=value1&amp;key2=value2... , this function inserts each key-value pair in the query string as one entry in the given map . Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped. You can specify one of the following encoding options: :www_form - (default, since v1.12.0) keys and values are decoded as per decode_www_form/1 . This is the format typically used by browsers on query strings and form data. It decodes &quot;+&quot; as &quot; &quot;. :rfc3986 - (since v1.12.0) keys and values are decoded as per decode/1 . The result is the same as :www_form except for leaving &quot;+&quot; as is in line with RFC 3986 . Encoding defaults to :www_form for backward compatibility. Use query_decoder/1 if you want to iterate over each value manually. Examples iex&gt; URI . decode_query ( &quot;foo=1&amp;bar=2&quot; ) %{ &quot;bar&quot; = &gt; &quot;2&quot; , &quot;foo&quot; = &gt; &quot;1&quot; } iex&gt; URI . decode_query ( &quot;percent=oh+yes%21&quot; , %{ &quot;starting&quot; = &gt; &quot;map&quot; } ) %{ &quot;percent&quot; = &gt; &quot;oh yes!&quot; , &quot;starting&quot; = &gt; &quot;map&quot; } iex&gt; URI . decode_query ( &quot;percent=oh+yes%21&quot; , %{ } , :rfc3986 ) %{ &quot;percent&quot; = &gt; &quot;oh+yes!&quot; }","ref":"URI.html#decode_query/3","title":"URI.decode_query/3","type":"function"},{"doc":"Decodes string as &quot;x-www-form-urlencoded&quot;. Note &quot;x-www-form-urlencoded&quot; is not specified as part of RFC 3986. However, it is a commonly used format to encode query strings and form data by browsers. Examples iex&gt; URI . decode_www_form ( &quot;%3Call+in%2F&quot; ) &quot;&lt;all in/&quot;","ref":"URI.html#decode_www_form/1","title":"URI.decode_www_form/1","type":"function"},{"doc":"Returns the default port for a given scheme . If the scheme is unknown to the URI module, this function returns nil . The default port for any scheme can be configured globally via default_port/2 . Examples iex&gt; URI . default_port ( &quot;ftp&quot; ) 21 iex&gt; URI . default_port ( &quot;ponzi&quot; ) nil","ref":"URI.html#default_port/1","title":"URI.default_port/1","type":"function"},{"doc":"Registers the default port for the given scheme . After this function is called, port will be returned by default_port/1 for the given scheme scheme . Note that this function changes the default port for the given scheme globally , meaning for every application. It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.","ref":"URI.html#default_port/2","title":"URI.default_port/2","type":"function"},{"doc":"Percent-escapes all characters that require escaping in string . This means reserved characters, such as : and / , and the so-called unreserved characters, which have the same meaning both escaped and unescaped, won't be escaped by default. See encode_www_form/1 if you are interested in escaping reserved characters too. This function also accepts a predicate function as an optional argument. If passed, this function will be called with each byte in string as its argument and should return a truthy value (anything other than false or nil ) if the given byte should be left as is, or return a falsy value ( false or nil ) if the character should be escaped. Defaults to URI.char_unescaped?/1 . Examples iex&gt; URI . encode ( &quot;ftp://s-ite.tld/?value=put it+й&quot; ) &quot;ftp://s-ite.tld/?value=put%20it+%D0%B9&quot; iex&gt; URI . encode ( &quot;a string&quot; , &amp; ( &amp;1 != ?i ) ) &quot;a str%69ng&quot;","ref":"URI.html#encode/2","title":"URI.encode/2","type":"function"},{"doc":"Encodes enumerable into a query string using encoding . Takes an enumerable that enumerates as a list of two-element tuples (for instance, a map or a keyword list) and returns a string in the form of key1=value1&amp;key2=value2... . Keys and values can be any term that implements the String.Chars protocol with the exception of lists, which are explicitly forbidden. You can specify one of the following encoding strategies: :www_form - (default, since v1.12.0) keys and values are URL encoded as per encode_www_form/1 . This is the format typically used by browsers on query strings and form data. It encodes &quot; &quot; as &quot;+&quot;. :rfc3986 - (since v1.12.0) the same as :www_form except it encodes &quot; &quot; as &quot;%20&quot; according RFC 3986 . This is the best option if you are encoding in a non-browser situation, since encoding spaces as &quot;+&quot; can be ambiguous to URI parsers. This can inadvertently lead to spaces being interpreted as literal plus signs. Encoding defaults to :www_form for backward compatibility. Examples iex&gt; query = %{ &quot;foo&quot; = &gt; 1 , &quot;bar&quot; = &gt; 2 } iex&gt; URI . encode_query ( query ) &quot;bar=2&amp;foo=1&quot; iex&gt; query = %{ &quot;key&quot; = &gt; &quot;value with spaces&quot; } iex&gt; URI . encode_query ( query ) &quot;key=value+with+spaces&quot; iex&gt; query = %{ &quot;key&quot; = &gt; &quot;value with spaces&quot; } iex&gt; URI . encode_query ( query , :rfc3986 ) &quot;key=value%20with%20spaces&quot; iex&gt; URI . encode_query ( %{ key : [ :a , :list ] } ) ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]","ref":"URI.html#encode_query/2","title":"URI.encode_query/2","type":"function"},{"doc":"Encodes string as &quot;x-www-form-urlencoded&quot;. Note &quot;x-www-form-urlencoded&quot; is not specified as part of RFC 3986. However, it is a commonly used format to encode query strings and form data by browsers. Example iex&gt; URI . encode_www_form ( &quot;put: it+й&quot; ) &quot;put%3A+it%2B%D0%B9&quot;","ref":"URI.html#encode_www_form/1","title":"URI.encode_www_form/1","type":"function"},{"doc":"Merges two URIs. This function merges two URIs as per RFC 3986, section 5.2 . Examples iex&gt; URI . merge ( URI . parse ( &quot;http://google.com&quot; ) , &quot;/query&quot; ) |&gt; to_string ( ) &quot;http://google.com/query&quot; iex&gt; URI . merge ( &quot;http://example.com&quot; , &quot;http://google.com&quot; ) |&gt; to_string ( ) &quot;http://google.com&quot;","ref":"URI.html#merge/2","title":"URI.merge/2","type":"function"},{"doc":"Parses a well-formed URI reference into its components. Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how URI.parse/1 can be used to parse a wide range of URIs. This function uses the parsing regular expression as defined in RFC 3986, Appendix B . When a URI is given without a port, the value returned by URI.default_port/1 for the URI's scheme is used for the :port field. If a %URI{} struct is given to this function, this function returns it unmodified. Examples iex&gt; URI . parse ( &quot;https://elixir-lang.org/&quot; ) % URI { authority : &quot;elixir-lang.org&quot; , fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : 443 , query : nil , scheme : &quot;https&quot; , userinfo : nil } iex&gt; URI . parse ( &quot;//elixir-lang.org/&quot; ) % URI { authority : &quot;elixir-lang.org&quot; , fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } iex&gt; URI . parse ( &quot;/foo/bar&quot; ) % URI { authority : nil , fragment : nil , host : nil , path : &quot;/foo/bar&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } iex&gt; URI . parse ( &quot;foo/bar&quot; ) % URI { authority : nil , fragment : nil , host : nil , path : &quot;foo/bar&quot; , port : nil , query : nil , scheme : nil , userinfo : nil }","ref":"URI.html#parse/1","title":"URI.parse/1","type":"function"},{"doc":"Returns a stream of two-element tuples representing key-value pairs in the given query . Key and value in each tuple will be binaries and will be percent-unescaped. You can specify one of the following encoding options: :www_form - (default, since v1.12.0) keys and values are decoded as per decode_www_form/1 . This is the format typically used by browsers on query strings and form data. It decodes &quot;+&quot; as &quot; &quot;. :rfc3986 - (since v1.12.0) keys and values are decoded as per decode/1 . The result is the same as :www_form except for leaving &quot;+&quot; as is in line with RFC 3986 . Encoding defaults to :www_form for backward compatibility. Examples iex&gt; URI . query_decoder ( &quot;foo=1&amp;bar=2&quot; ) |&gt; Enum . to_list ( ) [ { &quot;foo&quot; , &quot;1&quot; } , { &quot;bar&quot; , &quot;2&quot; } ] iex&gt; URI . query_decoder ( &quot;food=bread%26butter&amp;drinks=tap%20water+please&quot; ) |&gt; Enum . to_list ( ) [ { &quot;food&quot; , &quot;bread&amp;butter&quot; } , { &quot;drinks&quot; , &quot;tap water please&quot; } ] iex&gt; URI . query_decoder ( &quot;food=bread%26butter&amp;drinks=tap%20water+please&quot; , :rfc3986 ) |&gt; Enum . to_list ( ) [ { &quot;food&quot; , &quot;bread&amp;butter&quot; } , { &quot;drinks&quot; , &quot;tap water+please&quot; } ]","ref":"URI.html#query_decoder/2","title":"URI.query_decoder/2","type":"function"},{"doc":"Returns the string representation of the given URI struct . Examples iex&gt; uri = URI . parse ( &quot;http://google.com&quot; ) iex&gt; URI . to_string ( uri ) &quot;http://google.com&quot; iex&gt; uri = URI . parse ( &quot;foo://bar.baz&quot; ) iex&gt; URI . to_string ( uri ) &quot;foo://bar.baz&quot; Note that when creating this string representation, the :authority value will be used if the :host is nil . Otherwise, the :userinfo , :host , and :port will be used. iex&gt; URI . to_string ( % URI { authority : &quot;foo@example.com:80&quot; } ) &quot;//foo@example.com:80&quot; iex&gt; URI . to_string ( % URI { userinfo : &quot;bar&quot; , host : &quot;example.org&quot; , port : 81 } ) &quot;//bar@example.org:81&quot; iex&gt; URI . to_string ( % URI { ...&gt; authority : &quot;foo@example.com:80&quot; , ...&gt; userinfo : &quot;bar&quot; , ...&gt; host : &quot;example.org&quot; , ...&gt; port : 81 ...&gt; } ) &quot;//bar@example.org:81&quot;","ref":"URI.html#to_string/1","title":"URI.to_string/1","type":"function"},{"doc":"","ref":"URI.html#t:t/0","title":"URI.t/0","type":"type"},{"doc":"Functions for parsing and matching versions against requirements. A version is a string in a specific format or a Version generated after parsing via Version.parse/1 . Although Elixir projects are not required to follow SemVer, they must follow the format outlined on SemVer 2.0 schema . Versions In a nutshell, a version is represented by three numbers: MAJOR.MINOR.PATCH Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens ( [0-9A-Za-z-] ): &quot;1.0.0-alpha.3&quot; Build information can be added by appending a plus sign and a series of dot-separated identifiers immediately following the patch or pre-release version. Identifiers consist of only ASCII alphanumeric characters and hyphens ( [0-9A-Za-z-] ): &quot;1.0.0-alpha.3+20130417140000.amd64&quot; Struct The version is represented by the Version struct and fields are named according to SemVer 2.0: :major , :minor , :patch , :pre , and :build . Requirements Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as &gt; , &gt;= , &lt; , &lt;= , == , != that work as one would expect, and additionally the special operator ~&gt; described in detail further below. # Only version 2.0.0 &quot;== 2.0.0&quot; # Anything later than 2.0.0 &quot;&gt; 2.0.0&quot; Requirements also support and and or for complex conditions: # 2.0.0 and later until 2.1.0 &quot;&gt;= 2.0.0 and &lt; 2.1.0&quot; Since the example above is such a common requirement, it can be expressed as: &quot;~&gt; 2.0.0&quot; ~&gt; will never include pre-release versions of its upper bound, regardless of the usage of the :allow_pre option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for ~&gt; requirements and their corresponding translations. ~&gt; Translation ~&gt; 2.0.0 &gt;= 2.0.0 and &lt; 2.1.0 ~&gt; 2.1.2 &gt;= 2.1.2 and &lt; 2.2.0 ~&gt; 2.1.3-dev &gt;= 2.1.3-dev and &lt; 2.2.0 ~&gt; 2.0 &gt;= 2.0.0 and &lt; 3.0.0 ~&gt; 2.1 &gt;= 2.1.0 and &lt; 3.0.0 The requirement operand after the ~&gt; is allowed to omit the patch version, allowing us to express ~&gt; 2.1 or ~&gt; 2.1-dev , something that wouldn't be allowed when using the common comparison operators. When the :allow_pre option is set false in Version.match?/3 , the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to always allow pre-releases but note that in Hex :allow_pre is set to false . See the table below for examples. Requirement Version :allow_pre Matches ~&gt; 2.0 2.1.0 true or false true ~&gt; 2.0 3.0.0 true or false false ~&gt; 2.0.0 2.0.5 true or false true ~&gt; 2.0.0 2.1.0 true or false false ~&gt; 2.1.2 2.1.6-dev true true ~&gt; 2.1.2 2.1.6-dev false false ~&gt; 2.1-dev 2.2.0-dev true or false true ~&gt; 2.1.2-dev 2.1.6-dev true or false true &gt;= 2.1.0 2.2.0-dev true true &gt;= 2.1.0 2.2.0-dev false false &gt;= 2.1.0-dev 2.2.6-dev true or false true","ref":"Version.html","title":"Version","type":"module"},{"doc":"Compares two versions. Returns :gt if the first version is greater than the second one, and :lt for vice versa. If the two versions are equal, :eq is returned. Pre-releases are strictly less than their corresponding release versions. Patch segments are compared lexicographically if they are alphanumeric, and numerically otherwise. Build segments are ignored: if two versions differ only in their build segment they are considered to be equal. Raises a Version.InvalidVersionError exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise. Examples iex&gt; Version . compare ( &quot;2.0.1-alpha1&quot; , &quot;2.0.0&quot; ) :gt iex&gt; Version . compare ( &quot;1.0.0-beta&quot; , &quot;1.0.0-rc1&quot; ) :lt iex&gt; Version . compare ( &quot;1.0.0-10&quot; , &quot;1.0.0-2&quot; ) :gt iex&gt; Version . compare ( &quot;2.0.1+build0&quot; , &quot;2.0.1&quot; ) :eq iex&gt; Version . compare ( &quot;invalid&quot; , &quot;2.0.1&quot; ) ** (Version.InvalidVersionError) invalid version: &quot;invalid&quot;","ref":"Version.html#compare/2","title":"Version.compare/2","type":"function"},{"doc":"Compiles a requirement to an internal representation that may optimize matching. The internal representation is opaque.","ref":"Version.html#compile_requirement/1","title":"Version.compile_requirement/1","type":"function"},{"doc":"Checks if the given version matches the specification. Returns true if version satisfies requirement , false otherwise. Raises a Version.InvalidRequirementError exception if requirement is not parsable, or a Version.InvalidVersionError exception if version is not parsable. If given an already parsed version and requirement this function won't raise. Options :allow_pre (boolean) - when false , pre-release versions will not match unless the operand is a pre-release version. Defaults to true . For examples, please refer to the table above under the &quot;Requirements&quot; section. Examples iex&gt; Version . match? ( &quot;2.0.0&quot; , &quot;&gt; 1.0.0&quot; ) true iex&gt; Version . match? ( &quot;2.0.0&quot; , &quot;== 1.0.0&quot; ) false iex&gt; Version . match? ( &quot;2.1.6-dev&quot; , &quot;~&gt; 2.1.2&quot; ) true iex&gt; Version . match? ( &quot;2.1.6-dev&quot; , &quot;~&gt; 2.1.2&quot; , allow_pre : false ) false iex&gt; Version . match? ( &quot;foo&quot; , &quot;== 1.0.0&quot; ) ** (Version.InvalidVersionError) invalid version: &quot;foo&quot; iex&gt; Version . match? ( &quot;2.0.0&quot; , &quot;== == 1.0.0&quot; ) ** (Version.InvalidRequirementError) invalid requirement: &quot;== == 1.0.0&quot;","ref":"Version.html#match?/3","title":"Version.match?/3","type":"function"},{"doc":"Parses a version string into a Version struct. Examples iex&gt; { :ok , version } = Version . parse ( &quot;2.0.1-alpha1&quot; ) iex&gt; version # Version &lt; 2.0 . 1 - alpha1 &gt; iex&gt; Version . parse ( &quot;2.0-alpha1&quot; ) :error","ref":"Version.html#parse/1","title":"Version.parse/1","type":"function"},{"doc":"Parses a version string into a Version . If string is an invalid version, a Version.InvalidVersionError is raised. Examples iex&gt; Version . parse! ( &quot;2.0.1-alpha1&quot; ) # Version &lt; 2.0 . 1 - alpha1 &gt; iex&gt; Version . parse! ( &quot;2.0-alpha1&quot; ) ** (Version.InvalidVersionError) invalid version: &quot;2.0-alpha1&quot;","ref":"Version.html#parse!/1","title":"Version.parse!/1","type":"function"},{"doc":"Parses a version requirement string into a Version.Requirement struct. Examples iex&gt; { :ok , requirement } = Version . parse_requirement ( &quot;== 2.0.1&quot; ) iex&gt; requirement # Version.Requirement &lt; == 2.0 . 1 &gt; iex&gt; Version . parse_requirement ( &quot;== == 2.0.1&quot; ) :error","ref":"Version.html#parse_requirement/1","title":"Version.parse_requirement/1","type":"function"},{"doc":"Parses a version requirement string into a Version.Requirement struct. If string is an invalid requirement, a Version.InvalidRequirementError is raised. Examples iex&gt; Version . parse_requirement! ( &quot;== 2.0.1&quot; ) # Version.Requirement &lt; == 2.0 . 1 &gt; iex&gt; Version . parse_requirement! ( &quot;== == 2.0.1&quot; ) ** (Version.InvalidRequirementError) invalid requirement: &quot;== == 2.0.1&quot;","ref":"Version.html#parse_requirement!/1","title":"Version.parse_requirement!/1","type":"function"},{"doc":"","ref":"Version.html#t:build/0","title":"Version.build/0","type":"type"},{"doc":"","ref":"Version.html#t:major/0","title":"Version.major/0","type":"type"},{"doc":"","ref":"Version.html#t:minor/0","title":"Version.minor/0","type":"type"},{"doc":"","ref":"Version.html#t:patch/0","title":"Version.patch/0","type":"type"},{"doc":"","ref":"Version.html#t:pre/0","title":"Version.pre/0","type":"type"},{"doc":"","ref":"Version.html#t:requirement/0","title":"Version.requirement/0","type":"type"},{"doc":"","ref":"Version.html#t:t/0","title":"Version.t/0","type":"type"},{"doc":"","ref":"Version.html#t:version/0","title":"Version.version/0","type":"type"},{"doc":"A struct that holds version requirement information. The struct fields are private and should not be accessed. See the &quot;Requirements&quot; section in the Version module for more information.","ref":"Version.Requirement.html","title":"Version.Requirement","type":"module"},{"doc":"","ref":"Version.Requirement.html#t:t/0","title":"Version.Requirement.t/0","type":"opaque"},{"doc":"Key-based access to data structures. The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax. Access supports keyword lists ( Keyword ) and maps ( Map ) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist: iex&gt; keywords = [ a : 1 , b : 2 ] iex&gt; keywords [ :a ] 1 iex&gt; keywords [ :c ] nil iex&gt; map = %{ a : 1 , b : 2 } iex&gt; map [ :a ] 1 iex&gt; star_ratings = %{ 1.0 = &gt; &quot;★&quot; , 1.5 = &gt; &quot;★☆&quot; , 2.0 = &gt; &quot;★★&quot; } iex&gt; star_ratings [ 1.5 ] &quot;★☆&quot; This syntax is very convenient as it can be nested arbitrarily: iex&gt; keywords = [ a : 1 , b : 2 ] iex&gt; keywords [ :c ] [ :unknown ] nil This works because accessing anything on a nil value, returns nil itself: iex&gt; nil [ :a ] nil The access syntax can also be used with the Kernel.put_in/2 , Kernel.update_in/2 and Kernel.get_and_update_in/2 macros to allow values to be set in nested data structures: iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] [ :age ] , 28 ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } Attention! While the access syntax is allowed in maps via map[key] , if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key] , as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined). Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax. See the Map module for more information. Nested data structures Both key-based access syntaxes can be used with the nested update functions and macros in Kernel , such as Kernel.get_in/2 , Kernel.put_in/3 , Kernel.update_in/3 , Kernel.pop_in/2 , and Kernel.get_and_update_in/3 . For example, to update a map inside another map: iex&gt; users = %{ &quot;john&quot; = &gt; %{ age : 27 } , &quot;meg&quot; = &gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] . age , 28 ) %{ &quot;john&quot; = &gt; %{ age : 28 } , &quot;meg&quot; = &gt; %{ age : 23 } } This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the Access -related functions and macros in Kernel . For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase: iex&gt; languages = [ ...&gt; %{ name : &quot;elixir&quot; , type : :functional } , ...&gt; %{ name : &quot;c&quot; , type : :procedural } ...&gt; ] iex&gt; user = %{ name : &quot;john&quot; , languages : languages } iex&gt; update_in ( user , [ :languages , Access . all ( ) , :name ] , &amp; String . upcase / 1 ) %{ name : &quot;john&quot; , languages : [ %{ name : &quot;ELIXIR&quot; , type : :functional } , %{ name : &quot;C&quot; , type : :procedural } ] } See the functions key/1 , key!/1 , elem/1 , and all/0 for some of the available accessors.","ref":"Access.html","title":"Access","type":"behaviour"},{"doc":"Returns a function that accesses all the elements in a list. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; get_in ( list , [ Access . all ( ) , :name ] ) [ &quot;john&quot; , &quot;mary&quot; ] iex&gt; get_and_update_in ( list , [ Access . all ( ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ &quot;john&quot; , &quot;mary&quot; ] , [ %{ name : &quot;JOHN&quot; } , %{ name : &quot;MARY&quot; } ] } iex&gt; pop_in ( list , [ Access . all ( ) , :name ] ) { [ &quot;john&quot; , &quot;mary&quot; ] , [ %{ } , %{ } ] } Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2: iex&gt; require Integer iex&gt; get_and_update_in ( [ 1 , 2 , 3 , 4 , 5 ] , [ Access . all ( ) ] , fn num -&gt; ...&gt; if Integer . is_even ( num ) , do : :pop , else : { num , num * 2 } ...&gt; end ) { [ 1 , 2 , 3 , 4 , 5 ] , [ 2 , 6 , 10 ] } An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . all ( ) ] ) ** (RuntimeError) Access.all/0 expected a list, got: %{}","ref":"Access.html#all/0","title":"Access.all/0","type":"function"},{"doc":"Returns a function that accesses the element at index (zero based) of a list. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; get_in ( list , [ Access . at ( 1 ) , :name ] ) &quot;mary&quot; iex&gt; get_in ( list , [ Access . at ( - 1 ) , :name ] ) &quot;mary&quot; iex&gt; get_and_update_in ( list , [ Access . at ( 0 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , [ %{ name : &quot;JOHN&quot; } , %{ name : &quot;mary&quot; } ] } iex&gt; get_and_update_in ( list , [ Access . at ( - 1 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;mary&quot; , [ %{ name : &quot;john&quot; } , %{ name : &quot;MARY&quot; } ] } at/1 can also be used to pop elements out of a list or a key inside of a list: iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; pop_in ( list , [ Access . at ( 0 ) ] ) { %{ name : &quot;john&quot; } , [ %{ name : &quot;mary&quot; } ] } iex&gt; pop_in ( list , [ Access . at ( 0 ) , :name ] ) { &quot;john&quot; , [ %{ } , %{ name : &quot;mary&quot; } ] } When the index is out of bounds, nil is returned and the update function is never called: iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; get_in ( list , [ Access . at ( 10 ) , :name ] ) nil iex&gt; get_and_update_in ( list , [ Access . at ( 10 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { nil , [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] } An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . at ( 1 ) ] ) ** (RuntimeError) Access.at/1 expected a list, got: %{}","ref":"Access.html#at/1","title":"Access.at/1","type":"function"},{"doc":"Same as at/1 except that it raises Enum.OutOfBoundsError if the given index is out of bounds. Examples iex&gt; get_in ( [ :a , :b , :c ] , [ Access . at! ( 2 ) ] ) :c iex&gt; get_in ( [ :a , :b , :c ] , [ Access . at! ( 3 ) ] ) ** (Enum.OutOfBoundsError) out of bounds error","ref":"Access.html#at!/1","title":"Access.at!/1","type":"function"},{"doc":"Returns a function that accesses the element at the given index in a tuple. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. The returned function raises if index is out of bounds. Note that popping elements out of tuples is not possible and raises an error. Examples iex&gt; map = %{ user : { &quot;john&quot; , 27 } } iex&gt; get_in ( map , [ :user , Access . elem ( 0 ) ] ) &quot;john&quot; iex&gt; get_and_update_in ( map , [ :user , Access . elem ( 0 ) ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , %{ user : { &quot;JOHN&quot; , 27 } } } iex&gt; pop_in ( map , [ :user , Access . elem ( 0 ) ] ) ** (RuntimeError) cannot pop data from a tuple An error is raised if the accessed structure is not a tuple: iex&gt; get_in ( %{ } , [ Access . elem ( 0 ) ] ) ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}","ref":"Access.html#elem/1","title":"Access.elem/1","type":"function"},{"doc":"Fetches the value for the given key in a container (a map, keyword list, or struct that implements the Access behaviour). Returns {:ok, value} where value is the value under key if there is such a key, or :error if key is not found. Examples iex&gt; Access . fetch ( %{ name : &quot;meg&quot; , age : 26 } , :name ) { :ok , &quot;meg&quot; } iex&gt; Access . fetch ( [ ordered : true , on_timeout : :exit ] , :timeout ) :error","ref":"Access.html#fetch/2","title":"Access.fetch/2","type":"function"},{"doc":"Invoked in order to access the value stored under key in the given term term . This function should return {:ok, value} where value is the value under key if the key exists in the term, or :error if the key does not exist in the term. Many of the functions defined in the Access module internally call this function. This function is also used when the square-brackets access syntax ( structure[key] ) is used: the fetch/2 callback implemented by the module that defines the structure struct is invoked and if it returns {:ok, value} then value is returned, or if it returns :error then nil is returned. See the Map.fetch/2 and Keyword.fetch/2 implementations for examples of how to implement this callback.","ref":"Access.html#c:fetch/2","title":"Access.fetch/2","type":"callback"},{"doc":"Same as fetch/2 but returns the value directly, or raises a KeyError exception if key is not found. Examples iex&gt; Access . fetch! ( %{ name : &quot;meg&quot; , age : 26 } , :name ) &quot;meg&quot;","ref":"Access.html#fetch!/2","title":"Access.fetch!/2","type":"function"},{"doc":"Returns a function that accesses all elements of a list that match the provided predicate. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] iex&gt; get_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt; 20 ) ) , :name ] ) [ &quot;francine&quot; ] iex&gt; get_and_update_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &lt;= 20 ) ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ &quot;john&quot; ] , [ %{ name : &quot;JOHN&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] } filter/1 can also be used to pop elements out of a list or a key inside of a list: iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] iex&gt; pop_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 20 ) ) ] ) { [ %{ name : &quot;francine&quot; , salary : 30 } ] , [ %{ name : &quot;john&quot; , salary : 10 } ] } iex&gt; pop_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 20 ) ) , :name ] ) { [ &quot;francine&quot; ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ salary : 30 } ] } When no match is found, an empty list is returned and the update function is never called iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] iex&gt; get_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 50 ) ) , :name ] ) [ ] iex&gt; get_and_update_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 50 ) ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] } An error is raised if the predicate is not a function or is of the incorrect arity: iex&gt; get_in ( [ ] , [ Access . filter ( 5 ) ] ) ** (FunctionClauseError) no function clause matching in Access.filter/1 An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . filter ( fn a -&gt; a == 10 end ) ] ) ** (RuntimeError) Access.filter/1 expected a list, got: %{}","ref":"Access.html#filter/1","title":"Access.filter/1","type":"function"},{"doc":"Gets the value for the given key in a container (a map, keyword list, or struct that implements the Access behaviour). Returns the value under key if there is such a key, or default if key is not found. Examples iex&gt; Access . get ( %{ name : &quot;john&quot; } , :name , &quot;default name&quot; ) &quot;john&quot; iex&gt; Access . get ( %{ name : &quot;john&quot; } , :age , 25 ) 25 iex&gt; Access . get ( [ ordered : true ] , :timeout ) nil","ref":"Access.html#get/3","title":"Access.get/3","type":"function"},{"doc":"Gets and updates the given key in a container (a map, a keyword list, a struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present in container ) and must return a two-element tuple {current_value, new_value} : the &quot;get&quot; value current_value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key ( new_value ). fun may also return :pop , which means the current value should be removed from the container and returned. The returned value is a two-element tuple with the &quot;get&quot; value returned by fun and a new container with the updated value under key . Examples iex&gt; Access . get_and_update ( [ a : 1 ] , :a , fn current_value -&gt; ...&gt; { current_value , current_value + 1 } ...&gt; end ) { 1 , [ a : 2 ] }","ref":"Access.html#get_and_update/3","title":"Access.get_and_update/3","type":"function"},{"doc":"Invoked in order to access the value under key and update it at the same time. The implementation of this callback should invoke fun with the value under key in the passed structure data , or with nil if key is not present in it. This function must return either {current_value, new_value} or :pop . If the passed function returns {current_value, new_value} , the return value of this callback should be {current_value, new_data} , where: current_value is the retrieved value (which can be operated on before being returned) new_value is the new value to be stored under key new_data is data after updating the value of key with new_value . If the passed function returns :pop , the return value of this callback must be {value, new_data} where value is the value under key (or nil if not present) and new_data is data without key . See the implementations of Map.get_and_update/3 or Keyword.get_and_update/3 for more examples.","ref":"Access.html#c:get_and_update/3","title":"Access.get_and_update/3","type":"callback"},{"doc":"Returns a function that accesses the given key in a map/struct. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys: iex&gt; get_in ( %{ } , [ Access . key ( :user , %{ } ) , Access . key ( :name , &quot;meg&quot; ) ] ) &quot;meg&quot; Such is also useful when using update functions, allowing us to introduce values as we traverse the data structure for updates: iex&gt; put_in ( %{ } , [ Access . key ( :user , %{ } ) , Access . key ( :name ) ] , &quot;Mary&quot; ) %{ user : %{ name : &quot;Mary&quot; } } Examples iex&gt; map = %{ user : %{ name : &quot;john&quot; } } iex&gt; get_in ( map , [ Access . key ( :unknown , %{ } ) , Access . key ( :name , &quot;john&quot; ) ] ) &quot;john&quot; iex&gt; get_and_update_in ( map , [ Access . key ( :user ) , Access . key ( :name ) ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , %{ user : %{ name : &quot;JOHN&quot; } } } iex&gt; pop_in ( map , [ Access . key ( :user ) , Access . key ( :name ) ] ) { &quot;john&quot; , %{ user : %{ } } } An error is raised if the accessed structure is not a map or a struct: iex&gt; get_in ( nil , [ Access . key ( :foo ) ] ) ** (BadMapError) expected a map, got: nil iex&gt; get_in ( [ ] , [ Access . key ( :foo ) ] ) ** (BadMapError) expected a map, got: []","ref":"Access.html#key/2","title":"Access.key/2","type":"function"},{"doc":"Returns a function that accesses the given key in a map/struct. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Similar to key/2 , but the returned function raises if the key does not exist. Examples iex&gt; map = %{ user : %{ name : &quot;john&quot; } } iex&gt; get_in ( map , [ Access . key! ( :user ) , Access . key! ( :name ) ] ) &quot;john&quot; iex&gt; get_and_update_in ( map , [ Access . key! ( :user ) , Access . key! ( :name ) ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , %{ user : %{ name : &quot;JOHN&quot; } } } iex&gt; pop_in ( map , [ Access . key! ( :user ) , Access . key! ( :name ) ] ) { &quot;john&quot; , %{ user : %{ } } } iex&gt; get_in ( map , [ Access . key! ( :user ) , Access . key! ( :unknown ) ] ) ** (KeyError) key :unknown not found in: %{name: &quot;john&quot;} An error is raised if the accessed structure is not a map/struct: iex&gt; get_in ( [ ] , [ Access . key! ( :foo ) ] ) ** (RuntimeError) Access.key!/1 expected a map/struct, got: []","ref":"Access.html#key!/1","title":"Access.key!/1","type":"function"},{"doc":"Removes the entry with a given key from a container (a map, keyword list, or struct that implements the Access behaviour). Returns a tuple containing the value associated with the key and the updated container. nil is returned for the value if the key isn't in the container. Examples With a map: iex&gt; Access . pop ( %{ name : &quot;Elixir&quot; , creator : &quot;Valim&quot; } , :name ) { &quot;Elixir&quot; , %{ creator : &quot;Valim&quot; } } A keyword list: iex&gt; Access . pop ( [ name : &quot;Elixir&quot; , creator : &quot;Valim&quot; ] , :name ) { &quot;Elixir&quot; , [ creator : &quot;Valim&quot; ] } An unknown key: iex&gt; Access . pop ( %{ name : &quot;Elixir&quot; , creator : &quot;Valim&quot; } , :year ) { nil , %{ creator : &quot;Valim&quot; , name : &quot;Elixir&quot; } }","ref":"Access.html#pop/2","title":"Access.pop/2","type":"function"},{"doc":"Invoked to &quot;pop&quot; the value under key out of the given data structure. When key exists in the given structure data , the implementation should return a {value, new_data} tuple where value is the value that was under key and new_data is term without key . When key is not present in the given structure, a tuple {value, data} should be returned, where value is implementation-defined. See the implementations for Map.pop/3 or Keyword.pop/3 for more examples.","ref":"Access.html#c:pop/2","title":"Access.pop/2","type":"callback"},{"doc":"","ref":"Access.html#t:access_fun/2","title":"Access.access_fun/2","type":"type"},{"doc":"","ref":"Access.html#t:any_container/0","title":"Access.any_container/0","type":"type"},{"doc":"","ref":"Access.html#t:container/0","title":"Access.container/0","type":"type"},{"doc":"","ref":"Access.html#t:get_and_update_fun/2","title":"Access.get_and_update_fun/2","type":"type"},{"doc":"","ref":"Access.html#t:get_fun/1","title":"Access.get_fun/1","type":"type"},{"doc":"","ref":"Access.html#t:key/0","title":"Access.key/0","type":"type"},{"doc":"","ref":"Access.html#t:nil_container/0","title":"Access.nil_container/0","type":"type"},{"doc":"","ref":"Access.html#t:t/0","title":"Access.t/0","type":"type"},{"doc":"","ref":"Access.html#t:value/0","title":"Access.value/0","type":"type"},{"doc":"Returns an inclusive range between dates. Ranges must be created with the Date.range/2 or Date.range/3 function. The following fields are public: :first - the initial date on the range :last - the last date on the range :step - (since v1.12.0) the step The remaining fields are private and should not be accessed.","ref":"Date.Range.html","title":"Date.Range","type":"module"},{"doc":"","ref":"Date.Range.html#t:t/0","title":"Date.Range.t/0","type":"type"},{"doc":"Provides a set of algorithms to work with enumerables. In Elixir, an enumerable is any data type that implements the Enumerable protocol. List s ( [1, 2, 3] ), Map s ( %{foo: 1, bar: 2} ) and Range s ( 1..3 ) are common data types used as enumerables: iex&gt; Enum . map ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] iex&gt; Enum . sum ( [ 1 , 2 , 3 ] ) 6 iex&gt; Enum . map ( 1 . . 3 , fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] iex&gt; Enum . sum ( 1 . . 3 ) 6 iex&gt; map = %{ &quot;a&quot; = &gt; 1 , &quot;b&quot; = &gt; 2 } iex&gt; Enum . map ( map , fn { k , v } -&gt; { k , v * 2 } end ) [ { &quot;a&quot; , 2 } , { &quot;b&quot; , 4 } ] However, many other enumerables exist in the language, such as MapSet s and the data type returned by File.stream!/3 which allows a file to be traversed as if it was an enumerable. The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as Enum.map/2 . After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take. This linear behaviour should also be expected on operations like count/1 , member?/2 , at/2 and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the Enum module is meant to work with a large variety of data types and not all data types can provide optimized behaviour. Finally, note the functions in the Enum module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the Stream module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the Stream module for examples and documentation.","ref":"Enum.html","title":"Enum","type":"module"},{"doc":"Returns true if all elements in enumerable are truthy. When an element has a falsy value ( false or nil ) iteration stops immediately and false is returned. In all other cases true is returned. Examples iex&gt; Enum . all? ( [ 1 , 2 , 3 ] ) true iex&gt; Enum . all? ( [ 1 , nil , 3 ] ) false iex&gt; Enum . all? ( [ ] ) true","ref":"Enum.html#all?/1","title":"Enum.all?/1","type":"function"},{"doc":"Returns true if fun.(element) is truthy for all elements in enumerable . Iterates over enumerable and invokes fun on each element. If fun ever returns a falsy value ( false or nil ), iteration stops immediately and false is returned. Otherwise, true is returned. Examples iex&gt; Enum . all? ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) true iex&gt; Enum . all? ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) false iex&gt; Enum . all? ( [ ] , fn _ -&gt; nil end ) true As the last example shows, Enum.all?/2 returns true if enumerable is empty, regardless of fun . In an empty enumerable there is no element for which fun returns a falsy value, so the result must be true . This is a well-defined logical argument for empty collections.","ref":"Enum.html#all?/2","title":"Enum.all?/2","type":"function"},{"doc":"Returns true if at least one element in enumerable is truthy. When an element has a truthy value (neither false nor nil ) iteration stops immediately and true is returned. In all other cases false is returned. Examples iex&gt; Enum . any? ( [ false , false , false ] ) false iex&gt; Enum . any? ( [ false , true , false ] ) true iex&gt; Enum . any? ( [ ] ) false","ref":"Enum.html#any?/1","title":"Enum.any?/1","type":"function"},{"doc":"Returns true if fun.(element) is truthy for at least one element in enumerable . Iterates over the enumerable and invokes fun on each element. When an invocation of fun returns a truthy value (neither false nor nil ) iteration stops immediately and true is returned. In all other cases false is returned. Examples iex&gt; Enum . any? ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) false iex&gt; Enum . any? ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) true iex&gt; Enum . any? ( [ ] , fn x -&gt; x &gt; 0 end ) false","ref":"Enum.html#any?/2","title":"Enum.any?/2","type":"function"},{"doc":"Finds the element at the given index (zero-based). Returns default if index is out of bounds. A negative index can be passed, which means the enumerable is enumerated once and the index is counted from the end (for example, -1 finds the last element). Examples iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 0 ) 2 iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 2 ) 6 iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 4 ) nil iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 4 , :none ) :none","ref":"Enum.html#at/3","title":"Enum.at/3","type":"function"},{"doc":"Splits enumerable on every element for which fun returns a new value. Returns a list of lists. Examples iex&gt; Enum . chunk_by ( [ 1 , 2 , 2 , 3 , 4 , 4 , 6 , 7 , 7 ] , &amp; ( rem ( &amp;1 , 2 ) == 1 ) ) [ [ 1 ] , [ 2 , 2 ] , [ 3 ] , [ 4 , 4 , 6 ] , [ 7 , 7 ] ]","ref":"Enum.html#chunk_by/2","title":"Enum.chunk_by/2","type":"function"},{"doc":"Shortcut to chunk_every(enumerable, count, count) .","ref":"Enum.html#chunk_every/2","title":"Enum.chunk_every/2","type":"function"},{"doc":"Returns list of lists containing count elements each, where each new chunk starts step elements into the enumerable . step is optional and, if not passed, defaults to count , i.e. chunks do not overlap. If the last chunk does not have count elements to fill the chunk, elements are taken from leftover to fill in the chunk. If leftover does not have enough elements to fill the chunk, then a partial chunk is returned with less than count elements. If :discard is given in leftover , the last chunk is discarded unless it has exactly count elements. Examples iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 2 ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , :discard ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , [ 7 ] ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] , [ 5 , 6 , 7 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 ] , 3 , 3 , [ ] ) [ [ 1 , 2 , 3 ] , [ 4 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 ] , 10 ) [ [ 1 , 2 , 3 , 4 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 ] , 2 , 3 , [ ] ) [ [ 1 , 2 ] , [ 4 , 5 ] ]","ref":"Enum.html#chunk_every/4","title":"Enum.chunk_every/4","type":"function"},{"doc":"Chunks the enumerable with fine grained control when every chunk is emitted. chunk_fun receives the current element and the accumulator and must return: {:cont, chunk, acc} to emit a chunk and continue with the accumulator {:cont, acc} to not emit any chunk and continue with the accumulator {:halt, acc} to halt chunking over the enumerable . after_fun is invoked with the final accumulator when iteration is finished (or halt ed) to handle any trailing elements that were returned as part of an accumulator, but were not emitted as a chunk by chunk_fun . It must return: {:cont, chunk, acc} to emit a chunk. The chunk will be appended to the list of already emitted chunks. {:cont, acc} to not emit a chunk The acc in after_fun is required in order to mirror the tuple format from chunk_fun but it will be discarded since the traversal is complete. Returns a list of emitted chunks. Examples iex&gt; chunk_fun = fn element , acc -&gt; ...&gt; if rem ( element , 2 ) == 0 do ...&gt; { :cont , Enum . reverse ( [ element | acc ] ) , [ ] } ...&gt; else ...&gt; { :cont , [ element | acc ] } ...&gt; end ...&gt; end iex&gt; after_fun = fn ...&gt; [ ] -&gt; { :cont , [ ] } ...&gt; acc -&gt; { :cont , Enum . reverse ( acc ) , [ ] } ...&gt; end iex&gt; Enum . chunk_while ( 1 . . 10 , [ ] , chunk_fun , after_fun ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] , [ 7 , 8 ] , [ 9 , 10 ] ] iex&gt; Enum . chunk_while ( [ 1 , 2 , 3 , 5 , 7 ] , [ ] , chunk_fun , after_fun ) [ [ 1 , 2 ] , [ 3 , 5 , 7 ] ]","ref":"Enum.html#chunk_while/4","title":"Enum.chunk_while/4","type":"function"},{"doc":"Given an enumerable of enumerables, concatenates the enumerables into a single list. Examples iex&gt; Enum . concat ( [ 1 . . 3 , 4 . . 6 , 7 . . 9 ] ) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] iex&gt; Enum . concat ( [ [ 1 , [ 2 ] , 3 ] , [ 4 ] , [ 5 , 6 ] ] ) [ 1 , [ 2 ] , 3 , 4 , 5 , 6 ]","ref":"Enum.html#concat/1","title":"Enum.concat/1","type":"function"},{"doc":"Concatenates the enumerable on the right with the enumerable on the left . This function produces the same result as the Kernel.++/2 operator for lists. Examples iex&gt; Enum . concat ( 1 . . 3 , 4 . . 6 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; Enum . concat ( [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) [ 1 , 2 , 3 , 4 , 5 , 6 ]","ref":"Enum.html#concat/2","title":"Enum.concat/2","type":"function"},{"doc":"Returns the size of the enumerable . Examples iex&gt; Enum . count ( [ 1 , 2 , 3 ] ) 3","ref":"Enum.html#count/1","title":"Enum.count/1","type":"function"},{"doc":"Returns the count of elements in the enumerable for which fun returns a truthy value. Examples iex&gt; Enum . count ( [ 1 , 2 , 3 , 4 , 5 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) 2","ref":"Enum.html#count/2","title":"Enum.count/2","type":"function"},{"doc":"Counts the enumerable stopping at limit . This is useful for checking certain properties of the count of an enumerable without having to actually count the entire enumerable. For example, if you wanted to check that the count was exactly, at least, or more than a value. If the enumerable implements Enumerable.count/1 , the enumerable is not traversed and we return the lower of the two numbers. To force enumeration, use count_until/3 with fn _ -&gt; true end as the second argument. Examples iex&gt; Enum . count_until ( 1 . . 20 , 5 ) 5 iex&gt; Enum . count_until ( 1 . . 20 , 50 ) 20 iex&gt; Enum . count_until ( 1 . . 10 , 10 ) == 10 # At least 10 true iex&gt; Enum . count_until ( 1 . . 11 , 10 + 1 ) &gt; 10 # More than 10 true iex&gt; Enum . count_until ( 1 . . 5 , 10 ) &lt; 10 # Less than 10 true iex&gt; Enum . count_until ( 1 . . 10 , 10 + 1 ) == 10 # Exactly ten true","ref":"Enum.html#count_until/2","title":"Enum.count_until/2","type":"function"},{"doc":"Counts the elements in the enumerable for which fun returns a truthy value, stopping at limit . See count/2 and count_until/3 for more information. Examples iex&gt; Enum . count_until ( 1 . . 20 , fn x -&gt; rem ( x , 2 ) == 0 end , 7 ) 7 iex&gt; Enum . count_until ( 1 . . 20 , fn x -&gt; rem ( x , 2 ) == 0 end , 11 ) 10","ref":"Enum.html#count_until/3","title":"Enum.count_until/3","type":"function"},{"doc":"Enumerates the enumerable , returning a list where all consecutive duplicated elements are collapsed to a single element. Elements are compared using ===/2 . If you want to remove all duplicated elements, regardless of order, see uniq/1 . Examples iex&gt; Enum . dedup ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) [ 1 , 2 , 3 , 2 , 1 ] iex&gt; Enum . dedup ( [ 1 , 1 , 2 , 2.0 , :three , :three ] ) [ 1 , 2 , 2.0 , :three ]","ref":"Enum.html#dedup/1","title":"Enum.dedup/1","type":"function"},{"doc":"Enumerates the enumerable , returning a list where all consecutive duplicated elements are collapsed to a single element. The function fun maps every element to a term which is used to determine if two elements are duplicates. Examples iex&gt; Enum . dedup_by ( [ { 1 , :a } , { 2 , :b } , { 2 , :c } , { 1 , :a } ] , fn { x , _ } -&gt; x end ) [ { 1 , :a } , { 2 , :b } , { 1 , :a } ] iex&gt; Enum . dedup_by ( [ 5 , 1 , 2 , 3 , 2 , 1 ] , fn x -&gt; x &gt; 2 end ) [ 5 , 1 , 3 , 2 ]","ref":"Enum.html#dedup_by/2","title":"Enum.dedup_by/2","type":"function"},{"doc":"Drops the amount of elements from the enumerable . If a negative amount is given, the amount of last values will be dropped. The enumerable will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end. Examples iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , 2 ) [ 3 ] iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , 10 ) [ ] iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , 0 ) [ 1 , 2 , 3 ] iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , - 1 ) [ 1 , 2 ]","ref":"Enum.html#drop/2","title":"Enum.drop/2","type":"function"},{"doc":"Returns a list of every nth element in the enumerable dropped, starting with the first element. The first element is always dropped, unless nth is 0. The second argument specifying every nth element must be a non-negative integer. Examples iex&gt; Enum . drop_every ( 1 . . 10 , 2 ) [ 2 , 4 , 6 , 8 , 10 ] iex&gt; Enum . drop_every ( 1 . . 10 , 0 ) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] iex&gt; Enum . drop_every ( [ 1 , 2 , 3 ] , 1 ) [ ]","ref":"Enum.html#drop_every/2","title":"Enum.drop_every/2","type":"function"},{"doc":"Drops elements at the beginning of the enumerable while fun returns a truthy value. Examples iex&gt; Enum . drop_while ( [ 1 , 2 , 3 , 2 , 1 ] , fn x -&gt; x &lt; 3 end ) [ 3 , 2 , 1 ]","ref":"Enum.html#drop_while/2","title":"Enum.drop_while/2","type":"function"},{"doc":"Invokes the given fun for each element in the enumerable . Returns :ok . Examples Enum . each ( [ &quot;some&quot; , &quot;example&quot; ] , fn x -&gt; IO . puts ( x ) end ) &quot;some&quot; &quot;example&quot; #=&gt; :ok","ref":"Enum.html#each/2","title":"Enum.each/2","type":"function"},{"doc":"Determines if the enumerable is empty. Returns true if enumerable is empty, otherwise false . Examples iex&gt; Enum . empty? ( [ ] ) true iex&gt; Enum . empty? ( [ 1 , 2 , 3 ] ) false","ref":"Enum.html#empty?/1","title":"Enum.empty?/1","type":"function"},{"doc":"Finds the element at the given index (zero-based). Returns {:ok, element} if found, otherwise :error . A negative index can be passed, which means the enumerable is enumerated once and the index is counted from the end (for example, -1 fetches the last element). Examples iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , 0 ) { :ok , 2 } iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , - 3 ) { :ok , 2 } iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , 2 ) { :ok , 6 } iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , 4 ) :error","ref":"Enum.html#fetch/2","title":"Enum.fetch/2","type":"function"},{"doc":"Finds the element at the given index (zero-based). Raises OutOfBoundsError if the given index is outside the range of the enumerable . Examples iex&gt; Enum . fetch! ( [ 2 , 4 , 6 ] , 0 ) 2 iex&gt; Enum . fetch! ( [ 2 , 4 , 6 ] , 2 ) 6 iex&gt; Enum . fetch! ( [ 2 , 4 , 6 ] , 4 ) ** (Enum.OutOfBoundsError) out of bounds error","ref":"Enum.html#fetch!/2","title":"Enum.fetch!/2","type":"function"},{"doc":"Filters the enumerable , i.e. returns only those elements for which fun returns a truthy value. See also reject/2 which discards all elements where the function returns a truthy value. Examples iex&gt; Enum . filter ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) [ 2 ] Keep in mind that filter is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using flat_map/2 . For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass: strings = [ &quot;1234&quot; , &quot;abc&quot; , &quot;12ab&quot; ] Enum . flat_map ( strings , fn string -&gt; case Integer . parse ( string ) do # transform to integer { int , _rest } -&gt; [ int ] # skip the value :error -&gt; [ ] end end )","ref":"Enum.html#filter/2","title":"Enum.filter/2","type":"function"},{"doc":"Returns the first element for which fun returns a truthy value. If no such element is found, returns default . Examples iex&gt; Enum . find ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) 3 iex&gt; Enum . find ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) nil iex&gt; Enum . find ( [ 2 , 4 , 6 ] , 0 , fn x -&gt; rem ( x , 2 ) == 1 end ) 0","ref":"Enum.html#find/3","title":"Enum.find/3","type":"function"},{"doc":"Similar to find/3 , but returns the index (zero-based) of the element instead of the element itself. Examples iex&gt; Enum . find_index ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) nil iex&gt; Enum . find_index ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) 1","ref":"Enum.html#find_index/2","title":"Enum.find_index/2","type":"function"},{"doc":"Similar to find/3 , but returns the value of the function invocation instead of the element itself. The return value is considered to be found when the result is truthy (neither nil nor false ). Examples iex&gt; Enum . find_value ( [ 2 , 3 , 4 ] , fn x -&gt; ...&gt; if x &gt; 2 , do : x * x ...&gt; end ) 9 iex&gt; Enum . find_value ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) nil iex&gt; Enum . find_value ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) true iex&gt; Enum . find_value ( [ 1 , 2 , 3 ] , &quot;no bools!&quot; , &amp; is_boolean / 1 ) &quot;no bools!&quot;","ref":"Enum.html#find_value/3","title":"Enum.find_value/3","type":"function"},{"doc":"Maps the given fun over enumerable and flattens the result. This function returns a new enumerable built by appending the result of invoking fun on each element of enumerable together; conceptually, this is similar to a combination of map/2 and concat/1 . Examples iex&gt; Enum . flat_map ( [ :a , :b , :c ] , fn x -&gt; [ x , x ] end ) [ :a , :a , :b , :b , :c , :c ] iex&gt; Enum . flat_map ( [ { 1 , 3 } , { 4 , 6 } ] , fn { x , y } -&gt; x . . y end ) [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; Enum . flat_map ( [ :a , :b , :c ] , fn x -&gt; [ [ x ] ] end ) [ [ :a ] , [ :b ] , [ :c ] ]","ref":"Enum.html#flat_map/2","title":"Enum.flat_map/2","type":"function"},{"doc":"Maps and reduces an enumerable , flattening the given results (only one level deep). It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with :halt as first element and the accumulator as second. Examples iex&gt; enumerable = 1 . . 100 iex&gt; n = 3 iex&gt; Enum . flat_map_reduce ( enumerable , 0 , fn x , acc -&gt; ...&gt; if acc &lt; n , do : { [ x ] , acc + 1 } , else : { :halt , acc } ...&gt; end ) { [ 1 , 2 , 3 ] , 3 } iex&gt; Enum . flat_map_reduce ( 1 . . 5 , 0 , fn x , acc -&gt; { [ [ x ] ] , acc + x } end ) { [ [ 1 ] , [ 2 ] , [ 3 ] , [ 4 ] , [ 5 ] ] , 15 }","ref":"Enum.html#flat_map_reduce/3","title":"Enum.flat_map_reduce/3","type":"function"},{"doc":"Returns a map with keys as unique elements of enumerable and values as the count of every element. Examples iex&gt; Enum . frequencies ( ~w{ant buffalo ant ant buffalo dingo} ) %{ &quot;ant&quot; = &gt; 3 , &quot;buffalo&quot; = &gt; 2 , &quot;dingo&quot; = &gt; 1 }","ref":"Enum.html#frequencies/1","title":"Enum.frequencies/1","type":"function"},{"doc":"Returns a map with keys as unique elements given by key_fun and values as the count of every element. Examples iex&gt; Enum . frequencies_by ( ~w{aa aA bb cc} , &amp; String . downcase / 1 ) %{ &quot;aa&quot; = &gt; 2 , &quot;bb&quot; = &gt; 1 , &quot;cc&quot; = &gt; 1 } iex&gt; Enum . frequencies_by ( ~w{aaa aA bbb cc c} , &amp; String . length / 1 ) %{ 3 = &gt; 2 , 2 = &gt; 2 , 1 = &gt; 1 }","ref":"Enum.html#frequencies_by/2","title":"Enum.frequencies_by/2","type":"function"},{"doc":"Splits the enumerable into groups based on key_fun . The result is a map where each key is given by key_fun and each value is a list of elements given by value_fun . The order of elements within each list is preserved from the enumerable . However, like all maps, the resulting map is unordered. Examples iex&gt; Enum . group_by ( ~w{ant buffalo cat dingo} , &amp; String . length / 1 ) %{ 3 = &gt; [ &quot;ant&quot; , &quot;cat&quot; ] , 5 = &gt; [ &quot;dingo&quot; ] , 7 = &gt; [ &quot;buffalo&quot; ] } iex&gt; Enum . group_by ( ~w{ant buffalo cat dingo} , &amp; String . length / 1 , &amp; String . first / 1 ) %{ 3 = &gt; [ &quot;a&quot; , &quot;c&quot; ] , 5 = &gt; [ &quot;d&quot; ] , 7 = &gt; [ &quot;b&quot; ] }","ref":"Enum.html#group_by/3","title":"Enum.group_by/3","type":"function"},{"doc":"Intersperses separator between each element of the enumeration. Examples iex&gt; Enum . intersperse ( [ 1 , 2 , 3 ] , 0 ) [ 1 , 0 , 2 , 0 , 3 ] iex&gt; Enum . intersperse ( [ 1 ] , 0 ) [ 1 ] iex&gt; Enum . intersperse ( [ ] , 0 ) [ ]","ref":"Enum.html#intersperse/2","title":"Enum.intersperse/2","type":"function"},{"doc":"Inserts the given enumerable into a collectable . Note that passing a non-empty list as the collectable is deprecated. If you're collecting into a non-empty keyword list, consider using Keyword.merge(collectable, Enum.to_list(enumerable)) . If you're collecting into a non-empty list, consider something like Enum.to_list(enumerable) ++ collectable . Examples iex&gt; Enum . into ( [ 1 , 2 ] , [ ] ) [ 1 , 2 ] iex&gt; Enum . into ( [ a : 1 , b : 2 ] , %{ } ) %{ a : 1 , b : 2 } iex&gt; Enum . into ( %{ a : 1 } , %{ b : 2 } ) %{ a : 1 , b : 2 } iex&gt; Enum . into ( [ a : 1 , a : 2 ] , %{ } ) %{ a : 2 }","ref":"Enum.html#into/2","title":"Enum.into/2","type":"function"},{"doc":"Inserts the given enumerable into a collectable according to the transformation function. Examples iex&gt; Enum . into ( [ 2 , 3 ] , [ 3 ] , fn x -&gt; x * 3 end ) [ 3 , 6 , 9 ] iex&gt; Enum . into ( %{ a : 1 , b : 2 } , %{ c : 3 } , fn { k , v } -&gt; { k , v * 2 } end ) %{ a : 2 , b : 4 , c : 3 }","ref":"Enum.html#into/3","title":"Enum.into/3","type":"function"},{"doc":"Joins the given enumerable into a string using joiner as a separator. If joiner is not passed at all, it defaults to an empty string. All elements in the enumerable must be convertible to a string, otherwise an error is raised. Examples iex&gt; Enum . join ( [ 1 , 2 , 3 ] ) &quot;123&quot; iex&gt; Enum . join ( [ 1 , 2 , 3 ] , &quot; = &quot; ) &quot;1 = 2 = 3&quot;","ref":"Enum.html#join/2","title":"Enum.join/2","type":"function"},{"doc":"Returns a list where each element is the result of invoking fun on each corresponding element of enumerable . For maps, the function expects a key-value tuple. Examples iex&gt; Enum . map ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] iex&gt; Enum . map ( [ a : 1 , b : 2 ] , fn { k , v } -&gt; { k , - v } end ) [ a : - 1 , b : - 2 ]","ref":"Enum.html#map/2","title":"Enum.map/2","type":"function"},{"doc":"Returns a list of results of invoking fun on every nth element of enumerable , starting with the first element. The first element is always passed to the given function, unless nth is 0 . The second argument specifying every nth element must be a non-negative integer. If nth is 0 , then enumerable is directly converted to a list, without fun being ever applied. Examples iex&gt; Enum . map_every ( 1 . . 10 , 2 , fn x -&gt; x + 1000 end ) [ 1001 , 2 , 1003 , 4 , 1005 , 6 , 1007 , 8 , 1009 , 10 ] iex&gt; Enum . map_every ( 1 . . 10 , 3 , fn x -&gt; x + 1000 end ) [ 1001 , 2 , 3 , 1004 , 5 , 6 , 1007 , 8 , 9 , 1010 ] iex&gt; Enum . map_every ( 1 . . 5 , 0 , fn x -&gt; x + 1000 end ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; Enum . map_every ( [ 1 , 2 , 3 ] , 1 , fn x -&gt; x + 1000 end ) [ 1001 , 1002 , 1003 ]","ref":"Enum.html#map_every/3","title":"Enum.map_every/3","type":"function"},{"doc":"Maps and intersperses the given enumerable in one pass. Examples iex&gt; Enum . map_intersperse ( [ 1 , 2 , 3 ] , :a , &amp; ( &amp;1 * 2 ) ) [ 2 , :a , 4 , :a , 6 ]","ref":"Enum.html#map_intersperse/3","title":"Enum.map_intersperse/3","type":"function"},{"doc":"Maps and joins the given enumerable in one pass. If joiner is not passed at all, it defaults to an empty string. All elements returned from invoking the mapper must be convertible to a string, otherwise an error is raised. Examples iex&gt; Enum . map_join ( [ 1 , 2 , 3 ] , &amp; ( &amp;1 * 2 ) ) &quot;246&quot; iex&gt; Enum . map_join ( [ 1 , 2 , 3 ] , &quot; = &quot; , &amp; ( &amp;1 * 2 ) ) &quot;2 = 4 = 6&quot;","ref":"Enum.html#map_join/3","title":"Enum.map_join/3","type":"function"},{"doc":"Invokes the given function to each element in the enumerable to reduce it to a single element, while keeping an accumulator. Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator. The function, fun , receives two arguments: the first one is the element, and the second one is the accumulator. fun must return a tuple with two elements in the form of {result, accumulator} . For maps, the first tuple element must be a {key, value} tuple. Examples iex&gt; Enum . map_reduce ( [ 1 , 2 , 3 ] , 0 , fn x , acc -&gt; { x * 2 , x + acc } end ) { [ 2 , 4 , 6 ] , 6 }","ref":"Enum.html#map_reduce/3","title":"Enum.map_reduce/3","type":"function"},{"doc":"Returns the maximal element in the enumerable according to Erlang's term ordering. By default, the comparison is done with the &gt;= sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements. If the enumerable is empty, the provided empty_fallback is called. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . max ( [ 1 , 2 , 3 ] ) 3 The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example: iex&gt; Enum . max ( [ ~D[2017-03-31] , ~D[2017-04-01] ] ) ~D[2017-03-31] In the example above, max/2 returned March 31st instead of April 1st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; Enum . max ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-04-01] Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . max ( [ ] , &amp; &gt;= / 2 , fn -&gt; 0 end ) 0","ref":"Enum.html#max/3","title":"Enum.max/3","type":"function"},{"doc":"Returns the maximal element in the enumerable as calculated by the given fun . By default, the comparison is done with the &gt;= sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements. Calls the provided empty_fallback function and returns its value if enumerable is empty. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . max_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; ] , fn x -&gt; String . length ( x ) end ) &quot;aaa&quot; iex&gt; Enum . max_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; , &quot;b&quot; , &quot;bbb&quot; ] , &amp; String . length / 1 ) &quot;aaa&quot; The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . max_by ( users , &amp; ( &amp;1 . birthday ) , Date ) %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . max_by ( [ ] , &amp; String . length / 1 , fn -&gt; nil end ) nil","ref":"Enum.html#max_by/4","title":"Enum.max_by/4","type":"function"},{"doc":"Checks if element exists within the enumerable . Membership is tested with the match ( ===/2 ) operator. Examples iex&gt; Enum . member? ( 1 . . 10 , 5 ) true iex&gt; Enum . member? ( 1 . . 10 , 5.0 ) false iex&gt; Enum . member? ( [ 1.0 , 2.0 , 3.0 ] , 2 ) false iex&gt; Enum . member? ( [ 1.0 , 2.0 , 3.0 ] , 2.000 ) true iex&gt; Enum . member? ( [ :a , :b , :c ] , :d ) false When called outside guards, the in and not in operators work by using this function.","ref":"Enum.html#member?/2","title":"Enum.member?/2","type":"function"},{"doc":"Returns the minimal element in the enumerable according to Erlang's term ordering. By default, the comparison is done with the &lt;= sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements. If the enumerable is empty, the provided empty_fallback is called. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . min ( [ 1 , 2 , 3 ] ) 1 The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example: iex&gt; Enum . min ( [ ~D[2017-03-31] , ~D[2017-04-01] ] ) ~D[2017-04-01] In the example above, min/2 returned April 1st instead of March 31st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; Enum . min ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-03-31] Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . min ( [ ] , fn -&gt; 0 end ) 0","ref":"Enum.html#min/3","title":"Enum.min/3","type":"function"},{"doc":"Returns the minimal element in the enumerable as calculated by the given fun . By default, the comparison is done with the &lt;= sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements. Calls the provided empty_fallback function and returns its value if enumerable is empty. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . min_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; ] , fn x -&gt; String . length ( x ) end ) &quot;a&quot; iex&gt; Enum . min_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; , &quot;b&quot; , &quot;bbb&quot; ] , &amp; String . length / 1 ) &quot;a&quot; The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . min_by ( users , &amp; ( &amp;1 . birthday ) , Date ) %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . min_by ( [ ] , &amp; String . length / 1 , fn -&gt; nil end ) nil","ref":"Enum.html#min_by/4","title":"Enum.min_by/4","type":"function"},{"doc":"Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering. If multiple elements are considered maximal or minimal, the first one that was found is returned. Calls the provided empty_fallback function and returns its value if enumerable is empty. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . min_max ( [ 2 , 3 , 1 ] ) { 1 , 3 } iex&gt; Enum . min_max ( [ ] , fn -&gt; { nil , nil } end ) { nil , nil }","ref":"Enum.html#min_max/2","title":"Enum.min_max/2","type":"function"},{"doc":"Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function. If multiple elements are considered maximal or minimal, the first one that was found is returned. Examples iex&gt; Enum . min_max_by ( [ &quot;aaa&quot; , &quot;bb&quot; , &quot;c&quot; ] , fn x -&gt; String . length ( x ) end ) { &quot;c&quot; , &quot;aaa&quot; } iex&gt; Enum . min_max_by ( [ &quot;aaa&quot; , &quot;a&quot; , &quot;bb&quot; , &quot;c&quot; , &quot;ccc&quot; ] , &amp; String . length / 1 ) { &quot;a&quot; , &quot;aaa&quot; } iex&gt; Enum . min_max_by ( [ ] , &amp; String . length / 1 , fn -&gt; { nil , nil } end ) { nil , nil } The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . min_max_by ( users , &amp; ( &amp;1 . birthday ) , Date ) { %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } } Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . min_max_by ( [ ] , &amp; String . length / 1 , fn -&gt; nil end ) nil","ref":"Enum.html#min_max_by/4","title":"Enum.min_max_by/4","type":"function"},{"doc":"Returns the product of all elements. Raises ArithmeticError if enumerable contains a non-numeric value. Examples iex&gt; Enum . product ( [ ] ) 1 iex&gt; Enum . product ( [ 2 , 3 , 4 ] ) 24 iex&gt; Enum . product ( [ 2.0 , 3.0 , 4.0 ] ) 24.0","ref":"Enum.html#product/1","title":"Enum.product/1","type":"function"},{"doc":"Returns a random element of an enumerable . Raises Enum.EmptyError if enumerable is empty. This function uses Erlang's :rand module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed. The implementation is based on the reservoir sampling algorithm. It assumes that the sample being returned can fit into memory; the input enumerable doesn't have to, as it is traversed just once. If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory). Examples The examples below use the :exrop pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then :exsss is the default algorithm. If you are using :exsplus , then please update, as this algorithm is deprecated since Erlang/OTP 20. # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exrop , { 101 , 102 , 103 } ) iex&gt; Enum . random ( [ 1 , 2 , 3 ] ) 3 iex&gt; Enum . random ( [ 1 , 2 , 3 ] ) 2 iex&gt; Enum . random ( 1 . . 1_000 ) 846","ref":"Enum.html#random/1","title":"Enum.random/1","type":"function"},{"doc":"Invokes fun for each element in the enumerable with the accumulator. Raises Enum.EmptyError if enumerable is empty. The first element of the enumerable is used as the initial value of the accumulator. Then, the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the enumerable is done, the last accumulator is returned. Since the first element of the enumerable is used as the initial value of the accumulator, fun will only be executed n - 1 times where n is the length of the enumerable. This function won't call the specified function for enumerables that are one-element long. If you wish to use another value for the accumulator, use Enum.reduce/3 . Examples iex&gt; Enum . reduce ( [ 1 , 2 , 3 , 4 ] , fn x , acc -&gt; x * acc end ) 24","ref":"Enum.html#reduce/2","title":"Enum.reduce/2","type":"function"},{"doc":"Invokes fun for each element in the enumerable with the accumulator. The initial value of the accumulator is acc . The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator. Examples iex&gt; Enum . reduce ( [ 1 , 2 , 3 ] , 0 , fn x , acc -&gt; x + acc end ) 6 Reduce as a building block Reduce (sometimes called fold ) is a basic building block in functional programming. Almost all of the functions in the Enum module can be implemented on top of reduce. Those functions often rely on other operations, such as Enum.reverse/1 , which are optimized by the runtime. For example, we could implement map/2 in terms of reduce/3 as follows: def my_map ( enumerable , fun ) do enumerable |&gt; Enum . reduce ( [ ] , fn x , acc -&gt; [ fun . ( x ) | acc ] end ) |&gt; Enum . reverse ( ) end In the example above, Enum.reduce/3 accumulates the result of each call to fun into a list in reverse order, which is correctly ordered at the end by calling Enum.reverse/1 . Implementing functions like map/2 , filter/2 and others are a good exercise for understanding the power behind Enum.reduce/3 . When an operation cannot be expressed by any of the functions in the Enum module, developers will most likely resort to reduce/3 .","ref":"Enum.html#reduce/3","title":"Enum.reduce/3","type":"function"},{"doc":"Reduces enumerable until fun returns {:halt, term} . The return value for fun is expected to be {:cont, acc} to continue the reduction with acc as the new accumulator or {:halt, acc} to halt the reduction If fun returns {:halt, acc} the reduction is halted and the function returns acc . Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last {:cont, acc} . Examples iex&gt; Enum . reduce_while ( 1 . . 100 , 0 , fn x , acc -&gt; ...&gt; if x &lt; 5 , do : { :cont , acc + x } , else : { :halt , acc } ...&gt; end ) 10 iex&gt; Enum . reduce_while ( 1 . . 100 , 0 , fn x , acc -&gt; ...&gt; if x &gt; 0 , do : { :cont , acc + x } , else : { :halt , acc } ...&gt; end ) 5050","ref":"Enum.html#reduce_while/3","title":"Enum.reduce_while/3","type":"function"},{"doc":"Returns a list of elements in enumerable excluding those for which the function fun returns a truthy value. See also filter/2 . Examples iex&gt; Enum . reject ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) [ 1 , 3 ]","ref":"Enum.html#reject/2","title":"Enum.reject/2","type":"function"},{"doc":"Returns a list of elements in enumerable in reverse order. Examples iex&gt; Enum . reverse ( [ 1 , 2 , 3 ] ) [ 3 , 2 , 1 ]","ref":"Enum.html#reverse/1","title":"Enum.reverse/1","type":"function"},{"doc":"Reverses the elements in enumerable , appends the tail , and returns it as a list. This is an optimization for enumerable |&gt; Enum.reverse() |&gt; Enum.concat(tail) . Examples iex&gt; Enum . reverse ( [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) [ 3 , 2 , 1 , 4 , 5 , 6 ]","ref":"Enum.html#reverse/2","title":"Enum.reverse/2","type":"function"},{"doc":"Reverses the enumerable in the range from initial start_index through count elements. If count is greater than the size of the rest of the enumerable , then this function will reverse the rest of the enumerable. Examples iex&gt; Enum . reverse_slice ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 2 , 4 ) [ 1 , 2 , 6 , 5 , 4 , 3 ]","ref":"Enum.html#reverse_slice/3","title":"Enum.reverse_slice/3","type":"function"},{"doc":"Applies the given function to each element in the enumerable , storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the enumerable as the starting value. Examples iex&gt; Enum . scan ( 1 . . 5 , &amp; ( &amp;1 + &amp;2 ) ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Enum.html#scan/2","title":"Enum.scan/2","type":"function"},{"doc":"Applies the given function to each element in the enumerable , storing the result in a list and passing it as the accumulator for the next computation. Uses the given acc as the starting value. Examples iex&gt; Enum . scan ( 1 . . 5 , 0 , &amp; ( &amp;1 + &amp;2 ) ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Enum.html#scan/3","title":"Enum.scan/3","type":"function"},{"doc":"Returns a list with the elements of enumerable shuffled. This function uses Erlang's :rand module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed. Examples The examples below use the :exrop pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then :exsss is the default algorithm. If you are using :exsplus , then please update, as this algorithm is deprecated since Erlang/OTP 20. # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exrop , { 1 , 2 , 3 } ) iex&gt; Enum . shuffle ( [ 1 , 2 , 3 ] ) [ 3 , 1 , 2 ] iex&gt; Enum . shuffle ( [ 1 , 2 , 3 ] ) [ 1 , 3 , 2 ]","ref":"Enum.html#shuffle/1","title":"Enum.shuffle/1","type":"function"},{"doc":"Returns a subset list of the given enumerable by index_range . index_range must be a Range . Given an enumerable , it drops elements before index_range.first (zero-base), then it takes elements until element index_range.last (inclusively). Indexes are normalized, meaning that negative indexes will be counted from the end (for example, -1 means the last element of the enumerable ). If index_range.last is out of bounds, then it is assigned as the index of the last element. If the normalized index_range.first is out of bounds of the given enumerable , or this one is greater than the normalized index_range.last , then [] is returned. Examples iex&gt; Enum . slice ( 1 . . 100 , 5 . . 10 ) [ 6 , 7 , 8 , 9 , 10 , 11 ] iex&gt; Enum . slice ( 1 . . 10 , 5 . . 20 ) [ 6 , 7 , 8 , 9 , 10 ] # last five elements (negative indexes) iex&gt; Enum . slice ( 1 . . 30 , - 5 . . - 1 ) [ 26 , 27 , 28 , 29 , 30 ] For ranges where start &gt; stop , you need to explicit mark them as increasing: iex&gt; Enum . slice ( 1 . . 30 , 25 . . - 1 / / 1 ) [ 26 , 27 , 28 , 29 , 30 ] If values are out of bounds, it returns an empty list: iex&gt; Enum . slice ( 1 . . 10 , 11 . . 20 ) [ ] # first is greater than last iex&gt; Enum . slice ( 1 . . 10 , 6 . . 5 ) [ ]","ref":"Enum.html#slice/2","title":"Enum.slice/2","type":"function"},{"doc":"Returns a subset list of the given enumerable , from start_index (zero-based) with amount number of elements if available. Given an enumerable , it drops elements right before element start_index ; then, it takes amount of elements, returning as many elements as possible if there are not enough elements. A negative start_index can be passed, which means the enumerable is enumerated once and the index is counted from the end (for example, -1 starts slicing from the last element). It returns [] if amount is 0 or if start_index is out of bounds. Examples iex&gt; Enum . slice ( 1 . . 100 , 5 , 10 ) [ 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ] # amount to take is greater than the number of elements iex&gt; Enum . slice ( 1 . . 10 , 5 , 100 ) [ 6 , 7 , 8 , 9 , 10 ] iex&gt; Enum . slice ( 1 . . 10 , 5 , 0 ) [ ] # using a negative start index iex&gt; Enum . slice ( 1 . . 10 , - 6 , 3 ) [ 5 , 6 , 7 ] # out of bound start index (positive) iex&gt; Enum . slice ( 1 . . 10 , 10 , 5 ) [ ] # out of bound start index (negative) iex&gt; Enum . slice ( 1 . . 10 , - 11 , 5 ) [ ]","ref":"Enum.html#slice/3","title":"Enum.slice/3","type":"function"},{"doc":"Sorts the enumerable according to Erlang's term ordering. This function uses the merge sort algorithm. Do not use this function to sort structs, see sort/2 for more information. Examples iex&gt; Enum . sort ( [ 3 , 2 , 1 ] ) [ 1 , 2 , 3 ]","ref":"Enum.html#sort/1","title":"Enum.sort/1","type":"function"},{"doc":"Sorts the enumerable by the given function. This function uses the merge sort algorithm. The given function should compare two arguments, and return true if the first argument precedes or is in the same place as the second one. Examples iex&gt; Enum . sort ( [ 1 , 2 , 3 ] , &amp; ( &amp;1 &gt;= &amp;2 ) ) [ 3 , 2 , 1 ] The sorting algorithm will be stable as long as the given function returns true for values considered equal: iex&gt; Enum . sort ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; ( byte_size ( &amp;1 ) &lt;= byte_size ( &amp;2 ) ) ) [ &quot;of&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;monster&quot; ] If the function does not return true for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example: iex&gt; Enum . sort ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; ( byte_size ( &amp;1 ) &lt; byte_size ( &amp;2 ) ) ) [ &quot;of&quot; , &quot;kind&quot; , &quot;some&quot; , &quot;monster&quot; ] Ascending and descending sort/2 allows a developer to pass :asc or :desc as the sorting function, which is a convenience for &lt;=/2 and &gt;=/2 respectively. iex&gt; Enum . sort ( [ 2 , 3 , 1 ] , :asc ) [ 1 , 2 , 3 ] iex&gt; Enum . sort ( [ 2 , 3 , 1 ] , :desc ) [ 3 , 2 , 1 ] Sorting structs Do not use &lt;/2 , &lt;=/2 , &gt;/2 , &gt;=/2 and friends when sorting structs. That's because the built-in operators above perform structural comparison and not a semantic one. Imagine we sort the following list of dates: iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates ) [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] Note that the returned result is incorrect, because sort/1 by default uses &lt;=/2 , which will compare their structure. When comparing structures, the fields are compared in alphabetical order, which means the dates above will be compared by day , month and then year , which is the opposite of what we want. For this reason, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates , Date ) [ ~D[2019-01-01] , ~D[2019-06-06] , ~D[2020-03-02] ] To retrieve all dates in descending order, you can wrap the module in a tuple with :asc or :desc as first element: iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates , { :asc , Date } ) [ ~D[2019-01-01] , ~D[2019-06-06] , ~D[2020-03-02] ] iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates , { :desc , Date } ) [ ~D[2020-03-02] , ~D[2019-06-06] , ~D[2019-01-01] ]","ref":"Enum.html#sort/2","title":"Enum.sort/2","type":"function"},{"doc":"Sorts the mapped results of the enumerable according to the provided sorter function. This function maps each element of the enumerable using the provided mapper function. The enumerable is then sorted by the mapped elements using the sorter function, which defaults to Kernel.&lt;=/2 . sort_by/3 differs from sort/2 in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both elements, it's more efficient to use sort_by/3 . Examples Using the default sorter of &lt;=/2 : iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; byte_size / 1 ) [ &quot;of&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;monster&quot; ] Sorting by multiple properties - first by size, then by first letter (this takes advantage of the fact that tuples are compared element-by-element): iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; { byte_size ( &amp;1 ) , String . first ( &amp;1 ) } ) [ &quot;of&quot; , &quot;kind&quot; , &quot;some&quot; , &quot;monster&quot; ] Similar to sort/2 , you can pass a custom sorter: iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; byte_size / 1 , &amp; &gt;= / 2 ) [ &quot;monster&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; ] Or use :asc and :desc : iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; byte_size / 1 , :desc ) [ &quot;monster&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; ] As in sort/2 , avoid using the default sorting function to sort structs, as by default it performs structural comparison instead of a semantic one. In such cases, you shall pass a sorting function as third element or any module that implements a compare/2 function. For example, to sort users by their birthday in both ascending and descending order respectively: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . sort_by ( users , &amp; ( &amp;1 . birthday ) , Date ) [ %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } , %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } ] iex&gt; Enum . sort_by ( users , &amp; ( &amp;1 . birthday ) , { :desc , Date } ) [ %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } , %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } ]","ref":"Enum.html#sort_by/3","title":"Enum.sort_by/3","type":"function"},{"doc":"Splits the enumerable into two enumerables, leaving count elements in the first one. If count is a negative number, it starts counting from the back to the beginning of the enumerable . Be aware that a negative count implies the enumerable will be enumerated twice: once to calculate the position, and a second time to do the actual splitting. Examples iex&gt; Enum . split ( [ 1 , 2 , 3 ] , 2 ) { [ 1 , 2 ] , [ 3 ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , 10 ) { [ 1 , 2 , 3 ] , [ ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , 0 ) { [ ] , [ 1 , 2 , 3 ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , - 1 ) { [ 1 , 2 ] , [ 3 ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , - 5 ) { [ ] , [ 1 , 2 , 3 ] }","ref":"Enum.html#split/2","title":"Enum.split/2","type":"function"},{"doc":"Splits enumerable in two at the position of the element for which fun returns a falsy value ( false or nil ) for the first time. It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list. Examples iex&gt; Enum . split_while ( [ 1 , 2 , 3 , 4 ] , fn x -&gt; x &lt; 3 end ) { [ 1 , 2 ] , [ 3 , 4 ] } iex&gt; Enum . split_while ( [ 1 , 2 , 3 , 4 ] , fn x -&gt; x &lt; 0 end ) { [ ] , [ 1 , 2 , 3 , 4 ] } iex&gt; Enum . split_while ( [ 1 , 2 , 3 , 4 ] , fn x -&gt; x &gt; 0 end ) { [ 1 , 2 , 3 , 4 ] , [ ] }","ref":"Enum.html#split_while/2","title":"Enum.split_while/2","type":"function"},{"doc":"Splits the enumerable in two lists according to the given function fun . Splits the given enumerable in two lists by calling fun with each element in the enumerable as its only argument. Returns a tuple with the first list containing all the elements in enumerable for which applying fun returned a truthy value, and a second list with all the elements for which applying fun returned a falsy value ( false or nil ). The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below. Examples iex&gt; Enum . split_with ( [ 5 , 4 , 3 , 2 , 1 , 0 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) { [ 4 , 2 , 0 ] , [ 5 , 3 , 1 ] } iex&gt; Enum . split_with ( %{ a : 1 , b : - 2 , c : 1 , d : - 3 } , fn { _k , v } -&gt; v &lt; 0 end ) { [ b : - 2 , d : - 3 ] , [ a : 1 , c : 1 ] } iex&gt; Enum . split_with ( %{ a : 1 , b : - 2 , c : 1 , d : - 3 } , fn { _k , v } -&gt; v &gt; 50 end ) { [ ] , [ a : 1 , b : - 2 , c : 1 , d : - 3 ] } iex&gt; Enum . split_with ( %{ } , fn { _k , v } -&gt; v &gt; 50 end ) { [ ] , [ ] }","ref":"Enum.html#split_with/2","title":"Enum.split_with/2","type":"function"},{"doc":"Returns the sum of all elements. Raises ArithmeticError if enumerable contains a non-numeric value. Examples iex&gt; Enum . sum ( [ 1 , 2 , 3 ] ) 6 iex&gt; Enum . sum ( 1 . . 10 ) 55 iex&gt; Enum . sum ( 1 . . 10 / / 2 ) 25","ref":"Enum.html#sum/1","title":"Enum.sum/1","type":"function"},{"doc":"Takes an amount of elements from the beginning or the end of the enumerable . If a positive amount is given, it takes the amount elements from the beginning of the enumerable . If a negative amount is given, the amount of elements will be taken from the end. The enumerable will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end. If amount is 0 , it returns [] . Examples iex&gt; Enum . take ( [ 1 , 2 , 3 ] , 2 ) [ 1 , 2 ] iex&gt; Enum . take ( [ 1 , 2 , 3 ] , 10 ) [ 1 , 2 , 3 ] iex&gt; Enum . take ( [ 1 , 2 , 3 ] , 0 ) [ ] iex&gt; Enum . take ( [ 1 , 2 , 3 ] , - 1 ) [ 3 ]","ref":"Enum.html#take/2","title":"Enum.take/2","type":"function"},{"doc":"Returns a list of every nth element in the enumerable , starting with the first element. The first element is always included, unless nth is 0. The second argument specifying every nth element must be a non-negative integer. Examples iex&gt; Enum . take_every ( 1 . . 10 , 2 ) [ 1 , 3 , 5 , 7 , 9 ] iex&gt; Enum . take_every ( 1 . . 10 , 0 ) [ ] iex&gt; Enum . take_every ( [ 1 , 2 , 3 ] , 1 ) [ 1 , 2 , 3 ]","ref":"Enum.html#take_every/2","title":"Enum.take_every/2","type":"function"},{"doc":"Takes count random elements from enumerable . Note that this function will traverse the whole enumerable to get the random sublist. See random/1 for notes on implementation and random seed. Examples # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exrop , { 1 , 2 , 3 } ) iex&gt; Enum . take_random ( 1 . . 10 , 2 ) [ 7 , 2 ] iex&gt; Enum . take_random ( ?a . . ?z , 5 ) &#39;hypnt&#39;","ref":"Enum.html#take_random/2","title":"Enum.take_random/2","type":"function"},{"doc":"Takes the elements from the beginning of the enumerable while fun returns a truthy value. Examples iex&gt; Enum . take_while ( [ 1 , 2 , 3 ] , fn x -&gt; x &lt; 3 end ) [ 1 , 2 ]","ref":"Enum.html#take_while/2","title":"Enum.take_while/2","type":"function"},{"doc":"Converts enumerable to a list. Examples iex&gt; Enum . to_list ( 1 . . 3 ) [ 1 , 2 , 3 ]","ref":"Enum.html#to_list/1","title":"Enum.to_list/1","type":"function"},{"doc":"Enumerates the enumerable , removing all duplicated elements. Examples iex&gt; Enum . uniq ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) [ 1 , 2 , 3 ]","ref":"Enum.html#uniq/1","title":"Enum.uniq/1","type":"function"},{"doc":"Enumerates the enumerable , by removing the elements for which function fun returned duplicate elements. The function fun maps every element to a term. Two elements are considered duplicates if the return value of fun is equal for both of them. The first occurrence of each element is kept. Example iex&gt; Enum . uniq_by ( [ { 1 , :x } , { 2 , :y } , { 1 , :z } ] , fn { x , _ } -&gt; x end ) [ { 1 , :x } , { 2 , :y } ] iex&gt; Enum . uniq_by ( [ a : { :tea , 2 } , b : { :tea , 2 } , c : { :coffee , 1 } ] , fn { _ , y } -&gt; y end ) [ a : { :tea , 2 } , c : { :coffee , 1 } ]","ref":"Enum.html#uniq_by/2","title":"Enum.uniq_by/2","type":"function"},{"doc":"Opposite of zip/2 . Extracts two-element tuples from the given enumerable and groups them together. It takes an enumerable with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively. This function fails unless enumerable is or can be converted into a list of tuples with exactly two elements in each tuple. Examples iex&gt; Enum . unzip ( [ { :a , 1 } , { :b , 2 } , { :c , 3 } ] ) { [ :a , :b , :c ] , [ 1 , 2 , 3 ] } iex&gt; Enum . unzip ( %{ a : 1 , b : 2 } ) { [ :a , :b ] , [ 1 , 2 ] }","ref":"Enum.html#unzip/1","title":"Enum.unzip/1","type":"function"},{"doc":"Returns the enumerable with each element wrapped in a tuple alongside its index. May receive a function or an integer offset. If an offset is given, it will index from the given offset instead of from zero. If a function is given, it will index by invoking the function for each element and index (zero-based) of the enumerable. Examples iex&gt; Enum . with_index ( [ :a , :b , :c ] ) [ a : 0 , b : 1 , c : 2 ] iex&gt; Enum . with_index ( [ :a , :b , :c ] , 3 ) [ a : 3 , b : 4 , c : 5 ] iex&gt; Enum . with_index ( [ :a , :b , :c ] , fn element , index -&gt; { index , element } end ) [ { 0 , :a } , { 1 , :b } , { 2 , :c } ]","ref":"Enum.html#with_index/2","title":"Enum.with_index/2","type":"function"},{"doc":"Zips corresponding elements from a finite collection of enumerables into a list of tuples. The zipping finishes as soon as any enumerable in the given collection completes. Examples iex&gt; Enum . zip ( [ [ 1 , 2 , 3 ] , [ :a , :b , :c ] , [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] ] ) [ { 1 , :a , &quot;foo&quot; } , { 2 , :b , &quot;bar&quot; } , { 3 , :c , &quot;baz&quot; } ] iex&gt; Enum . zip ( [ [ 1 , 2 , 3 , 4 , 5 ] , [ :a , :b , :c ] ] ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } ]","ref":"Enum.html#zip/1","title":"Enum.zip/1","type":"function"},{"doc":"Zips corresponding elements from two enumerables into a list of tuples. The zipping finishes as soon as either enumerable completes. Examples iex&gt; Enum . zip ( [ 1 , 2 , 3 ] , [ :a , :b , :c ] ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } ] iex&gt; Enum . zip ( [ 1 , 2 , 3 , 4 , 5 ] , [ :a , :b , :c ] ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } ]","ref":"Enum.html#zip/2","title":"Enum.zip/2","type":"function"},{"doc":"Reduces a over all of the given enums, halting as soon as any enumerable is empty. The reducer will receive 2 args, a list of elements (one from each enum) and the accumulator. In practice, the behaviour provided by this function can be achieved with: Enum . reduce ( Stream . zip ( enums ) , acc , reducer ) But zip_reduce/4 exists for convenience purposes. Examples iex&gt; enums = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ] ...&gt; Enum . zip_reduce ( enums , [ ] , fn elements , acc -&gt; ...&gt; [ List . to_tuple ( elements ) | acc ] ...&gt; end ) [ { 1 , 2 , 3 } , { 1 , 2 , 3 } ] iex&gt; enums = [ [ 1 , 2 ] , %{ a : 3 , b : 4 } , [ 5 , 6 ] ] ...&gt; Enum . zip_reduce ( enums , [ ] , fn elements , acc -&gt; ...&gt; [ List . to_tuple ( elements ) | acc ] ...&gt; end ) [ { 2 , { :b , 4 } , 6 } , { 1 , { :a , 3 } , 5 } ]","ref":"Enum.html#zip_reduce/3","title":"Enum.zip_reduce/3","type":"function"},{"doc":"Reduces over two enumerables halting as soon as either enumerable is empty. In practice, the behaviour provided by this function can be achieved with: Enum . reduce ( Stream . zip ( left , right ) , acc , reducer ) But zip_reduce/4 exists for convenience purposes. Examples iex&gt; Enum . zip_reduce ( [ 1 , 2 ] , [ 3 , 4 ] , 0 , fn x , y , acc -&gt; x + y + acc end ) 10 iex&gt; Enum . zip_reduce ( [ 1 , 2 ] , [ 3 , 4 ] , [ ] , fn x , y , acc -&gt; [ x + y | acc ] end ) [ 6 , 4 ]","ref":"Enum.html#zip_reduce/4","title":"Enum.zip_reduce/4","type":"function"},{"doc":"Zips corresponding elements from a finite collection of enumerables into list, transforming them with the zip_fun function as it goes. The first element from each of the enums in enumerables will be put into a list which is then passed to the 1-arity zip_fun function. Then, the second elements from each of the enums are put into a list and passed to zip_fun , and so on until any one of the enums in enumerables runs out of elements. Returns a list with all the results of calling zip_fun . Examples iex&gt; Enum . zip_with ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] , fn [ x , y , z ] -&gt; x + y + z end ) [ 9 , 12 ] iex&gt; Enum . zip_with ( [ [ 1 , 2 ] , [ 3 , 4 ] ] , fn [ x , y ] -&gt; x + y end ) [ 4 , 6 ]","ref":"Enum.html#zip_with/2","title":"Enum.zip_with/2","type":"function"},{"doc":"Zips corresponding elements from two enumerables into a list, transforming them with the zip_fun function as it goes. The corresponding elements from each collection are passed to the provided 2-arity zip_fun function in turn. Returns a list that contains the result of calling zip_fun for each pair of elements. The zipping finishes as soon as either enumerable runs out of elements. Zipping Maps It's important to remember that zipping inherently relies on order. If you zip two lists you get the element at the index from each list in turn. If we zip two maps together it's tempting to think that you will get the given key in the left map and the matching key in the right map, but there is no such guarantee because map keys are not ordered! Consider the following: left = %{ :a = &gt; 1 , 1 = &gt; 3 } right = %{ :a = &gt; 1 , :b = &gt; :c } Enum . zip ( left , right ) # [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}] As you can see :a does not get paired with :a . If this is what you want, you should use Map.merge/3 . Examples iex&gt; Enum . zip_with ( [ 1 , 2 ] , [ 3 , 4 ] , fn x , y -&gt; x + y end ) [ 4 , 6 ] iex&gt; Enum . zip_with ( [ 1 , 2 ] , [ 3 , 4 , 5 , 6 ] , fn x , y -&gt; x + y end ) [ 4 , 6 ] iex&gt; Enum . zip_with ( [ 1 , 2 , 5 , 6 ] , [ 3 , 4 ] , fn x , y -&gt; x + y end ) [ 4 , 6 ]","ref":"Enum.html#zip_with/3","title":"Enum.zip_with/3","type":"function"},{"doc":"","ref":"Enum.html#t:acc/0","title":"Enum.acc/0","type":"type"},{"doc":"","ref":"Enum.html#t:default/0","title":"Enum.default/0","type":"type"},{"doc":"","ref":"Enum.html#t:element/0","title":"Enum.element/0","type":"type"},{"doc":"Zero-based index. It can also be a negative integer.","ref":"Enum.html#t:index/0","title":"Enum.index/0","type":"type"},{"doc":"","ref":"Enum.html#t:t/0","title":"Enum.t/0","type":"type"},{"doc":"A keyword list is a list that consists exclusively of two-element tuples. The first element of these tuples is known as the key , and it must be an atom. The second element, known as the value , can be any term. Keywords are mostly used to work with optional values. Examples For example, the following is a keyword list: [ { :exit_on_close , true } , { :active , :once } , { :packet_size , 1024 } ] Elixir provides a special and more concise syntax for keyword lists that looks like this: [ exit_on_close : true , active : :once , packet_size : 1024 ] The two syntaxes are completely equivalent. Like atoms, keyword lists keys must be composed of Unicode characters such as letters, numbers, underscore, and @ . If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes: iex&gt; [ &quot;exit on close&quot; : true ] [ &quot;exit on close&quot; : true ] Wrapping a keyword in quotes does not make it a string. Keyword lists keys are always atoms. If you use quotes around the key when quoting is not necessary, Elixir will warn. Duplicate keys and ordering A keyword may have duplicated keys so it is not strictly a key-value data type. However most of the functions in this module behave exactly as a key-value so they work similarly to the functions you would find in the Map module. For example, Keyword.get/3 will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, Keyword.put/3 and Keyword.delete/2 ensure all duplicated entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts. A handful of functions exist to handle duplicated keys, for example, get_values/2 returns all values for a given key and delete_first/2 deletes just one of the existing entries. Even though lists preserve the user ordering, the functions in Keyword do not guarantee any ordering. For example, if you invoke Keyword.put(opts, new_key, new_value) , there is no guarantee to where new_key will be added (to the front, to the end, or anywhere else). Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as: def my_function ( [ some_key : value , another_key : another_value ] ) will match my_function ( [ some_key : :foo , another_key : :bar ] ) but it won't match my_function ( [ another_key : :bar , some_key : :foo ] ) Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. Call syntax When keyword lists are passed as the last argument to a function, the square brackets around the keyword list can be omitted. For example, the keyword list syntax: String . split ( &quot;1-0&quot; , &quot;-&quot; , [ trim : true , parts : 2 ] ) can be written without the enclosing brackets whenever it is the last argument of a function call: String . split ( &quot;1-0&quot; , &quot;-&quot; , trim : true , parts : 2 ) Since tuples, lists, maps, and others are treated the same as function calls in Elixir syntax, this property is also available to them: iex&gt; { 1 , 2 , foo : :bar } { 1 , 2 , [ { :foo , :bar } ] } iex&gt; [ 1 , 2 , foo : :bar ] [ 1 , 2 , { :foo , :bar } ] iex&gt; %{ 1 = &gt; 2 , foo : :bar } %{ 1 = &gt; 2 , :foo = &gt; :bar }","ref":"Keyword.html","title":"Keyword","type":"module"},{"doc":"Deletes the entries in the keyword list for a specific key . If the key does not exist, returns the keyword list unchanged. Use delete_first/2 to delete just the first entry in case of duplicated keys. Examples iex&gt; Keyword . delete ( [ a : 1 , b : 2 ] , :a ) [ b : 2 ] iex&gt; Keyword . delete ( [ a : 1 , b : 2 , a : 3 ] , :a ) [ b : 2 ] iex&gt; Keyword . delete ( [ b : 2 ] , :a ) [ b : 2 ]","ref":"Keyword.html#delete/2","title":"Keyword.delete/2","type":"function"},{"doc":"Deletes the first entry in the keyword list for a specific key . If the key does not exist, returns the keyword list unchanged. Examples iex&gt; Keyword . delete_first ( [ a : 1 , b : 2 , a : 3 ] , :a ) [ b : 2 , a : 3 ] iex&gt; Keyword . delete_first ( [ b : 2 ] , :a ) [ b : 2 ]","ref":"Keyword.html#delete_first/2","title":"Keyword.delete_first/2","type":"function"},{"doc":"Drops the given keys from the keyword list. Duplicated keys are preserved in the new keyword list. Examples iex&gt; Keyword . drop ( [ a : 1 , b : 2 , c : 3 ] , [ :b , :d ] ) [ a : 1 , c : 3 ] iex&gt; Keyword . drop ( [ a : 1 , b : 2 , b : 3 , c : 3 , a : 5 ] , [ :b , :d ] ) [ a : 1 , c : 3 , a : 5 ]","ref":"Keyword.html#drop/2","title":"Keyword.drop/2","type":"function"},{"doc":"Checks if two keywords are equal. Two keywords are considered to be equal if they contain the same keys and those keys contain the same values. Examples iex&gt; Keyword . equal? ( [ a : 1 , b : 2 ] , [ b : 2 , a : 1 ] ) true iex&gt; Keyword . equal? ( [ a : 1 , b : 2 ] , [ b : 1 , a : 2 ] ) false iex&gt; Keyword . equal? ( [ a : 1 , b : 2 , a : 3 ] , [ b : 2 , a : 3 , a : 1 ] ) true Comparison between values is done with ===/3 , which means integers are not equivalent to floats: iex&gt; Keyword . equal? ( [ a : 1.0 ] , [ a : 1 ] ) false","ref":"Keyword.html#equal?/2","title":"Keyword.equal?/2","type":"function"},{"doc":"Fetches the value for a specific key and returns it in a tuple. If the key does not exist, returns :error . Examples iex&gt; Keyword . fetch ( [ a : 1 ] , :a ) { :ok , 1 } iex&gt; Keyword . fetch ( [ a : 1 ] , :b ) :error","ref":"Keyword.html#fetch/2","title":"Keyword.fetch/2","type":"function"},{"doc":"Fetches the value for specific key . If key does not exist, a KeyError is raised. Examples iex&gt; Keyword . fetch! ( [ a : 1 ] , :a ) 1 iex&gt; Keyword . fetch! ( [ a : 1 ] , :b ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#fetch!/2","title":"Keyword.fetch!/2","type":"function"},{"doc":"Gets the value for a specific key . If key does not exist, return the default value ( nil if no default value). If duplicated entries exist, the first one is returned. Use get_values/2 to retrieve all entries. Examples iex&gt; Keyword . get ( [ ] , :a ) nil iex&gt; Keyword . get ( [ a : 1 ] , :a ) 1 iex&gt; Keyword . get ( [ a : 1 ] , :b ) nil iex&gt; Keyword . get ( [ a : 1 ] , :b , 3 ) 3 With duplicated keys: iex&gt; Keyword . get ( [ a : 1 , a : 2 ] , :a , 3 ) 1 iex&gt; Keyword . get ( [ a : 1 , a : 2 ] , :b , 3 ) 3","ref":"Keyword.html#get/3","title":"Keyword.get/3","type":"function"},{"doc":"Gets the value from key and updates it, all in one pass. This fun argument receives the value of key (or nil if key is not present) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key . The fun may also return :pop , implying the current value shall be removed from the keyword list and returned. The returned value is a tuple with the current value returned by fun and a new keyword list with the updated value under key . Examples iex&gt; Keyword . get_and_update ( [ a : 1 ] , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , [ a : &quot;new value!&quot; ] } iex&gt; Keyword . get_and_update ( [ a : 1 ] , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { nil , [ b : &quot;new value!&quot; , a : 1 ] } iex&gt; Keyword . get_and_update ( [ a : 1 ] , :a , fn _ -&gt; :pop end ) { 1 , [ ] } iex&gt; Keyword . get_and_update ( [ a : 1 ] , :b , fn _ -&gt; :pop end ) { nil , [ a : 1 ] }","ref":"Keyword.html#get_and_update/3","title":"Keyword.get_and_update/3","type":"function"},{"doc":"Gets the value from key and updates it. Raises if there is no key . This fun argument receives the value of key and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key . The returned value is a tuple with the current value returned by fun and a new keyword list with the updated value under key . Examples iex&gt; Keyword . get_and_update! ( [ a : 1 ] , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , [ a : &quot;new value!&quot; ] } iex&gt; Keyword . get_and_update! ( [ a : 1 ] , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) ** (KeyError) key :b not found in: [a: 1] iex&gt; Keyword . get_and_update! ( [ a : 1 ] , :a , fn _ -&gt; ...&gt; :pop ...&gt; end ) { 1 , [ ] }","ref":"Keyword.html#get_and_update!/3","title":"Keyword.get_and_update!/3","type":"function"},{"doc":"Gets the value for a specific key . If key does not exist, lazily evaluates fun and returns its result. This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again. If duplicated entries exist, the first one is returned. Use get_values/2 to retrieve all entries. Examples iex&gt; keyword = [ a : 1 ] iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Keyword . get_lazy ( keyword , :a , fun ) 1 iex&gt; Keyword . get_lazy ( keyword , :b , fun ) 13","ref":"Keyword.html#get_lazy/3","title":"Keyword.get_lazy/3","type":"function"},{"doc":"Gets all values for a specific key . Examples iex&gt; Keyword . get_values ( [ ] , :a ) [ ] iex&gt; Keyword . get_values ( [ a : 1 ] , :a ) [ 1 ] iex&gt; Keyword . get_values ( [ a : 1 , a : 2 ] , :a ) [ 1 , 2 ]","ref":"Keyword.html#get_values/2","title":"Keyword.get_values/2","type":"function"},{"doc":"Returns whether a given key exists in the given keywords . Examples iex&gt; Keyword . has_key? ( [ a : 1 ] , :a ) true iex&gt; Keyword . has_key? ( [ a : 1 ] , :b ) false","ref":"Keyword.html#has_key?/2","title":"Keyword.has_key?/2","type":"function"},{"doc":"Returns all keys from the keyword list. Duplicated keys appear duplicated in the final list of keys. Examples iex&gt; Keyword . keys ( a : 1 , b : 2 ) [ :a , :b ] iex&gt; Keyword . keys ( a : 1 , b : 2 , a : 3 ) [ :a , :b , :a ] iex&gt; Keyword . keys ( [ { :a , 1 } , { &quot;b&quot; , 2 } , { :c , 3 } ] ) ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {&quot;b&quot;, 2}","ref":"Keyword.html#keys/1","title":"Keyword.keys/1","type":"function"},{"doc":"Returns true if term is a keyword list; otherwise returns false . Examples iex&gt; Keyword . keyword? ( [ ] ) true iex&gt; Keyword . keyword? ( a : 1 ) true iex&gt; Keyword . keyword? ( [ { Foo , 1 } ] ) true iex&gt; Keyword . keyword? ( [ { } ] ) false iex&gt; Keyword . keyword? ( [ :key ] ) false iex&gt; Keyword . keyword? ( %{ } ) false","ref":"Keyword.html#keyword?/1","title":"Keyword.keyword?/1","type":"function"},{"doc":"Merges two keyword lists into one. All keys, including duplicated keys, given in keywords2 will be added to keywords1 , overriding any existing one. There are no guarantees about the order of keys in the returned keyword. Examples iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 ] ) [ b : 2 , a : 3 , d : 4 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 , a : 5 ] ) [ b : 2 , a : 3 , d : 4 , a : 5 ] iex&gt; Keyword . merge ( [ a : 1 ] , [ 2 , 3 ] ) ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]","ref":"Keyword.html#merge/2","title":"Keyword.merge/2","type":"function"},{"doc":"Merges two keyword lists into one. All keys, including duplicated keys, given in keywords2 will be added to keywords1 . The given function will be invoked to solve conflicts. If keywords2 has duplicate keys, the given function will be invoked for each matching pair in keywords1 . There are no guarantees about the order of keys in the returned keyword. Examples iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 ] , fn _k , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) [ b : 2 , a : 4 , d : 4 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 , a : 5 ] , fn :a , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) [ b : 2 , a : 4 , d : 4 , a : 5 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 , a : 3 ] , [ a : 3 , d : 4 , a : 5 ] , fn :a , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) [ b : 2 , a : 4 , d : 4 , a : 8 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ :a , :b ] , fn :a , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]","ref":"Keyword.html#merge/3","title":"Keyword.merge/3","type":"function"},{"doc":"Returns an empty keyword list, i.e. an empty list. Examples iex&gt; Keyword . new ( ) [ ]","ref":"Keyword.html#new/0","title":"Keyword.new/0","type":"function"},{"doc":"Creates a keyword list from an enumerable. Duplicated entries are removed, the latest one prevails. Unlike Enum.into(enumerable, []) , Keyword.new(enumerable) guarantees the keys are unique. Examples iex&gt; Keyword . new ( [ { :b , 1 } , { :a , 2 } ] ) [ b : 1 , a : 2 ] iex&gt; Keyword . new ( [ { :a , 1 } , { :a , 2 } , { :a , 3 } ] ) [ a : 3 ]","ref":"Keyword.html#new/1","title":"Keyword.new/1","type":"function"},{"doc":"Creates a keyword list from an enumerable via the transformation function. Duplicated entries are removed, the latest one prevails. Unlike Enum.into(enumerable, [], fun) , Keyword.new(enumerable, fun) guarantees the keys are unique. Examples iex&gt; Keyword . new ( [ :a , :b ] , fn x -&gt; { x , x } end ) [ a : :a , b : :b ]","ref":"Keyword.html#new/2","title":"Keyword.new/2","type":"function"},{"doc":"Returns the first value for key and removes all associated entries in the keyword list. It returns a tuple where the first element is the first value for key and the second element is a keyword list with all entries associated with key removed. If the key is not present in the keyword list, {default, keyword_list} is returned. If you don't want to remove all the entries associated with key use pop_first/3 instead, that function will remove only the first entry. Examples iex&gt; Keyword . pop ( [ a : 1 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop ( [ a : 1 ] , :b ) { nil , [ a : 1 ] } iex&gt; Keyword . pop ( [ a : 1 ] , :b , 3 ) { 3 , [ a : 1 ] } iex&gt; Keyword . pop ( [ a : 1 , a : 2 ] , :a ) { 1 , [ ] }","ref":"Keyword.html#pop/3","title":"Keyword.pop/3","type":"function"},{"doc":"Returns the first value for key and removes all associated entries in the keyword list, raising if key is not present. This function behaves like pop/3 , but raises in cases the key is not present in the given keywords . Examples iex&gt; Keyword . pop! ( [ a : 1 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop! ( [ a : 1 , a : 2 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop! ( [ a : 1 ] , :b ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#pop!/2","title":"Keyword.pop!/2","type":"function"},{"doc":"Returns and removes the first value associated with key in the keyword list. Duplicated keys are not removed. Examples iex&gt; Keyword . pop_first ( [ a : 1 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop_first ( [ a : 1 ] , :b ) { nil , [ a : 1 ] } iex&gt; Keyword . pop_first ( [ a : 1 ] , :b , 3 ) { 3 , [ a : 1 ] } iex&gt; Keyword . pop_first ( [ a : 1 , a : 2 ] , :a ) { 1 , [ a : 2 ] }","ref":"Keyword.html#pop_first/3","title":"Keyword.pop_first/3","type":"function"},{"doc":"Lazily returns and removes all values associated with key in the keyword list. This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again. All duplicated keys are removed. See pop_first/3 for removing only the first entry. Examples iex&gt; keyword = [ a : 1 ] iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Keyword . pop_lazy ( keyword , :a , fun ) { 1 , [ ] } iex&gt; Keyword . pop_lazy ( keyword , :b , fun ) { 13 , [ a : 1 ] }","ref":"Keyword.html#pop_lazy/3","title":"Keyword.pop_lazy/3","type":"function"},{"doc":"Returns all values for key and removes all associated entries in the keyword list. It returns a tuple where the first element is a list of values for key and the second element is a keyword list with all entries associated with key removed. If the key is not present in the keyword list, {[], keyword_list} is returned. If you don't want to remove all the entries associated with key use pop_first/3 instead, that function will remove only the first entry. Examples iex&gt; Keyword . pop_values ( [ a : 1 ] , :a ) { [ 1 ] , [ ] } iex&gt; Keyword . pop_values ( [ a : 1 ] , :b ) { [ ] , [ a : 1 ] } iex&gt; Keyword . pop_values ( [ a : 1 , a : 2 ] , :a ) { [ 1 , 2 ] , [ ] }","ref":"Keyword.html#pop_values/2","title":"Keyword.pop_values/2","type":"function"},{"doc":"Puts the given value under key . If a previous value is already stored, all entries are removed and the value is overridden. Examples iex&gt; Keyword . put ( [ a : 1 ] , :b , 2 ) [ b : 2 , a : 1 ] iex&gt; Keyword . put ( [ a : 1 , b : 2 ] , :a , 3 ) [ a : 3 , b : 2 ] iex&gt; Keyword . put ( [ a : 1 , b : 2 , a : 4 ] , :a , 3 ) [ a : 3 , b : 2 ]","ref":"Keyword.html#put/3","title":"Keyword.put/3","type":"function"},{"doc":"Puts the given value under key unless the entry key already exists. Examples iex&gt; Keyword . put_new ( [ a : 1 ] , :b , 2 ) [ b : 2 , a : 1 ] iex&gt; Keyword . put_new ( [ a : 1 , b : 2 ] , :a , 3 ) [ a : 1 , b : 2 ]","ref":"Keyword.html#put_new/3","title":"Keyword.put_new/3","type":"function"},{"doc":"Evaluates fun and puts the result under key in keyword list unless key is already present. This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; keyword = [ a : 1 ] iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 3 ...&gt; end iex&gt; Keyword . put_new_lazy ( keyword , :a , fun ) [ a : 1 ] iex&gt; Keyword . put_new_lazy ( keyword , :b , fun ) [ b : 3 , a : 1 ]","ref":"Keyword.html#put_new_lazy/3","title":"Keyword.put_new_lazy/3","type":"function"},{"doc":"Puts a value under key only if the key already exists in keywords . In the case a value is stored multiple times in the keyword list, later occurrences are removed. Examples iex&gt; Keyword . replace ( [ a : 1 , b : 2 , a : 4 ] , :a , 3 ) [ a : 3 , b : 2 ] iex&gt; Keyword . replace ( [ a : 1 ] , :b , 2 ) [ a : 1 ]","ref":"Keyword.html#replace/3","title":"Keyword.replace/3","type":"function"},{"doc":"Puts a value under key only if the key already exists in keywords . If key is not present in keywords , a KeyError exception is raised. Examples iex&gt; Keyword . replace! ( [ a : 1 , b : 2 , a : 3 ] , :a , :new ) [ a : :new , b : 2 ] iex&gt; Keyword . replace! ( [ a : 1 , b : 2 , c : 3 , b : 4 ] , :b , :new ) [ a : 1 , b : :new , c : 3 ] iex&gt; Keyword . replace! ( [ a : 1 ] , :b , 2 ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#replace!/3","title":"Keyword.replace!/3","type":"function"},{"doc":"Takes all entries corresponding to the given keys and extracts them into a separate keyword list. Returns a tuple with the new list and the old list with removed keys. Keys for which there are no entries in the keyword list are ignored. Entries with duplicated keys end up in the same keyword list. Examples iex&gt; Keyword . split ( [ a : 1 , b : 2 , c : 3 ] , [ :a , :c , :e ] ) { [ a : 1 , c : 3 ] , [ b : 2 ] } iex&gt; Keyword . split ( [ a : 1 , b : 2 , c : 3 , a : 4 ] , [ :a , :c , :e ] ) { [ a : 1 , c : 3 , a : 4 ] , [ b : 2 ] }","ref":"Keyword.html#split/2","title":"Keyword.split/2","type":"function"},{"doc":"Takes all entries corresponding to the given keys and returns them in a new keyword list. Duplicated keys are preserved in the new keyword list. Examples iex&gt; Keyword . take ( [ a : 1 , b : 2 , c : 3 ] , [ :a , :c , :e ] ) [ a : 1 , c : 3 ] iex&gt; Keyword . take ( [ a : 1 , b : 2 , c : 3 , a : 5 ] , [ :a , :c , :e ] ) [ a : 1 , c : 3 , a : 5 ]","ref":"Keyword.html#take/2","title":"Keyword.take/2","type":"function"},{"doc":"Returns the keyword list itself. Examples iex&gt; Keyword . to_list ( a : 1 ) [ a : 1 ]","ref":"Keyword.html#to_list/1","title":"Keyword.to_list/1","type":"function"},{"doc":"Updates the key in keywords with the given function. If the key does not exist, it inserts the given default value. If there are duplicated keys, they are all removed and only the first one is updated. The default value will not be passed through the update function. Examples iex&gt; Keyword . update ( [ a : 1 ] , :a , 13 , fn existing_value -&gt; existing_value * 2 end ) [ a : 2 ] iex&gt; Keyword . update ( [ a : 1 , a : 2 ] , :a , 13 , fn existing_value -&gt; existing_value * 2 end ) [ a : 2 ] iex&gt; Keyword . update ( [ a : 1 ] , :b , 11 , fn existing_value -&gt; existing_value * 2 end ) [ a : 1 , b : 11 ]","ref":"Keyword.html#update/4","title":"Keyword.update/4","type":"function"},{"doc":"Updates the key with the given function. If the key does not exist, raises KeyError . If there are duplicated keys, they are all removed and only the first one is updated. Examples iex&gt; Keyword . update! ( [ a : 1 , b : 2 , a : 3 ] , :a , &amp; ( &amp;1 * 2 ) ) [ a : 2 , b : 2 ] iex&gt; Keyword . update! ( [ a : 1 , b : 2 , c : 3 ] , :b , &amp; ( &amp;1 * 2 ) ) [ a : 1 , b : 4 , c : 3 ] iex&gt; Keyword . update! ( [ a : 1 ] , :b , &amp; ( &amp;1 * 2 ) ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#update!/3","title":"Keyword.update!/3","type":"function"},{"doc":"Returns all values from the keyword list. Values from duplicated keys will be kept in the final list of values. Examples iex&gt; Keyword . values ( a : 1 , b : 2 ) [ 1 , 2 ] iex&gt; Keyword . values ( a : 1 , b : 2 , a : 3 ) [ 1 , 2 , 3 ]","ref":"Keyword.html#values/1","title":"Keyword.values/1","type":"function"},{"doc":"","ref":"Keyword.html#t:key/0","title":"Keyword.key/0","type":"type"},{"doc":"","ref":"Keyword.html#t:t/0","title":"Keyword.t/0","type":"type"},{"doc":"","ref":"Keyword.html#t:t/1","title":"Keyword.t/1","type":"type"},{"doc":"","ref":"Keyword.html#t:value/0","title":"Keyword.value/0","type":"type"},{"doc":"Linked lists hold zero, one, or more elements in the chosen order. Lists in Elixir are specified between square brackets: iex&gt; [ 1 , &quot;two&quot; , 3 , :four ] [ 1 , &quot;two&quot; , 3 , :four ] Two lists can be concatenated and subtracted using the Kernel.++/2 and Kernel.--/2 operators: iex&gt; [ 1 , 2 , 3 ] ++ [ 4 , 5 , 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; [ 1 , true , 2 , false , 3 , true ] -- [ true , false ] [ 1 , 2 , 3 , true ] An element can be prepended to a list using | : iex&gt; new = 0 iex&gt; list = [ 1 , 2 , 3 ] iex&gt; [ new | list ] [ 0 , 1 , 2 , 3 ] Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list: iex&gt; [ head | tail ] = [ 1 , 2 , 3 ] iex&gt; head 1 iex&gt; tail [ 2 , 3 ] Similarly, we could write the list [1, 2, 3] using only such pairs (called cons cells): iex&gt; [ 1 | [ 2 | [ 3 | [ ] ] ] ] [ 1 , 2 , 3 ] Some lists, called improper lists, do not have an empty list as the second element in the last cons cell: iex&gt; [ 1 | [ 2 | [ 3 | 4 ] ] ] [ 1 , 2 , 3 | 4 ] Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the IO module). Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time): iex&gt; list = [ 1 , 2 , 3 ] iex&gt; [ 0 | list ] # fast [ 0 , 1 , 2 , 3 ] iex&gt; list ++ [ 4 ] # slow [ 1 , 2 , 3 , 4 ] Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example length/1 and last/1 will run in linear time because they need to iterate through every element of the list, but first/1 will run in constant time because it only needs the first element. Lists also implement the Enumerable protocol, so many functions to work with lists are found in the Enum module. Additionally, the following functions and operators for lists are found in Kernel : ++/2 --/2 hd/1 tl/1 in/2 length/1 Charlists If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must: be within the range 0..0x10FFFF ( 0..1_114_111 ); and be out of the range 0xD800..0xDFFF ( 55_296..57_343 ), which is reserved in Unicode for UTF-16 surrogate pairs. Elixir uses single quotes to define charlists: iex&gt; &#39;héllo&#39; [ 104 , 233 , 108 , 108 , 111 ] In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters: iex&gt; &#39;abc&#39; &#39;abc&#39; Even though the representation changed, the raw data does remain a list of numbers, which can be handled as such: iex&gt; inspect ( &#39;abc&#39; , charlists : :as_list ) &quot;[97, 98, 99]&quot; iex&gt; Enum . map ( &#39;abc&#39; , fn num -&gt; 1000 + num end ) [ 1097 , 1098 , 1099 ] You can use the IEx.Helpers.i/1 helper to get a condensed rundown on charlists in IEx when you encounter them, which shows you the type, description and also the raw representation in one single summary. The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is Application.loaded_applications/0 : Application . loaded_applications ( ) #=&gt; [ #=&gt; {:stdlib, &#39;ERTS CXC 138 10&#39;, &#39;2.6&#39;}, #=&gt; {:compiler, &#39;ERTS CXC 138 10&#39;, &#39;6.0.1&#39;}, #=&gt; {:elixir, &#39;elixir&#39;, &#39;1.0.0&#39;}, #=&gt; {:kernel, &#39;ERTS CXC 138 10&#39;, &#39;4.1&#39;}, #=&gt; {:logger, &#39;logger&#39;, &#39;1.0.0&#39;} #=&gt; ] A list can be checked if it is made of only printable ASCII characters with ascii_printable?/2 . Improper lists are never deemed as charlists.","ref":"List.html","title":"List","type":"module"},{"doc":"Checks if list is a charlist made only of printable ASCII characters. Takes an optional limit as a second argument. ascii_printable?/2 only checks the printability of the list up to the limit . A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters: ?\\a - Bell ?\\b - Backspace ?\\t - Horizontal tab ?\\n - Line feed ?\\v - Vertical tab ?\\f - Form feed ?\\r - Carriage return ?\\e - Escape For more information read the Character groups section in the Wikipedia article of the ASCII standard. Examples iex&gt; List . ascii_printable? ( &#39;abc&#39; ) true iex&gt; List . ascii_printable? ( &#39;abc&#39; ++ [ 0 ] ) false iex&gt; List . ascii_printable? ( &#39;abc&#39; ++ [ 0 ] , 2 ) true Improper lists are not printable, even if made only of ASCII characters: iex&gt; List . ascii_printable? ( &#39;abc&#39; ++ ?d ) false","ref":"List.html#ascii_printable?/2","title":"List.ascii_printable?/2","type":"function"},{"doc":"Deletes the given element from the list . Returns a new list without the element. If the element occurs more than once in the list , just the first occurrence is removed. Examples iex&gt; List . delete ( [ :a , :b , :c ] , :a ) [ :b , :c ] iex&gt; List . delete ( [ :a , :b , :c ] , :d ) [ :a , :b , :c ] iex&gt; List . delete ( [ :a , :b , :b , :c ] , :b ) [ :a , :b , :c ] iex&gt; List . delete ( [ ] , :b ) [ ]","ref":"List.html#delete/2","title":"List.delete/2","type":"function"},{"doc":"Produces a new list by removing the value at the specified index . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . delete_at ( [ 1 , 2 , 3 ] , 0 ) [ 2 , 3 ] iex&gt; List . delete_at ( [ 1 , 2 , 3 ] , 10 ) [ 1 , 2 , 3 ] iex&gt; List . delete_at ( [ 1 , 2 , 3 ] , - 1 ) [ 1 , 2 ]","ref":"List.html#delete_at/2","title":"List.delete_at/2","type":"function"},{"doc":"Duplicates the given element n times in a list. n is an integer greater than or equal to 0 . If n is 0 , an empty list is returned. Examples iex&gt; List . duplicate ( &quot;hello&quot; , 0 ) [ ] iex&gt; List . duplicate ( &quot;hi&quot; , 1 ) [ &quot;hi&quot; ] iex&gt; List . duplicate ( &quot;bye&quot; , 2 ) [ &quot;bye&quot; , &quot;bye&quot; ] iex&gt; List . duplicate ( [ 1 , 2 ] , 3 ) [ [ 1 , 2 ] , [ 1 , 2 ] , [ 1 , 2 ] ]","ref":"List.html#duplicate/2","title":"List.duplicate/2","type":"function"},{"doc":"Returns the first element in list or default if list is empty. first/2 has been introduced in Elixir v1.12.0, while first/1 has been available since v1.0.0. Examples iex&gt; List . first ( [ ] ) nil iex&gt; List . first ( [ ] , 1 ) 1 iex&gt; List . first ( [ 1 ] ) 1 iex&gt; List . first ( [ 1 , 2 , 3 ] ) 1","ref":"List.html#first/2","title":"List.first/2","type":"function"},{"doc":"Flattens the given list of nested lists. Empty list elements are discarded. Examples iex&gt; List . flatten ( [ 1 , [ [ 2 ] , 3 ] ] ) [ 1 , 2 , 3 ] iex&gt; List . flatten ( [ [ ] , [ [ ] , [ ] ] ] ) [ ]","ref":"List.html#flatten/1","title":"List.flatten/1","type":"function"},{"doc":"Flattens the given list of nested lists. The list tail will be added at the end of the flattened list. Empty list elements from list are discarded, but not the ones from tail . Examples iex&gt; List . flatten ( [ 1 , [ [ 2 ] , 3 ] ] , [ 4 , 5 ] ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; List . flatten ( [ 1 , [ ] , 2 ] , [ 3 , [ ] , 4 ] ) [ 1 , 2 , 3 , [ ] , 4 ]","ref":"List.html#flatten/2","title":"List.flatten/2","type":"function"},{"doc":"Folds (reduces) the given list from the left with a function. Requires an accumulator. Examples iex&gt; List . foldl ( [ 5 , 5 ] , 10 , fn x , acc -&gt; x + acc end ) 20 iex&gt; List . foldl ( [ 1 , 2 , 3 , 4 ] , 0 , fn x , acc -&gt; x - acc end ) 2","ref":"List.html#foldl/3","title":"List.foldl/3","type":"function"},{"doc":"Folds (reduces) the given list from the right with a function. Requires an accumulator. Examples iex&gt; List . foldr ( [ 1 , 2 , 3 , 4 ] , 0 , fn x , acc -&gt; x - acc end ) - 2","ref":"List.html#foldr/3","title":"List.foldr/3","type":"function"},{"doc":"Returns true if list is an improper list. Otherwise returns false . Examples iex&gt; List . improper? ( [ 1 , 2 | 3 ] ) true iex&gt; List . improper? ( [ 1 , 2 , 3 ] ) false","ref":"List.html#improper?/1","title":"List.improper?/1","type":"function"},{"doc":"Returns a list with value inserted at the specified index . Note that index is capped at the list length. Negative indices indicate an offset from the end of the list . Examples iex&gt; List . insert_at ( [ 1 , 2 , 3 , 4 ] , 2 , 0 ) [ 1 , 2 , 0 , 3 , 4 ] iex&gt; List . insert_at ( [ 1 , 2 , 3 ] , 10 , 0 ) [ 1 , 2 , 3 , 0 ] iex&gt; List . insert_at ( [ 1 , 2 , 3 ] , - 1 , 0 ) [ 1 , 2 , 3 , 0 ] iex&gt; List . insert_at ( [ 1 , 2 , 3 ] , - 10 , 0 ) [ 0 , 1 , 2 , 3 ]","ref":"List.html#insert_at/3","title":"List.insert_at/3","type":"function"},{"doc":"Receives a list of tuples and deletes the first tuple where the element at position matches the given key . Returns the new list. Examples iex&gt; List . keydelete ( [ a : 1 , b : 2 ] , :a , 0 ) [ b : 2 ] iex&gt; List . keydelete ( [ a : 1 , b : 2 ] , 2 , 1 ) [ a : 1 ] iex&gt; List . keydelete ( [ a : 1 , b : 2 ] , :c , 0 ) [ a : 1 , b : 2 ]","ref":"List.html#keydelete/3","title":"List.keydelete/3","type":"function"},{"doc":"Receives a list of tuples and returns the first tuple where the element at position in the tuple matches the given key . If no matching tuple is found, default is returned. Examples iex&gt; List . keyfind ( [ a : 1 , b : 2 ] , :a , 0 ) { :a , 1 } iex&gt; List . keyfind ( [ a : 1 , b : 2 ] , 2 , 1 ) { :b , 2 } iex&gt; List . keyfind ( [ a : 1 , b : 2 ] , :c , 0 ) nil","ref":"List.html#keyfind/4","title":"List.keyfind/4","type":"function"},{"doc":"Receives a list of tuples and returns true if there is a tuple where the element at position in the tuple matches the given key . Examples iex&gt; List . keymember? ( [ a : 1 , b : 2 ] , :a , 0 ) true iex&gt; List . keymember? ( [ a : 1 , b : 2 ] , 2 , 1 ) true iex&gt; List . keymember? ( [ a : 1 , b : 2 ] , :c , 0 ) false","ref":"List.html#keymember?/3","title":"List.keymember?/3","type":"function"},{"doc":"Receives a list of tuples and if the identified element by key at position exists, it is replaced with new_tuple . Examples iex&gt; List . keyreplace ( [ a : 1 , b : 2 ] , :a , 0 , { :a , 3 } ) [ a : 3 , b : 2 ] iex&gt; List . keyreplace ( [ a : 1 , b : 2 ] , :a , 1 , { :a , 3 } ) [ a : 1 , b : 2 ]","ref":"List.html#keyreplace/4","title":"List.keyreplace/4","type":"function"},{"doc":"Receives a list of tuples and sorts the elements at position of the tuples. The sort is stable. Examples iex&gt; List . keysort ( [ a : 5 , b : 1 , c : 3 ] , 1 ) [ b : 1 , c : 3 , a : 5 ] iex&gt; List . keysort ( [ a : 5 , c : 1 , b : 3 ] , 0 ) [ a : 5 , b : 3 , c : 1 ]","ref":"List.html#keysort/2","title":"List.keysort/2","type":"function"},{"doc":"Receives a list of tuples and replaces the element identified by key at position with new_tuple . If the element does not exist, it is added to the end of the list . Examples iex&gt; List . keystore ( [ a : 1 , b : 2 ] , :a , 0 , { :a , 3 } ) [ a : 3 , b : 2 ] iex&gt; List . keystore ( [ a : 1 , b : 2 ] , :c , 0 , { :c , 3 } ) [ a : 1 , b : 2 , c : 3 ]","ref":"List.html#keystore/4","title":"List.keystore/4","type":"function"},{"doc":"Receives a list of tuples and returns the first tuple where the element at position in the tuple matches the given key , as well as the list without found tuple. If such a tuple is not found, nil will be returned. Examples iex&gt; List . keytake ( [ a : 1 , b : 2 ] , :a , 0 ) { { :a , 1 } , [ b : 2 ] } iex&gt; List . keytake ( [ a : 1 , b : 2 ] , 2 , 1 ) { { :b , 2 } , [ a : 1 ] } iex&gt; List . keytake ( [ a : 1 , b : 2 ] , :c , 0 ) nil","ref":"List.html#keytake/3","title":"List.keytake/3","type":"function"},{"doc":"Returns the last element in list or default if list is empty. last/2 has been introduced in Elixir v1.12.0, while last/1 has been available since v1.0.0. Examples iex&gt; List . last ( [ ] ) nil iex&gt; List . last ( [ ] , 1 ) 1 iex&gt; List . last ( [ 1 ] ) 1 iex&gt; List . last ( [ 1 , 2 , 3 ] ) 3","ref":"List.html#last/2","title":"List.last/2","type":"function"},{"doc":"Returns a keyword list that represents an edit script . The algorithm is outlined in the &quot;An O(ND) Difference Algorithm and Its Variations&quot; paper by E. Myers. An edit script is a keyword list. Each key describes the &quot;editing action&quot; to take in order to bring list1 closer to being equal to list2 ; a key can be :eq , :ins , or :del . Each value is a sublist of either list1 or list2 that should be inserted (if the corresponding key :ins ), deleted (if the corresponding key is :del ), or left alone (if the corresponding key is :eq ) in list1 in order to be closer to list2 . See myers_difference/3 if you want to handle nesting in the diff scripts. Examples iex&gt; List . myers_difference ( [ 1 , 4 , 2 , 3 ] , [ 1 , 2 , 3 , 4 ] ) [ eq : [ 1 ] , del : [ 4 ] , eq : [ 2 , 3 ] , ins : [ 4 ] ]","ref":"List.html#myers_difference/2","title":"List.myers_difference/2","type":"function"},{"doc":"Returns a keyword list that represents an edit script with nested diffs. This is an extension of myers_difference/2 where a diff_script function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or nil in case there is no such script. The returned inner edit script will be under the :diff key. Examples iex&gt; List . myers_difference ( [ &quot;a&quot; , &quot;db&quot; , &quot;c&quot; ] , [ &quot;a&quot; , &quot;bc&quot; ] , &amp; String . myers_difference / 2 ) [ eq : [ &quot;a&quot; ] , diff : [ del : &quot;d&quot; , eq : &quot;b&quot; , ins : &quot;c&quot; ] , del : [ &quot;c&quot; ] ]","ref":"List.html#myers_difference/3","title":"List.myers_difference/3","type":"function"},{"doc":"Returns and removes the value at the specified index in the list . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , 0 ) { 1 , [ 2 , 3 ] } iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , 5 ) { nil , [ 1 , 2 , 3 ] } iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , 5 , 10 ) { 10 , [ 1 , 2 , 3 ] } iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , - 1 ) { 3 , [ 1 , 2 ] }","ref":"List.html#pop_at/3","title":"List.pop_at/3","type":"function"},{"doc":"Returns a list with a replaced value at the specified index . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , 0 , 0 ) [ 0 , 2 , 3 ] iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , 10 , 0 ) [ 1 , 2 , 3 ] iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , - 1 , 0 ) [ 1 , 2 , 0 ] iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , - 10 , 0 ) [ 1 , 2 , 3 ]","ref":"List.html#replace_at/3","title":"List.replace_at/3","type":"function"},{"doc":"Returns true if list starts with the given prefix list; otherwise returns false . If prefix is an empty list, it returns true . Examples iex&gt; List . starts_with? ( [ 1 , 2 , 3 ] , [ 1 , 2 ] ) true iex&gt; List . starts_with? ( [ 1 , 2 ] , [ 1 , 2 , 3 ] ) false iex&gt; List . starts_with? ( [ :alpha ] , [ ] ) true iex&gt; List . starts_with? ( [ ] , [ :alpha ] ) false","ref":"List.html#starts_with?/2","title":"List.starts_with?/2","type":"function"},{"doc":"Converts a charlist to an atom. Elixir supports conversions from charlists which contains any Unicode code point. Inlined by the compiler. Examples iex&gt; List . to_atom ( &#39;Elixir&#39; ) :Elixir iex&gt; List . to_atom ( &#39;🌢 Elixir&#39; ) :&quot;🌢 Elixir&quot;","ref":"List.html#to_atom/1","title":"List.to_atom/1","type":"function"},{"doc":"Converts a list of integers representing Unicode code points, lists or strings into a charlist. Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the :binary module . Examples iex&gt; List . to_charlist ( [ 0x00E6 , 0x00DF ] ) &#39;æß&#39; iex&gt; List . to_charlist ( [ 0x0061 , &quot;bc&quot; ] ) &#39;abc&#39; iex&gt; List . to_charlist ( [ 0x0064 , &quot;ee&quot; , [ &#39;p&#39; ] ] ) &#39;deep&#39;","ref":"List.html#to_charlist/1","title":"List.to_charlist/1","type":"function"},{"doc":"Converts a charlist to an existing atom. Raises an ArgumentError if the atom does not exist. Elixir supports conversions from charlists which contains any Unicode code point. Inlined by the compiler. Examples iex&gt; _ = :my_atom iex&gt; List . to_existing_atom ( &#39;my_atom&#39; ) :my_atom iex&gt; _ = :&quot;🌢 Elixir&quot; iex&gt; List . to_existing_atom ( &#39;🌢 Elixir&#39; ) :&quot;🌢 Elixir&quot;","ref":"List.html#to_existing_atom/1","title":"List.to_existing_atom/1","type":"function"},{"doc":"Returns the float whose text representation is charlist . Inlined by the compiler. Examples iex&gt; List . to_float ( &#39;2.2017764e+0&#39; ) 2.2017764","ref":"List.html#to_float/1","title":"List.to_float/1","type":"function"},{"doc":"Returns an integer whose text representation is charlist . Inlined by the compiler. Examples iex&gt; List . to_integer ( &#39;123&#39; ) 123","ref":"List.html#to_integer/1","title":"List.to_integer/1","type":"function"},{"doc":"Returns an integer whose text representation is charlist in base base . Inlined by the compiler. The base needs to be between 2 and 36 . Examples iex&gt; List . to_integer ( &#39;3FF&#39; , 16 ) 1023","ref":"List.html#to_integer/2","title":"List.to_integer/2","type":"function"},{"doc":"Converts a list of integers representing code points, lists or strings into a string. To be converted to a string, a list must either be empty or only contain the following elements: strings integers representing Unicode code points a list containing one of these three elements Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the :binary module . Examples iex&gt; List . to_string ( [ 0x00E6 , 0x00DF ] ) &quot;æß&quot; iex&gt; List . to_string ( [ 0x0061 , &quot;bc&quot; ] ) &quot;abc&quot; iex&gt; List . to_string ( [ 0x0064 , &quot;ee&quot; , [ &#39;p&#39; ] ] ) &quot;deep&quot; iex&gt; List . to_string ( [ ] ) &quot;&quot;","ref":"List.html#to_string/1","title":"List.to_string/1","type":"function"},{"doc":"Converts a list to a tuple. Inlined by the compiler. Examples iex&gt; List . to_tuple ( [ :share , [ :elixir , 163 ] ] ) { :share , [ :elixir , 163 ] }","ref":"List.html#to_tuple/1","title":"List.to_tuple/1","type":"function"},{"doc":"Returns a list with an updated value at the specified index . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . update_at ( [ 1 , 2 , 3 ] , 0 , &amp; ( &amp;1 + 10 ) ) [ 11 , 2 , 3 ] iex&gt; List . update_at ( [ 1 , 2 , 3 ] , 10 , &amp; ( &amp;1 + 10 ) ) [ 1 , 2 , 3 ] iex&gt; List . update_at ( [ 1 , 2 , 3 ] , - 1 , &amp; ( &amp;1 + 10 ) ) [ 1 , 2 , 13 ] iex&gt; List . update_at ( [ 1 , 2 , 3 ] , - 10 , &amp; ( &amp;1 + 10 ) ) [ 1 , 2 , 3 ]","ref":"List.html#update_at/3","title":"List.update_at/3","type":"function"},{"doc":"Wraps term in a list if this is not list. If term is already a list, it returns the list. If term is nil , it returns an empty list. Examples iex&gt; List . wrap ( &quot;hello&quot; ) [ &quot;hello&quot; ] iex&gt; List . wrap ( [ 1 , 2 , 3 ] ) [ 1 , 2 , 3 ] iex&gt; List . wrap ( nil ) [ ]","ref":"List.html#wrap/1","title":"List.wrap/1","type":"function"},{"doc":"Zips corresponding elements from each list in list_of_lists . The zipping finishes as soon as any list terminates. Examples iex&gt; List . zip ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) [ { 1 , 3 , 5 } , { 2 , 4 , 6 } ] iex&gt; List . zip ( [ [ 1 , 2 ] , [ 3 ] , [ 5 , 6 ] ] ) [ { 1 , 3 , 5 } ]","ref":"List.html#zip/1","title":"List.zip/1","type":"function"},{"doc":"Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the %{} syntax, and key-value pairs can be expressed as key =&gt; value : iex&gt; %{ } %{ } iex&gt; %{ &quot;one&quot; = &gt; :two , 3 = &gt; &quot;four&quot; } %{ 3 = &gt; &quot;four&quot; , &quot;one&quot; = &gt; :two } Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created). Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator ( ===/2 ). If colliding keys are defined in a map literal, the last one prevails. When the key in a key-value pair is an atom, the key: value shorthand syntax can be used (as in many other special forms): iex&gt; %{ a : 1 , b : 2 } %{ a : 1 , b : 2 } If you want to mix the shorthand syntax with =&gt; , the shorthand syntax must come at the end: iex&gt; %{ &quot;hello&quot; = &gt; &quot;world&quot; , a : 1 , b : 2 } %{ :a = &gt; 1 , :b = &gt; 2 , &quot;hello&quot; = &gt; &quot;world&quot; } Keys in maps can be accessed through some of the functions in this module (such as Map.get/3 or Map.fetch/2 ) or through the map[] syntax provided by the Access module: iex&gt; map = %{ a : 1 , b : 2 } iex&gt; Map . fetch ( map , :a ) { :ok , 1 } iex&gt; map [ :b ] 2 iex&gt; map [ &quot;non_existing_key&quot; ] nil To access atom keys, one may also use the map.key notation. Note that map.key will raise a KeyError if the map doesn't contain the key :key , compared to map[:key] , that would return nil . map = %{ foo : &quot;bar&quot; , baz : &quot;bong&quot; } map . foo #=&gt; &quot;bar&quot; map . non_existing_key ** (KeyError) key :non_existing_key not found in: %{baz: &quot;bong&quot;, foo: &quot;bar&quot;} Note: do not add parens when accessing fields, such as in data.key() . If parenthesis are used, Elixir will expect data to be an atom representing a module and attempt to call the function key/0 in it. The two syntaxes for accessing keys reveal the dual nature of maps. The map[key] syntax is used for dynamically created maps that may have any key, of any type. map.key is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via defstruct/1 , are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time. Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map. iex&gt; %{ } = %{ foo : &quot;bar&quot; } %{ foo : &quot;bar&quot; } iex&gt; %{ a : a } = %{ :a = &gt; 1 , &quot;b&quot; = &gt; 2 , [ :c , :e , :e ] = &gt; 3 } iex&gt; a 1 But this will raise a MatchError exception: %{ :c = &gt; 3 } = %{ :a = &gt; 1 , 2 = &gt; :b } Variables can be used as map keys both when writing map literals as well as when matching: iex&gt; n = 1 1 iex&gt; %{ n = &gt; :one } %{ 1 = &gt; :one } iex&gt; %{ ^ n = &gt; :one } = %{ 1 = &gt; :one , 2 = &gt; :two , 3 = &gt; :three } %{ 1 = &gt; :one , 2 = &gt; :two , 3 = &gt; :three } Maps also support a specific update syntax to update the value stored under existing atom keys: iex&gt; map = %{ one : 1 , two : 2 } iex&gt; %{ map | one : &quot;one&quot; } %{ one : &quot;one&quot; , two : 2 } When a key that does not exist in the map is updated a KeyError exception will be raised: %{ map | three : 3 } The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as keys/1 and values/1 , run in linear time because they need to get to every element in the map. Maps also implement the Enumerable protocol, so many functions to work with maps are found in the Enum module. Additionally, the following functions for maps are found in Kernel : map_size/1","ref":"Map.html","title":"Map","type":"module"},{"doc":"Deletes the entry in map for a specific key . If the key does not exist, returns map unchanged. Inlined by the compiler. Examples iex&gt; Map . delete ( %{ a : 1 , b : 2 } , :a ) %{ b : 2 } iex&gt; Map . delete ( %{ b : 2 } , :a ) %{ b : 2 }","ref":"Map.html#delete/2","title":"Map.delete/2","type":"function"},{"doc":"Drops the given keys from map . If keys contains keys that are not in map , they're simply ignored. Examples iex&gt; Map . drop ( %{ a : 1 , b : 2 , c : 3 } , [ :b , :d ] ) %{ a : 1 , c : 3 }","ref":"Map.html#drop/2","title":"Map.drop/2","type":"function"},{"doc":"Checks if two maps are equal. Two maps are considered to be equal if they contain the same keys and those keys contain the same values. Note this function exists for completeness so the Map and Keyword modules provide similar APIs. In practice, developers often compare maps using ==/2 or ===/2 directly. Examples iex&gt; Map . equal? ( %{ a : 1 , b : 2 } , %{ b : 2 , a : 1 } ) true iex&gt; Map . equal? ( %{ a : 1 , b : 2 } , %{ b : 1 , a : 2 } ) false Comparison between keys and values is done with ===/3 , which means integers are not equivalent to floats: iex&gt; Map . equal? ( %{ a : 1.0 } , %{ a : 1 } ) false","ref":"Map.html#equal?/2","title":"Map.equal?/2","type":"function"},{"doc":"Fetches the value for a specific key in the given map . If map contains the given key then its value is returned in the shape of {:ok, value} . If map doesn't contain key , :error is returned. Inlined by the compiler. Examples iex&gt; Map . fetch ( %{ a : 1 } , :a ) { :ok , 1 } iex&gt; Map . fetch ( %{ a : 1 } , :b ) :error","ref":"Map.html#fetch/2","title":"Map.fetch/2","type":"function"},{"doc":"Fetches the value for a specific key in the given map , erroring out if map doesn't contain key . If map contains key , the corresponding value is returned. If map doesn't contain key , a KeyError exception is raised. Inlined by the compiler. Examples iex&gt; Map . fetch! ( %{ a : 1 } , :a ) 1","ref":"Map.html#fetch!/2","title":"Map.fetch!/2","type":"function"},{"doc":"Converts a struct to map. It accepts the struct module or a struct itself and simply removes the __struct__ field from the given struct or from a new struct generated from the given module. Example defmodule User do defstruct [ :name ] end Map . from_struct ( User ) #=&gt; %{name: nil} Map . from_struct ( % User { name : &quot;john&quot; } ) #=&gt; %{name: &quot;john&quot;}","ref":"Map.html#from_struct/1","title":"Map.from_struct/1","type":"function"},{"doc":"Gets the value for a specific key in map . If key is present in map then its value value is returned. Otherwise, default is returned. If default is not provided, nil is used. Examples iex&gt; Map . get ( %{ } , :a ) nil iex&gt; Map . get ( %{ a : 1 } , :a ) 1 iex&gt; Map . get ( %{ a : 1 } , :b ) nil iex&gt; Map . get ( %{ a : 1 } , :b , 3 ) 3","ref":"Map.html#get/3","title":"Map.get/3","type":"function"},{"doc":"Gets the value from key and updates it, all in one pass. fun is called with the current value under key in map (or nil if key is not present in map ) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key in the resulting new map. fun may also return :pop , which means the current value shall be removed from map and returned (making this function behave like Map.pop(map, key) ). The returned value is a two-element tuple with the current value returned by fun and a new map with the updated value under key . Examples iex&gt; Map . get_and_update ( %{ a : 1 } , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , %{ a : &quot;new value!&quot; } } iex&gt; Map . get_and_update ( %{ a : 1 } , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { nil , %{ a : 1 , b : &quot;new value!&quot; } } iex&gt; Map . get_and_update ( %{ a : 1 } , :a , fn _ -&gt; :pop end ) { 1 , %{ } } iex&gt; Map . get_and_update ( %{ a : 1 } , :b , fn _ -&gt; :pop end ) { nil , %{ a : 1 } }","ref":"Map.html#get_and_update/3","title":"Map.get_and_update/3","type":"function"},{"doc":"Gets the value from key and updates it, all in one pass. Raises if there is no key . Behaves exactly like get_and_update/3 , but raises a KeyError exception if key is not present in map . Examples iex&gt; Map . get_and_update! ( %{ a : 1 } , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , %{ a : &quot;new value!&quot; } } iex&gt; Map . get_and_update! ( %{ a : 1 } , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) ** (KeyError) key :b not found in: %{a: 1} iex&gt; Map . get_and_update! ( %{ a : 1 } , :a , fn _ -&gt; ...&gt; :pop ...&gt; end ) { 1 , %{ } }","ref":"Map.html#get_and_update!/3","title":"Map.get_and_update!/3","type":"function"},{"doc":"Gets the value for a specific key in map . If key is present in map then its value value is returned. Otherwise, fun is evaluated and its result is returned. This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; map = %{ a : 1 } iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Map . get_lazy ( map , :a , fun ) 1 iex&gt; Map . get_lazy ( map , :b , fun ) 13","ref":"Map.html#get_lazy/3","title":"Map.get_lazy/3","type":"function"},{"doc":"Returns whether the given key exists in the given map . Inlined by the compiler. Examples iex&gt; Map . has_key? ( %{ a : 1 } , :a ) true iex&gt; Map . has_key? ( %{ a : 1 } , :b ) false","ref":"Map.html#has_key?/2","title":"Map.has_key?/2","type":"function"},{"doc":"Returns all keys from map . Inlined by the compiler. Examples iex&gt; Map . keys ( %{ a : 1 , b : 2 } ) [ :a , :b ]","ref":"Map.html#keys/1","title":"Map.keys/1","type":"function"},{"doc":"Merges two maps into one. All keys in map2 will be added to map1 , overriding any existing one (i.e., the keys in map2 &quot;have precedence&quot; over the ones in map1 ). If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use Kernel.struct/2 . Inlined by the compiler. Examples iex&gt; Map . merge ( %{ a : 1 , b : 2 } , %{ a : 3 , d : 4 } ) %{ a : 3 , b : 2 , d : 4 }","ref":"Map.html#merge/2","title":"Map.merge/2","type":"function"},{"doc":"Merges two maps into one, resolving conflicts through the given fun . All keys in map2 will be added to map1 . The given function will be invoked when there are duplicate keys; its arguments are key (the duplicate key), value1 (the value of key in map1 ), and value2 (the value of key in map2 ). The value returned by fun is used as the value under key in the resulting map. Examples iex&gt; Map . merge ( %{ a : 1 , b : 2 } , %{ a : 3 , d : 4 } , fn _k , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) %{ a : 4 , b : 2 , d : 4 }","ref":"Map.html#merge/3","title":"Map.merge/3","type":"function"},{"doc":"Returns a new empty map. Examples iex&gt; Map . new ( ) %{ }","ref":"Map.html#new/0","title":"Map.new/0","type":"function"},{"doc":"Creates a map from an enumerable . Duplicated keys are removed; the latest one prevails. Examples iex&gt; Map . new ( [ { :b , 1 } , { :a , 2 } ] ) %{ a : 2 , b : 1 } iex&gt; Map . new ( a : 1 , a : 2 , a : 3 ) %{ a : 3 }","ref":"Map.html#new/1","title":"Map.new/1","type":"function"},{"doc":"Creates a map from an enumerable via the given transformation function. Duplicated keys are removed; the latest one prevails. Examples iex&gt; Map . new ( [ :a , :b ] , fn x -&gt; { x , x } end ) %{ a : :a , b : :b }","ref":"Map.html#new/2","title":"Map.new/2","type":"function"},{"doc":"Removes the value associated with key in map and returns the value and the updated map. If key is present in map , it returns {value, updated_map} where value is the value of the key and updated_map is the result of removing key from map . If key is not present in map , {default, map} is returned. Examples iex&gt; Map . pop ( %{ a : 1 } , :a ) { 1 , %{ } } iex&gt; Map . pop ( %{ a : 1 } , :b ) { nil , %{ a : 1 } } iex&gt; Map . pop ( %{ a : 1 } , :b , 3 ) { 3 , %{ a : 1 } }","ref":"Map.html#pop/3","title":"Map.pop/3","type":"function"},{"doc":"Removes the value associated with key in map and returns the value and the updated map, or it raises if key is not present. Behaves the same as pop/3 but raises if key is not present in map . Examples iex&gt; Map . pop! ( %{ a : 1 } , :a ) { 1 , %{ } } iex&gt; Map . pop! ( %{ a : 1 , b : 2 } , :a ) { 1 , %{ b : 2 } } iex&gt; Map . pop! ( %{ a : 1 } , :b ) ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#pop!/2","title":"Map.pop!/2","type":"function"},{"doc":"Lazily returns and removes the value associated with key in map . If key is present in map , it returns {value, new_map} where value is the value of the key and new_map is the result of removing key from map . If key is not present in map , {fun_result, map} is returned, where fun_result is the result of applying fun . This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; map = %{ a : 1 } iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Map . pop_lazy ( map , :a , fun ) { 1 , %{ } } iex&gt; Map . pop_lazy ( map , :b , fun ) { 13 , %{ a : 1 } }","ref":"Map.html#pop_lazy/3","title":"Map.pop_lazy/3","type":"function"},{"doc":"Puts the given value under key in map . Inlined by the compiler. Examples iex&gt; Map . put ( %{ a : 1 } , :b , 2 ) %{ a : 1 , b : 2 } iex&gt; Map . put ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 3 , b : 2 }","ref":"Map.html#put/3","title":"Map.put/3","type":"function"},{"doc":"Puts the given value under key unless the entry key already exists in map . Examples iex&gt; Map . put_new ( %{ a : 1 } , :b , 2 ) %{ a : 1 , b : 2 } iex&gt; Map . put_new ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 1 , b : 2 }","ref":"Map.html#put_new/3","title":"Map.put_new/3","type":"function"},{"doc":"Evaluates fun and puts the result under key in map unless key is already present. This function is useful in case you want to compute the value to put under key only if key is not already present, as for example, when the value is expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; map = %{ a : 1 } iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 3 ...&gt; end iex&gt; Map . put_new_lazy ( map , :a , fun ) %{ a : 1 } iex&gt; Map . put_new_lazy ( map , :b , fun ) %{ a : 1 , b : 3 }","ref":"Map.html#put_new_lazy/3","title":"Map.put_new_lazy/3","type":"function"},{"doc":"Puts a value under key only if the key already exists in map . Examples iex&gt; Map . replace ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 3 , b : 2 } iex&gt; Map . replace ( %{ a : 1 } , :b , 2 ) %{ a : 1 }","ref":"Map.html#replace/3","title":"Map.replace/3","type":"function"},{"doc":"Puts a value under key only if the key already exists in map . If key is not present in map , a KeyError exception is raised. Inlined by the compiler. Examples iex&gt; Map . replace! ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 3 , b : 2 } iex&gt; Map . replace! ( %{ a : 1 } , :b , 2 ) ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#replace!/3","title":"Map.replace!/3","type":"function"},{"doc":"Takes all entries corresponding to the given keys in map and extracts them into a separate map. Returns a tuple with the new map and the old map with removed keys. Keys for which there are no entries in map are ignored. Examples iex&gt; Map . split ( %{ a : 1 , b : 2 , c : 3 } , [ :a , :c , :e ] ) { %{ a : 1 , c : 3 } , %{ b : 2 } }","ref":"Map.html#split/2","title":"Map.split/2","type":"function"},{"doc":"Returns a new map with all the key-value pairs in map where the key is in keys . If keys contains keys that are not in map , they're simply ignored. Examples iex&gt; Map . take ( %{ a : 1 , b : 2 , c : 3 } , [ :a , :c , :e ] ) %{ a : 1 , c : 3 }","ref":"Map.html#take/2","title":"Map.take/2","type":"function"},{"doc":"Converts map to a list. Each key-value pair in the map is converted to a two-element tuple {key, value} in the resulting list. Inlined by the compiler. Examples iex&gt; Map . to_list ( %{ a : 1 } ) [ a : 1 ] iex&gt; Map . to_list ( %{ 1 = &gt; 2 } ) [ { 1 , 2 } ]","ref":"Map.html#to_list/1","title":"Map.to_list/1","type":"function"},{"doc":"Updates the key in map with the given function. If key is present in map then the existing value is passed to fun and its result is used as the updated value of key . If key is not present in map , default is inserted as the value of key . The default value will not be passed through the update function. Examples iex&gt; Map . update ( %{ a : 1 } , :a , 13 , fn existing_value -&gt; existing_value * 2 end ) %{ a : 2 } iex&gt; Map . update ( %{ a : 1 } , :b , 11 , fn existing_value -&gt; existing_value * 2 end ) %{ a : 1 , b : 11 }","ref":"Map.html#update/4","title":"Map.update/4","type":"function"},{"doc":"Updates key with the given function. If key is present in map then the existing value is passed to fun and its result is used as the updated value of key . If key is not present in map , a KeyError exception is raised. Examples iex&gt; Map . update! ( %{ a : 1 } , :a , &amp; ( &amp;1 * 2 ) ) %{ a : 2 } iex&gt; Map . update! ( %{ a : 1 } , :b , &amp; ( &amp;1 * 2 ) ) ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#update!/3","title":"Map.update!/3","type":"function"},{"doc":"Returns all values from map . Inlined by the compiler. Examples iex&gt; Map . values ( %{ a : 1 , b : 2 } ) [ 1 , 2 ]","ref":"Map.html#values/1","title":"Map.values/1","type":"function"},{"doc":"","ref":"Map.html#t:key/0","title":"Map.key/0","type":"type"},{"doc":"","ref":"Map.html#t:value/0","title":"Map.value/0","type":"type"},{"doc":"Functions that work on sets. A set is a data structure that can contain unique elements of any kind, without any particular order. MapSet is the &quot;go to&quot; set data structure in Elixir. A set can be constructed using MapSet.new/0 : iex&gt; MapSet . new ( ) # MapSet &lt; [ ] &gt; Elements in a set don't have to be of the same type and they can be populated from an enumerable using MapSet.new/1 : iex&gt; MapSet . new ( [ 1 , :two , { &quot;three&quot; } ] ) # MapSet &lt; [ 1 , :two , { &quot;three&quot; } ] &gt; Elements can be inserted using MapSet.put/2 : iex&gt; MapSet . new ( [ 2 ] ) |&gt; MapSet . put ( 4 ) |&gt; MapSet . put ( 0 ) # MapSet &lt; [ 0 , 2 , 4 ] &gt; By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op. iex&gt; map_set = MapSet . new ( ) iex&gt; MapSet . put ( map_set , &quot;foo&quot; ) # MapSet &lt; [ &quot;foo&quot; ] &gt; iex&gt; map_set |&gt; MapSet . put ( &quot;foo&quot; ) |&gt; MapSet . put ( &quot;foo&quot; ) # MapSet &lt; [ &quot;foo&quot; ] &gt; A MapSet is represented internally using the %MapSet{} struct. This struct can be used whenever there's a need to pattern match on something being a MapSet : iex&gt; match? ( % MapSet { } , MapSet . new ( ) ) true Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets. MapSet s can also be constructed starting from other collection-type data structures: for example, see MapSet.new/1 or Enum.into/2 . MapSet is built on top of Map , this means that they share many properties, including logarithmic time complexity. See the documentation for Map for more information on its execution time complexity.","ref":"MapSet.html","title":"MapSet","type":"module"},{"doc":"Deletes value from map_set . Returns a new set which is a copy of map_set but without value . Examples iex&gt; map_set = MapSet . new ( [ 1 , 2 , 3 ] ) iex&gt; MapSet . delete ( map_set , 4 ) # MapSet &lt; [ 1 , 2 , 3 ] &gt; iex&gt; MapSet . delete ( map_set , 2 ) # MapSet &lt; [ 1 , 3 ] &gt;","ref":"MapSet.html#delete/2","title":"MapSet.delete/2","type":"function"},{"doc":"Returns a set that is map_set1 without the members of map_set2 . Examples iex&gt; MapSet . difference ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) # MapSet &lt; [ 1 ] &gt;","ref":"MapSet.html#difference/2","title":"MapSet.difference/2","type":"function"},{"doc":"Checks if map_set1 and map_set2 have no members in common. Examples iex&gt; MapSet . disjoint? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 3 , 4 ] ) ) true iex&gt; MapSet . disjoint? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 ] ) ) false","ref":"MapSet.html#disjoint?/2","title":"MapSet.disjoint?/2","type":"function"},{"doc":"Checks if two sets are equal. The comparison between elements is done using ===/2 , which a set with 1 is not equivalent to a set with 1.0 . Examples iex&gt; MapSet . equal? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 1 , 1 ] ) ) true iex&gt; MapSet . equal? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 3 , 4 ] ) ) false iex&gt; MapSet . equal? ( MapSet . new ( [ 1 ] ) , MapSet . new ( [ 1.0 ] ) ) false","ref":"MapSet.html#equal?/2","title":"MapSet.equal?/2","type":"function"},{"doc":"Returns a set containing only members that map_set1 and map_set2 have in common. Examples iex&gt; MapSet . intersection ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) # MapSet &lt; [ 2 ] &gt; iex&gt; MapSet . intersection ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 3 , 4 ] ) ) # MapSet &lt; [ ] &gt;","ref":"MapSet.html#intersection/2","title":"MapSet.intersection/2","type":"function"},{"doc":"Checks if map_set contains value . Examples iex&gt; MapSet . member? ( MapSet . new ( [ 1 , 2 , 3 ] ) , 2 ) true iex&gt; MapSet . member? ( MapSet . new ( [ 1 , 2 , 3 ] ) , 4 ) false","ref":"MapSet.html#member?/2","title":"MapSet.member?/2","type":"function"},{"doc":"Returns a new set. Examples iex&gt; MapSet . new ( ) # MapSet &lt; [ ] &gt;","ref":"MapSet.html#new/0","title":"MapSet.new/0","type":"function"},{"doc":"Creates a set from an enumerable. Examples iex&gt; MapSet . new ( [ :b , :a , 3 ] ) # MapSet &lt; [ 3 , :a , :b ] &gt; iex&gt; MapSet . new ( [ 3 , 3 , 3 , 2 , 2 , 1 ] ) # MapSet &lt; [ 1 , 2 , 3 ] &gt;","ref":"MapSet.html#new/1","title":"MapSet.new/1","type":"function"},{"doc":"Creates a set from an enumerable via the transformation function. Examples iex&gt; MapSet . new ( [ 1 , 2 , 1 ] , fn x -&gt; 2 * x end ) # MapSet &lt; [ 2 , 4 ] &gt;","ref":"MapSet.html#new/2","title":"MapSet.new/2","type":"function"},{"doc":"Inserts value into map_set if map_set doesn't already contain it. Examples iex&gt; MapSet . put ( MapSet . new ( [ 1 , 2 , 3 ] ) , 3 ) # MapSet &lt; [ 1 , 2 , 3 ] &gt; iex&gt; MapSet . put ( MapSet . new ( [ 1 , 2 , 3 ] ) , 4 ) # MapSet &lt; [ 1 , 2 , 3 , 4 ] &gt;","ref":"MapSet.html#put/2","title":"MapSet.put/2","type":"function"},{"doc":"Returns the number of elements in map_set . Examples iex&gt; MapSet . size ( MapSet . new ( [ 1 , 2 , 3 ] ) ) 3","ref":"MapSet.html#size/1","title":"MapSet.size/1","type":"function"},{"doc":"Checks if map_set1 's members are all contained in map_set2 . This function checks if map_set1 is a subset of map_set2 . Examples iex&gt; MapSet . subset? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 1 , 2 , 3 ] ) ) true iex&gt; MapSet . subset? ( MapSet . new ( [ 1 , 2 , 3 ] ) , MapSet . new ( [ 1 , 2 ] ) ) false","ref":"MapSet.html#subset?/2","title":"MapSet.subset?/2","type":"function"},{"doc":"Converts map_set to a list. Examples iex&gt; MapSet . to_list ( MapSet . new ( [ 1 , 2 , 3 ] ) ) [ 1 , 2 , 3 ]","ref":"MapSet.html#to_list/1","title":"MapSet.to_list/1","type":"function"},{"doc":"Returns a set containing all members of map_set1 and map_set2 . Examples iex&gt; MapSet . union ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) # MapSet &lt; [ 1 , 2 , 3 , 4 ] &gt;","ref":"MapSet.html#union/2","title":"MapSet.union/2","type":"function"},{"doc":"","ref":"MapSet.html#t:t/0","title":"MapSet.t/0","type":"type"},{"doc":"","ref":"MapSet.html#t:t/1","title":"MapSet.t/1","type":"opaque"},{"doc":"","ref":"MapSet.html#t:value/0","title":"MapSet.value/0","type":"type"},{"doc":"Ranges represent a sequence of zero, one or many, ascending or descending integers with a common difference called step. Ranges are always inclusive and they may have custom steps. The most common form of creating and matching on ranges is via the first..last and first..last//step notations, auto-imported from Kernel : iex&gt; Enum . to_list ( 1 . . 3 ) [ 1 , 2 , 3 ] iex&gt; Enum . to_list ( 1 . . 3 / / 2 ) [ 1 , 3 ] iex&gt; Enum . to_list ( 3 . . 1 / / - 1 ) [ 3 , 2 , 1 ] Ranges may also have a single element: iex&gt; Enum . to_list ( 1 . . 1 ) [ 1 ] iex&gt; Enum . to_list ( 1 . . 1 / / 2 ) [ 1 ] Or even no elements at all: iex&gt; Enum . to_list ( 10 . . 0 / / 1 ) [ ] iex&gt; Enum . to_list ( 0 . . 10 / / - 1 ) [ ] When defining a range without a step, the step will be defined based on the first and last position of the range, If first &gt;= last , it will be an increasing range with a step of 1. Otherwise, it is a decreasing range. Note however implicitly decreasing ranges are deprecated. Therefore, if you need a decreasing range from 3 to 1 , prefer to write 3..1//-1 instead. Definition An increasing range first..last//step is a range from first to last increasing by step where all values v must be first &lt;= v and v &lt;= last . Therefore, a range 10..0//1 is an empty range because there is no value v that is 10 &lt;= v and v &lt;= 0 . Similarly, a decreasing range first..last//-step is a range from first to last decreasing by step where all values v must be first &gt;= v and v &gt;= last . Therefore, a range 0..10//-1 is an empty range because there is no value v that is 0 &gt;= v and v &gt;= 10 . Representation Internally, ranges are represented as structs: iex&gt; range = 1 . . 9 / / 2 1 . . 9 / / 2 iex&gt; first . . last / / step = range iex&gt; first 1 iex&gt; last 9 iex&gt; step 2 iex&gt; range . step 2 You can access the range fields ( first , last , and step ) directly but you should not modify nor create ranges by hand. Instead use the proper operators or new/2 and new/3 . A range implements the Enumerable protocol, which means functions in the Enum module can be used to work with ranges: iex&gt; range = 1 . . 10 1 . . 10 iex&gt; Enum . reduce ( range , 0 , fn i , acc -&gt; i * i + acc end ) 385 iex&gt; Enum . count ( range ) 10 iex&gt; Enum . member? ( range , 11 ) false iex&gt; Enum . member? ( range , 8 ) true Such function calls are efficient memory-wise no matter the size of the range. The implementation of the Enumerable protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.","ref":"Range.html","title":"Range","type":"module"},{"doc":"Checks if two ranges are disjoint. Examples iex&gt; Range . disjoint? ( 1 . . 5 , 6 . . 9 ) true iex&gt; Range . disjoint? ( 5 . . 1 , 6 . . 9 ) true iex&gt; Range . disjoint? ( 1 . . 5 , 5 . . 9 ) false iex&gt; Range . disjoint? ( 1 . . 5 , 2 . . 7 ) false Steps are also considered when computing the ranges to be disjoint: iex&gt; Range . disjoint? ( 1 . . 10 / / 2 , 2 . . 10 / / 2 ) true # First element in common in all below is 29 iex&gt; Range . disjoint? ( 2 . . 100 / / 3 , 9 . . 100 / / 5 ) false iex&gt; Range . disjoint? ( 101 . . 2 / / - 3 , 99 . . 9 / / - 5 ) false iex&gt; Range . disjoint? ( 1 . . 100 / / 14 , 8 . . 100 / / 21 ) false iex&gt; Range . disjoint? ( 57 . . - 1 / / - 14 , 8 . . 100 / / 21 ) false iex&gt; Range . disjoint? ( 1 . . 100 / / 14 , 51 . . 8 / / - 21 ) false # If 29 is out of range iex&gt; Range . disjoint? ( 1 . . 28 / / 14 , 8 . . 28 / / 21 ) true iex&gt; Range . disjoint? ( 2 . . 28 / / 3 , 9 . . 28 / / 5 ) true","ref":"Range.html#disjoint?/2","title":"Range.disjoint?/2","type":"function"},{"doc":"Creates a new range. If first is less than last , the range will be increasing from first to last . If first is equal to last , the range will contain one element, which is the number itself. If first is greater than last , the range will be decreasing from first to last , albeit this behaviour is deprecated. Therefore, it is advised to explicitly list the step with new/3 . Examples iex&gt; Range . new ( - 100 , 100 ) - 100 . . 100","ref":"Range.html#new/2","title":"Range.new/2","type":"function"},{"doc":"Creates a new range with step . Examples iex&gt; Range . new ( - 100 , 100 , 2 ) - 100 . . 100 / / 2","ref":"Range.html#new/3","title":"Range.new/3","type":"function"},{"doc":"Returns the size of range . Examples iex&gt; Range . size ( 1 . . 10 ) 10 iex&gt; Range . size ( 1 . . 10 / / 2 ) 5 iex&gt; Range . size ( 1 . . 10 / / 3 ) 4 iex&gt; Range . size ( 1 . . 10 / / - 1 ) 0 iex&gt; Range . size ( 10 . . 1 ) 10 iex&gt; Range . size ( 10 . . 1 / / - 1 ) 10 iex&gt; Range . size ( 10 . . 1 / / - 2 ) 5 iex&gt; Range . size ( 10 . . 1 / / - 3 ) 4 iex&gt; Range . size ( 10 . . 1 / / 1 ) 0","ref":"Range.html#size/1","title":"Range.size/1","type":"function"},{"doc":"","ref":"Range.html#t:limit/0","title":"Range.limit/0","type":"type"},{"doc":"","ref":"Range.html#t:step/0","title":"Range.step/0","type":"type"},{"doc":"","ref":"Range.html#t:t/0","title":"Range.t/0","type":"type"},{"doc":"","ref":"Range.html#t:t/2","title":"Range.t/2","type":"type"},{"doc":"Functions for creating and composing streams. Streams are composable, lazy enumerables (for an introduction on enumerables, see the Enum module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's Range is a stream: iex&gt; range = 1 . . 5 1 . . 5 iex&gt; Enum . map ( range , &amp; ( &amp;1 * 2 ) ) [ 2 , 4 , 6 , 8 , 10 ] In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The Stream module allows us to map the range, without triggering its enumeration: iex&gt; range = 1 . . 3 iex&gt; stream = Stream . map ( range , &amp; ( &amp;1 * 2 ) ) iex&gt; Enum . map ( stream , &amp; ( &amp;1 + 1 ) ) [ 3 , 5 , 7 ] Note that we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when Enum.map/2 is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in Stream are lazy and the functions in Enum are eager . Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with Enum , intermediate lists are created, while Stream creates a recipe of computations that are executed at a later moment. Let's see another example: 1 . . 3 |&gt; Enum . map ( &amp; IO . inspect ( &amp;1 ) ) |&gt; Enum . map ( &amp; ( &amp;1 * 2 ) ) |&gt; Enum . map ( &amp; IO . inspect ( &amp;1 ) ) 1 2 3 2 4 6 #=&gt; [2, 4, 6] Note that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams: stream = 1 . . 3 |&gt; Stream . map ( &amp; IO . inspect ( &amp;1 ) ) |&gt; Stream . map ( &amp; ( &amp;1 * 2 ) ) |&gt; Stream . map ( &amp; IO . inspect ( &amp;1 ) ) Enum . to_list ( stream ) 1 2 2 4 3 6 #=&gt; [2, 4, 6] Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once! That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call Stream.map/2 multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the Enum module. Like with Enum , the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as Stream.map/2 . After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take. Creating Streams There are many functions in Elixir's standard library that return streams, some examples are: IO.stream/2 - streams input lines, one by one URI.query_decoder/1 - decodes a query string, pair by pair This module also provides many convenience functions for creating streams, like Stream.cycle/1 , Stream.unfold/2 , Stream.resource/3 and more. Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.","ref":"Stream.html","title":"Stream","type":"module"},{"doc":"Chunks the enum by buffering elements for which fun returns the same value. Elements are only emitted when fun returns a new value or the enum finishes. Examples iex&gt; stream = Stream . chunk_by ( [ 1 , 2 , 2 , 3 , 4 , 4 , 6 , 7 , 7 ] , &amp; ( rem ( &amp;1 , 2 ) == 1 ) ) iex&gt; Enum . to_list ( stream ) [ [ 1 ] , [ 2 , 2 ] , [ 3 ] , [ 4 , 4 , 6 ] , [ 7 , 7 ] ]","ref":"Stream.html#chunk_by/2","title":"Stream.chunk_by/2","type":"function"},{"doc":"Shortcut to chunk_every(enum, count, count) .","ref":"Stream.html#chunk_every/2","title":"Stream.chunk_every/2","type":"function"},{"doc":"Streams the enumerable in chunks, containing count elements each, where each new chunk starts step elements into the enumerable. step is optional and, if not passed, defaults to count , i.e. chunks do not overlap. If the last chunk does not have count elements to fill the chunk, elements are taken from leftover to fill in the chunk. If leftover does not have enough elements to fill the chunk, then a partial chunk is returned with less than count elements. If :discard is given in leftover , the last chunk is discarded unless it has exactly count elements. Examples iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 2 ) |&gt; Enum . to_list ( ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , :discard ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , [ 7 ] ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] , [ 5 , 6 , 7 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 3 , [ ] ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ]","ref":"Stream.html#chunk_every/4","title":"Stream.chunk_every/4","type":"function"},{"doc":"Chunks the enum with fine grained control when every chunk is emitted. chunk_fun receives the current element and the accumulator and must return {:cont, element, acc} to emit the given chunk and continue with accumulator or {:cont, acc} to not emit any chunk and continue with the return accumulator. after_fun is invoked when iteration is done and must also return {:cont, element, acc} or {:cont, acc} . Examples iex&gt; chunk_fun = fn element , acc -&gt; ...&gt; if rem ( element , 2 ) == 0 do ...&gt; { :cont , Enum . reverse ( [ element | acc ] ) , [ ] } ...&gt; else ...&gt; { :cont , [ element | acc ] } ...&gt; end ...&gt; end iex&gt; after_fun = fn ...&gt; [ ] -&gt; { :cont , [ ] } ...&gt; acc -&gt; { :cont , Enum . reverse ( acc ) , [ ] } ...&gt; end iex&gt; stream = Stream . chunk_while ( 1 . . 10 , [ ] , chunk_fun , after_fun ) iex&gt; Enum . to_list ( stream ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] , [ 7 , 8 ] , [ 9 , 10 ] ]","ref":"Stream.html#chunk_while/4","title":"Stream.chunk_while/4","type":"function"},{"doc":"Creates a stream that enumerates each enumerable in an enumerable. Examples iex&gt; stream = Stream . concat ( [ 1 . . 3 , 4 . . 6 , 7 . . 9 ] ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]","ref":"Stream.html#concat/1","title":"Stream.concat/1","type":"function"},{"doc":"Creates a stream that enumerates the first argument, followed by the second. Examples iex&gt; stream = Stream . concat ( 1 . . 3 , 4 . . 6 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; stream1 = Stream . cycle ( [ 1 , 2 , 3 ] ) iex&gt; stream2 = Stream . cycle ( [ 4 , 5 , 6 ] ) iex&gt; stream = Stream . concat ( stream1 , stream2 ) iex&gt; Enum . take ( stream , 6 ) [ 1 , 2 , 3 , 1 , 2 , 3 ]","ref":"Stream.html#concat/2","title":"Stream.concat/2","type":"function"},{"doc":"Creates a stream that cycles through the given enumerable, infinitely. Examples iex&gt; stream = Stream . cycle ( [ 1 , 2 , 3 ] ) iex&gt; Enum . take ( stream , 5 ) [ 1 , 2 , 3 , 1 , 2 ]","ref":"Stream.html#cycle/1","title":"Stream.cycle/1","type":"function"},{"doc":"Creates a stream that only emits elements if they are different from the last emitted element. This function only ever needs to store the last emitted element. Elements are compared using ===/2 . Examples iex&gt; Stream . dedup ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 , 2 , 1 ]","ref":"Stream.html#dedup/1","title":"Stream.dedup/1","type":"function"},{"doc":"Creates a stream that only emits elements if the result of calling fun on the element is different from the (stored) result of calling fun on the last emitted element. Examples iex&gt; Stream . dedup_by ( [ { 1 , :x } , { 2 , :y } , { 2 , :z } , { 1 , :x } ] , fn { x , _ } -&gt; x end ) |&gt; Enum . to_list ( ) [ { 1 , :x } , { 2 , :y } , { 1 , :x } ]","ref":"Stream.html#dedup_by/2","title":"Stream.dedup_by/2","type":"function"},{"doc":"Lazily drops the next n elements from the enumerable. If a negative n is given, it will drop the last n elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until n additional elements have been emitted by the enum. Examples iex&gt; stream = Stream . drop ( 1 . . 10 , 5 ) iex&gt; Enum . to_list ( stream ) [ 6 , 7 , 8 , 9 , 10 ] iex&gt; stream = Stream . drop ( 1 . . 10 , - 5 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#drop/2","title":"Stream.drop/2","type":"function"},{"doc":"Creates a stream that drops every nth element from the enumerable. The first element is always dropped, unless nth is 0. nth must be a non-negative integer. Examples iex&gt; stream = Stream . drop_every ( 1 . . 10 , 2 ) iex&gt; Enum . to_list ( stream ) [ 2 , 4 , 6 , 8 , 10 ] iex&gt; stream = Stream . drop_every ( 1 . . 1000 , 1 ) iex&gt; Enum . to_list ( stream ) [ ] iex&gt; stream = Stream . drop_every ( [ 1 , 2 , 3 , 4 , 5 ] , 0 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#drop_every/2","title":"Stream.drop_every/2","type":"function"},{"doc":"Lazily drops elements of the enumerable while the given function returns a truthy value. Examples iex&gt; stream = Stream . drop_while ( 1 . . 10 , &amp; ( &amp;1 &lt;= 5 ) ) iex&gt; Enum . to_list ( stream ) [ 6 , 7 , 8 , 9 , 10 ]","ref":"Stream.html#drop_while/2","title":"Stream.drop_while/2","type":"function"},{"doc":"Executes the given function for each element. Useful for adding side effects (like printing) to a stream. Examples iex&gt; stream = Stream . each ( [ 1 , 2 , 3 ] , fn x -&gt; send ( self ( ) , x ) end ) iex&gt; Enum . to_list ( stream ) iex&gt; receive do : ( x when is_integer ( x ) -&gt; x ) 1 iex&gt; receive do : ( x when is_integer ( x ) -&gt; x ) 2 iex&gt; receive do : ( x when is_integer ( x ) -&gt; x ) 3","ref":"Stream.html#each/2","title":"Stream.each/2","type":"function"},{"doc":"Creates a stream that filters elements according to the given function on enumeration. Examples iex&gt; stream = Stream . filter ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) iex&gt; Enum . to_list ( stream ) [ 2 ]","ref":"Stream.html#filter/2","title":"Stream.filter/2","type":"function"},{"doc":"Maps the given fun over enumerable and flattens the result. This function returns a new stream built by appending the result of invoking fun on each element of enumerable together. Examples iex&gt; stream = Stream . flat_map ( [ 1 , 2 , 3 ] , fn x -&gt; [ x , x * 2 ] end ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 2 , 4 , 3 , 6 ] iex&gt; stream = Stream . flat_map ( [ 1 , 2 , 3 ] , fn x -&gt; [ [ x ] ] end ) iex&gt; Enum . to_list ( stream ) [ [ 1 ] , [ 2 ] , [ 3 ] ]","ref":"Stream.html#flat_map/2","title":"Stream.flat_map/2","type":"function"},{"doc":"Lazily intersperses intersperse_element between each element of the enumeration. Examples iex&gt; Stream . intersperse ( [ 1 , 2 , 3 ] , 0 ) |&gt; Enum . to_list ( ) [ 1 , 0 , 2 , 0 , 3 ] iex&gt; Stream . intersperse ( [ 1 ] , 0 ) |&gt; Enum . to_list ( ) [ 1 ] iex&gt; Stream . intersperse ( [ ] , 0 ) |&gt; Enum . to_list ( ) [ ]","ref":"Stream.html#intersperse/2","title":"Stream.intersperse/2","type":"function"},{"doc":"Creates a stream that emits a value after the given period n in milliseconds. The values emitted are an increasing counter starting at 0 . This operation will block the caller by the given interval every time a new element is streamed. Do not use this function to generate a sequence of numbers. If blocking the caller process is not necessary, use Stream.iterate(0, &amp; &amp;1 + 1) instead. Examples iex&gt; Stream . interval ( 10 ) |&gt; Enum . take ( 10 ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]","ref":"Stream.html#interval/1","title":"Stream.interval/1","type":"function"},{"doc":"Injects the stream values into the given collectable as a side-effect. This function is often used with run/1 since any evaluation is delayed until the stream is executed. See run/1 for an example.","ref":"Stream.html#into/3","title":"Stream.into/3","type":"function"},{"doc":"Emits a sequence of values, starting with start_value . Successive values are generated by calling next_fun on the previous value. Examples iex&gt; Stream . iterate ( 0 , &amp; ( &amp;1 + 1 ) ) |&gt; Enum . take ( 5 ) [ 0 , 1 , 2 , 3 , 4 ]","ref":"Stream.html#iterate/2","title":"Stream.iterate/2","type":"function"},{"doc":"Creates a stream that will apply the given function on enumeration. Examples iex&gt; stream = Stream . map ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 2 , 4 , 6 ]","ref":"Stream.html#map/2","title":"Stream.map/2","type":"function"},{"doc":"Creates a stream that will apply the given function on every nth element from the enumerable. The first element is always passed to the given function. nth must be a non-negative integer. Examples iex&gt; stream = Stream . map_every ( 1 . . 10 , 2 , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 2 , 2 , 6 , 4 , 10 , 6 , 14 , 8 , 18 , 10 ] iex&gt; stream = Stream . map_every ( [ 1 , 2 , 3 , 4 , 5 ] , 1 , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 2 , 4 , 6 , 8 , 10 ] iex&gt; stream = Stream . map_every ( 1 . . 5 , 0 , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#map_every/3","title":"Stream.map_every/3","type":"function"},{"doc":"Creates a stream that will reject elements according to the given function on enumeration. Examples iex&gt; stream = Stream . reject ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 ]","ref":"Stream.html#reject/2","title":"Stream.reject/2","type":"function"},{"doc":"Returns a stream generated by calling generator_fun repeatedly. Examples # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exrop , { 1 , 2 , 3 } ) iex&gt; Stream . repeatedly ( &amp; :rand . uniform / 0 ) |&gt; Enum . take ( 3 ) [ 0.7498295129076106 , 0.06161655489244533 , 0.7924073127680873 ]","ref":"Stream.html#repeatedly/1","title":"Stream.repeatedly/1","type":"function"},{"doc":"Emits a sequence of values for the given resource. Similar to transform/3 but the initial accumulated value is computed lazily via start_fun and executes an after_fun at the end of enumeration (both in cases of success and failure). Successive values are generated by calling next_fun with the previous accumulator (the initial value being the result returned by start_fun ) and it must return a tuple containing a list of elements to be emitted and the next accumulator. The enumeration finishes if it returns {:halt, acc} . As the name says, this function is useful to stream values from resources. Examples Stream . resource ( fn -&gt; File . open! ( &quot;sample&quot; ) end , fn file -&gt; case IO . read ( file , :line ) do data when is_binary ( data ) -&gt; { [ data ] , file } _ -&gt; { :halt , file } end end , fn file -&gt; File . close ( file ) end ) iex&gt; Stream . resource ( ...&gt; fn -&gt; ...&gt; { :ok , pid } = StringIO . open ( &quot;string&quot; ) ...&gt; pid ...&gt; end , ...&gt; fn pid -&gt; ...&gt; case IO . getn ( pid , &quot;&quot; , 1 ) do ...&gt; :eof -&gt; { :halt , pid } ...&gt; char -&gt; { [ char ] , pid } ...&gt; end ...&gt; end , ...&gt; fn pid -&gt; StringIO . close ( pid ) end ...&gt; ) |&gt; Enum . to_list ( ) [ &quot;s&quot; , &quot;t&quot; , &quot;r&quot; , &quot;i&quot; , &quot;n&quot; , &quot;g&quot; ]","ref":"Stream.html#resource/3","title":"Stream.resource/3","type":"function"},{"doc":"Runs the given stream. This is useful when a stream needs to be run, for side effects, and there is no interest in its return result. Examples Open up a file, replace all # by % and stream to another file without loading the whole file in memory: File . stream! ( &quot;/path/to/file&quot; ) |&gt; Stream . map ( &amp; String . replace ( &amp;1 , &quot;#&quot; , &quot;%&quot; ) ) |&gt; Stream . into ( File . stream! ( &quot;/path/to/other/file&quot; ) ) |&gt; Stream . run ( ) No computation will be done until we call one of the Enum functions or run/1 .","ref":"Stream.html#run/1","title":"Stream.run/1","type":"function"},{"doc":"Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the first element in the enumerable as the starting value. Examples iex&gt; stream = Stream . scan ( 1 . . 5 , &amp; ( &amp;1 + &amp;2 ) ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Stream.html#scan/2","title":"Stream.scan/2","type":"function"},{"doc":"Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given acc as the starting value. Examples iex&gt; stream = Stream . scan ( 1 . . 5 , 0 , &amp; ( &amp;1 + &amp;2 ) ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Stream.html#scan/3","title":"Stream.scan/3","type":"function"},{"doc":"Lazily takes the next count elements from the enumerable and stops enumeration. If a negative count is given, the last count values will be taken. For such, the collection is fully enumerated keeping up to 2 * count elements in memory. Once the end of the collection is reached, the last count elements will be executed. Therefore, using a negative count on an infinite collection will never return. Examples iex&gt; stream = Stream . take ( 1 . . 100 , 5 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; stream = Stream . take ( 1 . . 100 , - 5 ) iex&gt; Enum . to_list ( stream ) [ 96 , 97 , 98 , 99 , 100 ] iex&gt; stream = Stream . cycle ( [ 1 , 2 , 3 ] ) |&gt; Stream . take ( 5 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 1 , 2 ]","ref":"Stream.html#take/2","title":"Stream.take/2","type":"function"},{"doc":"Creates a stream that takes every nth element from the enumerable. The first element is always included, unless nth is 0. nth must be a non-negative integer. Examples iex&gt; stream = Stream . take_every ( 1 . . 10 , 2 ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 , 5 , 7 , 9 ] iex&gt; stream = Stream . take_every ( [ 1 , 2 , 3 , 4 , 5 ] , 1 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; stream = Stream . take_every ( 1 . . 1000 , 0 ) iex&gt; Enum . to_list ( stream ) [ ]","ref":"Stream.html#take_every/2","title":"Stream.take_every/2","type":"function"},{"doc":"Lazily takes elements of the enumerable while the given function returns a truthy value. Examples iex&gt; stream = Stream . take_while ( 1 . . 100 , &amp; ( &amp;1 &lt;= 5 ) ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#take_while/2","title":"Stream.take_while/2","type":"function"},{"doc":"Creates a stream that emits a single value after n milliseconds. The value emitted is 0 . This operation will block the caller by the given time until the element is streamed. Examples iex&gt; Stream . timer ( 10 ) |&gt; Enum . to_list ( ) [ 0 ]","ref":"Stream.html#timer/1","title":"Stream.timer/1","type":"function"},{"doc":"Transforms an existing stream. It expects an accumulator and a function that receives each stream element and an accumulator. It must return a tuple, where the first element is a new stream (often a list) or the atom :halt , and the second element is the accumulator to be used by the next element, if any, in both cases. Note: this function is equivalent to Enum.flat_map_reduce/3 , except this function does not return the accumulator once the stream is processed. Examples Stream.transform/3 is useful as it can be used as the basis to implement many of the functions defined in this module. For example, we can implement Stream.take(enum, n) as follows: iex&gt; enum = 1001 . . 9999 iex&gt; n = 3 iex&gt; stream = Stream . transform ( enum , 0 , fn i , acc -&gt; ...&gt; if acc &lt; n , do : { [ i ] , acc + 1 } , else : { :halt , acc } ...&gt; end ) iex&gt; Enum . to_list ( stream ) [ 1001 , 1002 , 1003 ]","ref":"Stream.html#transform/3","title":"Stream.transform/3","type":"function"},{"doc":"Transforms an existing stream with function-based start and finish. The accumulator is only calculated when transformation starts. It also allows an after function to be given which is invoked when the stream halts or completes. This function can be seen as a combination of Stream.resource/3 with Stream.transform/3 .","ref":"Stream.html#transform/4","title":"Stream.transform/4","type":"function"},{"doc":"Emits a sequence of values for the given accumulator. Successive values are generated by calling next_fun with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns nil . Examples iex&gt; Stream . unfold ( 5 , fn ...&gt; 0 -&gt; nil ...&gt; n -&gt; { n , n - 1 } ...&gt; end ) |&gt; Enum . to_list ( ) [ 5 , 4 , 3 , 2 , 1 ]","ref":"Stream.html#unfold/2","title":"Stream.unfold/2","type":"function"},{"doc":"Creates a stream that only emits elements if they are unique. Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected. Examples iex&gt; Stream . uniq ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 ]","ref":"Stream.html#uniq/1","title":"Stream.uniq/1","type":"function"},{"doc":"Creates a stream that only emits elements if they are unique, by removing the elements for which function fun returned duplicate elements. The function fun maps every element to a term which is used to determine if two elements are duplicates. Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected. Example iex&gt; Stream . uniq_by ( [ { 1 , :x } , { 2 , :y } , { 1 , :z } ] , fn { x , _ } -&gt; x end ) |&gt; Enum . to_list ( ) [ { 1 , :x } , { 2 , :y } ] iex&gt; Stream . uniq_by ( [ a : { :tea , 2 } , b : { :tea , 2 } , c : { :coffee , 1 } ] , fn { _ , y } -&gt; y end ) |&gt; Enum . to_list ( ) [ a : { :tea , 2 } , c : { :coffee , 1 } ]","ref":"Stream.html#uniq_by/2","title":"Stream.uniq_by/2","type":"function"},{"doc":"Creates a stream where each element in the enumerable will be wrapped in a tuple alongside its index. If an offset is given, we will index from the given offset instead of from zero. Examples iex&gt; stream = Stream . with_index ( [ 1 , 2 , 3 ] ) iex&gt; Enum . to_list ( stream ) [ { 1 , 0 } , { 2 , 1 } , { 3 , 2 } ] iex&gt; stream = Stream . with_index ( [ 1 , 2 , 3 ] , 3 ) iex&gt; Enum . to_list ( stream ) [ { 1 , 3 } , { 2 , 4 } , { 3 , 5 } ]","ref":"Stream.html#with_index/2","title":"Stream.with_index/2","type":"function"},{"doc":"Zips corresponding elements from a finite collection of enumerables into one stream of tuples. The zipping finishes as soon as any enumerable in the given collection completes. Examples iex&gt; concat = Stream . concat ( 1 . . 3 , 4 . . 6 ) iex&gt; cycle = Stream . cycle ( [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] ) iex&gt; Stream . zip ( [ concat , [ :a , :b , :c ] , cycle ] ) |&gt; Enum . to_list ( ) [ { 1 , :a , &quot;foo&quot; } , { 2 , :b , &quot;bar&quot; } , { 3 , :c , &quot;baz&quot; } ]","ref":"Stream.html#zip/1","title":"Stream.zip/1","type":"function"},{"doc":"Zips two enumerables together, lazily. The zipping finishes as soon as either enumerable completes. Examples iex&gt; concat = Stream . concat ( 1 . . 3 , 4 . . 6 ) iex&gt; cycle = Stream . cycle ( [ :a , :b , :c ] ) iex&gt; Stream . zip ( concat , cycle ) |&gt; Enum . to_list ( ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } , { 4 , :a } , { 5 , :b } , { 6 , :c } ]","ref":"Stream.html#zip/2","title":"Stream.zip/2","type":"function"},{"doc":"Lazily zips corresponding elements from a finite collection of enumerables into a new enumerable, transforming them with the zip_fun function as it goes. The first element from each of the enums in enumerables will be put into a list which is then passed to the 1-arity zip_fun function. Then, the second elements from each of the enums are put into a list and passed to zip_fun , and so on until any one of the enums in enumerables completes. Returns a new enumerable with the results of calling zip_fun . Examples iex&gt; concat = Stream . concat ( 1 . . 3 , 4 . . 6 ) iex&gt; Stream . zip_with ( [ concat , concat ] , fn [ a , b ] -&gt; a + b end ) |&gt; Enum . to_list ( ) [ 2 , 4 , 6 , 8 , 10 , 12 ] iex&gt; concat = Stream . concat ( 1 . . 3 , 4 . . 6 ) iex&gt; Stream . zip_with ( [ concat , concat , 1 . . 3 ] , fn [ a , b , c ] -&gt; a + b + c end ) |&gt; Enum . to_list ( ) [ 3 , 6 , 9 ]","ref":"Stream.html#zip_with/2","title":"Stream.zip_with/2","type":"function"},{"doc":"Lazily zips corresponding elements from two enumerables into a new one, transforming them with the zip_fun function as it goes. The zip_fun will be called with the first element from enumerable1 and the first element from enumerable2 , then with the second element from each, and so on until either one of the enumerables completes. Examples iex&gt; concat = Stream . concat ( 1 . . 3 , 4 . . 6 ) iex&gt; Stream . zip_with ( concat , concat , fn a , b -&gt; a + b end ) |&gt; Enum . to_list ( ) [ 2 , 4 , 6 , 8 , 10 , 12 ]","ref":"Stream.html#zip_with/3","title":"Stream.zip_with/3","type":"function"},{"doc":"","ref":"Stream.html#t:acc/0","title":"Stream.acc/0","type":"type"},{"doc":"","ref":"Stream.html#t:default/0","title":"Stream.default/0","type":"type"},{"doc":"","ref":"Stream.html#t:element/0","title":"Stream.element/0","type":"type"},{"doc":"Zero-based index.","ref":"Stream.html#t:index/0","title":"Stream.index/0","type":"type"},{"doc":"","ref":"Stream.html#t:timer/0","title":"Stream.timer/0","type":"type"},{"doc":"This module contains functions to manipulate files. Some of those functions are low-level, allowing the user to interact with files or IO devices, like open/2 , copy/3 and others. This module also provides higher level functions that work with filenames and have their naming based on Unix variants. For example, one can copy a file via cp/3 and remove files and directories recursively via rm_rf/1 . Paths given to functions in this module can be either relative to the current working directory (as returned by File.cwd/0 ), or absolute paths. Shell conventions like ~ are not expanded automatically. To use paths like ~/Downloads , you can use Path.expand/1 or Path.expand/2 to expand your path to an absolute path. Encoding In order to write and read files, one must use the functions in the IO module. By default, a file is opened in binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file, then the slower IO.read/2 and IO.write/2 functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees. Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is. API Most of the functions in this module return :ok or {:ok, result} in case of success, {:error, reason} otherwise. Those functions also have a variant that ends with ! which returns the result (instead of the {:ok, result} tuple) in case of success or raises an exception in case it fails. For example: File . read ( &quot;hello.txt&quot; ) #=&gt; {:ok, &quot;World&quot;} File . read ( &quot;invalid.txt&quot; ) #=&gt; {:error, :enoent} File . read! ( &quot;hello.txt&quot; ) #=&gt; &quot;World&quot; File . read! ( &quot;invalid.txt&quot; ) #=&gt; raises File.Error In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception). Processes and raw files Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor. This means files can be passed between nodes and message passing guarantees they can write to the same file in a network. However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in :raw mode. The options :read_ahead and :delayed_write are also useful when operating on large files or working with files in tight loops. Check :file.open/2 for more information about such options and other performance considerations.","ref":"File.html","title":"File","type":"module"},{"doc":"Sets the current working directory. The current working directory is set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the :cd option of System.cmd/3 and Port.open/2 . Returns :ok if successful, {:error, reason} otherwise.","ref":"File.html#cd/1","title":"File.cd/1","type":"function"},{"doc":"The same as cd/1 , but raises a File.Error exception if it fails.","ref":"File.html#cd!/1","title":"File.cd!/1","type":"function"},{"doc":"Changes the current directory to the given path , executes the given function and then reverts back to the previous path regardless of whether there is an exception. The current working directory is temporarily set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the :cd option of System.cmd/3 and Port.open/2 . Raises an error if retrieving or changing the current directory fails.","ref":"File.html#cd!/2","title":"File.cd!/2","type":"function"},{"doc":"Changes the group given by the group ID gid for a given file . Returns :ok on success, or {:error, reason} on failure.","ref":"File.html#chgrp/2","title":"File.chgrp/2","type":"function"},{"doc":"Same as chgrp/2 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#chgrp!/2","title":"File.chgrp!/2","type":"function"},{"doc":"Changes the mode for a given file . Returns :ok on success, or {:error, reason} on failure. Permissions File permissions are specified by adding together the following octal modes: 0o400 - read permission: owner 0o200 - write permission: owner 0o100 - execute permission: owner 0o040 - read permission: group 0o020 - write permission: group 0o010 - execute permission: group 0o004 - read permission: other 0o002 - write permission: other 0o001 - execute permission: other For example, setting the mode 0o755 gives it write, read and execute permission to the owner and both read and execute permission to group and others.","ref":"File.html#chmod/2","title":"File.chmod/2","type":"function"},{"doc":"Same as chmod/2 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#chmod!/2","title":"File.chmod!/2","type":"function"},{"doc":"Changes the owner given by the user ID uid for a given file . Returns :ok on success, or {:error, reason} on failure.","ref":"File.html#chown/2","title":"File.chown/2","type":"function"},{"doc":"Same as chown/2 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#chown!/2","title":"File.chown!/2","type":"function"},{"doc":"Closes the file referenced by io_device . It mostly returns :ok , except for some severe errors such as out of memory. Note that if the option :delayed_write was used when opening the file, close/1 might return an old write error and not even try to close the file. See open/2 for more information.","ref":"File.html#close/1","title":"File.close/1","type":"function"},{"doc":"Copies the contents of source to destination . Both parameters can be a filename or an IO device opened with open/2 . bytes_count specifies the number of bytes to copy, the default being :infinity . If file destination already exists, it is overwritten by the contents in source . Returns {:ok, bytes_copied} if successful, {:error, reason} otherwise. Compared to the cp/3 , this function is more low-level, allowing a copy from device to device limited by a number of bytes. On the other hand, cp/3 performs more extensive checks on both source and destination and it also preserves the file mode after copy. Typical error reasons are the same as in open/2 , read/1 and write/3 .","ref":"File.html#copy/3","title":"File.copy/3","type":"function"},{"doc":"The same as copy/3 but raises a File.CopyError exception if it fails. Returns the bytes_copied otherwise.","ref":"File.html#copy!/3","title":"File.copy!/3","type":"function"},{"doc":"Copies the contents of source_file to destination_file preserving its modes. source_file must be a file or a symbolic link to one. destination_file must be a path to a non-existent file. If either is a directory, {:error, :eisdir} will be returned. The callback function is invoked if the destination_file already exists. The function receives arguments for source_file and destination_file ; it should return true if the existing file should be overwritten, false if otherwise. The default callback returns true . The function returns :ok in case of success. Otherwise, it returns {:error, reason} . If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check copy/3 instead. Note: The command cp in Unix-like systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.","ref":"File.html#cp/3","title":"File.cp/3","type":"function"},{"doc":"The same as cp/3 , but raises a File.CopyError exception if it fails. Returns :ok otherwise.","ref":"File.html#cp!/3","title":"File.cp!/3","type":"function"},{"doc":"Copies the contents in source to destination recursively, maintaining the source directory structure and modes. If source is a file or a symbolic link to it, destination must be a path to an existent file, a symbolic link to one, or a path to a non-existent file. If source is a directory, or a symbolic link to it, then destination must be an existent directory or a symbolic link to one, or a path to a non-existent directory. If the source is a file, it copies source to destination . If the source is a directory, it copies the contents inside source into the destination directory. If a file already exists in the destination, it invokes callback . callback must be a function that takes two arguments: source and destination . The callback should return true if the existing file should be overwritten and false otherwise. This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed. The function returns {:ok, files_and_directories} in case of success, files_and_directories lists all files and directories copied in no specific order. It returns {:error, reason, file} otherwise. Note: The command cp in Unix-like systems behaves differently depending on whether destination is an existing directory or not. We have chosen to explicitly disallow this behaviour. If source is a file and destination is a directory, {:error, :eisdir} will be returned. Examples # Copies file &quot;a.txt&quot; to &quot;b.txt&quot; File . cp_r ( &quot;a.txt&quot; , &quot;b.txt&quot; ) # Copies all files in &quot;samples&quot; to &quot;tmp&quot; File . cp_r ( &quot;samples&quot; , &quot;tmp&quot; ) # Same as before, but asks the user how to proceed in case of conflicts File . cp_r ( &quot;samples&quot; , &quot;tmp&quot; , fn source , destination -&gt; IO . gets ( &quot;Overwriting \#{ destination } by \#{ source } . Type y to confirm. &quot; ) == &quot;y \\n &quot; end )","ref":"File.html#cp_r/3","title":"File.cp_r/3","type":"function"},{"doc":"The same as cp_r/3 , but raises a File.CopyError exception if it fails. Returns the list of copied files otherwise.","ref":"File.html#cp_r!/3","title":"File.cp_r!/3","type":"function"},{"doc":"Gets the current working directory. In rare circumstances, this function can fail on Unix-like systems. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns {:ok, cwd} in case of success, {:error, reason} otherwise.","ref":"File.html#cwd/0","title":"File.cwd/0","type":"function"},{"doc":"The same as cwd/0 , but raises a File.Error exception if it fails.","ref":"File.html#cwd!/0","title":"File.cwd!/0","type":"function"},{"doc":"Returns true if the given path is a directory. This function follows symbolic links, so if a symbolic link points to a directory, true is returned. Options The supported options are: :raw - a single atom to bypass the file server and only check for the file locally Examples File . dir? ( &quot;./test&quot; ) #=&gt; true File . dir? ( &quot;test&quot; ) #=&gt; true File . dir? ( &quot;/usr/bin&quot; ) #=&gt; true File . dir? ( &quot;~/Downloads&quot; ) #=&gt; false &quot;~/Downloads&quot; |&gt; Path . expand ( ) |&gt; File . dir? ( ) #=&gt; true","ref":"File.html#dir?/2","title":"File.dir?/2","type":"function"},{"doc":"Returns true if the given path exists. It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns false for symbolic links pointing to non-existing targets. Options The supported options are: :raw - a single atom to bypass the file server and only check for the file locally Examples File . exists? ( &quot;test/&quot; ) #=&gt; true File . exists? ( &quot;missing.txt&quot; ) #=&gt; false File . exists? ( &quot;/dev/null&quot; ) #=&gt; true","ref":"File.html#exists?/2","title":"File.exists?/2","type":"function"},{"doc":"Creates a hard link new to the file existing . Returns :ok if successful, {:error, reason} otherwise. If the operating system does not support hard links, returns {:error, :enotsup} .","ref":"File.html#ln/2","title":"File.ln/2","type":"function"},{"doc":"Same as ln/2 but raises a File.LinkError exception if it fails. Returns :ok otherwise.","ref":"File.html#ln!/2","title":"File.ln!/2","type":"function"},{"doc":"Creates a symbolic link new to the file or directory existing . Returns :ok if successful, {:error, reason} otherwise. If the operating system does not support symlinks, returns {:error, :enotsup} .","ref":"File.html#ln_s/2","title":"File.ln_s/2","type":"function"},{"doc":"Same as ln_s/2 but raises a File.LinkError exception if it fails. Returns :ok otherwise.","ref":"File.html#ln_s!/2","title":"File.ln_s!/2","type":"function"},{"doc":"Returns the list of files in the given directory. Returns {:ok, files} in case of success, {:error, reason} otherwise.","ref":"File.html#ls/1","title":"File.ls/1","type":"function"},{"doc":"The same as ls/1 but raises a File.Error exception in case of an error.","ref":"File.html#ls!/1","title":"File.ls!/1","type":"function"},{"doc":"Returns information about the path . If the file is a symlink, sets the type to :symlink and returns a File.Stat struct for the link. For any other file, returns exactly the same values as stat/2 . For more details, see :file.read_link_info/2 . Options The accepted options are: :time - configures how the file timestamps are returned The values for :time can be: :universal - returns a {date, time} tuple in UTC (default) :local - returns a {date, time} tuple using the machine time :posix - returns the time as integer seconds since epoch Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the time: :posix option.","ref":"File.html#lstat/2","title":"File.lstat/2","type":"function"},{"doc":"Same as lstat/2 but returns the File.Stat struct directly, or raises a File.Error exception if an error is returned.","ref":"File.html#lstat!/2","title":"File.lstat!/2","type":"function"},{"doc":"Tries to create the directory path . Missing parent directories are not created. Returns :ok if successful, or {:error, reason} if an error occurs. Typical error reasons are: :eacces - missing search or write permissions for the parent directories of path :eexist - there is already a file or directory named path :enoent - a component of path does not exist :enospc - there is no space left on the device :enotdir - a component of path is not a directory; on some platforms, :enoent is returned instead","ref":"File.html#mkdir/1","title":"File.mkdir/1","type":"function"},{"doc":"Same as mkdir/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#mkdir!/1","title":"File.mkdir!/1","type":"function"},{"doc":"Tries to create the directory path . Missing parent directories are created. Returns :ok if successful, or {:error, reason} if an error occurs. Typical error reasons are: :eacces - missing search or write permissions for the parent directories of path :enospc - there is no space left on the device :enotdir - a component of path is not a directory","ref":"File.html#mkdir_p/1","title":"File.mkdir_p/1","type":"function"},{"doc":"Same as mkdir_p/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#mkdir_p!/1","title":"File.mkdir_p!/1","type":"function"},{"doc":"Opens the given path . In order to write and read files, one must use the functions in the IO module. By default, a file is opened in :binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file and then all other functions from IO are available, since they work directly with Unicode data. modes_or_function can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling open(path, [], modes_or_function) . See the documentation for open/3 for more information on this function. The allowed modes: :binary - opens the file in binary mode, disabling special handling of Unicode sequences (default mode). :read - the file, which must exist, is opened for reading. :write - the file is opened for writing. It is created if it does not exist. If the file does exists, and if write is not combined with read, the file will be truncated. :append - the file will be opened for writing, and it will be created if it does not exist. Every write operation to a file opened with append will take place at the end of the file. :exclusive - the file, when opened for writing, is created if it does not exist. If the file exists, open will return {:error, :eexist} . :charlist - when this term is given, read operations on the file will return charlists rather than binaries. :compressed - makes it possible to read or write gzip compressed files. The compressed option must be combined with either read or write, but not both. Note that the file size obtained with stat/1 will most probably not match the number of bytes that can be read from a compressed file. :utf8 - this option denotes how data is actually stored in the disk file and makes the file perform automatic translation of characters to and from UTF-8. If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed. :delayed_write , :raw , :ram , :read_ahead , :sync , {:encoding, ...} , {:read_ahead, pos_integer} , {:delayed_write, non_neg_integer, non_neg_integer} - for more information about these options see :file.open/2 . This function returns: {:ok, io_device} - the file has been opened in the requested mode. io_device is actually the PID of the process which handles the file. This process monitors the process that originally opened the file (the owner process). If the owner process terminates, the file is closed and the process itself terminates too. If any process to which the io_device is linked terminates, the file will be closed and the process itself will be terminated. An io_device returned from this call can be used as an argument to the IO module functions. {:error, reason} - the file could not be opened. Examples { :ok , file } = File . open ( &quot;foo.tar.gz&quot; , [ :read , :compressed ] ) IO . read ( file , :line ) File . close ( file )","ref":"File.html#open/2","title":"File.open/2","type":"function"},{"doc":"Similar to open/2 but expects a function as its last argument. The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function. Returns {:ok, function_result} in case of success, {:error, reason} otherwise. This function expects the file to be closed with success, which is usually the case unless the :delayed_write option is given. For this reason, we do not recommend passing :delayed_write to this function. Examples File . open ( &quot;file.txt&quot; , [ :read , :write ] , fn file -&gt; IO . read ( file , :line ) end ) See open/2 for the list of available modes .","ref":"File.html#open/3","title":"File.open/3","type":"function"},{"doc":"Similar to open/2 but raises a File.Error exception if the file could not be opened. Returns the IO device otherwise. See open/2 for the list of available modes.","ref":"File.html#open!/2","title":"File.open!/2","type":"function"},{"doc":"Similar to open/3 but raises a File.Error exception if the file could not be opened. If it succeeds opening the file, it returns the function result on the IO device. See open/2 for the list of available modes .","ref":"File.html#open!/3","title":"File.open!/3","type":"function"},{"doc":"Returns {:ok, binary} , where binary is a binary data object that contains the contents of path , or {:error, reason} if an error occurs. Typical error reasons: :enoent - the file does not exist :eacces - missing permission for reading the file, or for searching one of the parent directories :eisdir - the named file is a directory :enotdir - a component of the file name is not a directory; on some platforms, :enoent is returned instead :enomem - there is not enough memory for the contents of the file You can use :file.format_error/1 to get a descriptive string of the error.","ref":"File.html#read/1","title":"File.read/1","type":"function"},{"doc":"Returns a binary with the contents of the given filename, or raises a File.Error exception if an error occurs.","ref":"File.html#read!/1","title":"File.read!/1","type":"function"},{"doc":"Reads the symbolic link at path . If path exists and is a symlink, returns {:ok, target} , otherwise returns {:error, reason} . For more details, see :file.read_link/1 . Typical error reasons are: :einval - path is not a symbolic link :enoent - path does not exist :enotsup - symbolic links are not supported on the current platform","ref":"File.html#read_link/1","title":"File.read_link/1","type":"function"},{"doc":"Same as read_link/1 but returns the target directly, or raises a File.Error exception if an error is returned.","ref":"File.html#read_link!/1","title":"File.read_link!/1","type":"function"},{"doc":"Returns true if the path is a regular file. This function follows symbolic links, so if a symbolic link points to a regular file, true is returned. Options The supported options are: :raw - a single atom to bypass the file server and only check for the file locally Examples File . regular? ( __ENV__ . file ) #=&gt; true","ref":"File.html#regular?/2","title":"File.regular?/2","type":"function"},{"doc":"Renames the source file to destination file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the destination filename, it is not sufficient to simply specify its directory. Returns :ok in case of success, {:error, reason} otherwise. Note: The command mv in Unix-like systems behaves differently depending on whether source is a file and the destination is an existing directory. We have chosen to explicitly disallow this behaviour. Examples # Rename file &quot;a.txt&quot; to &quot;b.txt&quot; File . rename ( &quot;a.txt&quot; , &quot;b.txt&quot; ) # Rename directory &quot;samples&quot; to &quot;tmp&quot; File . rename ( &quot;samples&quot; , &quot;tmp&quot; )","ref":"File.html#rename/2","title":"File.rename/2","type":"function"},{"doc":"The same as rename/2 but raises a File.RenameError exception if it fails. Returns :ok otherwise.","ref":"File.html#rename!/2","title":"File.rename!/2","type":"function"},{"doc":"Tries to delete the file path . Returns :ok if successful, or {:error, reason} if an error occurs. Note the file is deleted even if in read-only mode. Typical error reasons are: :enoent - the file does not exist :eacces - missing permission for the file or one of its parents :eperm - the file is a directory and user is not super-user :enotdir - a component of the file name is not a directory; on some platforms, :enoent is returned instead :einval - filename had an improper type, such as tuple Examples File . rm ( &quot;file.txt&quot; ) #=&gt; :ok File . rm ( &quot;tmp_dir/&quot; ) #=&gt; {:error, :eperm}","ref":"File.html#rm/1","title":"File.rm/1","type":"function"},{"doc":"Same as rm/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#rm!/1","title":"File.rm!/1","type":"function"},{"doc":"Removes files and directories recursively at the given path . Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail). Returns {:ok, files_and_directories} with all files and directories removed in no specific order, {:error, reason, file} otherwise. Examples File . rm_rf ( &quot;samples&quot; ) #=&gt; {:ok, [&quot;samples&quot;, &quot;samples/1.txt&quot;]} File . rm_rf ( &quot;unknown&quot; ) #=&gt; {:ok, []}","ref":"File.html#rm_rf/1","title":"File.rm_rf/1","type":"function"},{"doc":"Same as rm_rf/1 but raises a File.Error exception in case of failures, otherwise the list of files or directories removed.","ref":"File.html#rm_rf!/1","title":"File.rm_rf!/1","type":"function"},{"doc":"Tries to delete the dir at path . Returns :ok if successful, or {:error, reason} if an error occurs. It returns {:error, :eexist} if the directory is not empty. Examples File . rmdir ( &quot;tmp_dir&quot; ) #=&gt; :ok File . rmdir ( &quot;non_empty_dir&quot; ) #=&gt; {:error, :eexist} File . rmdir ( &quot;file.txt&quot; ) #=&gt; {:error, :enotdir}","ref":"File.html#rmdir/1","title":"File.rmdir/1","type":"function"},{"doc":"Same as rmdir/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#rmdir!/1","title":"File.rmdir!/1","type":"function"},{"doc":"Returns information about the path . If it exists, it returns a {:ok, info} tuple, where info is a File.Stat struct. Returns {:error, reason} with the same reasons as read/1 if a failure occurs. Options The accepted options are: :time - configures how the file timestamps are returned The values for :time can be: :universal - returns a {date, time} tuple in UTC (default) :local - returns a {date, time} tuple using the same time zone as the machine :posix - returns the time as integer seconds since epoch Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the time: :posix option.","ref":"File.html#stat/2","title":"File.stat/2","type":"function"},{"doc":"Same as stat/2 but returns the File.Stat directly, or raises a File.Error exception if an error is returned.","ref":"File.html#stat!/2","title":"File.stat!/2","type":"function"},{"doc":"Returns a File.Stream for the given path with the given modes . The stream implements both Enumerable and Collectable protocols, which means it can be used both for read and write. The line_or_bytes argument configures how the file is read when streaming, by :line (default) or by a given number of bytes. When using the :line option, CRLF line breaks ( &quot; &quot; ) are normalized to LF ( &quot; &quot; ). Operating the stream can fail on open for the same reasons as File.open!/2 . Note that the file is automatically opened each time streaming begins. There is no need to pass :read and :write modes, as those are automatically set by Elixir. Raw files Since Elixir controls when the streamed file is opened, the underlying device cannot be shared and as such it is convenient to open the file in raw mode for performance reasons. Therefore, Elixir will open streams in :raw mode with the :read_ahead option unless an encoding is specified. This means any data streamed into the file must be converted to iodata/0 type. If you pass, for example, [encoding: :utf8] or [encoding: {:utf16, :little}] in the modes parameter, the underlying stream will use IO.write/2 and the String.Chars protocol to convert the data. See IO.binwrite/2 and IO.write/2 . One may also consider passing the :delayed_write option if the stream is meant to be written to under a tight loop. Byte order marks If you pass :trim_bom in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file. Note that this function does not try to discover the file encoding basing on BOM. Examples # Read in 2048 byte chunks rather than lines File . stream! ( &quot;./test/test.data&quot; , [ ] , 2048 ) #=&gt; %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary], #=&gt; path: &quot;./test/test.data&quot;, raw: true} See Stream.run/1 for an example of streaming into a file.","ref":"File.html#stream!/3","title":"File.stream!/3","type":"function"},{"doc":"Updates modification time (mtime) and access time (atime) of the given file. The file is created if it doesn't exist. Requires datetime in UTC (as returned by :erlang.universaltime() ) or an integer representing the POSIX timestamp (as returned by System.os_time(:second) ). In Unix-like systems, changing the modification time may require you to be either root or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with {:error, :eperm} . Examples File . touch ( &quot;/tmp/a.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) #=&gt; :ok File . touch ( &quot;/fakedir/b.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) { :error , :enoent } File . touch ( &quot;/tmp/a.txt&quot; , 1544519753 ) #=&gt; :ok","ref":"File.html#touch/2","title":"File.touch/2","type":"function"},{"doc":"Same as touch/2 but raises a File.Error exception if it fails. Returns :ok otherwise. The file is created if it doesn't exist. Requires datetime in UTC (as returned by :erlang.universaltime() ) or an integer representing the POSIX timestamp (as returned by System.os_time(:second) ). Examples File . touch! ( &quot;/tmp/a.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) #=&gt; :ok File . touch! ( &quot;/fakedir/b.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) ** (File.Error) could not touch &quot;/fakedir/b.txt&quot;: no such file or directory File . touch! ( &quot;/tmp/a.txt&quot; , 1544519753 )","ref":"File.html#touch!/2","title":"File.touch!/2","type":"function"},{"doc":"Writes content to the file path . The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns :ok if successful, or {:error, reason} if an error occurs. content must be iodata (a list of bytes or a binary). Setting the encoding for this function has no effect. Warning: Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via File.open/2 and using the functions in IO to write to the file will yield much better performance than calling this function multiple times. Typical error reasons are: :enoent - a component of the file name does not exist :enotdir - a component of the file name is not a directory; on some platforms, :enoent is returned instead :enospc - there is no space left on the device :eacces - missing permission for writing the file or searching one of the parent directories :eisdir - the named file is a directory Check File.open/2 for other available options.","ref":"File.html#write/3","title":"File.write/3","type":"function"},{"doc":"Same as write/3 but raises a File.Error exception if it fails. Returns :ok otherwise.","ref":"File.html#write!/3","title":"File.write!/3","type":"function"},{"doc":"Writes the given File.Stat back to the file system at the given path. Returns :ok or {:error, reason} .","ref":"File.html#write_stat/3","title":"File.write_stat/3","type":"function"},{"doc":"Same as write_stat/3 but raises a File.Error exception if it fails. Returns :ok otherwise.","ref":"File.html#write_stat!/3","title":"File.write_stat!/3","type":"function"},{"doc":"","ref":"File.html#t:encoding_mode/0","title":"File.encoding_mode/0","type":"type"},{"doc":"","ref":"File.html#t:erlang_time/0","title":"File.erlang_time/0","type":"type"},{"doc":"","ref":"File.html#t:io_device/0","title":"File.io_device/0","type":"type"},{"doc":"","ref":"File.html#t:mode/0","title":"File.mode/0","type":"type"},{"doc":"","ref":"File.html#t:posix/0","title":"File.posix/0","type":"type"},{"doc":"","ref":"File.html#t:posix_time/0","title":"File.posix_time/0","type":"type"},{"doc":"","ref":"File.html#t:stat_options/0","title":"File.stat_options/0","type":"type"},{"doc":"","ref":"File.html#t:stream_mode/0","title":"File.stream_mode/0","type":"type"},{"doc":"A struct that holds file information. In Erlang, this struct is represented by a :file_info record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct. Its fields are: size - size of file in bytes. type - :device | :directory | :regular | :other | :symlink ; the type of the file. access - :read | :write | :read_write | :none ; the current system access to the file. atime - the last time the file was read. mtime - the last time the file was written. ctime - the interpretation of this time field depends on the operating system. On Unix-like operating systems, it is the last time the file or the inode was changed. In Windows, it is the time of creation. mode - the file permissions. links - the number of links to this file. This is always 1 for file systems which have no concept of links. major_device - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on. minor_device - only valid for character devices on Unix-like systems. In all other cases, this field is zero. inode - gives the inode number. On non-Unix-like file systems, this field will be zero. uid - indicates the owner of the file. Will be zero for non-Unix-like file systems. gid - indicates the group that owns the file. Will be zero for non-Unix-like file systems. The time type returned in atime , mtime , and ctime is dependent on the time type set in options. {:time, type} where type can be :local , :universal , or :posix . Default is :universal .","ref":"File.Stat.html","title":"File.Stat","type":"module"},{"doc":"Converts a :file_info record into a File.Stat .","ref":"File.Stat.html#from_record/1","title":"File.Stat.from_record/1","type":"function"},{"doc":"Converts a File.Stat struct to a :file_info record.","ref":"File.Stat.html#to_record/1","title":"File.Stat.to_record/1","type":"function"},{"doc":"","ref":"File.Stat.html#t:t/0","title":"File.Stat.t/0","type":"type"},{"doc":"Defines a File.Stream struct returned by File.stream!/3 . The following fields are public: path - the file path modes - the file modes raw - a boolean indicating if bin functions should be used line_or_bytes - if reading should read lines or a given number of bytes","ref":"File.Stream.html","title":"File.Stream","type":"module"},{"doc":"","ref":"File.Stream.html#t:t/0","title":"File.Stream.t/0","type":"type"},{"doc":"Functions handling input/output (IO). Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides :stdio and :stderr as shortcuts to Erlang's :standard_io and :standard_error . The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the String.Chars protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below. IO devices An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts: :stdio - a shortcut for :standard_io , which maps to the current Process.group_leader/0 in Erlang :stderr - a shortcut for the named process :standard_error provided in Erlang IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the :file.position/2 function. IO data IO data is a data type that can be used as a more efficient alternative to binaries in certain situations. A term of type IO data is a binary or a list containing bytes (integers within the 0..255 range) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary &quot;hello&quot; : [ ?h , &quot;el&quot; , [ &quot;l&quot; , [ ?o ] ] ] The built-in iodata/0 type is defined in terms of iolist/0 . An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself). Use cases for IO data IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary. def email ( username , domain ) do username &lt;&gt; &quot;@&quot; &lt;&gt; domain end In this function, creating the email address will copy the username and domain binaries. Now imagine you want to use the resulting email inside another binary: def welcome_message ( name , username , domain ) do &quot;Welcome \#{ name } , your email is: \#{ email ( username , domain ) } &quot; end IO . puts ( welcome_message ( &quot;Meg&quot; , &quot;meg&quot; , &quot;example.com&quot; ) ) #=&gt; &quot;Welcome Meg, your email is: meg@example.com&quot; Every time you concatenate binaries or use interpolation ( \#{} ) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data: def email ( username , domain ) do [ username , ?@ , domain ] end def welcome_message ( name , username , domain ) do [ &quot;Welcome &quot; , name , &quot;, your email is: &quot; , email ( username , domain ) ] end IO . puts ( welcome_message ( &quot;Meg&quot; , &quot;meg&quot; , &quot;example.com&quot; ) ) #=&gt; &quot;Welcome Meg, your email is: meg@example.com&quot; Building IO data is cheaper than concatenating binaries. Concatenating multiple pieces of IO data just means putting them together inside a list since IO data can be arbitrarily nested, and that's a cheap and efficient operation. Most of the IO-based APIs, such as :gen_tcp and IO , receive IO data and write it to the socket directly without converting it to binary. One drawback of IO data is that you can't do things like pattern match on the first part of a piece of IO data like you can with a binary, because you usually don't know the shape of the IO data. In those cases, you may need to convert it to a binary by calling iodata_to_binary/1 , which is reasonably efficient since it's implemented natively in C. Other functionality, like computing the length of IO data, can be computed directly on the iodata by calling iodata_length/1 . Chardata Erlang and Elixir also have the idea of chardata/0 . Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode code points. Bytes ( byte/0 ) are integers within the 0..255 range, while Unicode code points ( char/0 ) are integers within the 0..0x10FFFF range. The IO module provides the chardata_to_string/1 function for chardata as the &quot;counter-part&quot; of the iodata_to_binary/1 function for IO data. If you try to use iodata_to_binary/1 on chardata, it will result in an argument error. For example, let's try to put a code point that is not representable with one byte, like ?π , inside IO data: IO . iodata_to_binary ( [ &quot;The symbol for pi is: &quot; , ?π ] ) #=&gt; ** (ArgumentError) argument error If we use chardata instead, it will work as expected: iex&gt; IO . chardata_to_string ( [ &quot;The symbol for pi is: &quot; , ?π ] ) &quot;The symbol for pi is: π&quot;","ref":"IO.html","title":"IO","type":"module"},{"doc":"Reads from the IO device . The operation is Unicode unsafe. The device is iterated by the given number of bytes or line by line if :line is given. Alternatively, if :all is given, then whole device is returned. It returns: data - the output bytes :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume If :all is given, :eof is never returned, but an empty string in case the device has reached EOF. Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.","ref":"IO.html#binread/2","title":"IO.binread/2","type":"function"},{"doc":"Converts the IO device into an IO.Stream . The operation is Unicode unsafe. An IO.Stream implements both Enumerable and Collectable , allowing it to be used for both read and write. The device is iterated by the given number of bytes or line by line if :line is given. This reads from the IO device as a raw binary. Note that an IO stream has side effects and every time you go over the stream you may get different results. Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result.","ref":"IO.html#binstream/2","title":"IO.binstream/2","type":"function"},{"doc":"Writes iodata to the given device . This operation is meant to be used with &quot;raw&quot; devices that are started without an encoding. The given iodata is written as is to the device, without conversion. For more information on IO data, see the &quot;IO data&quot; section in the module documentation. Use write/2 for devices with encoding. Important: do not use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.","ref":"IO.html#binwrite/2","title":"IO.binwrite/2","type":"function"},{"doc":"Converts chardata into a string. For more information about chardata, see the &quot;Chardata&quot; section in the module documentation. In case the conversion fails, it raises an UnicodeConversionError . If a string is given, it returns the string itself. Examples iex&gt; IO . chardata_to_string ( [ 0x00E6 , 0x00DF ] ) &quot;æß&quot; iex&gt; IO . chardata_to_string ( [ 0x0061 , &quot;bc&quot; ] ) &quot;abc&quot; iex&gt; IO . chardata_to_string ( &quot;string&quot; ) &quot;string&quot;","ref":"IO.html#chardata_to_string/1","title":"IO.chardata_to_string/1","type":"function"},{"doc":"Gets a number of bytes from IO device :stdio . If :stdio is a Unicode device, count implies the number of Unicode code points to be retrieved. Otherwise, count is the number of raw bytes to be retrieved. See IO.getn/3 for a description of return values.","ref":"IO.html#getn/2","title":"IO.getn/2","type":"function"},{"doc":"Gets a number of bytes from the IO device . If the IO device is a Unicode device, count implies the number of Unicode code points to be retrieved. Otherwise, count is the number of raw bytes to be retrieved. It returns: data - the input characters :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume","ref":"IO.html#getn/3","title":"IO.getn/3","type":"function"},{"doc":"Reads a line from the IO device . It returns: data - the characters in the line terminated by a line-feed (LF) or end of file (EOF) :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume Examples To display &quot;What is your name?&quot; as a prompt and await user input: IO . gets ( &quot;What is your name? \\n &quot; )","ref":"IO.html#gets/2","title":"IO.gets/2","type":"function"},{"doc":"Inspects and writes the given item to the device. It's important to note that it returns the given item unchanged. This makes it possible to &quot;spy&quot; on values by inserting an IO.inspect/2 call almost anywhere in your code, for example, in the middle of a pipeline. It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the :width option. The output can be decorated with a label, by providing the :label option to easily distinguish it from other IO.inspect/2 calls. The label will be printed before the inspected item . See Inspect.Opts for a full list of remaining formatting options. Examples IO . inspect ( &lt;&lt; 0 , 1 , 2 &gt;&gt; , width : 40 ) Prints: &lt;&lt; 0 , 1 , 2 &gt;&gt; We can use the :label option to decorate the output: IO . inspect ( 1 . . 100 , label : &quot;a wonderful range&quot; ) Prints: a wonderful range : 1 . . 100 The :label option is especially useful with pipelines: [ 1 , 2 , 3 ] |&gt; IO . inspect ( label : &quot;before&quot; ) |&gt; Enum . map ( &amp; ( &amp;1 * 2 ) ) |&gt; IO . inspect ( label : &quot;after&quot; ) |&gt; Enum . sum ( ) Prints: before : [ 1 , 2 , 3 ] after : [ 2 , 4 , 6 ]","ref":"IO.html#inspect/2","title":"IO.inspect/2","type":"function"},{"doc":"Inspects item according to the given options using the IO device . See inspect/2 for a full list of options.","ref":"IO.html#inspect/3","title":"IO.inspect/3","type":"function"},{"doc":"Returns the size of an IO data. For more information about IO data, see the &quot;IO data&quot; section in the module documentation. Inlined by the compiler. Examples iex&gt; IO . iodata_length ( [ 1 , 2 | &lt;&lt; 3 , 4 &gt;&gt; ] ) 4","ref":"IO.html#iodata_length/1","title":"IO.iodata_length/1","type":"function"},{"doc":"Converts IO data into a binary The operation is Unicode unsafe. Note that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use chardata_to_string/1 instead. For more information about IO data and chardata, see the &quot;IO data&quot; section in the module documentation. If this function receives a binary, the same binary is returned. Inlined by the compiler. Examples iex&gt; bin1 = &lt;&lt; 1 , 2 , 3 &gt;&gt; iex&gt; bin2 = &lt;&lt; 4 , 5 &gt;&gt; iex&gt; bin3 = &lt;&lt; 6 &gt;&gt; iex&gt; IO . iodata_to_binary ( [ bin1 , 1 , [ 2 , 3 , bin2 ] , 4 | bin3 ] ) &lt;&lt; 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 4 , 6 &gt;&gt; iex&gt; bin = &lt;&lt; 1 , 2 , 3 &gt;&gt; iex&gt; IO . iodata_to_binary ( bin ) &lt;&lt; 1 , 2 , 3 &gt;&gt;","ref":"IO.html#iodata_to_binary/1","title":"IO.iodata_to_binary/1","type":"function"},{"doc":"Writes item to the given device , similar to write/2 , but adds a newline at the end. By default, the device is the standard output. It returns :ok if it succeeds. Examples IO . puts ( &quot;Hello World!&quot; ) #=&gt; Hello World! IO . puts ( :stderr , &quot;error&quot; ) #=&gt; error","ref":"IO.html#puts/2","title":"IO.puts/2","type":"function"},{"doc":"Reads from the IO device . The device is iterated by the given number of characters or line by line if :line is given. Alternatively, if :all is given, then whole device is returned. It returns: data - the output characters :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume If :all is given, :eof is never returned, but an empty string in case the device has reached EOF.","ref":"IO.html#read/2","title":"IO.read/2","type":"function"},{"doc":"Converts the IO device into an IO.Stream . An IO.Stream implements both Enumerable and Collectable , allowing it to be used for both read and write. The device is iterated by the given number of characters or line by line if :line is given. This reads from the IO as UTF-8. Check out IO.binstream/2 to handle the IO as a raw binary. Note that an IO stream has side effects and every time you go over the stream you may get different results. Examples Here is an example on how we mimic an echo server from the command line: Enum . each ( IO . stream ( :stdio , :line ) , &amp; IO . write ( &amp;1 ) )","ref":"IO.html#stream/2","title":"IO.stream/2","type":"function"},{"doc":"Writes a message to stderr, along with the current stacktrace. It returns :ok if it succeeds. Do not call this function at the tail of another function. Due to tail call optimization, a stacktrace entry would not be added and the stacktrace would be incorrectly trimmed. Therefore make sure at least one expression (or an atom such as :ok ) follows the IO.warn/1 call. Examples IO . warn ( &quot;variable bar is unused&quot; ) #=&gt; warning: variable bar is unused #=&gt; (iex) evaluator.ex:108: IEx.Evaluator.eval/4","ref":"IO.html#warn/1","title":"IO.warn/1","type":"function"},{"doc":"Writes a message to stderr, along with the given stacktrace . This function also notifies the compiler a warning was printed (in case --warnings-as-errors was enabled). It returns :ok if it succeeds. An empty list can be passed to avoid stacktrace printing. Examples stacktrace = [ { MyApp , :main , 1 , [ file : &#39;my_app.ex&#39; , line : 4 ] } ] IO . warn ( &quot;variable bar is unused&quot; , stacktrace ) #=&gt; warning: variable bar is unused #=&gt; my_app.ex:4: MyApp.main/1","ref":"IO.html#warn/2","title":"IO.warn/2","type":"function"},{"doc":"Writes chardata to the given device . By default, the device is the standard output. Examples IO . write ( &quot;sample&quot; ) #=&gt; sample IO . write ( :stderr , &quot;error&quot; ) #=&gt; error","ref":"IO.html#write/2","title":"IO.write/2","type":"function"},{"doc":"","ref":"IO.html#t:chardata/0","title":"IO.chardata/0","type":"type"},{"doc":"","ref":"IO.html#t:device/0","title":"IO.device/0","type":"type"},{"doc":"","ref":"IO.html#t:nodata/0","title":"IO.nodata/0","type":"type"},{"doc":"Functionality to render ANSI escape sequences. ANSI escape sequences are characters embedded in text used to control formatting, color, and other output options on video text terminals. ANSI escapes are typically enabled on all Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command: reg add HKCU \\ Console / v VirtualTerminalLevel / t REG_DWORD / d 1 After running the command above, you must restart your current console. Examples Because the ANSI escape sequences are embedded in text, the normal usage of these functions is to concatenate their output with text. formatted_text = IO.ANSI . blue_background ( ) &lt;&gt; &quot;Example&quot; &lt;&gt; IO.ANSI . reset ( ) IO . puts ( formatted_text ) A higher level and more convenient API is also available via IO.ANSI.format/1 , where you use atoms to represent each ANSI escape sequence and by default checks if ANSI is enabled: IO . puts ( IO.ANSI . format ( [ :blue_background , &quot;Example&quot; ] ) ) In case ANSI is disabled, the ANSI escape sequences are simply discarded.","ref":"IO.ANSI.html","title":"IO.ANSI","type":"module"},{"doc":"Sets foreground color to black.","ref":"IO.ANSI.html#black/0","title":"IO.ANSI.black/0","type":"function"},{"doc":"Sets background color to black.","ref":"IO.ANSI.html#black_background/0","title":"IO.ANSI.black_background/0","type":"function"},{"doc":"Blink: off.","ref":"IO.ANSI.html#blink_off/0","title":"IO.ANSI.blink_off/0","type":"function"},{"doc":"Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported.","ref":"IO.ANSI.html#blink_rapid/0","title":"IO.ANSI.blink_rapid/0","type":"function"},{"doc":"Blink: slow. Less than 150 per minute.","ref":"IO.ANSI.html#blink_slow/0","title":"IO.ANSI.blink_slow/0","type":"function"},{"doc":"Sets foreground color to blue.","ref":"IO.ANSI.html#blue/0","title":"IO.ANSI.blue/0","type":"function"},{"doc":"Sets background color to blue.","ref":"IO.ANSI.html#blue_background/0","title":"IO.ANSI.blue_background/0","type":"function"},{"doc":"Bright (increased intensity) or bold.","ref":"IO.ANSI.html#bright/0","title":"IO.ANSI.bright/0","type":"function"},{"doc":"Clears screen.","ref":"IO.ANSI.html#clear/0","title":"IO.ANSI.clear/0","type":"function"},{"doc":"Clears line.","ref":"IO.ANSI.html#clear_line/0","title":"IO.ANSI.clear_line/0","type":"function"},{"doc":"Sets foreground color.","ref":"IO.ANSI.html#color/1","title":"IO.ANSI.color/1","type":"function"},{"doc":"Sets the foreground color from individual RGB values. Valid values for each color are in the range 0 to 5.","ref":"IO.ANSI.html#color/3","title":"IO.ANSI.color/3","type":"function"},{"doc":"Sets background color.","ref":"IO.ANSI.html#color_background/1","title":"IO.ANSI.color_background/1","type":"function"},{"doc":"Sets the background color from individual RGB values. Valid values for each color are in the range 0 to 5.","ref":"IO.ANSI.html#color_background/3","title":"IO.ANSI.color_background/3","type":"function"},{"doc":"Conceal. Not widely supported.","ref":"IO.ANSI.html#conceal/0","title":"IO.ANSI.conceal/0","type":"function"},{"doc":"Crossed-out. Characters legible, but marked for deletion. Not widely supported.","ref":"IO.ANSI.html#crossed_out/0","title":"IO.ANSI.crossed_out/0","type":"function"},{"doc":"Sends cursor to the absolute position specified by line and column . Line 0 and column 0 would mean the top left corner.","ref":"IO.ANSI.html#cursor/2","title":"IO.ANSI.cursor/2","type":"function"},{"doc":"Sends cursor lines down.","ref":"IO.ANSI.html#cursor_down/1","title":"IO.ANSI.cursor_down/1","type":"function"},{"doc":"Sends cursor columns to the left.","ref":"IO.ANSI.html#cursor_left/1","title":"IO.ANSI.cursor_left/1","type":"function"},{"doc":"Sends cursor columns to the right.","ref":"IO.ANSI.html#cursor_right/1","title":"IO.ANSI.cursor_right/1","type":"function"},{"doc":"Sends cursor lines up.","ref":"IO.ANSI.html#cursor_up/1","title":"IO.ANSI.cursor_up/1","type":"function"},{"doc":"Sets foreground color to cyan.","ref":"IO.ANSI.html#cyan/0","title":"IO.ANSI.cyan/0","type":"function"},{"doc":"Sets background color to cyan.","ref":"IO.ANSI.html#cyan_background/0","title":"IO.ANSI.cyan_background/0","type":"function"},{"doc":"Default background color.","ref":"IO.ANSI.html#default_background/0","title":"IO.ANSI.default_background/0","type":"function"},{"doc":"Default text color.","ref":"IO.ANSI.html#default_color/0","title":"IO.ANSI.default_color/0","type":"function"},{"doc":"Checks if ANSI coloring is supported and enabled on this machine. This function simply reads the configuration value for :ansi_enabled in the :elixir application. The value is by default false unless Elixir can detect during startup that both stdout and stderr are terminals.","ref":"IO.ANSI.html#enabled?/0","title":"IO.ANSI.enabled?/0","type":"function"},{"doc":"Encircled.","ref":"IO.ANSI.html#encircled/0","title":"IO.ANSI.encircled/0","type":"function"},{"doc":"Faint (decreased intensity). Not widely supported.","ref":"IO.ANSI.html#faint/0","title":"IO.ANSI.faint/0","type":"function"},{"doc":"Sets alternative font 1.","ref":"IO.ANSI.html#font_1/0","title":"IO.ANSI.font_1/0","type":"function"},{"doc":"Sets alternative font 2.","ref":"IO.ANSI.html#font_2/0","title":"IO.ANSI.font_2/0","type":"function"},{"doc":"Sets alternative font 3.","ref":"IO.ANSI.html#font_3/0","title":"IO.ANSI.font_3/0","type":"function"},{"doc":"Sets alternative font 4.","ref":"IO.ANSI.html#font_4/0","title":"IO.ANSI.font_4/0","type":"function"},{"doc":"Sets alternative font 5.","ref":"IO.ANSI.html#font_5/0","title":"IO.ANSI.font_5/0","type":"function"},{"doc":"Sets alternative font 6.","ref":"IO.ANSI.html#font_6/0","title":"IO.ANSI.font_6/0","type":"function"},{"doc":"Sets alternative font 7.","ref":"IO.ANSI.html#font_7/0","title":"IO.ANSI.font_7/0","type":"function"},{"doc":"Sets alternative font 8.","ref":"IO.ANSI.html#font_8/0","title":"IO.ANSI.font_8/0","type":"function"},{"doc":"Sets alternative font 9.","ref":"IO.ANSI.html#font_9/0","title":"IO.ANSI.font_9/0","type":"function"},{"doc":"Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes. The named sequences are represented by atoms. It will also append an IO.ANSI.reset/0 to the chardata when a conversion is performed. If you don't want this behaviour, use format_fragment/2 . An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When false , no ANSI codes will be emitted. By default checks if ANSI is enabled using the enabled?/0 function. Examples iex&gt; IO.ANSI . format ( [ &quot;Hello, &quot; , :red , :bright , &quot;world!&quot; ] , true ) [ [ [ [ [ [ ] , &quot;Hello, &quot; ] | &quot; \\e [31m&quot; ] | &quot; \\e [1m&quot; ] , &quot;world!&quot; ] | &quot; \\e [0m&quot; ]","ref":"IO.ANSI.html#format/2","title":"IO.ANSI.format/2","type":"function"},{"doc":"Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes. The named sequences are represented by atoms. An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When false , no ANSI codes will be emitted. By default checks if ANSI is enabled using the enabled?/0 function. Examples iex&gt; IO.ANSI . format_fragment ( [ :bright , &#39;Word&#39; ] , true ) [ [ [ [ [ [ ] | &quot; \\e [1m&quot; ] , 87 ] , 111 ] , 114 ] , 100 ]","ref":"IO.ANSI.html#format_fragment/2","title":"IO.ANSI.format_fragment/2","type":"function"},{"doc":"Framed.","ref":"IO.ANSI.html#framed/0","title":"IO.ANSI.framed/0","type":"function"},{"doc":"Sets foreground color to green.","ref":"IO.ANSI.html#green/0","title":"IO.ANSI.green/0","type":"function"},{"doc":"Sets background color to green.","ref":"IO.ANSI.html#green_background/0","title":"IO.ANSI.green_background/0","type":"function"},{"doc":"Sends cursor home.","ref":"IO.ANSI.html#home/0","title":"IO.ANSI.home/0","type":"function"},{"doc":"Image: negative. Swap foreground and background.","ref":"IO.ANSI.html#inverse/0","title":"IO.ANSI.inverse/0","type":"function"},{"doc":"Image: positive. Normal foreground and background.","ref":"IO.ANSI.html#inverse_off/0","title":"IO.ANSI.inverse_off/0","type":"function"},{"doc":"Italic: on. Not widely supported. Sometimes treated as inverse.","ref":"IO.ANSI.html#italic/0","title":"IO.ANSI.italic/0","type":"function"},{"doc":"Sets foreground color to light black.","ref":"IO.ANSI.html#light_black/0","title":"IO.ANSI.light_black/0","type":"function"},{"doc":"Sets background color to light black.","ref":"IO.ANSI.html#light_black_background/0","title":"IO.ANSI.light_black_background/0","type":"function"},{"doc":"Sets foreground color to light blue.","ref":"IO.ANSI.html#light_blue/0","title":"IO.ANSI.light_blue/0","type":"function"},{"doc":"Sets background color to light blue.","ref":"IO.ANSI.html#light_blue_background/0","title":"IO.ANSI.light_blue_background/0","type":"function"},{"doc":"Sets foreground color to light cyan.","ref":"IO.ANSI.html#light_cyan/0","title":"IO.ANSI.light_cyan/0","type":"function"},{"doc":"Sets background color to light cyan.","ref":"IO.ANSI.html#light_cyan_background/0","title":"IO.ANSI.light_cyan_background/0","type":"function"},{"doc":"Sets foreground color to light green.","ref":"IO.ANSI.html#light_green/0","title":"IO.ANSI.light_green/0","type":"function"},{"doc":"Sets background color to light green.","ref":"IO.ANSI.html#light_green_background/0","title":"IO.ANSI.light_green_background/0","type":"function"},{"doc":"Sets foreground color to light magenta.","ref":"IO.ANSI.html#light_magenta/0","title":"IO.ANSI.light_magenta/0","type":"function"},{"doc":"Sets background color to light magenta.","ref":"IO.ANSI.html#light_magenta_background/0","title":"IO.ANSI.light_magenta_background/0","type":"function"},{"doc":"Sets foreground color to light red.","ref":"IO.ANSI.html#light_red/0","title":"IO.ANSI.light_red/0","type":"function"},{"doc":"Sets background color to light red.","ref":"IO.ANSI.html#light_red_background/0","title":"IO.ANSI.light_red_background/0","type":"function"},{"doc":"Sets foreground color to light white.","ref":"IO.ANSI.html#light_white/0","title":"IO.ANSI.light_white/0","type":"function"},{"doc":"Sets background color to light white.","ref":"IO.ANSI.html#light_white_background/0","title":"IO.ANSI.light_white_background/0","type":"function"},{"doc":"Sets foreground color to light yellow.","ref":"IO.ANSI.html#light_yellow/0","title":"IO.ANSI.light_yellow/0","type":"function"},{"doc":"Sets background color to light yellow.","ref":"IO.ANSI.html#light_yellow_background/0","title":"IO.ANSI.light_yellow_background/0","type":"function"},{"doc":"Sets foreground color to magenta.","ref":"IO.ANSI.html#magenta/0","title":"IO.ANSI.magenta/0","type":"function"},{"doc":"Sets background color to magenta.","ref":"IO.ANSI.html#magenta_background/0","title":"IO.ANSI.magenta_background/0","type":"function"},{"doc":"Underline: none.","ref":"IO.ANSI.html#no_underline/0","title":"IO.ANSI.no_underline/0","type":"function"},{"doc":"Normal color or intensity.","ref":"IO.ANSI.html#normal/0","title":"IO.ANSI.normal/0","type":"function"},{"doc":"Not framed or encircled.","ref":"IO.ANSI.html#not_framed_encircled/0","title":"IO.ANSI.not_framed_encircled/0","type":"function"},{"doc":"Not italic.","ref":"IO.ANSI.html#not_italic/0","title":"IO.ANSI.not_italic/0","type":"function"},{"doc":"Not overlined.","ref":"IO.ANSI.html#not_overlined/0","title":"IO.ANSI.not_overlined/0","type":"function"},{"doc":"Overlined.","ref":"IO.ANSI.html#overlined/0","title":"IO.ANSI.overlined/0","type":"function"},{"doc":"Sets primary (default) font.","ref":"IO.ANSI.html#primary_font/0","title":"IO.ANSI.primary_font/0","type":"function"},{"doc":"Sets foreground color to red.","ref":"IO.ANSI.html#red/0","title":"IO.ANSI.red/0","type":"function"},{"doc":"Sets background color to red.","ref":"IO.ANSI.html#red_background/0","title":"IO.ANSI.red_background/0","type":"function"},{"doc":"Resets all attributes.","ref":"IO.ANSI.html#reset/0","title":"IO.ANSI.reset/0","type":"function"},{"doc":"Image: negative. Swap foreground and background.","ref":"IO.ANSI.html#reverse/0","title":"IO.ANSI.reverse/0","type":"function"},{"doc":"Image: positive. Normal foreground and background.","ref":"IO.ANSI.html#reverse_off/0","title":"IO.ANSI.reverse_off/0","type":"function"},{"doc":"Underline: single.","ref":"IO.ANSI.html#underline/0","title":"IO.ANSI.underline/0","type":"function"},{"doc":"Sets foreground color to white.","ref":"IO.ANSI.html#white/0","title":"IO.ANSI.white/0","type":"function"},{"doc":"Sets background color to white.","ref":"IO.ANSI.html#white_background/0","title":"IO.ANSI.white_background/0","type":"function"},{"doc":"Sets foreground color to yellow.","ref":"IO.ANSI.html#yellow/0","title":"IO.ANSI.yellow/0","type":"function"},{"doc":"Sets background color to yellow.","ref":"IO.ANSI.html#yellow_background/0","title":"IO.ANSI.yellow_background/0","type":"function"},{"doc":"","ref":"IO.ANSI.html#t:ansicode/0","title":"IO.ANSI.ansicode/0","type":"type"},{"doc":"","ref":"IO.ANSI.html#t:ansidata/0","title":"IO.ANSI.ansidata/0","type":"type"},{"doc":"","ref":"IO.ANSI.html#t:ansilist/0","title":"IO.ANSI.ansilist/0","type":"type"},{"doc":"Defines an IO.Stream struct returned by IO.stream/2 and IO.binstream/2 . The following fields are public: device - the IO device raw - a boolean indicating if bin functions should be used line_or_bytes - if reading should read lines or a given number of bytes It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.","ref":"IO.Stream.html","title":"IO.Stream","type":"module"},{"doc":"","ref":"IO.Stream.html#t:t/0","title":"IO.Stream.t/0","type":"type"},{"doc":"Functions for parsing command line arguments. When calling a command, it's possible to pass command line options to modify what the command does. In this documentation, those are called &quot;switches&quot;, in other situations they may be called &quot;flags&quot; or simply &quot;options&quot;. A switch can be given a value, also called an &quot;argument&quot;. The main function in this module is parse/2 , which parses a list of command line options and arguments into a keyword list: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ ] , [ ] } OptionParser provides some conveniences out of the box, such as aliases and automatic handling of negation switches. The parse_head/2 function is an alternative to parse/2 which stops parsing as soon as it finds a value that is not a switch nor a value for a previous switch. This module also provides low-level functions, such as next/2 , for parsing switches manually, as well as split/1 and to_argv/1 for parsing from and converting switches to strings.","ref":"OptionParser.html","title":"OptionParser","type":"module"},{"doc":"Low-level function that parses one option. It accepts the same options as parse/2 and parse_head/2 as both functions are built on top of this function. This function may return: {:ok, key, value, rest} - the option key with value was successfully parsed {:invalid, key, value, rest} - the option key is invalid with value (returned when the value cannot be parsed according to the switch type) {:undefined, key, value, rest} - the option key is undefined (returned in strict mode when the switch is unknown or on nonexistent atoms) {:error, rest} - there are no switches at the head of the given argv","ref":"OptionParser.html#next/2","title":"OptionParser.next/2","type":"function"},{"doc":"Parses argv into a keyword list. It returns a three-element tuple with the form {parsed, args, invalid} , where: parsed is a keyword list of parsed switches with {switch_name, value} tuples in it; switch_name is the atom representing the switch name while value is the value for that switch parsed according to opts (see the &quot;Examples&quot; section for more information) args is a list of the remaining arguments in argv as strings invalid is a list of invalid options as {option_name, value} where option_name is the raw option and value is nil if the option wasn't expected or the string value if the value didn't have the expected type for the corresponding option Elixir converts switches to underscored atoms, so --source-path becomes :source_path . This is done to better suit Elixir conventions. However, this means that switches can't contain underscores and switches that do contain underscores are always returned in the list of invalid switches. When parsing, it is common to list switches and their expected types: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--source&quot; , &quot;lib&quot; ] , strict : [ source : :string ] ) { [ source : &quot;lib&quot; ] , [ ] , [ ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--source-path&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , ...&gt; strict : [ source_path : :string , verbose : :boolean ] ...&gt; ) { [ source_path : &quot;lib&quot; , verbose : true ] , [ &quot;test/enum_test.exs&quot; ] , [ ] } We will explore the valid switches and operation modes of option parser below. Options The following options are supported: :switches or :strict - see the &quot;Switch definitions&quot; section below :allow_nonexistent_atoms - see the &quot;Parsing unknown switches&quot; section below :aliases - see the &quot;Aliases&quot; section below Switch definitions Switches can be specified via one of two options: :strict - defines strict switches and their types. Any switch in argv that is not specified in the list is returned in the invalid options list. This is the preferred way to parse options. :switches - defines switches and their types. This function still attempts to parse switches that are not in this list. Both these options accept a keyword list where the key is an atom defining the name of the switch and value is the type of the switch (see the &quot;Types&quot; section below for more information). Note that you should only supply the :switches or the :strict option. If you supply both, an ArgumentError exception will be raised. Types Switches parsed by OptionParser may take zero or one arguments. The following switches types take no arguments: :boolean - sets the value to true when given (see also the &quot;Negation switches&quot; section below) :count - counts the number of times the switch is given The following switches take one argument: :integer - parses the value as an integer :float - parses the value as a float :string - parses the value as a string If a switch can't be parsed according to the given type, it is returned in the invalid options list. Modifiers Switches can be specified with modifiers, which change how they behave. The following modifiers are supported: :keep - keeps duplicated elements instead of overriding them; works with all types except :count . Specifying switch_name: :keep assumes the type of :switch_name will be :string . To use :keep with a type other than :string , use a list as the type for the switch. For example: [foo: [:integer, :keep]] . Negation switches In case a switch SWITCH is specified to have type :boolean , it may be passed as --no-SWITCH as well which will set the option to false : iex&gt; OptionParser . parse ( [ &quot;--no-op&quot; , &quot;path/to/file&quot; ] , switches : [ op : :boolean ] ) { [ op : false ] , [ &quot;path/to/file&quot; ] , [ ] } Parsing unknown switches When the :switches option is given, OptionParser will attempt to parse unknown switches: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; ] , switches : [ key : :string ] ) { [ debug : true ] , [ ] , [ ] } Even though we haven't specified --debug in the list of switches, it is part of the returned options. This would also work: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; , &quot;value&quot; ] , switches : [ key : :string ] ) { [ debug : &quot;value&quot; ] , [ ] , [ ] } Switches followed by a value will be assigned the value, as a string. Switches without an argument will be set automatically to true . Since we cannot assert the type of the switch value, it is preferred to use the :strict option that accepts only known switches and always verify their types. If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the --option-parser-example switch because the :option_parser_example atom is never used anywhere: OptionParser . parse ( [ &quot;--option-parser-example&quot; ] , switches : [ debug : :boolean ] ) # The :option_parser_example atom is not used anywhere below However, the code below would work as long as :option_parser_example atom is used at some point later (or earlier) in the same module . For example: { opts , _ , _ } = OptionParser . parse ( [ &quot;--option-parser-example&quot; ] , switches : [ debug : :boolean ] ) # ... then somewhere in the same module you access it ... opts [ :option_parser_example ] In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing allow_nonexistent_atoms: true as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems. Aliases A set of aliases can be specified in the :aliases option: iex&gt; OptionParser . parse ( [ &quot;-d&quot; ] , aliases : [ d : :debug ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ ] , [ ] } Examples Here are some examples of working with different types and modifiers: iex&gt; OptionParser . parse ( [ &quot;--unlock&quot; , &quot;path/to/file&quot; ] , strict : [ unlock : :boolean ] ) { [ unlock : true ] , [ &quot;path/to/file&quot; ] , [ ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--unlock&quot; , &quot;--limit&quot; , &quot;0&quot; , &quot;path/to/file&quot; ] , ...&gt; strict : [ unlock : :boolean , limit : :integer ] ...&gt; ) { [ unlock : true , limit : 0 ] , [ &quot;path/to/file&quot; ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--limit&quot; , &quot;3&quot; ] , strict : [ limit : :integer ] ) { [ limit : 3 ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--limit&quot; , &quot;xyz&quot; ] , strict : [ limit : :integer ] ) { [ ] , [ ] , [ { &quot;--limit&quot; , &quot;xyz&quot; } ] } iex&gt; OptionParser . parse ( [ &quot;--verbose&quot; ] , switches : [ verbose : :count ] ) { [ verbose : 1 ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;-v&quot; , &quot;-v&quot; ] , aliases : [ v : :verbose ] , strict : [ verbose : :count ] ) { [ verbose : 2 ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--unknown&quot; , &quot;xyz&quot; ] , strict : [ ] ) { [ ] , [ &quot;xyz&quot; ] , [ { &quot;--unknown&quot; , nil } ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--limit&quot; , &quot;3&quot; , &quot;--unknown&quot; , &quot;xyz&quot; ] , ...&gt; switches : [ limit : :integer ] ...&gt; ) { [ limit : 3 , unknown : &quot;xyz&quot; ] , [ ] , [ ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--unlock&quot; , &quot;path/to/file&quot; , &quot;--unlock&quot; , &quot;path/to/another/file&quot; ] , ...&gt; strict : [ unlock : :keep ] ...&gt; ) { [ unlock : &quot;path/to/file&quot; , unlock : &quot;path/to/another/file&quot; ] , [ ] , [ ] }","ref":"OptionParser.html#parse/2","title":"OptionParser.parse/2","type":"function"},{"doc":"The same as parse/2 but raises an OptionParser.ParseError exception if any invalid options are given. If there are no errors, returns a {parsed, rest} tuple where: parsed is the list of parsed switches (same as in parse/2 ) rest is the list of arguments (same as in parse/2 ) Examples iex&gt; OptionParser . parse! ( [ &quot;--debug&quot; , &quot;path/to/file&quot; ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ &quot;path/to/file&quot; ] } iex&gt; OptionParser . parse! ( [ &quot;--limit&quot; , &quot;xyz&quot; ] , strict : [ limit : :integer ] ) ** (OptionParser.ParseError) 1 error found! -- limit : Expected type integer , got &quot;xyz&quot; iex&gt; OptionParser . parse! ( [ &quot;--unknown&quot; , &quot;xyz&quot; ] , strict : [ ] ) ** (OptionParser.ParseError) 1 error found! -- unknown : Unknown option iex&gt; OptionParser . parse! ( ...&gt; [ &quot;-l&quot; , &quot;xyz&quot; , &quot;-f&quot; , &quot;bar&quot; ] , ...&gt; switches : [ limit : :integer , foo : :integer ] , ...&gt; aliases : [ l : :limit , f : :foo ] ...&gt; ) ** (OptionParser.ParseError) 2 errors found! - l : Expected type integer , got &quot;xyz&quot; - f : Expected type integer , got &quot;bar&quot;","ref":"OptionParser.html#parse!/2","title":"OptionParser.parse!/2","type":"function"},{"doc":"Similar to parse/2 but only parses the head of argv ; as soon as it finds a non-switch, it stops parsing. See parse/2 for more information. Example iex&gt; OptionParser . parse_head ( ...&gt; [ &quot;--source&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , ...&gt; switches : [ source : :string , verbose : :boolean ] ...&gt; ) { [ source : &quot;lib&quot; ] , [ &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , [ ] } iex&gt; OptionParser . parse_head ( ...&gt; [ &quot;--verbose&quot; , &quot;--source&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--unlock&quot; ] , ...&gt; switches : [ source : :string , verbose : :boolean , unlock : :boolean ] ...&gt; ) { [ verbose : true , source : &quot;lib&quot; ] , [ &quot;test/enum_test.exs&quot; , &quot;--unlock&quot; ] , [ ] }","ref":"OptionParser.html#parse_head/2","title":"OptionParser.parse_head/2","type":"function"},{"doc":"The same as parse_head/2 but raises an OptionParser.ParseError exception if any invalid options are given. If there are no errors, returns a {parsed, rest} tuple where: parsed is the list of parsed switches (same as in parse_head/2 ) rest is the list of arguments (same as in parse_head/2 ) Examples iex&gt; OptionParser . parse_head! ( ...&gt; [ &quot;--source&quot; , &quot;lib&quot; , &quot;path/to/file&quot; , &quot;--verbose&quot; ] , ...&gt; switches : [ source : :string , verbose : :boolean ] ...&gt; ) { [ source : &quot;lib&quot; ] , [ &quot;path/to/file&quot; , &quot;--verbose&quot; ] } iex&gt; OptionParser . parse_head! ( ...&gt; [ &quot;--number&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , ...&gt; strict : [ number : :integer ] ...&gt; ) ** (OptionParser.ParseError) 1 error found! -- number : Expected type integer , got &quot;lib&quot; iex&gt; OptionParser . parse_head! ( ...&gt; [ &quot;--verbose&quot; , &quot;--source&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--unlock&quot; ] , ...&gt; strict : [ verbose : :integer , source : :integer ] ...&gt; ) ** (OptionParser.ParseError) 2 errors found! -- verbose : Missing argument of type integer -- source : Expected type integer , got &quot;lib&quot;","ref":"OptionParser.html#parse_head!/2","title":"OptionParser.parse_head!/2","type":"function"},{"doc":"Splits a string into argv/0 chunks. This function splits the given string into a list of strings in a similar way to many shells. Examples iex&gt; OptionParser . split ( &quot;foo bar&quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; OptionParser . split ( &quot;foo \\&quot; bar baz \\&quot; &quot; ) [ &quot;foo&quot; , &quot;bar baz&quot; ]","ref":"OptionParser.html#split/1","title":"OptionParser.split/1","type":"function"},{"doc":"Receives a key-value enumerable and converts it to argv/0 . Keys must be atoms. Keys with nil value are discarded, boolean values are converted to --key or --no-key (if the value is true or false , respectively), and all other values are converted using Kernel.to_string/1 . It is advised to pass to to_argv/2 the same set of options given to parse/2 . Some switches can only be reconstructed correctly with the :switches information in hand. Examples iex&gt; OptionParser . to_argv ( foo_bar : &quot;baz&quot; ) [ &quot;--foo-bar&quot; , &quot;baz&quot; ] iex&gt; OptionParser . to_argv ( bool : true , bool : false , discarded : nil ) [ &quot;--bool&quot; , &quot;--no-bool&quot; ] Some switches will output different values based on the switches types: iex&gt; OptionParser . to_argv ( [ number : 2 ] , switches : [ ] ) [ &quot;--number&quot; , &quot;2&quot; ] iex&gt; OptionParser . to_argv ( [ number : 2 ] , switches : [ number : :count ] ) [ &quot;--number&quot; , &quot;--number&quot; ]","ref":"OptionParser.html#to_argv/2","title":"OptionParser.to_argv/2","type":"function"},{"doc":"","ref":"OptionParser.html#t:argv/0","title":"OptionParser.argv/0","type":"type"},{"doc":"","ref":"OptionParser.html#t:errors/0","title":"OptionParser.errors/0","type":"type"},{"doc":"","ref":"OptionParser.html#t:options/0","title":"OptionParser.options/0","type":"type"},{"doc":"","ref":"OptionParser.html#t:parsed/0","title":"OptionParser.parsed/0","type":"type"},{"doc":"This module provides conveniences for manipulating or retrieving file system paths. The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8). The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like wildcard/2 and expand/1 ).","ref":"Path.html","title":"Path","type":"module"},{"doc":"Converts the given path to an absolute one. Unlike expand/1 , no attempt is made to resolve .. , . or ~ . Examples Unix-like operating systems Path . absname ( &quot;foo&quot; ) #=&gt; &quot;/usr/local/foo&quot; Path . absname ( &quot;../x&quot; ) #=&gt; &quot;/usr/local/../x&quot; Windows Path . absname ( &quot;foo&quot; ) #=&gt; &quot;D:/usr/local/foo&quot; Path . absname ( &quot;../x&quot; ) #=&gt; &quot;D:/usr/local/../x&quot;","ref":"Path.html#absname/1","title":"Path.absname/1","type":"function"},{"doc":"Builds a path from relative_to to path . If path is already an absolute path, relative_to is ignored. See also relative_to/2 . Unlike expand/2 , no attempt is made to resolve .. , . or ~ . Examples iex&gt; Path . absname ( &quot;foo&quot; , &quot;bar&quot; ) &quot;bar/foo&quot; iex&gt; Path . absname ( &quot;../x&quot; , &quot;bar&quot; ) &quot;bar/../x&quot;","ref":"Path.html#absname/2","title":"Path.absname/2","type":"function"},{"doc":"Returns the last component of the path or the path itself if it does not contain any directory separators. Examples iex&gt; Path . basename ( &quot;foo&quot; ) &quot;foo&quot; iex&gt; Path . basename ( &quot;foo/bar&quot; ) &quot;bar&quot; iex&gt; Path . basename ( &quot;/&quot; ) &quot;&quot;","ref":"Path.html#basename/1","title":"Path.basename/1","type":"function"},{"doc":"Returns the last component of path with the extension stripped. This function should be used to remove a specific extension which may or may not be there. Examples iex&gt; Path . basename ( &quot;~/foo/bar.ex&quot; , &quot;.ex&quot; ) &quot;bar&quot; iex&gt; Path . basename ( &quot;~/foo/bar.exs&quot; , &quot;.ex&quot; ) &quot;bar.exs&quot; iex&gt; Path . basename ( &quot;~/foo/bar.old.ex&quot; , &quot;.ex&quot; ) &quot;bar.old&quot;","ref":"Path.html#basename/2","title":"Path.basename/2","type":"function"},{"doc":"Returns the directory component of path . Examples iex&gt; Path . dirname ( &quot;/foo/bar.ex&quot; ) &quot;/foo&quot; iex&gt; Path . dirname ( &quot;/foo/bar/baz.ex&quot; ) &quot;/foo/bar&quot; iex&gt; Path . dirname ( &quot;/foo/bar/&quot; ) &quot;/foo/bar&quot; iex&gt; Path . dirname ( &quot;bar.ex&quot; ) &quot;.&quot;","ref":"Path.html#dirname/1","title":"Path.dirname/1","type":"function"},{"doc":"Converts the path to an absolute one and expands any . and .. characters and a leading ~ . Examples Path . expand ( &quot;/foo/bar/../baz&quot; ) #=&gt; &quot;/foo/baz&quot;","ref":"Path.html#expand/1","title":"Path.expand/1","type":"function"},{"doc":"Expands the path relative to the path given as the second argument expanding any . and .. characters. If the path is already an absolute path, relative_to is ignored. Note that this function treats a path with a leading ~ as an absolute one. The second argument is first expanded to an absolute path. Examples # Assuming that the absolute path to baz is /quux/baz Path . expand ( &quot;foo/bar/../bar&quot; , &quot;baz&quot; ) #=&gt; &quot;/quux/baz/foo/bar&quot; Path . expand ( &quot;foo/bar/../bar&quot; , &quot;/baz&quot; ) #=&gt; &quot;/baz/foo/bar&quot; Path . expand ( &quot;/foo/bar/../bar&quot; , &quot;/baz&quot; ) #=&gt; &quot;/foo/bar&quot;","ref":"Path.html#expand/2","title":"Path.expand/2","type":"function"},{"doc":"Returns the extension of the last component of path . Examples iex&gt; Path . extname ( &quot;foo.erl&quot; ) &quot;.erl&quot; iex&gt; Path . extname ( &quot;~/foo/bar&quot; ) &quot;&quot;","ref":"Path.html#extname/1","title":"Path.extname/1","type":"function"},{"doc":"Joins a list of paths. This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining. Examples iex&gt; Path . join ( [ &quot;~&quot; , &quot;foo&quot; ] ) &quot;~/foo&quot; iex&gt; Path . join ( [ &quot;foo&quot; ] ) &quot;foo&quot; iex&gt; Path . join ( [ &quot;/&quot; , &quot;foo&quot; , &quot;bar/&quot; ] ) &quot;/foo/bar&quot;","ref":"Path.html#join/1","title":"Path.join/1","type":"function"},{"doc":"Joins two paths. The right path will always be expanded to its relative format and any trailing slash will be removed when joining. Examples iex&gt; Path . join ( &quot;foo&quot; , &quot;bar&quot; ) &quot;foo/bar&quot; iex&gt; Path . join ( &quot;/foo&quot; , &quot;/bar/&quot; ) &quot;/foo/bar&quot; The functions in this module support chardata, so giving a list will treat it as a single entity: iex&gt; Path . join ( &quot;foo&quot; , [ &quot;bar&quot; , &quot;fiz&quot; ] ) &quot;foo/barfiz&quot; iex&gt; Path . join ( [ &quot;foo&quot; , &quot;bar&quot; ] , &quot;fiz&quot; ) &quot;foobar/fiz&quot;","ref":"Path.html#join/2","title":"Path.join/2","type":"function"},{"doc":"Forces the path to be a relative path. Examples Unix-like operating systems Path . relative ( &quot;/usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;../usr/local/bin&quot; ) #=&gt; &quot;../usr/local/bin&quot; Windows Path . relative ( &quot;D:/usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;D:bar.ex&quot; ) #=&gt; &quot;bar.ex&quot; Path . relative ( &quot;/bar/foo.ex&quot; ) #=&gt; &quot;bar/foo.ex&quot;","ref":"Path.html#relative/1","title":"Path.relative/1","type":"function"},{"doc":"Returns the given path relative to the given from path. In other words, this function tries to strip the from prefix from path . This function does not query the file system, so it assumes no symlinks between the paths. In case a direct relative path cannot be found, it returns the original path. Examples iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/usr/local&quot; ) &quot;foo&quot; iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/&quot; ) &quot;usr/local/foo&quot; iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/etc&quot; ) &quot;/usr/local/foo&quot; iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/usr/local/foo&quot; ) &quot;.&quot;","ref":"Path.html#relative_to/2","title":"Path.relative_to/2","type":"function"},{"doc":"Convenience to get the path relative to the current working directory. If, for some reason, the current working directory cannot be retrieved, this function returns the given path .","ref":"Path.html#relative_to_cwd/1","title":"Path.relative_to_cwd/1","type":"function"},{"doc":"Returns the path with the extension stripped. Examples iex&gt; Path . rootname ( &quot;/foo/bar&quot; ) &quot;/foo/bar&quot; iex&gt; Path . rootname ( &quot;/foo/bar.ex&quot; ) &quot;/foo/bar&quot;","ref":"Path.html#rootname/1","title":"Path.rootname/1","type":"function"},{"doc":"Returns the path with the extension stripped. This function should be used to remove a specific extension which may or may not be there. Examples iex&gt; Path . rootname ( &quot;/foo/bar.erl&quot; , &quot;.erl&quot; ) &quot;/foo/bar&quot; iex&gt; Path . rootname ( &quot;/foo/bar.erl&quot; , &quot;.ex&quot; ) &quot;/foo/bar.erl&quot;","ref":"Path.html#rootname/2","title":"Path.rootname/2","type":"function"},{"doc":"Splits the path into a list at the path separator. If an empty string is given, returns an empty list. On Windows, path is split on both &quot;\\&quot; and &quot;/&quot; separators and the driver letter, if there is one, is always returned in lowercase. Examples iex&gt; Path . split ( &quot;&quot; ) [ ] iex&gt; Path . split ( &quot;foo&quot; ) [ &quot;foo&quot; ] iex&gt; Path . split ( &quot;/foo/bar&quot; ) [ &quot;/&quot; , &quot;foo&quot; , &quot;bar&quot; ]","ref":"Path.html#split/1","title":"Path.split/1","type":"function"},{"doc":"Returns the path type. Examples Unix-like operating systems Path . type ( &quot;/&quot; ) #=&gt; :absolute Path . type ( &quot;/usr/local/bin&quot; ) #=&gt; :absolute Path . type ( &quot;usr/local/bin&quot; ) #=&gt; :relative Path . type ( &quot;../usr/local/bin&quot; ) #=&gt; :relative Path . type ( &quot;~/file&quot; ) #=&gt; :relative Windows Path . type ( &quot;D:/usr/local/bin&quot; ) #=&gt; :absolute Path . type ( &quot;usr/local/bin&quot; ) #=&gt; :relative Path . type ( &quot;D:bar.ex&quot; ) #=&gt; :volumerelative Path . type ( &quot;/bar/foo.ex&quot; ) #=&gt; :volumerelative","ref":"Path.html#type/1","title":"Path.type/1","type":"function"},{"doc":"Traverses paths according to the given glob expression and returns a list of matches. The wildcard looks like an ordinary path, except that the following &quot;wildcard characters&quot; are interpreted in a special way: ? - matches one character. * - matches any number of characters up to the end of the filename, the next dot, or the next slash. ** - two adjacent * 's used as a single pattern will match all files and zero or more directories and subdirectories. [char1,char2,...] - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself. {item1,item2,...} - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself. Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: &quot;a&quot; will not match &quot;A&quot; . Directory separators must always be written as / , even on Windows. You may call Path.expand/1 to normalize the path before invoking this function. By default, the patterns * and ? do not match files starting with a dot . . See the :match_dot option in the &quot;Options&quot; section below. Options :match_dot - (boolean) if false , the special wildcard characters * and ? will not match files starting with a dot ( . ). If true , files starting with a . will not be treated specially. Defaults to false . Examples Imagine you have a directory called projects with three Elixir projects inside of it: elixir , ex_doc , and plug . You can find all .beam files inside the ebin directory of each project as follows: Path . wildcard ( &quot;projects/*/ebin/**/*.beam&quot; ) If you want to search for both .beam and .app files, you could do: Path . wildcard ( &quot;projects/*/ebin/**/*.{beam,app}&quot; )","ref":"Path.html#wildcard/2","title":"Path.wildcard/2","type":"function"},{"doc":"","ref":"Path.html#t:t/0","title":"Path.t/0","type":"type"},{"doc":"Functions for interacting with the external world through ports. Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing. Example iex&gt; port = Port . open ( { :spawn , &quot;cat&quot; } , [ :binary ] ) iex&gt; send ( port , { self ( ) , { :command , &quot;hello&quot; } } ) iex&gt; send ( port , { self ( ) , { :command , &quot;world&quot; } } ) iex&gt; flush ( ) { # Port &lt; 0.1444 &gt; , { :data , &quot;hello&quot; } } { # Port &lt; 0.1444 &gt; , { :data , &quot;world&quot; } } iex&gt; send ( port , { self ( ) , :close } ) :ok iex&gt; flush ( ) { # Port &lt; 0.1464 &gt; , :closed } :ok In the example above, we have created a new port that executes the program cat . cat is a program available on Unix-like operating systems that receives data from multiple inputs and concatenates them in the output. After the port was created, we sent it two commands in the form of messages using Kernel.send/2 . The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;. After sending those two messages, we invoked the IEx helper flush() , which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Note that the messages are in binary because we passed the :binary option when opening the port in Port.open/2 . Without such option, it would have yielded a list of bytes. Once everything was done, we closed the port. Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below. Message and function APIs There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module. The messages supported by ports and their counterpart function APIs are listed below: {pid, {:command, binary}} - sends the given data to the port. See command/3 . {pid, :close} - closes the port. Unless the port is already closed, the port will reply with {port, :closed} message once it has flushed its buffers and effectively closed. See close/1 . {pid, {:connect, new_pid}} - sets the new_pid as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes new_pid the new connected processes. Unless the port is dead, the port will reply to the old owner with {port, :connected} . See connect/2 . On its turn, the port will send the connected process the following messages: {port, {:data, data}} - data sent by the port {port, :closed} - reply to the {pid, :close} message {port, :connected} - reply to the {pid, {:connect, new_pid}} message {:EXIT, port, reason} - exit signals in case the port crashes. If reason is not :normal , this message will only be received if the owner process is trapping exits Open mechanisms The port can be opened through four main mechanisms. As a short summary, prefer to using the :spawn and :spawn_executable options mentioned below. The other two options, :spawn_driver and :fd are for advanced usage within the VM. Also consider using System.cmd/3 if all you want is to execute a program and retrieve its return value. spawn The :spawn tuple receives a binary that is going to be executed as a full invocation. For example, we can use it to invoke &quot;echo hello&quot; directly: iex&gt; port = Port . open ( { :spawn , &quot;echo hello&quot; } , [ :binary ] ) iex&gt; flush ( ) { # Port &lt; 0.1444 &gt; , { :data , &quot;hello \\n &quot; } } :spawn will retrieve the program name from the argument and traverse your operating system $PATH environment variable looking for a matching program. Although the above is handy, it means it is impossible to invoke an executable that has whitespaces on its name or in any of its arguments. For those reasons, most times it is preferable to execute :spawn_executable . spawn_executable Spawn executable is a more restricted and explicit version of spawn. It expects full file paths to the executable you want to execute. If they are in your $PATH , they can be retrieved by calling System.find_executable/1 : iex&gt; path = System . find_executable ( &quot;echo&quot; ) iex&gt; port = Port . open ( { :spawn_executable , path } , [ :binary , args : [ &quot;hello world&quot; ] ] ) iex&gt; flush ( ) { # Port &lt; 0.1380 &gt; , { :data , &quot;hello world \\n &quot; } } When using :spawn_executable , the list of arguments can be passed via the :args option as done above. For the full list of options, see the documentation for the Erlang function :erlang.open_port/2 . fd The :fd name option allows developers to access in and out file descriptors used by the Erlang VM. You would use those only if you are reimplementing core part of the Runtime System, such as the :user and :shell processes. Zombie operating system processes A port can be closed via the close/1 function or by sending a {pid, :close} message. However, if the VM crashes, a long-running program started by the port will have its stdin and stdout channels closed but it won't be automatically terminated . While most Unix command line tools will exit once its communication channels are closed, not all command line applications will do so. You can easily check this by starting the port and then shutting down the VM and inspecting your operating system to see if the port process is still running. While we encourage graceful termination by detecting if stdin/stdout has been closed, we do not always have control over how third-party software terminates. In those cases, you can wrap the application in a script that checks for stdin. Here is such script that has been verified to work on bash shells: #!/usr/bin/env bash # Start the program in the background exec &quot;$@&quot; &amp; pid1 = $ ! # Silence warnings from here on exec &gt; / dev / null 2 &gt; &amp;1 # Read from stdin in the background and # kill running program when stdin closes exec 0 &lt; &amp;0 $ ( while read ; do : ; done kill - KILL $ pid1 ) &amp; pid2 = $ ! # Clean up wait $ pid1 ret = $ ? kill - KILL $ pid2 exit $ ret Note the program above hijacks stdin, so you won't be able to communicate with the underlying software via stdin (on the positive side, software that reads from stdin typically terminates when stdin closes). Now instead of: Port . open ( { :spawn_executable , &quot;/path/to/program&quot; } , args : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) You may invoke: Port . open ( { :spawn_executable , &quot;/path/to/wrapper&quot; } , args : [ &quot;/path/to/program&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] )","ref":"Port.html","title":"Port","type":"module"},{"doc":"Closes the port . For more information, see :erlang.port_close/1 . Inlined by the compiler.","ref":"Port.html#close/1","title":"Port.close/1","type":"function"},{"doc":"Sends data to the port driver port . For more information, see :erlang.port_command/2 . Inlined by the compiler.","ref":"Port.html#command/3","title":"Port.command/3","type":"function"},{"doc":"Associates the port identifier with a pid . For more information, see :erlang.port_connect/2 . Inlined by the compiler.","ref":"Port.html#connect/2","title":"Port.connect/2","type":"function"},{"doc":"Demonitors the monitor identified by the given reference . If monitor_ref is a reference which the calling process obtained by calling monitor/1 , that monitoring is turned off. If the monitoring is already turned off, nothing happens. See :erlang.demonitor/2 for more information. Inlined by the compiler.","ref":"Port.html#demonitor/2","title":"Port.demonitor/2","type":"function"},{"doc":"Returns information about the port or nil if the port is closed. For more information, see :erlang.port_info/1 .","ref":"Port.html#info/1","title":"Port.info/1","type":"function"},{"doc":"Returns information about the port or nil if the port is closed. For more information, see :erlang.port_info/2 .","ref":"Port.html#info/2","title":"Port.info/2","type":"function"},{"doc":"Returns a list of all ports in the current node. Inlined by the compiler.","ref":"Port.html#list/0","title":"Port.list/0","type":"function"},{"doc":"Starts monitoring the given port from the calling process. Once the monitored port process dies, a message is delivered to the monitoring process in the shape of: { :DOWN , ref , :port , object , reason } where: ref is a monitor reference returned by this function; object is either the port being monitored (when monitoring by port ID) or {name, node} (when monitoring by a port name); reason is the exit reason. See :erlang.monitor/2 for more information. Inlined by the compiler.","ref":"Port.html#monitor/1","title":"Port.monitor/1","type":"function"},{"doc":"Opens a port given a tuple name and a list of options . The module documentation above contains documentation and examples for the supported name values, summarized below: {:spawn, command} - runs an external program. command must contain the program name and optionally a list of arguments separated by space. If passing programs or arguments with space in their name, use the next option. {:spawn_executable, filename} - runs the executable given by the absolute file name filename . Arguments can be passed via the :args option. {:spawn_driver, command} - spawns so-called port drivers. {:fd, fd_in, fd_out} - accesses file descriptors, fd_in and fd_out opened by the VM. For more information and the list of options, see :erlang.open_port/2 . Inlined by the compiler.","ref":"Port.html#open/2","title":"Port.open/2","type":"function"},{"doc":"","ref":"Port.html#t:name/0","title":"Port.name/0","type":"type"},{"doc":"Controls an IO device process that wraps a string. A StringIO IO device can be passed as a &quot;device&quot; to most of the functions in the IO module. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;foo&quot; ) iex&gt; IO . read ( pid , 2 ) &quot;fo&quot;","ref":"StringIO.html","title":"StringIO","type":"module"},{"doc":"Returns a specification to start this module under a supervisor. See Supervisor .","ref":"StringIO.html#child_spec/1","title":"StringIO.child_spec/1","type":"function"},{"doc":"Stops the IO device and returns the remaining input/output buffers. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;in&quot; ) iex&gt; IO . write ( pid , &quot;out&quot; ) iex&gt; StringIO . close ( pid ) { :ok , { &quot;in&quot; , &quot;out&quot; } }","ref":"StringIO.html#close/1","title":"StringIO.close/1","type":"function"},{"doc":"Returns the current input/output buffers for the given IO device. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;in&quot; ) iex&gt; IO . write ( pid , &quot;out&quot; ) iex&gt; StringIO . contents ( pid ) { &quot;in&quot; , &quot;out&quot; }","ref":"StringIO.html#contents/1","title":"StringIO.contents/1","type":"function"},{"doc":"Flushes the output buffer and returns its current contents. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;in&quot; ) iex&gt; IO . write ( pid , &quot;out&quot; ) iex&gt; StringIO . flush ( pid ) &quot;out&quot; iex&gt; StringIO . contents ( pid ) { &quot;in&quot; , &quot;&quot; }","ref":"StringIO.html#flush/1","title":"StringIO.flush/1","type":"function"},{"doc":"Creates an IO device. string will be the initial input of the newly created device. options_or_function can be a keyword list of options or a function. If options are provided, the result will be {:ok, pid} , returning the IO device created. The option :capture_prompt , when set to true , causes prompts (which are specified as arguments to IO.get* functions) to be included in the device's output. If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with :ok and the result of the function. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;foo&quot; ) iex&gt; IO . gets ( pid , &quot;&gt;&quot; ) &quot;foo&quot; iex&gt; StringIO . contents ( pid ) { &quot;&quot; , &quot;&quot; } iex&gt; { :ok , pid } = StringIO . open ( &quot;foo&quot; , capture_prompt : true ) iex&gt; IO . gets ( pid , &quot;&gt;&quot; ) &quot;foo&quot; iex&gt; StringIO . contents ( pid ) { &quot;&quot; , &quot;&gt;&quot; } iex&gt; StringIO . open ( &quot;foo&quot; , fn pid -&gt; ...&gt; input = IO . gets ( pid , &quot;&gt;&quot; ) ...&gt; IO . write ( pid , &quot;The input was \#{ input } &quot; ) ...&gt; StringIO . contents ( pid ) ...&gt; end ) { :ok , { &quot;&quot; , &quot;The input was foo&quot; } }","ref":"StringIO.html#open/2","title":"StringIO.open/2","type":"function"},{"doc":"Creates an IO device. string will be the initial input of the newly created device. The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with :ok and the result of the function. Options :capture_prompt - if set to true , prompts (specified as arguments to IO.get* functions) are captured in the output. Defaults to false . :encoding (since v1.10.0) - encoding of the IO device. Allowed values are :unicode (default) and :latin1 . Examples iex&gt; StringIO . open ( &quot;foo&quot; , [ ] , fn pid -&gt; ...&gt; input = IO . gets ( pid , &quot;&gt;&quot; ) ...&gt; IO . write ( pid , &quot;The input was \#{ input } &quot; ) ...&gt; StringIO . contents ( pid ) ...&gt; end ) { :ok , { &quot;&quot; , &quot;The input was foo&quot; } } iex&gt; StringIO . open ( &quot;foo&quot; , [ capture_prompt : true ] , fn pid -&gt; ...&gt; input = IO . gets ( pid , &quot;&gt;&quot; ) ...&gt; IO . write ( pid , &quot;The input was \#{ input } &quot; ) ...&gt; StringIO . contents ( pid ) ...&gt; end ) { :ok , { &quot;&quot; , &quot;&gt;The input was foo&quot; } }","ref":"StringIO.html#open/3","title":"StringIO.open/3","type":"function"},{"doc":"The System module provides functions that interact directly with the VM or the host system. Time The System module also provides functions that work with time, returning different times kept by the system with support for different time units. One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes &quot;time warps&quot;. In order to understand how such changes may be harmful, imagine the following code: ## DO NOT DO THIS prev = System . os_time ( ) # ... execute some code ... next = System . os_time ( ) diff = next - prev If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via System.monotonic_time/0 which never decreases and does not leap: ## DO THIS prev = System . monotonic_time ( ) # ... execute some code ... next = System . monotonic_time ( ) diff = next - prev Generally speaking, the VM provides three time measurements: os_time/0 - the time reported by the operating system (OS). This time may be adjusted forwards or backwards in time with no limitation; system_time/0 - the VM view of the os_time/0 . The system time and operating system time may not match in case of time warps although the VM works towards aligning them. This time is not monotonic (i.e., it may decrease) as its behaviour is configured by the VM time warp mode ; monotonic_time/0 - a monotonically increasing time provided by the Erlang VM. The time functions in this module work in the :native unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the :native unit, to avoid loss of precision, with convert_time_unit/3 being invoked at the end to convert to a specific time unit like :millisecond or :microsecond . See the time_unit/0 type for more information. For a more complete rundown on the VM support for different times, see the chapter on time and time correction in the Erlang docs.","ref":"System.html","title":"System","type":"module"},{"doc":"Lists command line arguments. Returns the list of command line arguments passed to the program.","ref":"System.html#argv/0","title":"System.argv/0","type":"function"},{"doc":"Modifies command line arguments. Changes the list of command line arguments. Use it with caution, as it destroys any previous argv information.","ref":"System.html#argv/1","title":"System.argv/1","type":"function"},{"doc":"Registers a program exit handler function. Registers a function that will be invoked at the end of an Elixir script. A script is typically started via the command line via the elixir and mix executables. The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, and others) won't be available by the time the handler function is invoked. The function must receive the exit status code as an argument. If the VM terminates programmatically, via System.stop/1 , System.halt/1 , or exit signals, the at_exit/1 callbacks are not executed.","ref":"System.html#at_exit/1","title":"System.at_exit/1","type":"function"},{"doc":"Elixir build information. Returns a map with the Elixir version, the Erlang/OTP release it was compiled with, a short Git revision hash and the date and time it was built. Every value in the map is a string, and these are: :build - the Elixir version, short Git revision hash and Erlang/OTP release it was compiled with :date - a string representation of the ISO8601 date and time it was built :otp_release - OTP release it was compiled with :revision - short Git revision hash. If Git was not available at building time, it is set to &quot;&quot; :version - the Elixir version One should not rely on the specific formats returned by each of those fields. Instead one should use specialized functions, such as version/0 to retrieve the Elixir version and otp_release/0 to retrieve the Erlang/OTP release. Examples iex&gt; System . build_info ( ) %{ build : &quot;1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)&quot; , date : &quot;2018-12-24T01:09:21Z&quot; , otp_release : &quot;21&quot; , revision : &quot;772a00a0c&quot; , version : &quot;1.9.0-dev&quot; }","ref":"System.html#build_info/0","title":"System.build_info/0","type":"function"},{"doc":"Executes the given command with args . command is expected to be an executable available in PATH unless an absolute path is given. args must be a list of binaries which the executable will receive as its arguments as is. This means that: environment variables will not be interpolated wildcard expansion will not happen (unless Path.wildcard/2 is used explicitly) arguments do not need to be escaped or quoted for shell safety This function returns a tuple containing the collected result and the command exit status. Internally, this function uses a Port for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the Port module describes this problem and possible solutions under the &quot;Zombie processes&quot; section. Examples iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello&quot; ] ) { &quot;hello \\n &quot; , 0 } iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello&quot; ] , env : [ { &quot;MIX_ENV&quot; , &quot;test&quot; } ] ) { &quot;hello \\n &quot; , 0 } iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello&quot; ] , into : IO . stream ( :stdio , :line ) ) hello { % IO.Stream { } , 0 } Options :into - injects the result into the given collectable, defaults to &quot;&quot; :cd - the directory to run the command in :env - an enumerable of tuples containing environment key-value as binary. The child process inherits all environment variables from its parent process, the Elixir application, except those overwritten or cleared using this option. Specify a value of nil to clear (unset) an environment variable, which is useful for preventing credentials passed to the application from leaking into child processes. :arg0 - sets the command arg0 :stderr_to_stdout - redirects stderr to stdout when true :parallelism - when true , the VM will schedule port tasks to improve parallelism in the system. If set to false , the VM will try to perform commands immediately, improving latency at the expense of parallelism. The default can be set on system startup by passing the &quot;+spp&quot; argument to --erl . Error reasons If invalid arguments are given, ArgumentError is raised by System.cmd/3 . System.cmd/3 also expects a strict set of options and will raise if unknown or invalid options are given. Furthermore, System.cmd/3 may fail with one of the POSIX reasons detailed below: :system_limit - all available ports in the Erlang emulator are in use :enomem - there was not enough memory to create the port :eagain - there are no more available operating system processes :enametoolong - the external command given was too long :emfile - there are no more available file descriptors (for the operating system process that the Erlang emulator runs in) :enfile - the file table is full (for the entire operating system) :eacces - the command does not point to an executable file :enoent - the command does not point to an existing file Shell commands If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check :os.cmd/1 .","ref":"System.html#cmd/3","title":"System.cmd/3","type":"function"},{"doc":"Returns the endianness the system was compiled with.","ref":"System.html#compiled_endianness/0","title":"System.compiled_endianness/0","type":"function"},{"doc":"Converts time from time unit from_unit to time unit to_unit . The result is rounded via the floor function. convert_time_unit/3 accepts an additional time unit (other than the ones in the time_unit/0 type) called :native . :native is the time unit used by the Erlang runtime system. It's determined when the runtime starts and stays the same until the runtime is stopped, but could differ the next time the runtime is started on the same machine. For this reason, you should use this function to convert :native time units to a predictable unit before you display them to humans. To determine how many seconds the :native unit represents in your current runtime, you can call this function to convert 1 second to the :native time unit: System.convert_time_unit(1, :second, :native) .","ref":"System.html#convert_time_unit/3","title":"System.convert_time_unit/3","type":"function"},{"doc":"Current working directory. Returns the current working directory or nil if one is not available.","ref":"System.html#cwd/0","title":"System.cwd/0","type":"function"},{"doc":"Current working directory, exception on error. Returns the current working directory or raises RuntimeError .","ref":"System.html#cwd!/0","title":"System.cwd!/0","type":"function"},{"doc":"Deletes an environment variable. Removes the variable varname from the environment.","ref":"System.html#delete_env/1","title":"System.delete_env/1","type":"function"},{"doc":"Returns the endianness.","ref":"System.html#endianness/0","title":"System.endianness/0","type":"function"},{"doc":"Returns the value of the given environment variable or :error if not found. If the environment variable varname is set, then {:ok, value} is returned where value is a string. If varname is not set, :error is returned. Examples iex&gt; System . fetch_env ( &quot;PORT&quot; ) { :ok , &quot;4000&quot; } iex&gt; System . fetch_env ( &quot;NOT_SET&quot; ) :error","ref":"System.html#fetch_env/1","title":"System.fetch_env/1","type":"function"},{"doc":"Returns the value of the given environment variable or raises if not found. Same as get_env/1 but raises instead of returning nil when the variable is not set. Examples iex&gt; System . fetch_env! ( &quot;PORT&quot; ) &quot;4000&quot; iex&gt; System . fetch_env! ( &quot;NOT_SET&quot; ) ** (ArgumentError) could not fetch environment variable &quot;NOT_SET&quot; because it is not set","ref":"System.html#fetch_env!/1","title":"System.fetch_env!/1","type":"function"},{"doc":"Locates an executable on the system. This function looks up an executable program given its name using the environment variable PATH on Windows and Unix-like operating systems. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with .com , .cmd or similar extensions.","ref":"System.html#find_executable/1","title":"System.find_executable/1","type":"function"},{"doc":"Returns all system environment variables. The returned value is a map containing name-value pairs. Variable names and their values are strings.","ref":"System.html#get_env/0","title":"System.get_env/0","type":"function"},{"doc":"Returns the value of the given environment variable. The returned value of the environment variable varname is a string. If the environment variable is not set, returns the string specified in default or nil if none is specified. Examples iex&gt; System . get_env ( &quot;PORT&quot; ) &quot;4000&quot; iex&gt; System . get_env ( &quot;NOT_SET&quot; ) nil iex&gt; System . get_env ( &quot;NOT_SET&quot; , &quot;4001&quot; ) &quot;4001&quot;","ref":"System.html#get_env/2","title":"System.get_env/2","type":"function"},{"doc":"Erlang VM process identifier. Returns the process identifier of the current Erlang emulator in the format most commonly used by the operating system environment. For more information, see :os.getpid/0 .","ref":"System.html#get_pid/0","title":"System.get_pid/0","type":"function"},{"doc":"Immediately halts the Erlang runtime system. Terminates the Erlang runtime system without properly shutting down applications and ports. Please see stop/1 for a careful shutdown of the system. status must be a non-negative integer, the atom :abort or a binary. If an integer, the runtime system exits with the integer value which is returned to the operating system. If :abort , the runtime system aborts producing a core dump, if that is enabled in the operating system. If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1. Note that on many platforms, only the status codes 0-255 are supported by the operating system. For more information, see :erlang.halt/1 . Examples System . halt ( 0 ) System . halt ( 1 ) System . halt ( :abort )","ref":"System.html#halt/1","title":"System.halt/1","type":"function"},{"doc":"Returns the current monotonic time in the :native time unit. This time is monotonically increasing and starts in an unspecified point in time. Inlined by the compiler.","ref":"System.html#monotonic_time/0","title":"System.monotonic_time/0","type":"function"},{"doc":"Returns the current monotonic time in the given time unit. This time is monotonically increasing and starts in an unspecified point in time.","ref":"System.html#monotonic_time/1","title":"System.monotonic_time/1","type":"function"},{"doc":"Checks if the system will halt or not at the end of ARGV processing.","ref":"System.html#no_halt/0","title":"System.no_halt/0","type":"function"},{"doc":"Marks if the system should halt or not at the end of ARGV processing.","ref":"System.html#no_halt/1","title":"System.no_halt/1","type":"function"},{"doc":"Returns the current operating system (OS) time. The result is returned in the :native time unit. This time may be adjusted forwards or backwards in time with no limitation and is not monotonic. Inlined by the compiler.","ref":"System.html#os_time/0","title":"System.os_time/0","type":"function"},{"doc":"Returns the current operating system (OS) time in the given time unit . This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.","ref":"System.html#os_time/1","title":"System.os_time/1","type":"function"},{"doc":"Returns the Erlang/OTP release number.","ref":"System.html#otp_release/0","title":"System.otp_release/0","type":"function"},{"doc":"Returns the operating system PID for the current Erlang runtime system instance. Returns a string containing the (usually) numerical identifier for a process. On Unix-like operating systems, this is typically the return value of the getpid() system call. On Windows, the process ID as returned by the GetCurrentProcessId() system call is used. Examples System . pid ( )","ref":"System.html#pid/0","title":"System.pid/0","type":"function"},{"doc":"Sets multiple environment variables. Sets a new value for each environment variable corresponding to each {key, value} pair in enum .","ref":"System.html#put_env/1","title":"System.put_env/1","type":"function"},{"doc":"Sets an environment variable value. Sets a new value for the environment variable varname .","ref":"System.html#put_env/2","title":"System.put_env/2","type":"function"},{"doc":"Restarts all applications in the Erlang runtime system. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system starts all applications once again. Examples System . restart ( )","ref":"System.html#restart/0","title":"System.restart/0","type":"function"},{"doc":"Returns the number of schedulers in the VM.","ref":"System.html#schedulers/0","title":"System.schedulers/0","type":"function"},{"doc":"Returns the number of schedulers online in the VM.","ref":"System.html#schedulers_online/0","title":"System.schedulers_online/0","type":"function"},{"doc":"Deprecated mechanism to retrieve the last exception stacktrace. Starting from Erlang/OTP 23, this function will always return an empty list.","ref":"System.html#stacktrace/0","title":"System.stacktrace/0","type":"function"},{"doc":"Carefully stops the Erlang runtime system. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling halt/1 . status must be a non-negative integer value which is returned by the runtime system to the operating system. Note that on many platforms, only the status codes 0-255 are supported by the operating system. Examples System . stop ( 0 ) System . stop ( 1 )","ref":"System.html#stop/1","title":"System.stop/1","type":"function"},{"doc":"Returns the current system time in the :native time unit. It is the VM view of the os_time/0 . They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic. Inlined by the compiler.","ref":"System.html#system_time/0","title":"System.system_time/0","type":"function"},{"doc":"Returns the current system time in the given time unit. It is the VM view of the os_time/0 . They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.","ref":"System.html#system_time/1","title":"System.system_time/1","type":"function"},{"doc":"Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time. The result is returned in the :native time unit. See time_offset/1 for more information. Inlined by the compiler.","ref":"System.html#time_offset/0","title":"System.time_offset/0","type":"function"},{"doc":"Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time. The result is returned in the given time unit unit . The returned offset, added to an Erlang monotonic time (for instance, one obtained with monotonic_time/1 ), gives the Erlang system time that corresponds to that monotonic time.","ref":"System.html#time_offset/1","title":"System.time_offset/1","type":"function"},{"doc":"Writable temporary directory. Returns a writable temporary directory. Searches for directories in the following order: the directory named by the TMPDIR environment variable the directory named by the TEMP environment variable the directory named by the TMP environment variable C:\\TMP on Windows or /tmp on Unix-like operating systems as a last resort, the current working directory Returns nil if none of the above are writable.","ref":"System.html#tmp_dir/0","title":"System.tmp_dir/0","type":"function"},{"doc":"Writable temporary directory, exception on error. Same as tmp_dir/0 but raises RuntimeError instead of returning nil if no temp dir is set.","ref":"System.html#tmp_dir!/0","title":"System.tmp_dir!/0","type":"function"},{"doc":"Traps the given signal to execute the fun . Important : Trapping signals may have strong implications on how a system shuts down and behave in production and therefore it is extremely discouraged for libraries to set their own traps. Instead, they should redirect users to configure them themselves. The only cases where it is acceptable for libraries to set their own traps is when using Elixir in script mode, such as in .exs files and via Mix tasks. An optional id that uniquely identifies the function can be given, otherwise a unique one is automatically generated. If a previously registered id is given, this function returns an error tuple. The id can be used to remove a registered signal by calling untrap_signal/2 . The given fun receives no arguments and it must return :ok . It returns {:ok, id} in case of success, {:error, :already_registered} in case the id has already been registered for the given signal, or {:error, :not_sup} in case trapping exists is not supported by the current OS. The first time a signal is trapped, it will override the default behaviour from the operating system. If the same signal is trapped multiple times, subsequent functions given to trap_signal will execute first . In other words, you can consider each function is prepended to the signal handler. By default, the Erlang VM register traps to the three signals: :sigstop - gracefully shuts down the VM with stop/0 :sigquit - halts the VM via halt/0 :sigusr1 - halts the VM via status code of 1 Therefore, if you add traps to the signals above, the default behaviour above will be executed after all user signals. Implementation notes All signals run from a single process. Therefore, blocking the fun will block subsequent traps. It is also not possible to add or remove traps from within a trap itself. Internally, this functionality is built on top of :os.set_signal/2 . When you register a trap, Elixir automatically sets it to :handle and it reverts it back to :default once all traps are removed (except for :sigquit , :sigterm , and :sigusr1 which are always handled). If you or a library call :os.set_signal/2 directly, it may disable Elixir traps (or Elixir may override your configuration).","ref":"System.html#trap_signal/3","title":"System.trap_signal/3","type":"function"},{"doc":"Generates and returns an integer that is unique in the current runtime instance. &quot;Unique&quot; means that this function, called with the same list of modifiers , will never return the same integer more than once on the current runtime instance. If modifiers is [] , then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer: :positive - the returned integer is guaranteed to be positive. :monotonic - the returned integer is monotonically increasing. This means that, on the same runtime instance (but even on different processes), integers returned using the :monotonic modifier will always be strictly less than integers returned by successive calls with the :monotonic modifier. All modifiers listed above can be combined; repeated modifiers in modifiers will be ignored. Inlined by the compiler.","ref":"System.html#unique_integer/1","title":"System.unique_integer/1","type":"function"},{"doc":"Removes a previously registered signal with id .","ref":"System.html#untrap_signal/2","title":"System.untrap_signal/2","type":"function"},{"doc":"User home directory. Returns the user home directory (platform independent).","ref":"System.html#user_home/0","title":"System.user_home/0","type":"function"},{"doc":"User home directory, exception on error. Same as user_home/0 but raises RuntimeError instead of returning nil if no user home is set.","ref":"System.html#user_home!/0","title":"System.user_home!/0","type":"function"},{"doc":"Elixir version information. Returns Elixir's version as binary.","ref":"System.html#version/0","title":"System.version/0","type":"function"},{"doc":"","ref":"System.html#t:signal/0","title":"System.signal/0","type":"type"},{"doc":"The time unit to be passed to functions like monotonic_time/1 and others. The :second , :millisecond , :microsecond and :nanosecond time units controls the return value of the functions that accept a time unit. A time unit can also be a strictly positive integer. In this case, it represents the &quot;parts per second&quot;: the time will be returned in 1 / parts_per_second seconds. For example, using the :millisecond time unit is equivalent to using 1000 as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).","ref":"System.html#t:time_unit/0","title":"System.time_unit/0","type":"type"},{"doc":"This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir. Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API. For the actual date, time and datetime structures, see Date , Time , NaiveDateTime and DateTime . Note designations for year, month, day, and the like, are overspecified (i.e. an integer instead of 1..12 for months) because different calendars may have a different number of days per month, months per year and so on.","ref":"Calendar.html","title":"Calendar","type":"behaviour"},{"doc":"Returns true if two calendars have the same moment of starting a new day, false otherwise. If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.","ref":"Calendar.html#compatible_calendars?/2","title":"Calendar.compatible_calendars?/2","type":"function"},{"doc":"Converts the date into a string according to the calendar.","ref":"Calendar.html#c:date_to_string/3","title":"Calendar.date_to_string/3","type":"callback"},{"doc":"Converts the datetime (with time zone) into a string according to the calendar.","ref":"Calendar.html#c:datetime_to_string/11","title":"Calendar.datetime_to_string/11","type":"callback"},{"doc":"Calculates the day and era from the given year , month , and day .","ref":"Calendar.html#c:day_of_era/3","title":"Calendar.day_of_era/3","type":"callback"},{"doc":"Calculates the day of the week from the given year , month , and day . The starting_on represents the starting day of the week. All calendars must support at least the :default value. They may also support other values representing their days of the week.","ref":"Calendar.html#c:day_of_week/4","title":"Calendar.day_of_week/4","type":"callback"},{"doc":"Calculates the day of the year from the given year , month , and day .","ref":"Calendar.html#c:day_of_year/3","title":"Calendar.day_of_year/3","type":"callback"},{"doc":"Define the rollover moment for the given calendar. This is the moment, in your calendar, when the current day ends and the next day starts. The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them. This day fraction should be in its most simplified form possible, to make comparisons fast. Examples If, in your Calendar, a new day starts at midnight, return {0, 1}. If, in your Calendar, a new day starts at sunrise, return {1, 4}. If, in your Calendar, a new day starts at noon, return {1, 2}. If, in your Calendar, a new day starts at sunset, return {3, 4}.","ref":"Calendar.html#c:day_rollover_relative_to_midnight_utc/0","title":"Calendar.day_rollover_relative_to_midnight_utc/0","type":"callback"},{"doc":"Returns how many days there are in the given year-month.","ref":"Calendar.html#c:days_in_month/2","title":"Calendar.days_in_month/2","type":"callback"},{"doc":"Gets the current time zone database.","ref":"Calendar.html#get_time_zone_database/0","title":"Calendar.get_time_zone_database/0","type":"function"},{"doc":"Returns true if the given year is a leap year. A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return false if it does not support the concept of leap years.","ref":"Calendar.html#c:leap_year?/1","title":"Calendar.leap_year?/1","type":"callback"},{"doc":"Returns how many months there are in the given year.","ref":"Calendar.html#c:months_in_year/1","title":"Calendar.months_in_year/1","type":"callback"},{"doc":"Converts iso_days/0 to the Calendar's datetime format.","ref":"Calendar.html#c:naive_datetime_from_iso_days/1","title":"Calendar.naive_datetime_from_iso_days/1","type":"callback"},{"doc":"Converts the given datetime (without time zone) into the iso_days/0 format.","ref":"Calendar.html#c:naive_datetime_to_iso_days/7","title":"Calendar.naive_datetime_to_iso_days/7","type":"callback"},{"doc":"Converts the datetime (without time zone) into a string according to the calendar.","ref":"Calendar.html#c:naive_datetime_to_string/7","title":"Calendar.naive_datetime_to_string/7","type":"callback"},{"doc":"Parses the string representation for a date returned by date_to_string/3 into a date-tuple.","ref":"Calendar.html#c:parse_date/1","title":"Calendar.parse_date/1","type":"callback"},{"doc":"Parses the string representation for a naive datetime returned by naive_datetime_to_string/7 into a naive-datetime-tuple. The given string may contain a timezone offset but it is ignored.","ref":"Calendar.html#c:parse_naive_datetime/1","title":"Calendar.parse_naive_datetime/1","type":"callback"},{"doc":"Parses the string representation for a time returned by time_to_string/4 into a time-tuple.","ref":"Calendar.html#c:parse_time/1","title":"Calendar.parse_time/1","type":"callback"},{"doc":"Parses the string representation for a datetime returned by datetime_to_string/11 into a datetime-tuple. The returned datetime must be in UTC. The original utc_offset it was written in must be returned in the result.","ref":"Calendar.html#c:parse_utc_datetime/1","title":"Calendar.parse_utc_datetime/1","type":"callback"},{"doc":"Sets the current time zone database.","ref":"Calendar.html#put_time_zone_database/1","title":"Calendar.put_time_zone_database/1","type":"function"},{"doc":"Calculates the quarter of the year from the given year , month , and day .","ref":"Calendar.html#c:quarter_of_year/3","title":"Calendar.quarter_of_year/3","type":"callback"},{"doc":"Formats received datetime into a string. The datetime can be any of the Calendar types ( Time , Date , NaiveDateTime , and DateTime ) or any map, as long as they contain all of the relevant fields necessary for formatting. For example, if you use %Y to format the year, the datetime must have the :year field. Therefore, if you pass a Time , or a map without the :year field to a format that expects %Y , an error will be raised. Options :preferred_datetime - a string for the preferred format to show datetimes, it can't contain the %c format and defaults to &quot;%Y-%m-%d %H:%M:%S&quot; if the option is not received :preferred_date - a string for the preferred format to show dates, it can't contain the %x format and defaults to &quot;%Y-%m-%d&quot; if the option is not received :preferred_time - a string for the preferred format to show times, it can't contain the %X format and defaults to &quot;%H:%M:%S&quot; if the option is not received :am_pm_names - a function that receives either :am or :pm and returns the name of the period of the day, if the option is not received it defaults to a function that returns &quot;am&quot; and &quot;pm&quot; , respectively :month_names - a function that receives a number and returns the name of the corresponding month, if the option is not received it defaults to a function that returns the month names in English :abbreviated_month_names - a function that receives a number and returns the abbreviated name of the corresponding month, if the option is not received it defaults to a function that returns the abbreviated month names in English :day_of_week_names - a function that receives a number and returns the name of the corresponding day of week, if the option is not received it defaults to a function that returns the day of week names in English :abbreviated_day_of_week_names - a function that receives a number and returns the abbreviated name of the corresponding day of week, if the option is not received it defaults to a function that returns the abbreviated day of week names in English Formatting syntax The formatting syntax for strftime is a sequence of characters in the following format: % &lt; padding &gt; &lt; width &gt; &lt; format &gt; where: % : indicates the start of a formatted section &lt;padding&gt; : set the padding (see below) &lt;width&gt; : a number indicating the minimum size of the formatted section &lt;format&gt; : the format itself (see below) Accepted padding options - : no padding, removes all padding from the format _ : pad with spaces 0 : pad with zeroes Accepted formats The accepted formats are: Format Description Examples (in ISO) a Abbreviated name of day Mon A Full name of day Monday b Abbreviated month name Jan B Full month name January c Preferred date+time representation 2018-10-17 12:34:56 d Day of the month 01, 31 f Microseconds (does not support width and padding modifiers) 000000, 999999, 0123 H Hour using a 24-hour clock 00, 23 I Hour using a 12-hour clock 01, 12 j Day of the year 001, 366 m Month 01, 12 M Minute 00, 59 p &quot;AM&quot; or &quot;PM&quot; (noon is &quot;PM&quot;, midnight as &quot;AM&quot;) AM, PM P &quot;am&quot; or &quot;pm&quot; (noon is &quot;pm&quot;, midnight as &quot;am&quot;) am, pm q Quarter 1, 2, 3, 4 S Second 00, 59, 60 u Day of the week 1 (Monday), 7 (Sunday) x Preferred date (without time) representation 2018-10-17 X Preferred time (without date) representation 12:34:56 y Year as 2-digits 01, 01, 86, 18 Y Year -0001, 0001, 1986 z +hhmm/-hhmm time zone offset from UTC (empty string if naive) +0300, -0530 Z Time zone abbreviation (empty string if naive) CET, BRST % Literal &quot;%&quot; character % Any other character will be interpreted as an invalid format and raise an error Examples Without options: iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%y-%m-%d %I:%M:%S %p&quot; ) &quot;19-08-26 01:52:06 PM&quot; iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%a, %B %d %Y&quot; ) &quot;Mon, August 26 2019&quot; iex&gt; Calendar . strftime ( ~U[2020-04-02 13:52:06.0Z] , &quot;%B %-d, %Y&quot; ) &quot;April 2, 2020&quot; iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%c&quot; ) &quot;2019-08-26 13:52:06&quot; With options: iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%c&quot; , preferred_datetime : &quot;%H:%M:%S %d-%m-%y&quot; ) &quot;13:52:06 26-08-19&quot; iex&gt; Calendar . strftime ( ...&gt; ~U[2019-08-26 13:52:06.0Z] , ...&gt; &quot;%A&quot; , ...&gt; day_of_week_names : fn day_of_week -&gt; ...&gt; { &quot;segunda-feira&quot; , &quot;terça-feira&quot; , &quot;quarta-feira&quot; , &quot;quinta-feira&quot; , ...&gt; &quot;sexta-feira&quot; , &quot;sábado&quot; , &quot;domingo&quot; } ...&gt; |&gt; elem ( day_of_week - 1 ) ...&gt; end ...&gt; ) &quot;segunda-feira&quot; iex&gt; Calendar . strftime ( ...&gt; ~U[2019-08-26 13:52:06.0Z] , ...&gt; &quot;%B&quot; , ...&gt; month_names : fn month -&gt; ...&gt; { &quot;январь&quot; , &quot;февраль&quot; , &quot;март&quot; , &quot;апрель&quot; , &quot;май&quot; , &quot;июнь&quot; , ...&gt; &quot;июль&quot; , &quot;август&quot; , &quot;сентябрь&quot; , &quot;октябрь&quot; , &quot;ноябрь&quot; , &quot;декабрь&quot; } ...&gt; |&gt; elem ( month - 1 ) ...&gt; end ...&gt; ) &quot;август&quot;","ref":"Calendar.html#strftime/3","title":"Calendar.strftime/3","type":"function"},{"doc":"Converts day_fraction/0 to the Calendar's time format.","ref":"Calendar.html#c:time_from_day_fraction/1","title":"Calendar.time_from_day_fraction/1","type":"callback"},{"doc":"Converts the given time to the day_fraction/0 format.","ref":"Calendar.html#c:time_to_day_fraction/4","title":"Calendar.time_to_day_fraction/4","type":"callback"},{"doc":"Converts the time into a string according to the calendar.","ref":"Calendar.html#c:time_to_string/4","title":"Calendar.time_to_string/4","type":"callback"},{"doc":"Returns a microsecond tuple truncated to a given precision ( :microsecond , :millisecond or :second ).","ref":"Calendar.html#truncate/2","title":"Calendar.truncate/2","type":"function"},{"doc":"Should return true if the given date describes a proper date in the calendar.","ref":"Calendar.html#c:valid_date?/3","title":"Calendar.valid_date?/3","type":"callback"},{"doc":"Should return true if the given time describes a proper time in the calendar.","ref":"Calendar.html#c:valid_time?/4","title":"Calendar.valid_time?/4","type":"callback"},{"doc":"Calculates the year and era from the given year .","ref":"Calendar.html#c:year_of_era/1","title":"Calendar.year_of_era/1","type":"callback"},{"doc":"A calendar implementation","ref":"Calendar.html#t:calendar/0","title":"Calendar.calendar/0","type":"type"},{"doc":"Any map/struct that contains the date fields","ref":"Calendar.html#t:date/0","title":"Calendar.date/0","type":"type"},{"doc":"Any map/struct that contains the datetime fields","ref":"Calendar.html#t:datetime/0","title":"Calendar.datetime/0","type":"type"},{"doc":"","ref":"Calendar.html#t:day/0","title":"Calendar.day/0","type":"type"},{"doc":"The internal time format is used when converting between calendars. It represents time as a fraction of a day (starting from midnight). parts_in_day specifies how much of the day is already passed, while parts_per_day signifies how many parts there fit in a day.","ref":"Calendar.html#t:day_fraction/0","title":"Calendar.day_fraction/0","type":"type"},{"doc":"A tuple representing the day and the era .","ref":"Calendar.html#t:day_of_era/0","title":"Calendar.day_of_era/0","type":"type"},{"doc":"","ref":"Calendar.html#t:day_of_week/0","title":"Calendar.day_of_week/0","type":"type"},{"doc":"","ref":"Calendar.html#t:era/0","title":"Calendar.era/0","type":"type"},{"doc":"","ref":"Calendar.html#t:hour/0","title":"Calendar.hour/0","type":"type"},{"doc":"The internal date format that is used when converting between calendars. This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).","ref":"Calendar.html#t:iso_days/0","title":"Calendar.iso_days/0","type":"type"},{"doc":"Microseconds with stored precision. The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.","ref":"Calendar.html#t:microsecond/0","title":"Calendar.microsecond/0","type":"type"},{"doc":"","ref":"Calendar.html#t:minute/0","title":"Calendar.minute/0","type":"type"},{"doc":"","ref":"Calendar.html#t:month/0","title":"Calendar.month/0","type":"type"},{"doc":"Any map/struct that contains the naive_datetime fields","ref":"Calendar.html#t:naive_datetime/0","title":"Calendar.naive_datetime/0","type":"type"},{"doc":"","ref":"Calendar.html#t:second/0","title":"Calendar.second/0","type":"type"},{"doc":"The time zone standard offset in seconds (typically not zero in summer times). It must be added to utc_offset/0 to get the total offset from UTC used for &quot;wall time&quot;.","ref":"Calendar.html#t:std_offset/0","title":"Calendar.std_offset/0","type":"type"},{"doc":"Any map/struct that contains the time fields","ref":"Calendar.html#t:time/0","title":"Calendar.time/0","type":"type"},{"doc":"The time zone ID according to the IANA tz database (for example, Europe/Zurich)","ref":"Calendar.html#t:time_zone/0","title":"Calendar.time_zone/0","type":"type"},{"doc":"Specifies the time zone database for calendar operations. Many functions in the DateTime module require a time zone database. By default, it uses the default time zone database returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes and returns {:error, :utc_only_time_zone_database} for any other time zone. Other time zone databases (including ones provided by packages) can be configured as default either via configuration: config :elixir , :time_zone_database , CustomTimeZoneDatabase or by calling Calendar.put_time_zone_database/1 . See Calendar.TimeZoneDatabase for more information on custom time zone databases.","ref":"Calendar.html#t:time_zone_database/0","title":"Calendar.time_zone_database/0","type":"type"},{"doc":"The time zone UTC offset in seconds for standard time. See also std_offset/0 .","ref":"Calendar.html#t:utc_offset/0","title":"Calendar.utc_offset/0","type":"type"},{"doc":"","ref":"Calendar.html#t:week/0","title":"Calendar.week/0","type":"type"},{"doc":"","ref":"Calendar.html#t:year/0","title":"Calendar.year/0","type":"type"},{"doc":"The time zone abbreviation (for example, CET or CEST or BST, and such)","ref":"Calendar.html#t:zone_abbr/0","title":"Calendar.zone_abbr/0","type":"type"},{"doc":"The default calendar implementation, a Gregorian calendar following ISO 8601. This calendar implements a proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted. ISO 8601 compliance The ISO 8601 specification is feature-rich, but allows applications to selectively implement most parts of it. The choices Elixir makes are catalogued below. Features The standard library supports a minimal set of possible ISO 8601 features. Specifically, the parser only supports calendar dates and does not support ordinal and week formats. By default Elixir only parses extended-formatted date/times. You can opt-in to parse basic-formatted date/times. NaiveDateTime.to_iso8601/2 and DateTime.to_iso8601/2 allow you to produce either basic or extended formatted strings, and Calendar.strftime/2 allows you to format datetimes however else you desire. Elixir does not support reduced accuracy formats (for example, a date without the day component) nor decimal precisions in the lowest component (such as 10:01:25,5 ). No functions exist to parse ISO 8601 durations or time intervals. Examples Elixir expects the extended format by default when parsing: iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23T23:50:07&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123T235007&quot; ) { :error , :invalid_format } Parsing can be restricted to basic if desired: iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123T235007Z&quot; , :basic ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123T235007Z&quot; , :extended ) { :error , :invalid_format } Only calendar dates are supported in parsing; ordinal and week dates are not. iex&gt; Calendar.ISO . parse_date ( &quot;2015-04-15&quot; ) { :ok , { 2015 , 4 , 15 } } iex&gt; Calendar.ISO . parse_date ( &quot;2015-105&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015-W16&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015-W016-3&quot; ) { :error , :invalid_format } Years, months, days, hours, minutes, and seconds must be fully specified: iex&gt; Calendar.ISO . parse_date ( &quot;2015-04-15&quot; ) { :ok , { 2015 , 4 , 15 } } iex&gt; Calendar.ISO . parse_date ( &quot;2015-04&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07.0123456&quot; ) { :ok , { 23 , 50 , 7 , { 12345 , 6 } } } iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;23:50&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_time ( &quot;23&quot; ) { :error , :invalid_format } Extensions The parser and formatter adopt one ISO 8601 extension: extended year notation. This allows dates to be prefixed with a + or - sign, extending the range of expressible years from the default ( 0000..9999 ) to -9999..9999 . Elixir still restricts years in this format to four digits. Examples iex&gt; Calendar.ISO . parse_date ( &quot;-2015-01-23&quot; ) { :ok , { - 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_date ( &quot;+2015-01-23&quot; ) { :ok , { 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;-2015-01-23 23:50:07&quot; ) { :ok , { - 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;+2015-01-23 23:50:07&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;-2015-01-23 23:50:07Z&quot; ) { :ok , { - 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;+2015-01-23 23:50:07Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } Additions ISO 8601 does not allow a whitespace instead of T as a separator between date and times, both when parsing and formatting. This is a common enough representation, Elixir allows it during parsing. The formatting of dates in NaiveDateTime.to_iso8601/1 and DateTime.to_iso8601/1 do produce specification-compliant string representations using the T separator. Examples iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07.0123456&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23T23:50:07.0123456&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07.0123456Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23T23:50:07.0123456Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } , 0 }","ref":"Calendar.ISO.html","title":"Calendar.ISO","type":"module"},{"doc":"Converts the given date into a string. By default, returns dates formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; Calendar.ISO . date_to_string ( 2015 , 2 , 28 ) &quot;2015-02-28&quot; iex&gt; Calendar.ISO . date_to_string ( 2017 , 8 , 1 ) &quot;2017-08-01&quot; iex&gt; Calendar.ISO . date_to_string ( - 99 , 1 , 31 ) &quot;-0099-01-31&quot; iex&gt; Calendar.ISO . date_to_string ( 2015 , 2 , 28 , :basic ) &quot;20150228&quot; iex&gt; Calendar.ISO . date_to_string ( - 99 , 1 , 31 , :basic ) &quot;-00990131&quot;","ref":"Calendar.ISO.html#date_to_string/4","title":"Calendar.ISO.date_to_string/4","type":"function"},{"doc":"Converts the datetime (with time zone) into a string. By default, returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; time_zone = &quot;Etc/UTC&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;UTC&quot; , 0 , 0 ) &quot;2017-08-01 01:02:03.00000Z&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;UTC&quot; , 3600 , 0 ) &quot;2017-08-01 01:02:03.00000+01:00&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;UTC&quot; , 3600 , 3600 ) &quot;2017-08-01 01:02:03.00000+02:00&quot; iex&gt; time_zone = &quot;Europe/Berlin&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;CET&quot; , 3600 , 0 ) &quot;2017-08-01 01:02:03.00000+01:00 CET Europe/Berlin&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;CDT&quot; , 3600 , 3600 ) &quot;2017-08-01 01:02:03.00000+02:00 CDT Europe/Berlin&quot; iex&gt; time_zone = &quot;America/Los_Angeles&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;PST&quot; , - 28800 , 0 ) &quot;2015-02-28 01:02:03.00000-08:00 PST America/Los_Angeles&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;PDT&quot; , - 28800 , 3600 ) &quot;2015-02-28 01:02:03.00000-07:00 PDT America/Los_Angeles&quot; iex&gt; time_zone = &quot;Europe/Berlin&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;CET&quot; , 3600 , 0 , :basic ) &quot;20170801 010203.00000+0100 CET Europe/Berlin&quot;","ref":"Calendar.ISO.html#datetime_to_string/12","title":"Calendar.ISO.datetime_to_string/12","type":"function"},{"doc":"Calculates the day and era from the given year , month , and day . Examples iex&gt; Calendar.ISO . day_of_era ( 0 , 1 , 1 ) { 366 , 0 } iex&gt; Calendar.ISO . day_of_era ( 1 , 1 , 1 ) { 1 , 1 } iex&gt; Calendar.ISO . day_of_era ( 0 , 12 , 31 ) { 1 , 0 } iex&gt; Calendar.ISO . day_of_era ( 0 , 12 , 30 ) { 2 , 0 } iex&gt; Calendar.ISO . day_of_era ( - 1 , 12 , 31 ) { 367 , 0 }","ref":"Calendar.ISO.html#day_of_era/3","title":"Calendar.ISO.day_of_era/3","type":"function"},{"doc":"Calculates the day of the week from the given year , month , and day . It is an integer from 1 to 7, where 1 is the given starting_on weekday. For example, if starting_on is set to :monday , then 1 is Monday and 7 is Sunday. starting_on can also be :default , which is equivalent to :monday . Examples iex&gt; Calendar.ISO . day_of_week ( 2016 , 10 , 31 , :monday ) { 1 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 1 , :monday ) { 2 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 2 , :monday ) { 3 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 3 , :monday ) { 4 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 4 , :monday ) { 5 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 5 , :monday ) { 6 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 6 , :monday ) { 7 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( - 99 , 1 , 31 , :monday ) { 4 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 10 , 31 , :sunday ) { 2 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 1 , :sunday ) { 3 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 2 , :sunday ) { 4 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 3 , :sunday ) { 5 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 4 , :sunday ) { 6 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 5 , :sunday ) { 7 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 6 , :sunday ) { 1 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( - 99 , 1 , 31 , :sunday ) { 5 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 10 , 31 , :saturday ) { 3 , 1 , 7 }","ref":"Calendar.ISO.html#day_of_week/4","title":"Calendar.ISO.day_of_week/4","type":"function"},{"doc":"Calculates the day of the year from the given year , month , and day . It is an integer from 1 to 366. Examples iex&gt; Calendar.ISO . day_of_year ( 2016 , 1 , 31 ) 31 iex&gt; Calendar.ISO . day_of_year ( - 99 , 2 , 1 ) 32 iex&gt; Calendar.ISO . day_of_year ( 2018 , 2 , 28 ) 59","ref":"Calendar.ISO.html#day_of_year/3","title":"Calendar.ISO.day_of_year/3","type":"function"},{"doc":"See Calendar.day_rollover_relative_to_midnight_utc/0 for documentation.","ref":"Calendar.ISO.html#day_rollover_relative_to_midnight_utc/0","title":"Calendar.ISO.day_rollover_relative_to_midnight_utc/0","type":"function"},{"doc":"Returns how many days there are in the given year-month. Examples iex&gt; Calendar.ISO . days_in_month ( 1900 , 1 ) 31 iex&gt; Calendar.ISO . days_in_month ( 1900 , 2 ) 28 iex&gt; Calendar.ISO . days_in_month ( 2000 , 2 ) 29 iex&gt; Calendar.ISO . days_in_month ( 2001 , 2 ) 28 iex&gt; Calendar.ISO . days_in_month ( 2004 , 2 ) 29 iex&gt; Calendar.ISO . days_in_month ( 2004 , 4 ) 30 iex&gt; Calendar.ISO . days_in_month ( - 1 , 5 ) 31","ref":"Calendar.ISO.html#days_in_month/2","title":"Calendar.ISO.days_in_month/2","type":"function"},{"doc":"Returns if the given year is a leap year. Examples iex&gt; Calendar.ISO . leap_year? ( 2000 ) true iex&gt; Calendar.ISO . leap_year? ( 2001 ) false iex&gt; Calendar.ISO . leap_year? ( 2004 ) true iex&gt; Calendar.ISO . leap_year? ( 1900 ) false iex&gt; Calendar.ISO . leap_year? ( - 4 ) true","ref":"Calendar.ISO.html#leap_year?/1","title":"Calendar.ISO.leap_year?/1","type":"function"},{"doc":"Returns how many months there are in the given year. Example iex&gt; Calendar.ISO . months_in_year ( 2004 ) 12","ref":"Calendar.ISO.html#months_in_year/1","title":"Calendar.ISO.months_in_year/1","type":"function"},{"doc":"Converts the Calendar.iso_days/0 format to the datetime format specified by this calendar. Examples iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { 0 , { 0 , 86400 } } ) { 0 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { 730_485 , { 0 , 86400 } } ) { 2000 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { 730_485 , { 43200 , 86400 } } ) { 2000 , 1 , 1 , 12 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { - 365 , { 0 , 86400000000 } } ) { - 1 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } }","ref":"Calendar.ISO.html#naive_datetime_from_iso_days/1","title":"Calendar.ISO.naive_datetime_from_iso_days/1","type":"function"},{"doc":"Returns the Calendar.iso_days/0 format of the specified date. Examples iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( 0 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } ) { 0 , { 0 , 86400000000 } } iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( 2000 , 1 , 1 , 12 , 0 , 0 , { 0 , 6 } ) { 730485 , { 43200000000 , 86400000000 } } iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( 2000 , 1 , 1 , 13 , 0 , 0 , { 0 , 6 } ) { 730485 , { 46800000000 , 86400000000 } } iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( - 1 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } ) { - 365 , { 0 , 86400000000 } }","ref":"Calendar.ISO.html#naive_datetime_to_iso_days/7","title":"Calendar.ISO.naive_datetime_to_iso_days/7","type":"function"},{"doc":"Converts the datetime (without time zone) into a string. By default, returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; Calendar.ISO . naive_datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 6 } ) &quot;2015-02-28 01:02:03.000004&quot; iex&gt; Calendar.ISO . naive_datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } ) &quot;2017-08-01 01:02:03.00000&quot; iex&gt; Calendar.ISO . naive_datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 6 } , :basic ) &quot;20150228 010203.000004&quot;","ref":"Calendar.ISO.html#naive_datetime_to_string/8","title":"Calendar.ISO.naive_datetime_to_string/8","type":"function"},{"doc":"Parses a date string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_date ( &quot;2015-01-23&quot; ) { :ok , { 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_date ( &quot;2015:01:23&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015-01-32&quot; ) { :error , :invalid_date }","ref":"Calendar.ISO.html#parse_date/1","title":"Calendar.ISO.parse_date/1","type":"function"},{"doc":"Parses a date string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_date ( &quot;20150123&quot; , :basic ) { :ok , { 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_date ( &quot;20150123&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_date/2","title":"Calendar.ISO.parse_date/2","type":"function"},{"doc":"Parses a naive datetime string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07-02:30&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07.0&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 1 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07,0123456&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } }","ref":"Calendar.ISO.html#parse_naive_datetime/1","title":"Calendar.ISO.parse_naive_datetime/1","type":"function"},{"doc":"Parses a naive datetime string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123 235007&quot; , :basic ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123 235007&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_naive_datetime/2","title":"Calendar.ISO.parse_naive_datetime/2","type":"function"},{"doc":"Parses a time string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07Z&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;T23:50:07Z&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } }","ref":"Calendar.ISO.html#parse_time/1","title":"Calendar.ISO.parse_time/1","type":"function"},{"doc":"Parses a time string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_time ( &quot;235007&quot; , :basic ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;235007&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_time/2","title":"Calendar.ISO.parse_time/2","type":"function"},{"doc":"Parses a UTC datetime string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07+02:30&quot; ) { :ok , { 2015 , 1 , 23 , 21 , 20 , 7 , { 0 , 0 } } , 9000 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07&quot; ) { :error , :missing_offset }","ref":"Calendar.ISO.html#parse_utc_datetime/1","title":"Calendar.ISO.parse_utc_datetime/1","type":"function"},{"doc":"Parses a UTC datetime string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;20150123 235007Z&quot; , :basic ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;20150123 235007Z&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_utc_datetime/2","title":"Calendar.ISO.parse_utc_datetime/2","type":"function"},{"doc":"Calculates the quarter of the year from the given year , month , and day . It is an integer from 1 to 4. Examples iex&gt; Calendar.ISO . quarter_of_year ( 2016 , 1 , 31 ) 1 iex&gt; Calendar.ISO . quarter_of_year ( 2016 , 4 , 3 ) 2 iex&gt; Calendar.ISO . quarter_of_year ( - 99 , 9 , 31 ) 3 iex&gt; Calendar.ISO . quarter_of_year ( 2018 , 12 , 28 ) 4","ref":"Calendar.ISO.html#quarter_of_year/3","title":"Calendar.ISO.quarter_of_year/3","type":"function"},{"doc":"Converts a day fraction to this Calendar's representation of time. Examples iex&gt; Calendar.ISO . time_from_day_fraction ( { 1 , 2 } ) { 12 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . time_from_day_fraction ( { 13 , 24 } ) { 13 , 0 , 0 , { 0 , 6 } }","ref":"Calendar.ISO.html#time_from_day_fraction/1","title":"Calendar.ISO.time_from_day_fraction/1","type":"function"},{"doc":"Returns the normalized day fraction of the specified time. Examples iex&gt; Calendar.ISO . time_to_day_fraction ( 0 , 0 , 0 , { 0 , 6 } ) { 0 , 86400000000 } iex&gt; Calendar.ISO . time_to_day_fraction ( 12 , 34 , 56 , { 123 , 6 } ) { 45296000123 , 86400000000 }","ref":"Calendar.ISO.html#time_to_day_fraction/4","title":"Calendar.ISO.time_to_day_fraction/4","type":"function"},{"doc":"Converts the given time into a string. By default, returns times formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 6 } ) &quot;02:02:02.000002&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 2 } ) &quot;02:02:02.00&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 0 } ) &quot;02:02:02&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 6 } , :basic ) &quot;020202.000002&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 6 } , :extended ) &quot;02:02:02.000002&quot;","ref":"Calendar.ISO.html#time_to_string/5","title":"Calendar.ISO.time_to_string/5","type":"function"},{"doc":"Determines if the date given is valid according to the proleptic Gregorian calendar. Examples iex&gt; Calendar.ISO . valid_date? ( 2015 , 2 , 28 ) true iex&gt; Calendar.ISO . valid_date? ( 2015 , 2 , 30 ) false iex&gt; Calendar.ISO . valid_date? ( - 1 , 12 , 31 ) true iex&gt; Calendar.ISO . valid_date? ( - 1 , 12 , 32 ) false","ref":"Calendar.ISO.html#valid_date?/3","title":"Calendar.ISO.valid_date?/3","type":"function"},{"doc":"Determines if the date given is valid according to the proleptic Gregorian calendar. Leap seconds are not supported by the built-in Calendar.ISO. Examples iex&gt; Calendar.ISO . valid_time? ( 10 , 50 , 25 , { 3006 , 6 } ) true iex&gt; Calendar.ISO . valid_time? ( 23 , 59 , 60 , { 0 , 0 } ) false iex&gt; Calendar.ISO . valid_time? ( 24 , 0 , 0 , { 0 , 0 } ) false","ref":"Calendar.ISO.html#valid_time?/4","title":"Calendar.ISO.valid_time?/4","type":"function"},{"doc":"Calculates the year and era from the given year . The ISO calendar has two eras: the &quot;current era&quot; (CE) which starts in year 1 and is defined as era 1 . And &quot;before the current era&quot; (BCE) for those years less than 1 , defined as era 0 . Examples iex&gt; Calendar.ISO . year_of_era ( 1 ) { 1 , 1 } iex&gt; Calendar.ISO . year_of_era ( 2018 ) { 2018 , 1 } iex&gt; Calendar.ISO . year_of_era ( 0 ) { 1 , 0 } iex&gt; Calendar.ISO . year_of_era ( - 1 ) { 2 , 0 }","ref":"Calendar.ISO.html#year_of_era/1","title":"Calendar.ISO.year_of_era/1","type":"function"},{"doc":"&quot;Before the Current Era&quot; or &quot;Before the Common Era&quot; (BCE), for those years less than 1 .","ref":"Calendar.ISO.html#t:bce/0","title":"Calendar.ISO.bce/0","type":"type"},{"doc":"The &quot;Current Era&quot; or the &quot;Common Era&quot; (CE) which starts in year 1 .","ref":"Calendar.ISO.html#t:ce/0","title":"Calendar.ISO.ce/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:day/0","title":"Calendar.ISO.day/0","type":"type"},{"doc":"Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.","ref":"Calendar.ISO.html#t:day_of_week/0","title":"Calendar.ISO.day_of_week/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:day_of_year/0","title":"Calendar.ISO.day_of_year/0","type":"type"},{"doc":"The calendar era. The ISO calendar has two eras: CE - which starts in year 1 and is defined as era 1 . BCE - for those years less than 1 and is defined as era 0 .","ref":"Calendar.ISO.html#t:era/0","title":"Calendar.ISO.era/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:hour/0","title":"Calendar.ISO.hour/0","type":"type"},{"doc":"Microseconds with stored precision. The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.","ref":"Calendar.ISO.html#t:microsecond/0","title":"Calendar.ISO.microsecond/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:minute/0","title":"Calendar.ISO.minute/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:month/0","title":"Calendar.ISO.month/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:quarter_of_year/0","title":"Calendar.ISO.quarter_of_year/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:second/0","title":"Calendar.ISO.second/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:weekday/0","title":"Calendar.ISO.weekday/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:year/0","title":"Calendar.ISO.year/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:year_of_era/0","title":"Calendar.ISO.year_of_era/0","type":"type"},{"doc":"This module defines a behaviour for providing time zone data. IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.","ref":"Calendar.TimeZoneDatabase.html","title":"Calendar.TimeZoneDatabase","type":"behaviour"},{"doc":"Time zone period for a point in time in UTC for a specific time zone. Takes a time zone name and a point in time for UTC and returns a time_zone_period for that point in time.","ref":"Calendar.TimeZoneDatabase.html#c:time_zone_period_from_utc_iso_days/2","title":"Calendar.TimeZoneDatabase.time_zone_period_from_utc_iso_days/2","type":"callback"},{"doc":"Possible time zone periods for a certain time zone and wall clock date and time. When the provided datetime is ambiguous a tuple with :ambiguous and two possible periods. The periods in the list are sorted with the first element being the one that begins first. When the provided datetime is in a gap - for instance during the &quot;spring forward&quot; when going from winter time to summer time, a tuple with :gap and two periods with limits are returned in a nested tuple. The first nested two-tuple is the period before the gap and a naive datetime with a limit for when the period ends (wall time). The second nested two-tuple is the period just after the gap and a datetime (wall time) for when the period begins just after the gap. If there is only a single possible period for the provided datetime , then a tuple with :ok and the time_zone_period is returned.","ref":"Calendar.TimeZoneDatabase.html#c:time_zone_periods_from_wall_datetime/2","title":"Calendar.TimeZoneDatabase.time_zone_periods_from_wall_datetime/2","type":"callback"},{"doc":"A period where a certain combination of UTC offset, standard offset and zone abbreviation is in effect. For instance one period could be the summer of 2018 in &quot;Europe/London&quot; where summer time / daylight saving time is in effect and lasts from spring to autumn. At autumn the std_offset changes along with the zone_abbr so a different period is needed during winter.","ref":"Calendar.TimeZoneDatabase.html#t:time_zone_period/0","title":"Calendar.TimeZoneDatabase.time_zone_period/0","type":"type"},{"doc":"Limit for when a certain time zone period begins or ends. A beginning is inclusive. An ending is exclusive. Eg. if a period is from 2015-03-29 01:00:00 and until 2015-10-25 01:00:00, the period includes and begins from the beginning of 2015-03-29 01:00:00 and lasts until just before 2015-10-25 01:00:00. A beginning or end for certain periods are infinite. For instance the latest period for time zones without DST or plans to change. However for the purpose of this behaviour they are only used for gaps in wall time where the needed period limits are at a certain time.","ref":"Calendar.TimeZoneDatabase.html#t:time_zone_period_limit/0","title":"Calendar.TimeZoneDatabase.time_zone_period_limit/0","type":"type"},{"doc":"Built-in time zone database that works only in Etc/UTC. For all other time zones, it returns {:error, :utc_only_time_zone_database} .","ref":"Calendar.UTCOnlyTimeZoneDatabase.html","title":"Calendar.UTCOnlyTimeZoneDatabase","type":"module"},{"doc":"Agents are a simple abstraction around state. Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time. The Agent module provides a basic server implementation that allows state to be retrieved and updated via a simple API. Examples For example, the following agent implements a counter: defmodule Counter do use Agent def start_link ( initial_value ) do Agent . start_link ( fn -&gt; initial_value end , name : __MODULE__ ) end def value do Agent . get ( __MODULE__ , &amp; &amp;1 ) end def increment do Agent . update ( __MODULE__ , &amp; ( &amp;1 + 1 ) ) end end Usage would be: Counter . start_link ( 0 ) #=&gt; {:ok, #PID&lt;0.123.0&gt;} Counter . value ( ) #=&gt; 0 Counter . increment ( ) #=&gt; :ok Counter . increment ( ) #=&gt; :ok Counter . value ( ) #=&gt; 2 Thanks to the agent server process, the counter can be safely incremented concurrently. Agents provide a segregation between the client and server APIs (similar to GenServer s). In particular, the functions passed as arguments to the calls to Agent functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled. Consider these two examples: # Compute in the agent/server def get_something ( agent ) do Agent . get ( agent , fn state -&gt; do_something_expensive ( state ) end ) end # Compute in the agent/client def get_something ( agent ) do Agent . get ( agent , &amp; &amp;1 ) |&gt; do_something_expensive ( ) end The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling do_something_expensive(state) outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values. How to supervise An Agent is most commonly started under a supervision tree. When we invoke use Agent , it automatically defines a child_spec/1 function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do: children = [ { Counter , 0 } ] Supervisor . start_link ( children , strategy : :one_for_all ) While one could also simply pass the Counter as a child to the supervisor, such as: children = [ Counter # Same as {Counter, []} ] Supervisor . start_link ( children , strategy : :one_for_all ) The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example: def start_link ( opts ) do { initial_value , opts } = Keyword . pop ( opts , :initial_value , 0 ) Agent . start_link ( fn -&gt; initial_value end , opts ) end and then you can use Counter , {Counter, name: :my_counter} or even {Counter, initial_value: 0, name: :my_counter} as a child specification. use Agent also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated child_spec/1 can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the child should be restarted, defaults to :permanent :shutdown - how to shut down the child, either immediately or by giving it time to shut down For example: use Agent , restart : :transient , shutdown : 10_000 See the &quot;Child specification&quot; section in the Supervisor module for more detailed information. The @doc annotation immediately preceding use Agent will be attached to the generated child_spec/1 function. Name registration An agent is bound to the same name registration rules as GenServers. Read more about it in the GenServer documentation. A word on distributed agents It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments. In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module. Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by shutting down some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module. The best solution is to simply use the explicit module, function, and arguments APIs when working with distributed agents. Hot code swapping An agent can have its code hot swapped live by simply passing a module, function, and arguments tuple to the update instruction. For example, imagine you have an agent named :sample and you want to convert its inner state from a keyword list to a map. It can be done with the following instruction: { :update , :sample , { :advanced , { Enum , :into , [ %{ } ] } } } The agent's state will be added to the given list of arguments ( [%{}] ) as the first argument.","ref":"Agent.html","title":"Agent","type":"module"},{"doc":"Performs a cast ( fire and forget ) operation on the agent state. The function fun is sent to the agent which invokes the function passing the agent state. The return value of fun becomes the new state of the agent. Note that cast returns :ok immediately, regardless of whether agent (or the node it should live on) exists. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . cast ( pid , fn state -&gt; state + 1 end ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 43","ref":"Agent.html#cast/2","title":"Agent.cast/2","type":"function"},{"doc":"Performs a cast ( fire and forget ) operation on the agent state. Same as cast/2 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . cast ( pid , Kernel , :+ , [ 12 ] ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 54","ref":"Agent.html#cast/4","title":"Agent.cast/4","type":"function"},{"doc":"Returns a specification to start an agent under a supervisor. See the &quot;Child specification&quot; section in the Supervisor module for more detailed information.","ref":"Agent.html#child_spec/1","title":"Agent.child_spec/1","type":"function"},{"doc":"Gets an agent value via the given anonymous function. The function fun is sent to the agent which invokes the function passing the agent state. The result of the function invocation is returned from this function. timeout is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom :infinity to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . get ( pid , fn state -&gt; state end ) 42","ref":"Agent.html#get/3","title":"Agent.get/3","type":"function"},{"doc":"Gets an agent value via the given function. Same as get/3 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments.","ref":"Agent.html#get/5","title":"Agent.get/5","type":"function"},{"doc":"Gets and updates the agent state in one operation via the given anonymous function. The function fun is sent to the agent which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent. timeout is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom :infinity to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . get_and_update ( pid , fn state -&gt; { state , state + 1 } end ) 42 iex&gt; Agent . get ( pid , fn state -&gt; state end ) 43","ref":"Agent.html#get_and_update/3","title":"Agent.get_and_update/3","type":"function"},{"doc":"Gets and updates the agent state in one operation via the given function. Same as get_and_update/3 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments.","ref":"Agent.html#get_and_update/5","title":"Agent.get_and_update/5","type":"function"},{"doc":"Starts an agent process without links (outside of a supervision tree). See start_link/2 for more information. Examples iex&gt; { :ok , pid } = Agent . start ( fn -&gt; 42 end ) iex&gt; Agent . get ( pid , fn state -&gt; state end ) 42","ref":"Agent.html#start/2","title":"Agent.start/2","type":"function"},{"doc":"Starts an agent without links with the given module, function, and arguments. See start_link/4 for more information.","ref":"Agent.html#start/4","title":"Agent.start/4","type":"function"},{"doc":"Starts an agent linked to the current process with the given function. This is often used to start the agent as part of a supervision tree. Once the agent is spawned, the given function fun is invoked in the server process, and should return the initial agent state. Note that start_link/2 does not return until the given function has returned. Options The :name option is used for registration as described in the module documentation. If the :timeout option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return {:error, :timeout} . If the :debug option is present, the corresponding function in the :sys module will be invoked. If the :spawn_opt option is present, its value will be passed as options to the underlying process as in Process.spawn/4 . Return values If the server is successfully created and initialized, the function returns {:ok, pid} , where pid is the PID of the server. If an agent with the specified name already exists, the function returns {:error, {:already_started, pid}} with the PID of that process. If the given function callback fails, the function returns {:error, reason} . Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . get ( pid , fn state -&gt; state end ) 42 iex&gt; { :error , { exception , _stacktrace } } = Agent . start ( fn -&gt; raise &quot;oops&quot; end ) iex&gt; exception % RuntimeError { message : &quot;oops&quot; }","ref":"Agent.html#start_link/2","title":"Agent.start_link/2","type":"function"},{"doc":"Starts an agent linked to the current process. Same as start_link/2 but a module, function, and arguments are expected instead of an anonymous function; fun in module will be called with the given arguments args to initialize the state.","ref":"Agent.html#start_link/4","title":"Agent.start_link/4","type":"function"},{"doc":"Synchronously stops the agent with the given reason . It returns :ok if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report will be logged. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . stop ( pid ) :ok","ref":"Agent.html#stop/3","title":"Agent.stop/3","type":"function"},{"doc":"Updates the agent state via the given anonymous function. The function fun is sent to the agent which invokes the function passing the agent state. The return value of fun becomes the new state of the agent. This function always returns :ok . timeout is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom :infinity to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . update ( pid , fn state -&gt; state + 1 end ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 43","ref":"Agent.html#update/3","title":"Agent.update/3","type":"function"},{"doc":"Updates the agent state via the given function. Same as update/3 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . update ( pid , Kernel , :+ , [ 12 ] ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 54","ref":"Agent.html#update/5","title":"Agent.update/5","type":"function"},{"doc":"The agent reference","ref":"Agent.html#t:agent/0","title":"Agent.agent/0","type":"type"},{"doc":"The agent name","ref":"Agent.html#t:name/0","title":"Agent.name/0","type":"type"},{"doc":"Return values of start* functions","ref":"Agent.html#t:on_start/0","title":"Agent.on_start/0","type":"type"},{"doc":"The agent state","ref":"Agent.html#t:state/0","title":"Agent.state/0","type":"type"},{"doc":"A module for working with applications and defining application callbacks. Applications are the idiomatic way to package software in Erlang/OTP. To get the idea, they are similar to the &quot;library&quot; concept common in other programming languages, but with some additional characteristics. An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and life cycle. Applications are loaded , started , and stopped . Each application also has its own environment, which provides a unified API for configuring each application. Developers typically interact with the application environment and its callback module. Therefore those will be the topics we will cover first before jumping into details about the application resource file and life-cycle. The application environment Each application has its own environment. The environment is a keyword list that maps atoms to terms. Note that this environment is unrelated to the operating system environment. By default, the environment of an application is an empty list. In a Mix project's mix.exs file, you can set the :env key in application/0 : def application do [ env : [ db_host : &quot;localhost&quot; ] ] end Now, in your application, you can read this environment by using functions such as fetch_env!/2 and friends: defmodule MyApp.DBClient do def start_link ( ) do SomeLib.DBClient . start_link ( host : db_host ( ) ) end defp db_host do Application . fetch_env! ( :my_app , :db_host ) end end In Mix projects, the environment of the application and its dependencies can be overridden via the config/config.exs file. For example, someone using your application can override its :db_host environment variable as follows: import Config config :my_app , :db_host , &quot;db.local&quot; You can also change the application environment dynamically by using functions such as put_env/3 and delete_env/2 . However, as a rule of thumb, each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications. Compile-time environment In the previous example, we read the application environment at runtime: defmodule MyApp.DBClient do def start_link ( ) do SomeLib.DBClient . start_link ( host : db_host ( ) ) end defp db_host do Application . fetch_env! ( :my_app , :db_host ) end end In other words, the environment key :db_host for application :my_app will only be read when MyApp.DBClient effectively starts. While reading the application environment at runtime is the preferred approach, in some rare occasions you may want to use the application environment to configure the compilation of a certain project. This is often done by calling get_env/3 outside of a function: defmodule MyApp.DBClient do @db_host Application . get_env ( :my_app , :db_host , &quot;db.local&quot; ) def start_link ( ) do SomeLib.DBClient . start_link ( host : @db_host ) end end This approach has one big limitation: if you change the value of the application environment after the code is compiled, the value used at runtime is not going to change! For example, if your config/runtime.exs has: config :my_app , :db_host , &quot;db.production&quot; This value will have no effect as the code was compiled to connect to &quot;db.local&quot;, which is mostly likely unavailable in the production environment. For those reasons, reading the application environment at runtime should be the first choice. However, if you really have to read the application environment during compilation, we recommend you to use compile_env/3 instead: @db_host Application . compile_env ( :my_app , :db_host , &quot;db.local&quot; ) By using compile_env/3 , tools like Mix will store the values used during compilation and compare the compilation values with the runtime values whenever your system starts, raising an error in case they differ. The application callback module Applications can be loaded, started, and stopped. Generally, build tools like Mix take care of starting an application and all of its dependencies for you, but you can also do it manually by calling: { :ok , _ } = Application . ensure_all_started ( :some_app ) When an application starts, developers may configure a callback module that executes custom code. Developers use this callback to start the application supervision tree. The first step to do so is to add a :mod key to the application/0 definition in your mix.exs file. It expects a tuple, with the application callback module and start argument (commonly an empty list): def application do [ mod : { MyApp , [ ] } ] end The MyApp module given to :mod needs to implement the Application behaviour. This can be done by putting use Application in that module and implementing the start/2 callback, for example: defmodule MyApp do use Application def start ( _type , _args ) do children = [ ] Supervisor . start_link ( children , strategy : :one_for_one ) end end The start/2 callback has to spawn and link a supervisor and return {:ok, pid} or {:ok, pid, state} , where pid is the PID of the supervisor, and state is an optional application state. args is the second element of the tuple given to the :mod option. The type argument passed to start/2 is usually :normal unless in a distributed setup where application takeovers and failovers are configured. Distributed applications are beyond the scope of this documentation. When an application is shutting down, its stop/1 callback is called after the supervision tree has been stopped by the runtime. This callback allows the application to do any final cleanup. The argument is the state returned by start/2 , if it did, or [] otherwise. The return value of stop/1 is ignored. By using Application , modules get a default implementation of stop/1 that ignores its argument and returns :ok , but it can be overridden. Application callback modules may also implement the optional callback prep_stop/1 . If present, prep_stop/1 is invoked before the supervision tree is terminated. Its argument is the state returned by start/2 , if it did, or [] otherwise, and its return value is passed to stop/1 . The application resource file In the sections above, we have configured an application in the application/0 section of the mix.exs file. Ultimately, Mix will use this configuration to create an application resource file , which is a file called APP_NAME.app . For example, the application resource file of the OTP application ex_unit is called ex_unit.app . You can learn more about the generation of application resource files in the documentation of Mix.Tasks.Compile.App , available as well by running mix help compile.app . The application life cycle Loading applications Applications are loaded , which means that the runtime finds and processes their resource files: Application . load ( :ex_unit ) #=&gt; :ok When an application is loaded, the environment specified in its resource file is merged with any overrides from config files. Loading an application does not load its modules. In practice, you rarely load applications by hand because that is part of the start process, explained next. Starting applications Applications are also started : Application . start ( :ex_unit ) #=&gt; :ok Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a main procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic. When an application is started, the Application.load/1 is automatically invoked if it hasn't been done yet. Then, it checks if the dependencies listed in the applications key of the resource file are already started. Having at least one dependency not started is an error condition. Functions like ensure_all_started/1 takes care of starting an application and all of its dependencies for you. If the application does not have a callback module configured, starting is done at this point. Otherwise, its start/2 callback is invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any. Stopping applications Started applications are, finally, stopped : Application . stop ( :ex_unit ) #=&gt; :ok Stopping an application without a callback module is defined, but except for some system tracing, it is in practice a no-op. Stopping an application with a callback module has three steps: If present, invoke the optional callback prep_stop/1 . Terminate the top-level supervisor. Invoke the required callback stop/1 . The arguments passed to the callbacks are related to the state optionally returned by start/2 , and are documented in the section about the callback module above. It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The stop/1 callback is invoked only after termination of the whole supervision tree. Shutting down a live system cleanly can be done by calling System.stop/1 . It will shut down every application in the opposite order they had been started. By default, a SIGTERM from the operating system will automatically translate to System.stop/0 . You can also have more explicit control over operating system signals via the :os.set_signal/2 function. Tooling The Mix build tool automates most of the application management tasks. For example, mix test automatically starts your application dependencies and your application itself before your test runs. mix run --no-halt boots your current project and can be used to start a long running system. See mix help run . Developers can also use mix release to build releases . Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring. Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See mix help archive.build and mix help escript.build for more detail. Further information For further details on applications please check the documentation of the :application Erlang module , and the Applications section of the OTP Design Principles User's Guide .","ref":"Application.html","title":"Application","type":"behaviour"},{"doc":"Gets the directory for app. This information is returned based on the code path. Here is an example: File . mkdir_p! ( &quot;foo/ebin&quot; ) Code . prepend_path ( &quot;foo/ebin&quot; ) Application . app_dir ( :foo ) #=&gt; &quot;foo&quot; Even though the directory is empty and there is no .app file it is considered the application directory based on the name &quot;foo/ebin&quot;. The name may contain a dash - which is considered to be the app version and it is removed for the lookup purposes: File . mkdir_p! ( &quot;bar-123/ebin&quot; ) Code . prepend_path ( &quot;bar-123/ebin&quot; ) Application . app_dir ( :bar ) #=&gt; &quot;bar-123&quot; For more information on code paths, check the Code module in Elixir and also Erlang's :code module .","ref":"Application.html#app_dir/1","title":"Application.app_dir/1","type":"function"},{"doc":"Returns the given path inside app_dir/1 . If path is a string, then it will be used as the path inside app_dir/1 . If path is a list of strings, it will be joined (see Path.join/1 ) and the result will be used as the path inside app_dir/1 . Examples File . mkdir_p! ( &quot;foo/ebin&quot; ) Code . prepend_path ( &quot;foo/ebin&quot; ) Application . app_dir ( :foo , &quot;my_path&quot; ) #=&gt; &quot;foo/my_path&quot; Application . app_dir ( :foo , [ &quot;my&quot; , &quot;nested&quot; , &quot;path&quot; ] ) #=&gt; &quot;foo/my/nested/path&quot;","ref":"Application.html#app_dir/2","title":"Application.app_dir/2","type":"function"},{"doc":"Reads the application environment at compilation time. Similar to get_env/3 , except it must be used to read values at compile time. This allows Elixir to track when configuration values change between compile time and runtime. The first argument is the application name. The second argument key_or_path is either an atom key or a path to traverse in search of the configuration, starting with an atom key. For example, imagine the following configuration: config :my_app , :key , [ foo : [ bar : :baz ] ] We can access it during compile time as: Application . compile_env ( :my_app , :key ) #=&gt; [foo: [bar: :baz]] Application . compile_env ( :my_app , [ :key , :foo ] ) #=&gt; [bar: :baz] Application . compile_env ( :my_app , [ :key , :foo , :bar ] ) #=&gt; :baz A default value can also be given as third argument. If any of the keys in the path along the way is missing, the default value is used: Application . compile_env ( :my_app , [ :unknown , :foo , :bar ] , :default ) #=&gt; :default Application . compile_env ( :my_app , [ :key , :unknown , :bar ] , :default ) #=&gt; :default Application . compile_env ( :my_app , [ :key , :foo , :unknown ] , :default ) #=&gt; :default Giving a path is useful to let Elixir know that only certain paths in a large configuration are compile time dependent.","ref":"Application.html#compile_env/3","title":"Application.compile_env/3","type":"macro"},{"doc":"Reads the application environment at compilation time or raises. This is the same as compile_env/3 but it raises an ArgumentError if the configuration is not available.","ref":"Application.html#compile_env!/2","title":"Application.compile_env!/2","type":"macro"},{"doc":"Callback invoked after code upgrade, if the application environment has changed. changed is a keyword list of keys and their changed values in the application environment. new is a keyword list with all new keys and their values. removed is a list with all removed keys.","ref":"Application.html#c:config_change/3","title":"Application.config_change/3","type":"callback"},{"doc":"Deletes the key from the given app environment. It receives the same options as put_env/4 . Returns :ok .","ref":"Application.html#delete_env/3","title":"Application.delete_env/3","type":"function"},{"doc":"Ensures the given app and its applications are started. Same as start/2 but also starts the applications listed under :applications in the .app file in case they were not previously started.","ref":"Application.html#ensure_all_started/2","title":"Application.ensure_all_started/2","type":"function"},{"doc":"Ensures the given app is loaded. Same as load/2 but returns :ok if the application was already loaded.","ref":"Application.html#ensure_loaded/1","title":"Application.ensure_loaded/1","type":"function"},{"doc":"Ensures the given app is started. Same as start/2 but returns :ok if the application was already started. This is useful in scripts and in test setup, where test applications need to be explicitly started: :ok = Application . ensure_started ( :my_test_dep )","ref":"Application.html#ensure_started/2","title":"Application.ensure_started/2","type":"function"},{"doc":"Returns the value for key in app 's environment in a tuple. If the configuration parameter does not exist, the function returns :error .","ref":"Application.html#fetch_env/2","title":"Application.fetch_env/2","type":"function"},{"doc":"Returns the value for key in app 's environment. If the configuration parameter does not exist, raises ArgumentError . Important: if you are reading the application environment at compilation time, for example, inside the module definition instead of inside of a function, see compile_env!/2 instead.","ref":"Application.html#fetch_env!/2","title":"Application.fetch_env!/2","type":"function"},{"doc":"Formats the error reason returned by start/2 , ensure_started/2 , stop/1 , load/1 and unload/1 , returns a string.","ref":"Application.html#format_error/1","title":"Application.format_error/1","type":"function"},{"doc":"Returns all key-value pairs for app .","ref":"Application.html#get_all_env/1","title":"Application.get_all_env/1","type":"function"},{"doc":"Gets the application for the given module. The application is located by analyzing the spec of all loaded applications. Returns nil if the module is not listed in any application spec.","ref":"Application.html#get_application/1","title":"Application.get_application/1","type":"function"},{"doc":"Returns the value for key in app 's environment. If the configuration parameter does not exist, the function returns the default value. Important: if you are reading the application environment at compilation time, for example, inside the module definition instead of inside of a function, see compile_env/3 instead. Important: if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our library guidelines . Examples get_env/3 is commonly used to read the configuration of your OTP applications. Since Mix configurations are commonly used to configure applications, we will use this as a point of illustration. Consider a new application :my_app . :my_app contains a database engine which supports a pool of databases. The database engine needs to know the configuration for each of those databases, and that configuration is supplied by key-value pairs in environment of :my_app . config :my_app , Databases.RepoOne , # A database configuration ip : &quot;localhost&quot; , port : 5433 config :my_app , Databases.RepoTwo , # Another database configuration (for the same OTP app) ip : &quot;localhost&quot; , port : 20717 config :my_app , my_app_databases : [ Databases.RepoOne , Databases.RepoTwo ] Our database engine used by :my_app needs to know what databases exist, and what the database configurations are. The database engine can make a call to get_env(:my_app, :my_app_databases) to retrieve the list of databases (specified by module names). Our database engine can then traverse each repository in the list and then call get_env(:my_app, Databases.RepoOne) and so forth to retrieve the configuration of each one.","ref":"Application.html#get_env/3","title":"Application.get_env/3","type":"function"},{"doc":"Loads the given app . In order to be loaded, an .app file must be in the load paths. All :included_applications will also be loaded. Loading the application does not start it nor load its modules, but it does load its environment.","ref":"Application.html#load/1","title":"Application.load/1","type":"function"},{"doc":"Returns a list with information about the applications which have been loaded.","ref":"Application.html#loaded_applications/0","title":"Application.loaded_applications/0","type":"function"},{"doc":"Called before stopping the application. This function is called before the top-level supervisor is terminated. It receives the state returned by start/2 , if it did, or [] otherwise. The return value is later passed to stop/1 .","ref":"Application.html#c:prep_stop/1","title":"Application.prep_stop/1","type":"callback"},{"doc":"Puts the environment for multiple apps at the same time. The given config should not: have the same application listed more than once have the same key inside the same application listed more than once If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later). It receives the same options as put_env/4 . Returns :ok .","ref":"Application.html#put_all_env/2","title":"Application.put_all_env/2","type":"function"},{"doc":"Puts the value in key for the given app . Options :timeout - the timeout for the change (defaults to 5_000 milliseconds) :persistent - persists the given value on application load and reloads If put_env/4 is called before the application is loaded, the application environment values specified in the .app file will override the ones previously set. The :persistent option can be set to true when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.","ref":"Application.html#put_env/4","title":"Application.put_env/4","type":"function"},{"doc":"Returns the spec for app . The following keys are returned: :description :id :vsn :modules :maxP :maxT :registered :included_applications :applications :mod :start_phases Note the environment is not returned as it can be accessed via fetch_env/2 . Returns nil if the application is not loaded.","ref":"Application.html#spec/1","title":"Application.spec/1","type":"function"},{"doc":"Returns the value for key in app 's specification. See spec/1 for the supported keys. If the given specification parameter does not exist, this function will raise. Returns nil if the application is not loaded.","ref":"Application.html#spec/2","title":"Application.spec/2","type":"function"},{"doc":"Starts the given app . If the app is not loaded, the application will first be loaded using load/1 . Any included application, defined in the :included_applications key of the .app file will also be loaded, but they won't be started. Furthermore, all applications listed in the :applications key must be explicitly started before this application is. If not, {:error, {:not_started, app}} is returned, where app is the name of the missing application. In case you want to automatically load and start all of app 's dependencies, see ensure_all_started/2 . The type argument specifies the type of the application: :permanent - if app terminates, all other applications and the entire node are also terminated. :transient - if app terminates with :normal reason, it is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire node are also terminated. :temporary - if app terminates, it is reported but no other applications are terminated (the default). Note that it is always possible to stop an application explicitly by calling stop/1 . Regardless of the type of the application, no other applications will be affected. Note also that the :transient type is of little practical use, since when a supervision tree terminates, the reason is set to :shutdown , not :normal .","ref":"Application.html#start/2","title":"Application.start/2","type":"function"},{"doc":"Called when an application is started. This function is called when an application is started using Application.start/2 (and functions on top of that, such as Application.ensure_started/2 ). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision). start_type defines how the application is started: :normal - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key :start_phases is :undefined . {:takeover, node} - used if the application is distributed and is started on the current node because of a failover on the node node . {:failover, node} - used if the application is distributed and is started on the current node because of a failover on node node , and the application specification key :start_phases is not :undefined . start_args are the arguments passed to the application in the :mod specification key (for example, mod: {MyApp, [:my_args]} ). This function should either return {:ok, pid} or {:ok, pid, state} if startup is successful. pid should be the PID of the top supervisor. state can be an arbitrary term, and if omitted will default to [] ; if the application is later stopped, state is passed to the stop/1 callback (see the documentation for the stop/1 callback for more information). use Application provides no default implementation for the start/2 callback.","ref":"Application.html#c:start/2","title":"Application.start/2","type":"callback"},{"doc":"Starts an application in synchronous phases. This function is called after start/2 finishes but before Application.start/2 returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.","ref":"Application.html#c:start_phase/3","title":"Application.start_phase/3","type":"callback"},{"doc":"Returns a list with information about the applications which are currently running.","ref":"Application.html#started_applications/1","title":"Application.started_applications/1","type":"function"},{"doc":"Stops the given app . When stopped, the application is still loaded.","ref":"Application.html#stop/1","title":"Application.stop/1","type":"function"},{"doc":"Called after an application has been stopped. This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the start/2 callback did, and should perform any necessary cleanup. The return value of this callback is ignored. state is the state returned by start/2 , if it did, or [] otherwise. If the optional callback prep_stop/1 is present, state is its return value instead. use Application defines a default implementation of this function which does nothing and just returns :ok .","ref":"Application.html#c:stop/1","title":"Application.stop/1","type":"callback"},{"doc":"Unloads the given app . It will also unload all :included_applications . Note that the function does not purge the application modules.","ref":"Application.html#unload/1","title":"Application.unload/1","type":"function"},{"doc":"","ref":"Application.html#t:app/0","title":"Application.app/0","type":"type"},{"doc":"","ref":"Application.html#t:application_key/0","title":"Application.application_key/0","type":"type"},{"doc":"","ref":"Application.html#t:key/0","title":"Application.key/0","type":"type"},{"doc":"","ref":"Application.html#t:restart_type/0","title":"Application.restart_type/0","type":"type"},{"doc":"","ref":"Application.html#t:start_type/0","title":"Application.start_type/0","type":"type"},{"doc":"","ref":"Application.html#t:state/0","title":"Application.state/0","type":"type"},{"doc":"","ref":"Application.html#t:value/0","title":"Application.value/0","type":"type"},{"doc":"A simple keyword-based configuration API. Example This module is most commonly used to define application configuration, typically in config/config.exs : import Config config :some_app , key1 : &quot;value1&quot; , key2 : &quot;value2&quot; import_config &quot; \#{ config_env ( ) } .exs&quot; import Config will import the functions config/2 , config/3 config_env/0 , config_target/0 , and import_config/1 to help you manage your configuration. config/2 and config/3 are used to define key-value configuration for a given application. Once Mix starts, it will automatically evaluate the configuration file and persist the configuration above into :some_app 's application environment, which can be accessed in as follows: &quot;value1&quot; = Application . fetch_env! ( :some_app , :key1 ) Finally, the line import_config &quot;\#{config_env()}.exs&quot; will import other config files based on the current configuration environment, such as config/dev.exs and config/test.exs . Config also provides a low-level API for evaluating and reading configuration, under the Config.Reader module. Important: if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. Also note that the config/config.exs of a library is not evaluated when the library is used as a dependency, as configuration is always meant to configure the current project. For more information, read our library guidelines . Migrating from use Mix.Config The Config module in Elixir was introduced in v1.9 as a replacement to Mix.Config , which was specific to Mix and has been deprecated. You can leverage Config instead of Mix.Config in three steps. The first step is to replace use Mix.Config at the top of your config files by import Config . The second is to make sure your import_config/1 calls do not have a wildcard character. If so, you need to perform the wildcard lookup manually. For example, if you did: import_config &quot;../apps/*/config/config.exs&quot; It has to be replaced by: for config &lt;- &quot;../apps/*/config/config.exs&quot; |&gt; Path . expand ( __DIR__ ) |&gt; Path . wildcard ( ) do import_config config end The last step is to replace all Mix.env() calls by config_env() . config/runtime.exs For runtime configuration, you can use the config/runtime.exs file. It is executed right before applications start in both Mix and releases (assembled with mix release ).","ref":"Config.html","title":"Config","type":"module"},{"doc":"Configures the given root_key . Keyword lists are always deep-merged. Examples The given opts are merged into the existing configuration for the given root_key . Conflicting keys are overridden by the ones specified in opts . For example, the application configuration below config :logger , level : :warn , backends : [ :console ] config :logger , level : :info , truncate : 1024 will have a final configuration for :logger of: [ level : :info , backends : [ :console ] , truncate : 1024 ]","ref":"Config.html#config/2","title":"Config.config/2","type":"function"},{"doc":"Configures the given key for the given root_key . Keyword lists are always deep merged. Examples The given opts are merged into the existing values for key in the given root_key . Conflicting keys are overridden by the ones specified in opts . For example, the application configuration below config :ecto , Repo , log_level : :warn , adapter : Ecto.Adapters.Postgres config :ecto , Repo , log_level : :info , pool_size : 10 will have a final value of the configuration for the Repo key in the :ecto application of: [ log_level : :info , pool_size : 10 , adapter : Ecto.Adapters.Postgres ]","ref":"Config.html#config/3","title":"Config.config/3","type":"function"},{"doc":"Returns the environment this configuration file is executed on. In Mix projects this function returns the environment this configuration file is executed on. In releases, the environment when mix release ran. This is most often used to execute conditional code: if config_env ( ) == :prod do config :my_app , :debug , false end","ref":"Config.html#config_env/0","title":"Config.config_env/0","type":"macro"},{"doc":"Returns the target this configuration file is executed on. This is most often used to execute conditional code: if config_target ( ) == :host do config :my_app , :debug , false end","ref":"Config.html#config_target/0","title":"Config.config_target/0","type":"macro"},{"doc":"Imports configuration from the given file. In case the file doesn't exist, an error is raised. If file is a relative, it will be expanded relatively to the directory the current configuration file is in. Examples This is often used to emulate configuration across environments: import_config &quot; \#{ config_env ( ) } .exs&quot; Note, however, some configuration files, such as config/runtime.exs does not support imports, as they are meant to be copied across systems.","ref":"Config.html#import_config/1","title":"Config.import_config/1","type":"macro"},{"doc":"Specifies a provider API that loads configuration during boot. Config providers are typically used during releases to load external configuration while the system boots. This is done by starting the VM with the minimum amount of applications running, then invoking all of the providers, and then restarting the system. This requires a mutable configuration file on disk, as the results of the providers are written to the file system. For more information on runtime configuration, see mix release . Multiple config files One common use of config providers is to specify multiple configuration files in a release. Elixir ships with one provider, called Config.Reader , which is capable of handling Elixir's built-in config files. For example, imagine you want to list some basic configuration on Mix's built-in config/runtime.exs file, but you also want some additional configuration files. To do so, you can do this in your mix.exs : releases : [ demo : [ config_providers : [ { Config.Reader , { :system , &quot;RELEASE_ROOT&quot; , &quot;/extra_config.exs&quot; } } ] ] ] You can place this extra_config.exs file in your release in multiple ways: If it is available on the host when assembling the release, you can place it on &quot;rel/overlays/extra_config.exs&quot; and it will be automatically copied to the release root If it is available on the target during deployment, you can simply copy it to the release root as a step in your deployment Now once the system boots, it will load both config/runtime.exs and extra_config.exs early in the boot process. Custom config provider You can also implement custom config providers, similar to how Config.Reader works. For example, imagine you need to load some configuration from a JSON file and load that into the system. Said configuration provider would look like: defmodule JSONConfigProvider do @behaviour Config.Provider # Let&#39;s pass the path to the JSON file as config def init ( path ) when is_binary ( path ) , do : path def load ( config , path ) do # We need to start any app we may depend on. { :ok , _ } = Application . ensure_all_started ( :jason ) json = path |&gt; File . read! ( ) |&gt; Jason . decode! ( ) Config.Reader . merge ( config , my_app : [ some_value : json [ &quot;my_app_some_value&quot; ] , another_value : json [ &quot;my_app_another_value&quot; ] , ] ) end end Then, when specifying your release, you can specify the provider in the release configuration: releases : [ demo : [ config_providers : [ { JSONConfigProvider , &quot;/etc/config.json&quot; } ] ] ]","ref":"Config.Provider.html","title":"Config.Provider","type":"behaviour"},{"doc":"Invoked when initializing a config provider. A config provider is typically initialized on the machine where the system is assembled and not on the target machine. The init/1 callback is useful to verify the arguments given to the provider and prepare the state that will be given to load/2 . Furthermore, because the state returned by init/1 can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.","ref":"Config.Provider.html#c:init/1","title":"Config.Provider.init/1","type":"callback"},{"doc":"Loads configuration (typically during system boot). It receives the current config and the state returned by init/1 . Then, you typically read the extra configuration from an external source and merge it into the received config . Merging should be done with Config.Reader.merge/2 , as it performs deep merge. It should return the updated config. Note that load/2 is typically invoked very early in the boot process, therefore if you need to use an application in the provider, it is your responsibility to start it.","ref":"Config.Provider.html#c:load/2","title":"Config.Provider.load/2","type":"callback"},{"doc":"Resolves a config_path/0 to an actual path.","ref":"Config.Provider.html#resolve_config_path!/1","title":"Config.Provider.resolve_config_path!/1","type":"function"},{"doc":"Validates a config_path/0 .","ref":"Config.Provider.html#validate_config_path!/1","title":"Config.Provider.validate_config_path!/1","type":"function"},{"doc":"","ref":"Config.Provider.html#t:config/0","title":"Config.Provider.config/0","type":"type"},{"doc":"A path pointing to a configuration file. Since configuration files are often accessed on target machines, it can be expressed either as: a binary representing an absolute path a {:system, system_var, path} tuple where the config is the concatenation of the environment variable system_var with the given path","ref":"Config.Provider.html#t:config_path/0","title":"Config.Provider.config_path/0","type":"type"},{"doc":"","ref":"Config.Provider.html#t:state/0","title":"Config.Provider.state/0","type":"type"},{"doc":"API for reading config files defined with Config . As a provider Config.Reader can also be used as a Config.Provider . When used as a provider, it expects a single argument: the configuration path (as outlined in Config.Provider.config_path/0 ) for the file to be read and loaded during the system boot. For example, if you expect the target system to have a config file in an absolute path, you can configure your mix release as: config_providers : [ { Config.Reader , &quot;/etc/config.exs&quot; } ] Or if you want to read a custom path inside the release: config_providers : [ { Config.Reader , { :system , &quot;RELEASE_ROOT&quot; , &quot;/config.exs&quot; } } ] You can also pass a keyword list of options to the reader, where the :path is a required key: config_providers : [ { Config.Reader , path : &quot;/etc/config.exs&quot; , env : :prod , imports : :disabled } ] Note by default Mix releases supports runtime configuration via a config/runtime.exs . If a config/runtime.exs exists in your application, it is automatically copied inside the release and automatically set as a config provider.","ref":"Config.Reader.html","title":"Config.Reader","type":"module"},{"doc":"Evaluates the configuration contents for the given file . Accepts the same options as read!/2 .","ref":"Config.Reader.html#eval!/3","title":"Config.Reader.eval!/3","type":"function"},{"doc":"Merges two configurations. The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them. Examples iex&gt; Config.Reader . merge ( [ app : [ k : :v1 ] ] , [ app : [ k : :v2 ] ] ) [ app : [ k : :v2 ] ] iex&gt; Config.Reader . merge ( [ app : [ k : [ v1 : 1 , v2 : 2 ] ] ] , [ app : [ k : [ v2 : :a , v3 : :b ] ] ] ) [ app : [ k : [ v1 : 1 , v2 : :a , v3 : :b ] ] ] iex&gt; Config.Reader . merge ( [ app1 : [ ] ] , [ app2 : [ ] ] ) [ app1 : [ ] , app2 : [ ] ]","ref":"Config.Reader.html#merge/2","title":"Config.Reader.merge/2","type":"function"},{"doc":"Reads the configuration file. Options :imports - a list of already imported paths or :disabled to disable imports :env - the environment the configuration file runs on. See Config.config_env/0 for sample usage :target - the target the configuration file runs on. See Config.config_target/0 for sample usage","ref":"Config.Reader.html#read!/2","title":"Config.Reader.read!/2","type":"function"},{"doc":"Reads the given configuration file and returns the configuration with its imports. Accepts the same options as read!/2 . Although note the :imports option cannot be disabled in read_imports!/2 .","ref":"Config.Reader.html#read_imports!/2","title":"Config.Reader.read_imports!/2","type":"function"},{"doc":"A supervisor that starts children dynamically. The Supervisor module was designed to handle mostly static children that are started in the given order when the supervisor starts. A DynamicSupervisor starts with no children. Instead, children are started on demand via start_child/2 . When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering. Examples A dynamic supervisor is started with no children, a supervision strategy (the only strategy currently supported is :one_for_one ), and a name: children = [ { DynamicSupervisor , strategy : :one_for_one , name : MyApp.DynamicSupervisor } ] Supervisor . start_link ( children , strategy : :one_for_one ) The options given in the child specification are documented in start_link/1 . Once the dynamic supervisor is running, we can start children with start_child/2 , which receives a child specification: { :ok , agent1 } = DynamicSupervisor . start_child ( MyApp.DynamicSupervisor , { Agent , fn -&gt; %{ } end } ) Agent . update ( agent1 , &amp; Map . put ( &amp;1 , :key , &quot;value&quot; ) ) Agent . get ( agent1 , &amp; &amp;1 ) #=&gt; %{key: &quot;value&quot;} { :ok , agent2 } = DynamicSupervisor . start_child ( MyApp.DynamicSupervisor , { Agent , fn -&gt; %{ } end } ) Agent . get ( agent2 , &amp; &amp;1 ) #=&gt; %{} DynamicSupervisor . count_children ( MyApp.DynamicSupervisor ) #=&gt; %{active: 2, specs: 2, supervisors: 0, workers: 2} Module-based supervisors Similar to Supervisor , dynamic supervisors also support module-based supervisors. defmodule MyApp.DynamicSupervisor do # Automatically defines child_spec/1 use DynamicSupervisor def start_link ( init_arg ) do DynamicSupervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end @impl true def init ( _init_arg ) do DynamicSupervisor . init ( strategy : :one_for_one ) end end See the Supervisor docs for a discussion of when you may want to use module-based supervisors. A @doc annotation immediately preceding use DynamicSupervisor will be attached to the generated child_spec/1 function. Name registration A supervisor is bound to the same name registration rules as a GenServer . Read more about these rules in the documentation for GenServer . Migrating from Supervisor's :simple_one_for_one In case you were using the deprecated :simple_one_for_one strategy from the Supervisor module, you can migrate to the DynamicSupervisor in few steps. Imagine the given &quot;old&quot; code: defmodule MySupervisor do use Supervisor def start_link ( init_arg ) do Supervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end def start_child ( foo , bar , baz ) do # This will start child by calling MyWorker.start_link(init_arg, foo, bar, baz) Supervisor . start_child ( __MODULE__ , [ foo , bar , baz ] ) end @impl true def init ( init_arg ) do children = [ # Or the deprecated: worker(MyWorker, [init_arg]) %{ id : MyWorker , start : { MyWorker , :start_link , [ init_arg ] } } ] Supervisor . init ( children , strategy : :simple_one_for_one ) end end It can be upgraded to the DynamicSupervisor like this: defmodule MySupervisor do use DynamicSupervisor def start_link ( init_arg ) do DynamicSupervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end def start_child ( foo , bar , baz ) do # If MyWorker is not using the new child specs, we need to pass a map: # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}} spec = { MyWorker , foo : foo , bar : bar , baz : baz } DynamicSupervisor . start_child ( __MODULE__ , spec ) end @impl true def init ( init_arg ) do DynamicSupervisor . init ( strategy : :one_for_one , extra_arguments : [ init_arg ] ) end end The difference is that the DynamicSupervisor expects the child specification at the moment start_child/2 is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as [initial_arg] , it can be given in the :extra_arguments flag on DynamicSupervisor.init/1 .","ref":"DynamicSupervisor.html","title":"DynamicSupervisor","type":"behaviour"},{"doc":"Returns a specification to start a dynamic supervisor under a supervisor. See Supervisor .","ref":"DynamicSupervisor.html#child_spec/1","title":"DynamicSupervisor.child_spec/1","type":"function"},{"doc":"Returns a map containing count values for the supervisor. The map contains the following keys: :specs - the number of children processes :active - the count of all actively running child processes managed by this supervisor :supervisors - the count of all supervisors whether or not the child process is still alive :workers - the count of all workers, whether or not the child process is still alive","ref":"DynamicSupervisor.html#count_children/1","title":"DynamicSupervisor.count_children/1","type":"function"},{"doc":"Receives a set of options that initializes a dynamic supervisor. This is typically invoked at the end of the init/1 callback of module-based supervisors. See the &quot;Module-based supervisors&quot; section in the module documentation for more information. The options received by this function are also supported by start_link/1 . This function returns a tuple containing the supervisor options. Examples def init ( _arg ) do DynamicSupervisor . init ( max_children : 1000 , strategy : :one_for_one ) end Options :strategy - the restart strategy option. The only supported value is :one_for_one which means that no other child is terminated if a child process terminates. You can learn more about strategies in the Supervisor module docs. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . :max_children - the maximum amount of children to be running under this supervisor at the same time. When :max_children is exceeded, start_child/2 returns {:error, :max_children} . Defaults to :infinity . :extra_arguments - arguments that are prepended to the arguments specified in the child spec given to start_child/2 . Defaults to an empty list.","ref":"DynamicSupervisor.html#init/1","title":"DynamicSupervisor.init/1","type":"function"},{"doc":"Callback invoked to start the supervisor and during hot code upgrades. Developers typically invoke DynamicSupervisor.init/1 at the end of their init callback to return the proper supervision flags.","ref":"DynamicSupervisor.html#c:init/1","title":"DynamicSupervisor.init/1","type":"callback"},{"doc":"Dynamically adds a child specification to supervisor and starts that child. child_spec should be a valid child specification as detailed in the &quot;Child specification&quot; section of the documentation for Supervisor . The child process will be started as defined in the child specification. If the child process start function returns {:ok, child} or {:ok, child, info} , then child specification and PID are added to the supervisor and this function returns the same value. If the child process start function returns :ignore , then no child is added to the supervision tree and this function returns :ignore too. If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns {:error, error} where error is the error or erroneous value returned from child process start function, or failure reason if it fails. If the supervisor already has N children in a way that N exceeds the amount of :max_children set on the supervisor initialization (see init/1 ), then this function returns {:error, :max_children} .","ref":"DynamicSupervisor.html#start_child/2","title":"DynamicSupervisor.start_child/2","type":"function"},{"doc":"Starts a supervisor with the given options. The :strategy is a required option and the currently supported value is :one_for_one . The remaining options can be found in the init/1 docs. The :name option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the GenServer module docs. If the supervisor is successfully spawned, this function returns {:ok, pid} , where pid is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns {:error, {:already_started, pid}} , where pid is the PID of that process. Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with :normal reason.","ref":"DynamicSupervisor.html#start_link/1","title":"DynamicSupervisor.start_link/1","type":"function"},{"doc":"Starts a module-based supervisor process with the given module and arg . To start the supervisor, the init/1 callback will be invoked in the given module , with arg as its argument. The init/1 callback must return a supervisor specification which can be created with the help of the init/1 function. If the init/1 callback returns :ignore , this function returns :ignore as well and the supervisor terminates with reason :normal . If it fails or returns an incorrect value, this function returns {:error, term} where term is a term with information about the error, and the supervisor terminates with reason term . The :name option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the GenServer module docs.","ref":"DynamicSupervisor.html#start_link/3","title":"DynamicSupervisor.start_link/3","type":"function"},{"doc":"Synchronously stops the given supervisor with the given reason . It returns :ok if the supervisor terminates with the given reason. If it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"DynamicSupervisor.html#stop/3","title":"DynamicSupervisor.stop/3","type":"function"},{"doc":"Terminates the given child identified by pid . If successful, this function returns :ok . If there is no process with the given PID, this function returns {:error, :not_found} .","ref":"DynamicSupervisor.html#terminate_child/2","title":"DynamicSupervisor.terminate_child/2","type":"function"},{"doc":"Returns a list with information about all children. Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception. This function returns a list of tuples containing: id - it is always :undefined for dynamic supervisors child - the PID of the corresponding child process or the atom :restarting if the process is about to be restarted type - :worker or :supervisor as defined in the child specification modules - as defined in the child specification","ref":"DynamicSupervisor.html#which_children/1","title":"DynamicSupervisor.which_children/1","type":"function"},{"doc":"Options given to start_link and init/1 functions","ref":"DynamicSupervisor.html#t:init_option/0","title":"DynamicSupervisor.init_option/0","type":"type"},{"doc":"Return values of start_child functions","ref":"DynamicSupervisor.html#t:on_start_child/0","title":"DynamicSupervisor.on_start_child/0","type":"type"},{"doc":"Options given to start_link functions","ref":"DynamicSupervisor.html#t:option/0","title":"DynamicSupervisor.option/0","type":"type"},{"doc":"Supported strategies","ref":"DynamicSupervisor.html#t:strategy/0","title":"DynamicSupervisor.strategy/0","type":"type"},{"doc":"The supervisor flags returned on init","ref":"DynamicSupervisor.html#t:sup_flags/0","title":"DynamicSupervisor.sup_flags/0","type":"type"},{"doc":"A behaviour module for implementing the server of a client-server relation. A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree. Example The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in. Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements: defmodule Stack do use GenServer # Callbacks @impl true def init ( stack ) do { :ok , stack } end @impl true def handle_call ( :pop , _from , [ head | tail ] ) do { :reply , head , tail } end @impl true def handle_cast ( { :push , element } , state ) do { :noreply , [ element | state ] } end end # Start the server { :ok , pid } = GenServer . start_link ( Stack , [ :hello ] ) # This is the client GenServer . call ( pid , :pop ) #=&gt; :hello GenServer . cast ( pid , { :push , :world } ) #=&gt; :ok GenServer . call ( pid , :pop ) #=&gt; :world We start our Stack by calling start_link/2 , passing the module with the server implementation and its initial argument (a list representing the stack containing the element :hello ). We can primarily interact with the server by sending two types of messages. call messages expect a reply from the server (and are therefore synchronous) while cast messages do not. Every time you do a GenServer.call/3 , the client will send a message that must be handled by the handle_call/3 callback in the GenServer. A cast/2 message must be handled by handle_cast/2 . There are 8 possible callbacks to be implemented when you use a GenServer . The only required callback is init/1 . Client / Server APIs Although in the example above we have used GenServer.start_link/3 and friends to directly start and communicate with the server, most of the time we don't call the GenServer functions directly. Instead, we wrap the calls in new functions representing the public API of the server. Here is a better implementation of our Stack module: defmodule Stack do use GenServer # Client def start_link ( default ) when is_list ( default ) do GenServer . start_link ( __MODULE__ , default ) end def push ( pid , element ) do GenServer . cast ( pid , { :push , element } ) end def pop ( pid ) do GenServer . call ( pid , :pop ) end # Server (callbacks) @impl true def init ( stack ) do { :ok , stack } end @impl true def handle_call ( :pop , _from , [ head | tail ] ) do { :reply , head , tail } end @impl true def handle_cast ( { :push , element } , state ) do { :noreply , [ element | state ] } end end In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules. How to supervise A GenServer is most commonly started under a supervision tree. When we invoke use GenServer , it automatically defines a child_spec/1 function that allows us to start the Stack directly under a supervisor. To start a default stack of [:hello] under a supervisor, one may do: children = [ { Stack , [ :hello ] } ] Supervisor . start_link ( children , strategy : :one_for_all ) Note you can also start it simply as Stack , which is the same as {Stack, []} : children = [ Stack # The same as {Stack, []} ] Supervisor . start_link ( children , strategy : :one_for_all ) In both cases, Stack.start_link/1 is always invoked. use GenServer also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated child_spec/1 can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the child should be restarted, defaults to :permanent :shutdown - how to shut down the child, either immediately or by giving it time to shut down For example: use GenServer , restart : :transient , shutdown : 10_000 See the &quot;Child specification&quot; section in the Supervisor module for more detailed information. The @doc annotation immediately preceding use GenServer will be attached to the generated child_spec/1 function. Name registration Both start_link/3 and start/3 support the GenServer to register a name on start via the :name option. Registered names are also automatically cleaned up on termination. The supported values are: an atom - the GenServer is registered locally with the given name using Process.register/2 . {:global, term} - the GenServer is registered globally with the given term using the functions in the :global module . {:via, module, term} - the GenServer is registered with the given mechanism and name. The :via option expects a module that exports register_name/2 , unregister_name/1 , whereis_name/1 and send/2 . One such example is the :global module which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called Registry for locally storing names that are generated dynamically. For example, we could start and register our Stack server locally as follows: # Start the server and register it locally with name MyStack { :ok , _ } = GenServer . start_link ( Stack , [ :hello ] , name : MyStack ) # Now messages can be sent directly to MyStack GenServer . call ( MyStack , :pop ) #=&gt; :hello Once the server is started, the remaining functions in this module ( call/3 , cast/2 , and friends) will also accept an atom, or any {:global, ...} or {:via, ...} tuples. In general, the following formats are supported: a PID an atom if the server is locally registered {atom, node} if the server is locally registered at another node {:global, term} if the server is globally registered {:via, module, name} if the server is registered through an alternative registry If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the Registry module. Receiving &quot;regular&quot; messages The goal of a GenServer is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave. Besides the synchronous and asynchronous communication provided by call/3 and cast/2 , &quot;regular&quot; messages sent by functions such as Kernel.send/2 , Process.send_after/4 and similar, can be handled inside the handle_info/2 callback. handle_info/2 can be used in many situations, such as handling monitor DOWN messages sent by Process.monitor/1 . Another use case for handle_info/2 is to perform periodic work, with the help of Process.send_after/4 : defmodule MyApp.Periodically do use GenServer def start_link ( _ ) do GenServer . start_link ( __MODULE__ , %{ } ) end @impl true def init ( state ) do # Schedule work to be performed on start schedule_work ( ) { :ok , state } end @impl true def handle_info ( :work , state ) do # Do the desired work here # ... # Reschedule once more schedule_work ( ) { :noreply , state } end defp schedule_work do # We schedule the work to happen in 2 hours (written in milliseconds). # Alternatively, one might write :timer.hours(2) Process . send_after ( self ( ) , :work , 2 * 60 * 60 * 1000 ) end end Timeouts The return value of init/1 or any of the handle_* callbacks may include a timeout value in milliseconds; if not, :infinity is assumed. The timeout can be used to detect a lull in incoming messages. If the process has no messages waiting when the timeout is set and the number of given milliseconds pass without any message arriving, then handle_info/2 will be called with :timeout as the first argument. The timeout is cleared if any message is waiting or arrives before the given timeout. Because a message may arrive before the timeout is set, even a timeout of 0 milliseconds is not guaranteed to execute. To take another action immediately and unconditionally, use a :continue instruction. When (not) to use a GenServer So far, we have learned that a GenServer can be used as a supervised process that handles sync and async calls. It can also handle system messages, such as periodic messages and monitoring events. GenServer processes may also be named. A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes. In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer: def add ( a , b ) do GenServer . call ( __MODULE__ , { :add , a , b } ) end def subtract ( a , b ) do GenServer . call ( __MODULE__ , { :subtract , a , b } ) end def handle_call ( { :add , a , b } , _from , state ) do { :reply , a + b , state } end def handle_call ( { :subtract , a , b } , _from , state ) do { :reply , a - b , state } end This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly: def add ( a , b ) do a + b end def subtract ( a , b ) do a - b end If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization. Debugging with the :sys module GenServers, as special processes , can be debugged using the :sys module . Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes. Let's explore the basic functions from the :sys module used for debugging: :sys.get_state/2 - allows retrieval of the state of the process. In the case of a GenServer process, it will be the callback module state, as passed into the callback functions as last argument. :sys.get_status/2 - allows retrieval of the status of the process. This status includes the process dictionary, if the process is running or is suspended, the parent PID, the debugger state, and the state of the behaviour module, which includes the callback module state (as returned by :sys.get_state/2 ). It's possible to change how this status is represented by defining the optional GenServer.format_status/2 callback. :sys.trace/3 - prints all the system events to :stdio . :sys.statistics/3 - manages collection of process statistics. :sys.no_debug/2 - turns off all debug handlers for the given process. It is very important to switch off debugging once we're done. Excessive debug handlers or those that should be turned off, but weren't, can seriously damage the performance of the system. :sys.suspend/2 - allows to suspend a process so that it only replies to system messages but no other messages. A suspended process can be reactivated via :sys.resume/2 . Let's see how we could use those functions for debugging the stack server we defined earlier. iex&gt; { :ok , pid } = Stack . start_link ( [ ] ) iex&gt; :sys . statistics ( pid , true ) # turn on collecting process statistics iex&gt; :sys . trace ( pid , true ) # turn on event printing iex&gt; Stack . push ( pid , 1 ) * DBG * &lt; 0.122 . 0 &gt; got cast { push , 1 } * DBG * &lt; 0.122 . 0 &gt; new state [ 1 ] :ok iex&gt; :sys . get_state ( pid ) [ 1 ] iex&gt; Stack . pop ( pid ) * DBG * &lt; 0.122 . 0 &gt; got call pop from &lt; 0.80 . 0 &gt; * DBG * &lt; 0.122 . 0 &gt; sent 1 to &lt; 0.80 . 0 &gt; , new state [ ] 1 iex&gt; :sys . statistics ( pid , :get ) { :ok , [ start_time : { { 2016 , 7 , 16 } , { 12 , 29 , 41 } } , current_time : { { 2016 , 7 , 16 } , { 12 , 29 , 50 } } , reductions : 117 , messages_in : 2 , messages_out : 0 ] } iex&gt; :sys . no_debug ( pid ) # turn off all debug handlers :ok iex&gt; :sys . get_status ( pid ) { :status , # PID &lt; 0 . 122 . 0 &gt; , { :module , :gen_server } , [ [ &quot;$initial_call&quot; : { Stack , :init , 1 } , # process dictionary &quot;$ancestors&quot; : [ # PID &lt; 0 . 80 . 0 &gt; , # PID &lt; 0 . 51 . 0 &gt; ] ] , :running , # :running | :suspended # PID &lt; 0 . 80 . 0 &gt; , # parent [ ] , # debugger state [ header : &#39;Status for generic server &lt;0.122.0&gt;&#39; , # module status data : [ { &#39;Status&#39; , :running } , { &#39;Parent&#39; , # PID &lt; 0 . 80 . 0 &gt; } , { &#39;Logged events&#39; , [ ] } ] , data : [ { &#39;State&#39; , [ 1 ] } ] ] ] } Learn more If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight. GenServer - Elixir's Getting Started Guide :gen_server module documentation gen_server Behaviour - OTP Design Principles Clients and Servers - Learn You Some Erlang for Great Good!","ref":"GenServer.html","title":"GenServer","type":"behaviour"},{"doc":"Casts all servers locally registered as name at the specified nodes. This function returns immediately and ignores nodes that do not exist, or where the server name does not exist. See multi_call/4 for more information.","ref":"GenServer.html#abcast/3","title":"GenServer.abcast/3","type":"function"},{"doc":"Makes a synchronous call to the server and waits for its reply. The client sends the given request to the server and waits until a reply arrives or a timeout occurs. handle_call/3 will be called on the server to handle the request. server can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module. Timeouts timeout is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom :infinity to wait indefinitely. The default value is 5000 . If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.","ref":"GenServer.html#call/3","title":"GenServer.call/3","type":"function"},{"doc":"Sends an asynchronous request to the server . This function always returns :ok regardless of whether the destination server (or node) exists. Therefore it is unknown whether the destination server successfully handled the message. handle_cast/2 will be called on the server to handle the request. In case the server is on a node which is not yet connected to the caller one, the semantics differ depending on the used Erlang/OTP version. server can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module. Before Erlang/OTP 21, the call is going to block until a connection happens. This was done to guarantee ordering. Starting with Erlang/OTP 21, both Erlang and Elixir do not block the call.","ref":"GenServer.html#cast/2","title":"GenServer.cast/2","type":"function"},{"doc":"Invoked to change the state of the GenServer when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed. old_vsn is the previous version of the module (defined by the @vsn attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element :down . state is the current state of the GenServer and extra is any extra data required to change the state. Returning {:ok, new_state} changes the state to new_state and the code change is successful. Returning {:error, reason} fails the code change with reason reason and the state remains as the previous state. If code_change/3 raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects. This callback is optional.","ref":"GenServer.html#c:code_change/3","title":"GenServer.code_change/3","type":"callback"},{"doc":"Invoked in some cases to retrieve a formatted version of the GenServer status. This callback can be useful to control the appearance of the status of the GenServer . For example, it can be used to return a compact representation of the GenServer 's state to avoid having large state terms printed. one of :sys.get_status/1 or :sys.get_status/2 is invoked to get the status of the GenServer ; in such cases, reason is :normal the GenServer terminates abnormally and logs an error; in such cases, reason is :terminate pdict_and_state is a two-elements list [pdict, state] where pdict is a list of {key, value} tuples representing the current process dictionary of the GenServer and state is the current state of the GenServer .","ref":"GenServer.html#c:format_status/2","title":"GenServer.format_status/2","type":"callback"},{"doc":"Invoked to handle synchronous call/3 messages. call/3 will block until a reply is received (unless the call times out or nodes are disconnected). request is the request message sent by a call/3 , from is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and state is the current state of the GenServer . Returning {:reply, reply, new_state} sends the response reply to the caller and continues the loop with new state new_state . Returning {:reply, reply, new_state, timeout} is similar to {:reply, reply, new_state} except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information. Returning {:reply, reply, new_state, :hibernate} is similar to {:reply, reply, new_state} except the process is hibernated and will continue the loop once a message is in its message queue. However, if a message is already in the message queue, the process will continue the loop immediately. Hibernating a GenServer causes garbage collection and leaves a continuous heap that minimises the memory used by the process. Returning {:reply, reply, new_state, {:continue, continue}} is similar to {:reply, reply, new_state} except handle_continue/2 will be invoked immediately after with the value continue as first argument. Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial. Returning {:noreply, new_state} does not send a response to the caller and continues the loop with new state new_state . The response must be sent with reply/2 . There are three main use cases for not replying using the return value: To reply before returning from the callback because the response is known before calling a slow function. To reply after returning from the callback because the response is not yet available. To reply from another process, such as a task. When replying from another process the GenServer should exit if the other process exits without replying as the caller will be blocking awaiting a reply. Returning {:noreply, new_state, timeout | :hibernate | {:continue, continue}} is similar to {:noreply, new_state} except a timeout, hibernation or continue occurs as with a :reply tuple. Returning {:stop, reason, reply, new_state} stops the loop and terminate/2 is called with reason reason and state new_state . Then, the reply is sent as the response to call and the process exits with reason reason . Returning {:stop, reason, new_state} is similar to {:stop, reason, reply, new_state} except a reply is not sent. This callback is optional. If one is not implemented, the server will fail if a call is performed against it.","ref":"GenServer.html#c:handle_call/3","title":"GenServer.handle_call/3","type":"callback"},{"doc":"Invoked to handle asynchronous cast/2 messages. request is the request message sent by a cast/2 and state is the current state of the GenServer . Returning {:noreply, new_state} continues the loop with new state new_state . Returning {:noreply, new_state, timeout} is similar to {:noreply, new_state} except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information. Returning {:noreply, new_state, :hibernate} is similar to {:noreply, new_state} except the process is hibernated before continuing the loop. See handle_call/3 for more information. Returning {:noreply, new_state, {:continue, continue}} is similar to {:noreply, new_state} except handle_continue/2 will be invoked immediately after with the value continue as first argument. Returning {:stop, reason, new_state} stops the loop and terminate/2 is called with the reason reason and state new_state . The process exits with reason reason . This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.","ref":"GenServer.html#c:handle_cast/2","title":"GenServer.handle_cast/2","type":"callback"},{"doc":"Invoked to handle continue instructions. It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way. Return values are the same as handle_cast/2 . This callback is optional. If one is not implemented, the server will fail if a continue instruction is used. This callback is only supported on Erlang/OTP 21+.","ref":"GenServer.html#c:handle_continue/2","title":"GenServer.handle_continue/2","type":"callback"},{"doc":"Invoked to handle all other messages. msg is the message and state is the current state of the GenServer . When a timeout occurs the message is :timeout . Return values are the same as handle_cast/2 . This callback is optional. If one is not implemented, the received message will be logged.","ref":"GenServer.html#c:handle_info/2","title":"GenServer.handle_info/2","type":"callback"},{"doc":"Invoked when the server is started. start_link/3 or start/3 will block until it returns. init_arg is the argument term (second argument) passed to start_link/3 . Returning {:ok, state} will cause start_link/3 to return {:ok, pid} and the process to enter its loop. Returning {:ok, state, timeout} is similar to {:ok, state} , except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information. Returning {:ok, state, :hibernate} is similar to {:ok, state} except the process is hibernated before entering the loop. See handle_call/3 for more information on hibernation. Returning {:ok, state, {:continue, continue}} is similar to {:ok, state} except that immediately after entering the loop, the handle_continue/2 callback will be invoked with the value continue as first argument. Returning :ignore will cause start_link/3 to return :ignore and the process will exit normally without entering the loop or calling terminate/2 . If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the GenServer . The remainder of the supervision tree will be started and so the GenServer should not be required by other processes. It can be started later with Supervisor.restart_child/2 as the child specification is saved in the parent supervisor. The main use cases for this are: The GenServer is disabled by configuration but might be enabled later. An error occurred and it will be handled by a different mechanism than the Supervisor . Likely this approach involves calling Supervisor.restart_child/2 after a delay to attempt a restart. Returning {:stop, reason} will cause start_link/3 to return {:error, reason} and the process to exit with reason reason without entering the loop or calling terminate/2 .","ref":"GenServer.html#c:init/1","title":"GenServer.init/1","type":"callback"},{"doc":"Calls all servers locally registered as name at the specified nodes . First, the request is sent to every node in nodes ; then, the caller waits for the replies. This function returns a two-element tuple {replies, bad_nodes} where: replies - is a list of {node, reply} tuples where node is the node that replied and reply is its reply bad_nodes - is a list of nodes that either did not exist or where a server with the given name did not exist or did not reply nodes is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node). To avoid that late answers (after the timeout) pollute the caller's message queue, a middleman process is used to do the actual calls. Late answers will then be discarded when they arrive to a terminated process. Examples Assuming the Stack GenServer mentioned in the docs for the GenServer module is registered as Stack in the :&quot;foo@my-machine&quot; and :&quot;bar@my-machine&quot; nodes: GenServer . multi_call ( Stack , :pop ) #=&gt; {[{:&quot;foo@my-machine&quot;, :hello}, {:&quot;bar@my-machine&quot;, :world}], []}","ref":"GenServer.html#multi_call/4","title":"GenServer.multi_call/4","type":"function"},{"doc":"Replies to a client. This function can be used to explicitly send a reply to a client that called call/3 or multi_call/4 when the reply cannot be specified in the return value of handle_call/3 . client must be the from argument (the second argument) accepted by handle_call/3 callbacks. reply is an arbitrary term which will be given back to the client as the return value of the call. Note that reply/2 can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the from argument somehow). This function always returns :ok . Examples def handle_call ( :reply_in_one_second , from , state ) do Process . send_after ( self ( ) , { :reply , from } , 1_000 ) { :noreply , state } end def handle_info ( { :reply , from } , state ) do GenServer . reply ( from , :one_second_has_passed ) { :noreply , state } end","ref":"GenServer.html#reply/2","title":"GenServer.reply/2","type":"function"},{"doc":"Starts a GenServer process without links (outside of a supervision tree). See start_link/3 for more information.","ref":"GenServer.html#start/3","title":"GenServer.start/3","type":"function"},{"doc":"Starts a GenServer process linked to the current process. This is often used to start the GenServer as part of a supervision tree. Once the server is started, the init/1 function of the given module is called with init_arg as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until init/1 has returned. Note that a GenServer started with start_link/3 is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the :normal reasons in case it is configured to trap exits in the init/1 callback. Options :name - used for name registration as described in the &quot;Name registration&quot; section in the documentation for GenServer :timeout - if present, the server is allowed to spend the given number of milliseconds initializing or it will be terminated and the start function will return {:error, :timeout} :debug - if present, the corresponding function in the :sys module is invoked :spawn_opt - if present, its value is passed as options to the underlying process as in Process.spawn/4 :hibernate_after - if present, the GenServer process awaits any message for the given number of milliseconds and if no message is received, the process goes into hibernation automatically (by calling :proc_lib.hibernate/3 ). Return values If the server is successfully created and initialized, this function returns {:ok, pid} , where pid is the PID of the server. If a process with the specified server name already exists, this function returns {:error, {:already_started, pid}} with the PID of that process. If the init/1 callback fails with reason , this function returns {:error, reason} . Otherwise, if it returns {:stop, reason} or :ignore , the process is terminated and this function returns {:error, reason} or :ignore , respectively.","ref":"GenServer.html#start_link/3","title":"GenServer.start_link/3","type":"function"},{"doc":"Synchronously stops the server with the given reason . The terminate/2 callback of the given server will be invoked before exiting. This function returns :ok if the server terminates with the given reason; if it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"GenServer.html#stop/3","title":"GenServer.stop/3","type":"function"},{"doc":"Invoked when the server is about to exit. It should do any cleanup required. reason is exit reason and state is the current state of the GenServer . The return value is ignored. terminate/2 is called if the GenServer traps exits (using Process.flag/2 ) and the parent process sends an exit signal, or a callback (except init/1 ) does one of the following: returns a :stop tuple raises (via Kernel.raise/2 ) or exits (via Kernel.exit/1 ) returns an invalid value If part of a supervision tree, a GenServer will receive an exit signal when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be: :brutal_kill : the GenServer is killed and so terminate/2 is not called. a timeout value, where the supervisor will send the exit signal :shutdown and the GenServer will have the duration of the timeout to terminate. If after duration of this timeout the process is still alive, it will be killed immediately. For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the Supervisor module. If the GenServer receives an exit signal (that is not :normal ) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call terminate/2 . Note that a process does NOT trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected. Therefore it is not guaranteed that terminate/2 is called when a GenServer exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the GenServer controls a port (for example, :gen_tcp.socket ) or File.io_device/0 , because these will be closed on receiving a GenServer 's exit signal and do not need to be closed manually in terminate/2 . If reason is neither :normal , :shutdown , nor {:shutdown, term} an error is logged. This callback is optional.","ref":"GenServer.html#c:terminate/2","title":"GenServer.terminate/2","type":"callback"},{"doc":"Returns the pid or {name, node} of a GenServer process, nil otherwise. To be precise, nil is returned whenever a pid or {name, node} cannot be returned. Note there is no guarantee the returned pid or {name, node} is alive, as a process could terminate immediately after it is looked up. Examples For example, to lookup a server process, monitor it and send a cast to it: process = GenServer . whereis ( server ) monitor = Process . monitor ( process ) GenServer . cast ( process , :hello )","ref":"GenServer.html#whereis/1","title":"GenServer.whereis/1","type":"function"},{"doc":"Debug options supported by the start* functions","ref":"GenServer.html#t:debug/0","title":"GenServer.debug/0","type":"type"},{"doc":"Tuple describing the client of a call request. pid is the PID of the caller and tag is a unique term used to identify the call.","ref":"GenServer.html#t:from/0","title":"GenServer.from/0","type":"type"},{"doc":"The GenServer name","ref":"GenServer.html#t:name/0","title":"GenServer.name/0","type":"type"},{"doc":"Return values of start* functions","ref":"GenServer.html#t:on_start/0","title":"GenServer.on_start/0","type":"type"},{"doc":"Option values used by the start* functions","ref":"GenServer.html#t:option/0","title":"GenServer.option/0","type":"type"},{"doc":"Options used by the start* functions","ref":"GenServer.html#t:options/0","title":"GenServer.options/0","type":"type"},{"doc":"The server reference. This is either a plain PID or a value representing a registered name. See the &quot;Name registration&quot; section of this document for more information.","ref":"GenServer.html#t:server/0","title":"GenServer.server/0","type":"type"},{"doc":"Functions related to VM nodes. Some of the functions in this module are inlined by the compiler, similar to functions in the Kernel module and they are explicitly marked in their docs as &quot;inlined by the compiler&quot;. For more information about inlined functions, check out the Kernel module.","ref":"Node.html","title":"Node","type":"module"},{"doc":"Returns true if the local node is alive. That is, if the node can be part of a distributed system.","ref":"Node.html#alive?/0","title":"Node.alive?/0","type":"function"},{"doc":"Establishes a connection to node . Returns true if successful, false if not, and the atom :ignored if the local node is not alive. For more information, see :net_kernel.connect_node/1 .","ref":"Node.html#connect/1","title":"Node.connect/1","type":"function"},{"doc":"Forces the disconnection of a node. This will appear to the node as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns true if disconnection succeeds, otherwise false . If the local node is not alive, the function returns :ignored . For more information, see :erlang.disconnect_node/1 .","ref":"Node.html#disconnect/1","title":"Node.disconnect/1","type":"function"},{"doc":"Returns the magic cookie of the local node. Returns the cookie if the node is alive, otherwise :nocookie .","ref":"Node.html#get_cookie/0","title":"Node.get_cookie/0","type":"function"},{"doc":"Returns a list of all visible nodes in the system, excluding the local node. Same as list(:visible) . Inlined by the compiler.","ref":"Node.html#list/0","title":"Node.list/0","type":"function"},{"doc":"Returns a list of nodes according to argument given. The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements. For more information, see :erlang.nodes/1 . Inlined by the compiler.","ref":"Node.html#list/1","title":"Node.list/1","type":"function"},{"doc":"Monitors the status of the node. If flag is true , monitoring is turned on. If flag is false , monitoring is turned off. For more information, see :erlang.monitor_node/2 . For monitoring status changes of all nodes, see :net_kernel.monitor_nodes/2 .","ref":"Node.html#monitor/2","title":"Node.monitor/2","type":"function"},{"doc":"Behaves as monitor/2 except that it allows an extra option to be given, namely :allow_passive_connect . For more information, see :erlang.monitor_node/3 . For monitoring status changes of all nodes, see :net_kernel.monitor_nodes/2 .","ref":"Node.html#monitor/3","title":"Node.monitor/3","type":"function"},{"doc":"Tries to set up a connection to node. Returns :pang if it fails, or :pong if it is successful. Examples iex&gt; Node . ping ( :unknown_node ) :pang","ref":"Node.html#ping/1","title":"Node.ping/1","type":"function"},{"doc":"Returns the current node. It returns the same as the built-in node() .","ref":"Node.html#self/0","title":"Node.self/0","type":"function"},{"doc":"Sets the magic cookie of node to the atom cookie . The default node is Node.self/0 , the local node. If node is the local node, the function also sets the cookie of all other unknown nodes to cookie . This function will raise FunctionClauseError if the given node is not alive.","ref":"Node.html#set_cookie/2","title":"Node.set_cookie/2","type":"function"},{"doc":"Returns the PID of a new process started by the application of fun on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn/2 . Inlined by the compiler.","ref":"Node.html#spawn/2","title":"Node.spawn/2","type":"function"},{"doc":"Returns the PID of a new process started by the application of fun on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn_opt/3 . Inlined by the compiler.","ref":"Node.html#spawn/3","title":"Node.spawn/3","type":"function"},{"doc":"Returns the PID of a new process started by the application of module.function(args) on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn/4 . Inlined by the compiler.","ref":"Node.html#spawn/4","title":"Node.spawn/4","type":"function"},{"doc":"Returns the PID of a new process started by the application of module.function(args) on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn/4 . Inlined by the compiler.","ref":"Node.html#spawn/5","title":"Node.spawn/5","type":"function"},{"doc":"Returns the PID of a new linked process started by the application of fun on node . A link is created between the calling process and the new process, atomically. If node does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason :noconnection will be received). Inlined by the compiler.","ref":"Node.html#spawn_link/2","title":"Node.spawn_link/2","type":"function"},{"doc":"Returns the PID of a new linked process started by the application of module.function(args) on node . A link is created between the calling process and the new process, atomically. If node does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason :noconnection will be received). Inlined by the compiler.","ref":"Node.html#spawn_link/4","title":"Node.spawn_link/4","type":"function"},{"doc":"Turns a non-distributed node into a distributed node. This functionality starts the :net_kernel and other related processes. This function is rarely invoked in practice. Instead, nodes are named and started via the command line by using the --sname and --name flags. If you need to use this function to dynamically name a node, please make sure the epmd operating system process is running by calling epmd -daemon . Invoking this function when the distribution has already been started, either via the command line interface or dynamically, will return an error. Examples { :ok , pid } = Node . start ( :example , :shortnames , 15000 )","ref":"Node.html#start/3","title":"Node.start/3","type":"function"},{"doc":"Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the node was started with Node.start/3 , otherwise returns {:error, :not_allowed} . Returns {:error, :not_found} if the local node is not alive.","ref":"Node.html#stop/0","title":"Node.stop/0","type":"function"},{"doc":"","ref":"Node.html#t:state/0","title":"Node.state/0","type":"type"},{"doc":"","ref":"Node.html#t:t/0","title":"Node.t/0","type":"type"},{"doc":"Conveniences for working with processes and the process dictionary. Besides the functions available in this module, the Kernel module exposes and auto-imports some basic functionality related to processes available through the following functions: Kernel.spawn/1 and Kernel.spawn/3 Kernel.spawn_link/1 and Kernel.spawn_link/3 Kernel.spawn_monitor/1 and Kernel.spawn_monitor/3 Kernel.self/0 Kernel.send/2 While this module provides low-level conveniences to work with processes, developers typically use abstractions such as Agent , GenServer , Registry , Supervisor and Task for building their systems and resort to this module for gathering information, trapping exits, links and monitoring.","ref":"Process.html","title":"Process","type":"module"},{"doc":"Tells whether the given process is alive on the local node. If the process identified by pid is alive (that is, it's not exiting and has not exited yet) than this function returns true . Otherwise, it returns false . pid must refer to a process running on the local node or ArgumentError is raised. Inlined by the compiler.","ref":"Process.html#alive?/1","title":"Process.alive?/1","type":"function"},{"doc":"Cancels a timer returned by send_after/3 . When the result is an integer, it represents the time in milliseconds left until the timer would have expired. When the result is false , a timer corresponding to timer_ref could not be found. This can happen either because the timer expired, because it has already been canceled, or because timer_ref never corresponded to a timer. Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet. Inlined by the compiler. Options :async - (boolean) when false , the request for cancellation is synchronous. When true , the request for cancellation is asynchronous, meaning that the request to cancel the timer is issued and :ok is returned right away. Defaults to false . :info - (boolean) whether to return information about the timer being cancelled. When the :async option is false and :info is true , then either an integer or false (like described above) is returned. If :async is false and :info is false , :ok is returned. If :async is true and :info is true , a message in the form {:cancel_timer, timer_ref, result} (where result is an integer or false like described above) is sent to the caller of this function when the cancellation has been performed. If :async is true and :info is false , no message is sent. Defaults to true .","ref":"Process.html#cancel_timer/2","title":"Process.cancel_timer/2","type":"function"},{"doc":"Deletes the given key from the process dictionary. Returns the value that was under key in the process dictionary, or nil if key was not stored in the process dictionary. Examples iex&gt; Process . put ( :comments , [ &quot;comment&quot; , &quot;other comment&quot; ] ) iex&gt; Process . delete ( :comments ) [ &quot;comment&quot; , &quot;other comment&quot; ] iex&gt; Process . delete ( :comments ) nil","ref":"Process.html#delete/1","title":"Process.delete/1","type":"function"},{"doc":"Demonitors the monitor identified by the given reference . If monitor_ref is a reference which the calling process obtained by calling monitor/1 , that monitoring is turned off. If the monitoring is already turned off, nothing happens. See :erlang.demonitor/2 for more information. Inlined by the compiler. Examples pid = spawn ( fn -&gt; 1 + 2 end ) ref = Process . monitor ( pid ) Process . demonitor ( ref ) #=&gt; true","ref":"Process.html#demonitor/2","title":"Process.demonitor/2","type":"function"},{"doc":"Sends an exit signal with the given reason to pid . The following behaviour applies if reason is any term except :normal or :kill : If pid is not trapping exits, pid will exit with the given reason . If pid is trapping exits, the exit signal is transformed into a message {:EXIT, from, reason} and delivered to the message queue of pid . If reason is the atom :normal , pid will not exit (unless pid is the calling process, in which case it will exit with the reason :normal ). If it is trapping exits, the exit signal is transformed into a message {:EXIT, from, :normal} and delivered to its message queue. If reason is the atom :kill , that is if Process.exit(pid, :kill) is called, an untrappable exit signal is sent to pid which will unconditionally exit with reason :killed . Inlined by the compiler. Examples Process . exit ( pid , :kill ) #=&gt; true","ref":"Process.html#exit/2","title":"Process.exit/2","type":"function"},{"doc":"Sets the given flag to value for the calling process. Returns the old value of flag . See :erlang.process_flag/2 for more information. Inlined by the compiler.","ref":"Process.html#flag/2","title":"Process.flag/2","type":"function"},{"doc":"Sets the given flag to value for the given process pid . Returns the old value of flag . It raises ArgumentError if pid is not a local process. The allowed values for flag are only a subset of those allowed in flag/2 , namely :save_calls . See :erlang.process_flag/3 for more information. Inlined by the compiler.","ref":"Process.html#flag/3","title":"Process.flag/3","type":"function"},{"doc":"Returns all key-value pairs in the process dictionary. Inlined by the compiler.","ref":"Process.html#get/0","title":"Process.get/0","type":"function"},{"doc":"Returns the value for the given key in the process dictionary, or default if key is not set. Examples # Assuming :locale was not set iex&gt; Process . get ( :locale , &quot;pt&quot; ) &quot;pt&quot; iex&gt; Process . put ( :locale , &quot;fr&quot; ) nil iex&gt; Process . get ( :locale , &quot;pt&quot; ) &quot;fr&quot;","ref":"Process.html#get/2","title":"Process.get/2","type":"function"},{"doc":"Returns all keys in the process dictionary. Inlined by the compiler. Examples # Assuming :locale was not set iex&gt; :locale in Process . get_keys ( ) false iex&gt; Process . put ( :locale , &quot;pt&quot; ) nil iex&gt; :locale in Process . get_keys ( ) true","ref":"Process.html#get_keys/0","title":"Process.get_keys/0","type":"function"},{"doc":"Returns all keys in the process dictionary that have the given value . Inlined by the compiler.","ref":"Process.html#get_keys/1","title":"Process.get_keys/1","type":"function"},{"doc":"Returns the PID of the group leader for the calling process. Inlined by the compiler. Examples Process . group_leader ( ) #=&gt; #PID&lt;0.53.0&gt;","ref":"Process.html#group_leader/0","title":"Process.group_leader/0","type":"function"},{"doc":"Sets the group leader of the given pid to leader . Typically, this is used when a process started from a certain shell should have a group leader other than :init . Inlined by the compiler.","ref":"Process.html#group_leader/2","title":"Process.group_leader/2","type":"function"},{"doc":"Puts the calling process into a &quot;hibernation&quot; state. The calling process is put into a waiting state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future. See :erlang.hibernate/3 for more information. Inlined by the compiler.","ref":"Process.html#hibernate/3","title":"Process.hibernate/3","type":"function"},{"doc":"Returns information about the process identified by pid , or returns nil if the process is not alive. Use this only for debugging information. See :erlang.process_info/1 for more information.","ref":"Process.html#info/1","title":"Process.info/1","type":"function"},{"doc":"Returns information about the process identified by pid , or returns nil if the process is not alive. See :erlang.process_info/2 for more information.","ref":"Process.html#info/2","title":"Process.info/2","type":"function"},{"doc":"Creates a link between the calling process and the given item (process or port). Links are bidirectional. Linked processes can be unlinked by using unlink/1 . If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen. When two processes are linked, each one receives exit signals from the other (see also exit/2 ). Let's assume pid1 and pid2 are linked. If pid2 exits with a reason other than :normal (which is also the exit reason used when a process finishes its job) and pid1 is not trapping exits (see flag/2 ), then pid1 will exit with the same reason as pid2 and in turn emit an exit signal to all its other linked processes. The behaviour when pid1 is trapping exits is described in exit/2 . See :erlang.link/1 for more information. Inlined by the compiler.","ref":"Process.html#link/1","title":"Process.link/1","type":"function"},{"doc":"Returns a list of PIDs corresponding to all the processes currently existing on the local node. Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, alive?/1 will return false but its PID will be part of the list of PIDs returned by this function. See :erlang.processes/0 for more information. Inlined by the compiler. Examples Process . list ( ) #=&gt; [#PID&lt;0.0.0&gt;, #PID&lt;0.1.0&gt;, #PID&lt;0.2.0&gt;, #PID&lt;0.3.0&gt;, ...]","ref":"Process.html#list/0","title":"Process.list/0","type":"function"},{"doc":"Starts monitoring the given item from the calling process. Once the monitored process dies, a message is delivered to the monitoring process in the shape of: { :DOWN , ref , :process , object , reason } where: ref is a monitor reference returned by this function; object is either a pid of the monitored process (if monitoring a PID) or {name, node} (if monitoring a remote or local name); reason is the exit reason. If the process is already dead when calling Process.monitor/1 , a :DOWN message is delivered immediately. See &quot;The need for monitoring&quot; for an example. See :erlang.monitor/2 for more information. Inlined by the compiler. Examples pid = spawn ( fn -&gt; 1 + 2 end ) #=&gt; #PID&lt;0.118.0&gt; Process . monitor ( pid ) #=&gt; #Reference&lt;0.906660723.3006791681.40191&gt; Process . exit ( pid , :kill ) #=&gt; true receive do msg -&gt; msg end #=&gt; {:DOWN, #Reference&lt;0.906660723.3006791681.40191&gt;, :process, #PID&lt;0.118.0&gt;, :noproc}","ref":"Process.html#monitor/1","title":"Process.monitor/1","type":"function"},{"doc":"Stores the given key - value pair in the process dictionary. The return value of this function is the value that was previously stored under key , or nil in case no value was stored under it. Examples # Assuming :locale was not set iex&gt; Process . put ( :locale , &quot;en&quot; ) nil iex&gt; Process . put ( :locale , &quot;fr&quot; ) &quot;en&quot;","ref":"Process.html#put/2","title":"Process.put/2","type":"function"},{"doc":"Reads a timer created by send_after/3 . When the result is an integer, it represents the time in milliseconds left until the timer will expire. When the result is false , a timer corresponding to timer_ref could not be found. This can be either because the timer expired, because it has already been canceled, or because timer_ref never corresponded to a timer. Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet. Inlined by the compiler.","ref":"Process.html#read_timer/1","title":"Process.read_timer/1","type":"function"},{"doc":"Registers the given pid_or_port under the given name . name must be an atom and can then be used instead of the PID/port identifier when sending messages with Kernel.send/2 . register/2 will fail with ArgumentError in any of the following cases: the PID/Port is not existing locally and alive the name is already registered the pid_or_port is already registered under a different name The following names are reserved and cannot be assigned to processes nor ports: nil false true :undefined Examples Process . register ( self ( ) , :test ) #=&gt; true send ( :test , :hello ) #=&gt; :hello send ( :wrong_name , :hello ) ** (ArgumentError) argument error","ref":"Process.html#register/2","title":"Process.register/2","type":"function"},{"doc":"Returns a list of names which have been registered using register/2 . Inlined by the compiler. Examples Process . register ( self ( ) , :test ) Process . registered ( ) #=&gt; [:test, :elixir_config, :inet_db, ...]","ref":"Process.html#registered/0","title":"Process.registered/0","type":"function"},{"doc":"Sends a message to the given dest . dest may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node. Inlined by the compiler. Options :noconnect - when used, if sending the message would require an auto-connection to another node the message is not sent and :noconnect is returned. :nosuspend - when used, if sending the message would cause the sender to be suspended the message is not sent and :nosuspend is returned. Otherwise the message is sent and :ok is returned. Examples iex&gt; Process . send ( { :name , :node_that_does_not_exist } , :hi , [ :noconnect ] ) :noconnect","ref":"Process.html#send/3","title":"Process.send/3","type":"function"},{"doc":"Sends msg to dest after time milliseconds. If dest is a PID, it must be the PID of a local process, dead or alive. If dest is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process. The message is not sent immediately. Therefore, dest can receive other messages in-between even when time is 0 . This function returns a timer reference, which can be read with read_timer/1 or canceled with cancel_timer/1 . The timer will be automatically canceled if the given dest is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when dest is an atom (as the atom resolution is done on delivery). Inlined by the compiler. Options :abs - (boolean) when false , time is treated as relative to the current monotonic time. When true , time is the absolute value of the Erlang monotonic time at which msg should be delivered to dest . To read more about Erlang monotonic time and other time-related concepts, look at the documentation for the System module. Defaults to false . Examples timer_ref = Process . send_after ( pid , :hi , 1000 )","ref":"Process.html#send_after/4","title":"Process.send_after/4","type":"function"},{"doc":"Sleeps the current process for the given timeout . timeout is either the number of milliseconds to sleep as an integer or the atom :infinity . When :infinity is given, the current process will sleep forever, and not consume or reply to messages. Use this function with extreme care . For almost all situations where you would use sleep/1 in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing. For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages. In other words, do not : Task . start_link ( fn -&gt; do_something ( ) ... end ) # Wait until work is done Process . sleep ( 2000 ) But do : parent = self ( ) Task . start_link ( fn -&gt; do_something ( ) send ( parent , :work_is_done ) ... end ) receive do :work_is_done -&gt; :ok after # Optional timeout 30_000 -&gt; :timeout end For cases like the one above, Task.async/1 and Task.await/2 are preferred. Similarly, if you are waiting for a process to terminate, monitor that process instead of sleeping. Do not : Task . start_link ( fn -&gt; ... end ) # Wait until task terminates Process . sleep ( 2000 ) Instead do : { :ok , pid } = Task . start_link ( fn -&gt; ... end ) ref = Process . monitor ( pid ) receive do { :DOWN , ^ ref , _ , _ , _ } -&gt; :task_is_down after # Optional timeout 30_000 -&gt; :timeout end","ref":"Process.html#sleep/1","title":"Process.sleep/1","type":"function"},{"doc":"Spawns the given function according to the given options. The result depends on the given options. In particular, if :monitor is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID. More options are available; for the comprehensive list of available options check :erlang.spawn_opt/4 . Inlined by the compiler. Examples Process . spawn ( fn -&gt; 1 + 2 end , [ :monitor ] ) #=&gt; {#PID&lt;0.93.0&gt;, #Reference&lt;0.18808174.1939079169.202418&gt;} Process . spawn ( fn -&gt; 1 + 2 end , [ :link ] ) #=&gt; #PID&lt;0.95.0&gt;","ref":"Process.html#spawn/2","title":"Process.spawn/2","type":"function"},{"doc":"Spawns the given function fun from module mod , passing the given args according to the given options. The result depends on the given options. In particular, if :monitor is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID. It also accepts extra options, for the list of available options check :erlang.spawn_opt/4 . Inlined by the compiler.","ref":"Process.html#spawn/4","title":"Process.spawn/4","type":"function"},{"doc":"Removes the link between the calling process and the given item (process or port). If there is no such link, this function does nothing. If pid_or_port does not exist, this function does not produce any errors and simply does nothing. The return value of this function is always true . See :erlang.unlink/1 for more information. Inlined by the compiler.","ref":"Process.html#unlink/1","title":"Process.unlink/1","type":"function"},{"doc":"Removes the registered name , associated with a PID or a port identifier. Fails with ArgumentError if the name is not registered to any PID or port. Inlined by the compiler. Examples Process . register ( self ( ) , :test ) #=&gt; true Process . unregister ( :test ) #=&gt; true Process . unregister ( :wrong_name ) ** (ArgumentError) argument error","ref":"Process.html#unregister/1","title":"Process.unregister/1","type":"function"},{"doc":"Returns the PID or port identifier registered under name or nil if the name is not registered. See :erlang.whereis/1 for more information. Examples Process . register ( self ( ) , :test ) Process . whereis ( :test ) #=&gt; #PID&lt;0.84.0&gt; Process . whereis ( :wrong_name ) #=&gt; nil","ref":"Process.html#whereis/1","title":"Process.whereis/1","type":"function"},{"doc":"A process destination. A remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node.","ref":"Process.html#t:dest/0","title":"Process.dest/0","type":"type"},{"doc":"","ref":"Process.html#t:spawn_opt/0","title":"Process.spawn_opt/0","type":"type"},{"doc":"","ref":"Process.html#t:spawn_opts/0","title":"Process.spawn_opts/0","type":"type"},{"doc":"A local, decentralized and scalable key-value process storage. It allows developers to lookup one or more processes with a given key. If the registry has :unique keys, a key points to 0 or 1 process. If the registry allows :duplicate keys, a single key may point to any number of processes. In both cases, different keys could identify the same process. Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation ( ===/2 ). The registry can be used for different purposes, such as name lookups (using the :via option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below. The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries. Using in :via Once the registry is started with a given name using Registry.start_link/1 , it can be used to register and access named processes using the {:via, Registry, {registry, key}} tuple: { :ok , _ } = Registry . start_link ( keys : :unique , name : Registry.ViaTest ) name = { :via , Registry , { Registry.ViaTest , &quot;agent&quot; } } { :ok , _ } = Agent . start_link ( fn -&gt; 0 end , name : name ) Agent . get ( name , &amp; &amp;1 ) #=&gt; 0 Agent . update ( name , &amp; ( &amp;1 + 1 ) ) Agent . get ( name , &amp; &amp;1 ) #=&gt; 1 In the previous example, we were not interested in associating a value to the process: Registry . lookup ( Registry.ViaTest , &quot;agent&quot; ) #=&gt; [{self(), nil}] However, in some cases it may be desired to associate a value to the process using the alternate {:via, Registry, {registry, key, value}} tuple: { :ok , _ } = Registry . start_link ( keys : :unique , name : Registry.ViaTest ) name = { :via , Registry , { Registry.ViaTest , &quot;agent&quot; , :hello } } { :ok , _ } = Agent . start_link ( fn -&gt; 0 end , name : name ) Registry . lookup ( Registry.ViaTest , &quot;agent&quot; ) #=&gt; [{self(), :hello}] To this point, we have been starting Registry using start_link/1 . Typically the registry is started as part of a supervision tree though: { Registry , keys : :unique , name : Registry.ViaTest } Only registries with unique keys can be used in :via . If the name is already taken, the case-specific start_link function ( Agent.start_link/2 in the example above) will return {:error, {:already_started, current_pid}} . Using as a dispatcher Registry has a dispatch mechanism that allows developers to implement custom dispatch logic triggered from the caller. For example, let's say we have a duplicate registry started as so: { :ok , _ } = Registry . start_link ( keys : :duplicate , name : Registry.DispatcherTest ) By calling register/3 , different processes can register under a given key and associate any value under that key. In this case, let's register the current process under the key &quot;hello&quot; and attach the {IO, :inspect} tuple to it: { :ok , _ } = Registry . register ( Registry.DispatcherTest , &quot;hello&quot; , { IO , :inspect } ) Now, an entity interested in dispatching events for a given key may call dispatch/3 passing in the key and a callback. This callback will be invoked with a list of all the values registered under the requested key, alongside the PID of the process that registered each value, in the form of {pid, value} tuples. In our example, value will be the {module, function} tuple in the code above: Registry . dispatch ( Registry.DispatcherTest , &quot;hello&quot; , fn entries -&gt; for { pid , { module , function } } &lt;- entries , do : apply ( module , function , [ pid ] ) end ) # Prints #PID&lt;...&gt; where the PID is for the process that called register/3 above #=&gt; :ok Dispatching happens in the process that calls dispatch/3 either serially or concurrently in case of multiple partitions (via spawned tasks). The registered processes are not involved in dispatching unless involving them is done explicitly (for example, by sending them a message in the callback). Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors: require Logger Registry . dispatch ( Registry.DispatcherTest , &quot;hello&quot; , fn entries -&gt; for { pid , { module , function } } &lt;- entries do try do apply ( module , function , [ pid ] ) catch kind , reason -&gt; formatted = Exception . format ( kind , reason , __STACKTRACE__ ) Logger . error ( &quot;Registry.dispatch/3 failed with \#{ formatted } &quot; ) end end end ) # Prints #PID&lt;...&gt; #=&gt; :ok You could also replace the whole apply system by explicitly sending messages. That's the example we will see next. Using as a PubSub Registries can also be used to implement a local, non-distributed, scalable PubSub by relying on the dispatch/3 function, similarly to the previous section: in this case, however, we will send messages to each associated process, instead of invoking a given module-function. In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments: { :ok , _ } = Registry . start_link ( keys : :duplicate , name : Registry.PubSubTest , partitions : System . schedulers_online ( ) ) { :ok , _ } = Registry . register ( Registry.PubSubTest , &quot;hello&quot; , [ ] ) Registry . dispatch ( Registry.PubSubTest , &quot;hello&quot; , fn entries -&gt; for { pid , _ } &lt;- entries , do : send ( pid , { :broadcast , &quot;world&quot; } ) end ) #=&gt; :ok The example above broadcasted the message {:broadcast, &quot;world&quot;} to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &quot;hello&quot; . The third argument given to register/3 is a value associated to the current process. While in the previous section we used it when dispatching, in this particular example we are not interested in it, so we have set it to an empty list. You could store a more meaningful value if necessary. Registrations Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation. However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as Process.monitor/1 which will deliver the :DOWN message immediately if the monitored process is already dead and Kernel.send/2 which acts as a no-op for dead processes. ETS Note that the registry uses one ETS table plus two ETS tables per partition.","ref":"Registry.html","title":"Registry","type":"module"},{"doc":"Returns a specification to start a registry under a supervisor. See Supervisor .","ref":"Registry.html#child_spec/1","title":"Registry.child_spec/1","type":"function"},{"doc":"Returns the number of registered keys in a registry. It runs in constant time. Examples In the example below we register the current process and ask for the number of keys in the registry: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueCountTest ) iex&gt; Registry . count ( Registry.UniqueCountTest ) 0 iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueCountTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueCountTest , &quot;world&quot; , :world ) iex&gt; Registry . count ( Registry.UniqueCountTest ) 2 The same applies to duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateCountTest ) iex&gt; Registry . count ( Registry.DuplicateCountTest ) 0 iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateCountTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateCountTest , &quot;hello&quot; , :world ) iex&gt; Registry . count ( Registry.DuplicateCountTest ) 2","ref":"Registry.html#count/1","title":"Registry.count/1","type":"function"},{"doc":"Returns the number of {pid, value} pairs under the given key in registry that match pattern . Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom :_ can be used to ignore a given value or tuple element, while the atom :&quot;$1&quot; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the $1 &gt; 1 guard condition would be expressed as the {:&gt;, :&quot;$1&quot;, 1} tuple. Please note that guard conditions will work only for assigned variables like :&quot;$1&quot; , :&quot;$2&quot; , and so forth. Avoid usage of special match variables :&quot;$_&quot; and :&quot;$$&quot; , because it might not work as expected. Zero will be returned if there is no match. For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up. Examples In the example below we register the current process under the same key in a duplicate registry but with different values: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.CountMatchTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.CountMatchTest , &quot;hello&quot; , { 1 , :atom , 1 } ) iex&gt; { :ok , _ } = Registry . register ( Registry.CountMatchTest , &quot;hello&quot; , { 2 , :atom , 2 } ) iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { 1 , :_ , :_ } ) 1 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { 2 , :_ , :_ } ) 1 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :_ , :atom , :_ } ) 2 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :&quot;$1&quot; , :_ , :&quot;$1&quot; } ) 2 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :_ , :_ , :&quot;$1&quot; } , [ { :&gt; , :&quot;$1&quot; , 1 } ] ) 1 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :_ , :&quot;$1&quot; , :_ } , [ { :is_atom , :&quot;$1&quot; } ] ) 2","ref":"Registry.html#count_match/4","title":"Registry.count_match/4","type":"function"},{"doc":"Deletes registry metadata for the given key in registry . Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.DeleteMetaTest ) iex&gt; Registry . put_meta ( Registry.DeleteMetaTest , :custom_key , &quot;custom_value&quot; ) :ok iex&gt; Registry . meta ( Registry.DeleteMetaTest , :custom_key ) { :ok , &quot;custom_value&quot; } iex&gt; Registry . delete_meta ( Registry.DeleteMetaTest , :custom_key ) :ok iex&gt; Registry . meta ( Registry.DeleteMetaTest , :custom_key ) :error","ref":"Registry.html#delete_meta/2","title":"Registry.delete_meta/2","type":"function"},{"doc":"Invokes the callback with all entries under key in each partition for the given registry . The list of entries is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked. If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and parallel: true is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition. See the module documentation for examples of using the dispatch/3 function for building custom dispatching or a pubsub system.","ref":"Registry.html#dispatch/4","title":"Registry.dispatch/4","type":"function"},{"doc":"Returns the known keys for the given pid in registry in no particular order. If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry. Examples Registering under a unique registry does not allow multiple entries: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueKeysTest ) iex&gt; Registry . keys ( Registry.UniqueKeysTest , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueKeysTest , &quot;hello&quot; , :world ) iex&gt; Registry . register ( Registry.UniqueKeysTest , &quot;hello&quot; , :later ) # registry is :unique { :error , { :already_registered , self ( ) } } iex&gt; Registry . keys ( Registry.UniqueKeysTest , self ( ) ) [ &quot;hello&quot; ] Such is possible for duplicate registries though: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateKeysTest ) iex&gt; Registry . keys ( Registry.DuplicateKeysTest , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateKeysTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateKeysTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.DuplicateKeysTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ]","ref":"Registry.html#keys/2","title":"Registry.keys/2","type":"function"},{"doc":"Finds the {pid, value} pair for the given key in registry in no particular order. An empty list if there is no match. For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up. Examples In the example below we register the current process and look it up both from itself and other processes: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueLookupTest ) iex&gt; Registry . lookup ( Registry.UniqueLookupTest , &quot;hello&quot; ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . lookup ( Registry.UniqueLookupTest , &quot;hello&quot; ) [ { self ( ) , :world } ] iex&gt; Task . async ( fn -&gt; Registry . lookup ( Registry.UniqueLookupTest , &quot;hello&quot; ) end ) |&gt; Task . await ( ) [ { self ( ) , :world } ] The same applies to duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateLookupTest ) iex&gt; Registry . lookup ( Registry.DuplicateLookupTest , &quot;hello&quot; ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . lookup ( Registry.DuplicateLookupTest , &quot;hello&quot; ) [ { self ( ) , :world } ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :another ) iex&gt; Enum . sort ( Registry . lookup ( Registry.DuplicateLookupTest , &quot;hello&quot; ) ) [ { self ( ) , :another } , { self ( ) , :world } ]","ref":"Registry.html#lookup/2","title":"Registry.lookup/2","type":"function"},{"doc":"Returns {pid, value} pairs under the given key in registry that match pattern . Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom :_ can be used to ignore a given value or tuple element, while the atom :&quot;$1&quot; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the $1 &gt; 1 guard condition would be expressed as the {:&gt;, :&quot;$1&quot;, 1} tuple. Please note that guard conditions will work only for assigned variables like :&quot;$1&quot; , :&quot;$2&quot; , and so forth. Avoid usage of special match variables :&quot;$_&quot; and :&quot;$$&quot; , because it might not work as expected. An empty list will be returned if there is no match. For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up. Examples In the example below we register the current process under the same key in a duplicate registry but with different values: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.MatchTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.MatchTest , &quot;hello&quot; , { 1 , :atom , 1 } ) iex&gt; { :ok , _ } = Registry . register ( Registry.MatchTest , &quot;hello&quot; , { 2 , :atom , 2 } ) iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { 1 , :_ , :_ } ) [ { self ( ) , { 1 , :atom , 1 } } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { 2 , :_ , :_ } ) [ { self ( ) , { 2 , :atom , 2 } } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :_ , :atom , :_ } ) |&gt; Enum . sort ( ) [ { self ( ) , { 1 , :atom , 1 } } , { self ( ) , { 2 , :atom , 2 } } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :&quot;$1&quot; , :_ , :&quot;$1&quot; } ) |&gt; Enum . sort ( ) [ { self ( ) , { 1 , :atom , 1 } } , { self ( ) , { 2 , :atom , 2 } } ] iex&gt; guards = [ { :&gt; , :&quot;$1&quot; , 1 } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :_ , :_ , :&quot;$1&quot; } , guards ) [ { self ( ) , { 2 , :atom , 2 } } ] iex&gt; guards = [ { :is_atom , :&quot;$1&quot; } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :_ , :&quot;$1&quot; , :_ } , guards ) |&gt; Enum . sort ( ) [ { self ( ) , { 1 , :atom , 1 } } , { self ( ) , { 2 , :atom , 2 } } ]","ref":"Registry.html#match/4","title":"Registry.match/4","type":"function"},{"doc":"Reads registry metadata given on start_link/1 . Atoms and tuples are allowed as keys. Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.MetaTest , meta : [ custom_key : &quot;custom_value&quot; ] ) iex&gt; Registry . meta ( Registry.MetaTest , :custom_key ) { :ok , &quot;custom_value&quot; } iex&gt; Registry . meta ( Registry.MetaTest , :unknown_key ) :error","ref":"Registry.html#meta/2","title":"Registry.meta/2","type":"function"},{"doc":"Stores registry metadata. Atoms and tuples are allowed as keys. Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.PutMetaTest ) iex&gt; Registry . put_meta ( Registry.PutMetaTest , :custom_key , &quot;custom_value&quot; ) :ok iex&gt; Registry . meta ( Registry.PutMetaTest , :custom_key ) { :ok , &quot;custom_value&quot; } iex&gt; Registry . put_meta ( Registry.PutMetaTest , { :tuple , :key } , &quot;tuple_value&quot; ) :ok iex&gt; Registry . meta ( Registry.PutMetaTest , { :tuple , :key } ) { :ok , &quot;tuple_value&quot; }","ref":"Registry.html#put_meta/3","title":"Registry.put_meta/3","type":"function"},{"doc":"Registers the current process under the given key in registry . A value to be associated with this registration must also be given. This value will be retrieved whenever dispatching or doing a key lookup. This function returns {:ok, owner} or {:error, reason} . The owner is the PID in the registry partition responsible for the PID. The owner is automatically linked to the caller. If the registry has unique keys, it will return {:ok, owner} unless the key is already associated to a PID, in which case it returns {:error, {:already_registered, pid}} . If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed. Examples Registering under a unique registry does not allow multiple entries: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueRegisterTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueRegisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . register ( Registry.UniqueRegisterTest , &quot;hello&quot; , :later ) { :error , { :already_registered , self ( ) } } iex&gt; Registry . keys ( Registry.UniqueRegisterTest , self ( ) ) [ &quot;hello&quot; ] Such is possible for duplicate registries though: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateRegisterTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateRegisterTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateRegisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.DuplicateRegisterTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ]","ref":"Registry.html#register/3","title":"Registry.register/3","type":"function"},{"doc":"Select key, pid, and values registered using full match specs. The spec consists of a list of three part tuples, in the shape of [{match_pattern, guards, body}] . The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is {key, pid, value} . The atom :_ can be used to ignore a given value or tuple element, while the atom :&quot;$1&quot; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like {:&quot;$1&quot;, :_, :_} . The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the $1 &gt; 1 guard condition would be expressed as the {:&gt;, :&quot;$1&quot;, 1} tuple. Please note that guard conditions will work only for assigned variables like :&quot;$1&quot; , :&quot;$2&quot; , and so forth. The third part, the body, is a list of shapes of the returned entries. Like guards, you have access to assigned variables like :&quot;$1&quot; , which you can combine with hardcoded values to freely shape entries Note that tuples have to be wrapped in an additional tuple. To get a result format like %{key: key, pid: pid, value: value} , assuming you bound those variables in order in the match part, you would provide a body like [%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}] . Like guards, you can use some operations like :element to modify the output format. Do not use special match variables :&quot;$_&quot; and :&quot;$$&quot; , because they might not work as expected. Note that for large registries with many partitions this will be costly as it builds the result by concatenating all the partitions. Examples This example shows how to get everything from the registry. iex&gt; Registry . start_link ( keys : :unique , name : Registry.SelectAllTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;hello&quot; , :value ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;world&quot; , :value ) iex&gt; Registry . select ( Registry.SelectAllTest , [ { { :&quot;$1&quot; , :&quot;$2&quot; , :&quot;$3&quot; } , [ ] , [ { { :&quot;$1&quot; , :&quot;$2&quot; , :&quot;$3&quot; } } ] } ] ) [ { &quot;world&quot; , self ( ) , :value } , { &quot;hello&quot; , self ( ) , :value } ] Get all keys in the registry. iex&gt; Registry . start_link ( keys : :unique , name : Registry.SelectAllTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;hello&quot; , :value ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;world&quot; , :value ) iex&gt; Registry . select ( Registry.SelectAllTest , [ { { :&quot;$1&quot; , :_ , :_ } , [ ] , [ :&quot;$1&quot; ] } ] ) [ &quot;world&quot; , &quot;hello&quot; ]","ref":"Registry.html#select/2","title":"Registry.select/2","type":"function"},{"doc":"Starts the registry as a supervisor process. Manually it can be started as: Registry . start_link ( keys : :unique , name : MyApp.Registry ) In your supervisor tree, you would write: Supervisor . start_link ( [ { Registry , keys : :unique , name : MyApp.Registry } ] , strategy : :one_for_one ) For intensive workloads, the registry may also be partitioned (by specifying the :partitions option). If partitioning is required then a good default is to set the number of partitions to the number of schedulers available: Registry . start_link ( keys : :unique , name : MyApp.Registry , partitions : System . schedulers_online ( ) ) or: Supervisor . start_link ( [ { Registry , keys : :unique , name : MyApp.Registry , partitions : System . schedulers_online ( ) } ] , strategy : :one_for_one ) Options The registry requires the following keys: :keys - chooses if keys are :unique or :duplicate :name - the name of the registry and its tables The following keys are optional: :partitions - the number of partitions in the registry. Defaults to 1 . :listeners - a list of named processes which are notified of :register and :unregister events. The registered process must be monitored by the listener if the listener wants to be notified if the registered process crashes. :meta - a keyword list of metadata to be attached to the registry.","ref":"Registry.html#start_link/1","title":"Registry.start_link/1","type":"function"},{"doc":"Unregisters all entries for the given key associated to the current process in registry . Always returns :ok and automatically unlinks the current process from the owner if there are no more keys associated to the current process. See also register/3 to read more about the &quot;owner&quot;. Examples For unique registries: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueUnregisterTest ) iex&gt; Registry . register ( Registry.UniqueUnregisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.UniqueUnregisterTest , self ( ) ) [ &quot;hello&quot; ] iex&gt; Registry . unregister ( Registry.UniqueUnregisterTest , &quot;hello&quot; ) :ok iex&gt; Registry . keys ( Registry.UniqueUnregisterTest , self ( ) ) [ ] For duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateUnregisterTest ) iex&gt; Registry . register ( Registry.DuplicateUnregisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . register ( Registry.DuplicateUnregisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.DuplicateUnregisterTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ] iex&gt; Registry . unregister ( Registry.DuplicateUnregisterTest , &quot;hello&quot; ) :ok iex&gt; Registry . keys ( Registry.DuplicateUnregisterTest , self ( ) ) [ ]","ref":"Registry.html#unregister/2","title":"Registry.unregister/2","type":"function"},{"doc":"Unregisters entries for keys matching a pattern associated to the current process in registry . Examples For unique registries it can be used to conditionally unregister a key on the basis of whether or not it matches a particular value. iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueUnregisterMatchTest ) iex&gt; Registry . register ( Registry.UniqueUnregisterMatchTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.UniqueUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; ] iex&gt; Registry . unregister_match ( Registry.UniqueUnregisterMatchTest , &quot;hello&quot; , :foo ) :ok iex&gt; Registry . keys ( Registry.UniqueUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; ] iex&gt; Registry . unregister_match ( Registry.UniqueUnregisterMatchTest , &quot;hello&quot; , :world ) :ok iex&gt; Registry . keys ( Registry.UniqueUnregisterMatchTest , self ( ) ) [ ] For duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateUnregisterMatchTest ) iex&gt; Registry . register ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_a ) iex&gt; Registry . register ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_b ) iex&gt; Registry . register ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_c ) iex&gt; Registry . keys ( Registry.DuplicateUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; , &quot;hello&quot; ] iex&gt; Registry . unregister_match ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_a ) :ok iex&gt; Registry . keys ( Registry.DuplicateUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ] iex&gt; Registry . lookup ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; ) [ { self ( ) , :world_b } , { self ( ) , :world_c } ]","ref":"Registry.html#unregister_match/4","title":"Registry.unregister_match/4","type":"function"},{"doc":"Updates the value for key for the current process in the unique registry . Returns a {new_value, old_value} tuple or :error if there is no such key assigned to the current process. If a non-unique registry is given, an error is raised. Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.UpdateTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.UpdateTest , &quot;hello&quot; , 1 ) iex&gt; Registry . lookup ( Registry.UpdateTest , &quot;hello&quot; ) [ { self ( ) , 1 } ] iex&gt; Registry . update_value ( Registry.UpdateTest , &quot;hello&quot; , &amp; ( &amp;1 + 1 ) ) { 2 , 1 } iex&gt; Registry . lookup ( Registry.UpdateTest , &quot;hello&quot; ) [ { self ( ) , 2 } ]","ref":"Registry.html#update_value/3","title":"Registry.update_value/3","type":"function"},{"doc":"Reads the values for the given key for pid in registry . For unique registries, it is either an empty list or a list with a single element. For duplicate registries, it is a list with zero, one, or multiple elements. Examples In the example below we register the current process and look it up both from itself and other processes: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueLookupTest ) iex&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , self ( ) ) [ :world ] iex&gt; Task . async ( fn -&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , self ( ) ) end ) |&gt; Task . await ( ) [ ] iex&gt; parent = self ( ) iex&gt; Task . async ( fn -&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , parent ) end ) |&gt; Task . await ( ) [ :world ] The same applies to duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateLookupTest ) iex&gt; Registry . values ( Registry.DuplicateLookupTest , &quot;hello&quot; , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . values ( Registry.DuplicateLookupTest , &quot;hello&quot; , self ( ) ) [ :world ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :another ) iex&gt; Enum . sort ( Registry . values ( Registry.DuplicateLookupTest , &quot;hello&quot; , self ( ) ) ) [ :another , :world ]","ref":"Registry.html#values/3","title":"Registry.values/3","type":"function"},{"doc":"A pattern used to representing the output format part of a match spec","ref":"Registry.html#t:body/0","title":"Registry.body/0","type":"type"},{"doc":"A guard to be evaluated when matching on objects in a registry","ref":"Registry.html#t:guard/0","title":"Registry.guard/0","type":"type"},{"doc":"A list of guards to be evaluated when matching on objects in a registry","ref":"Registry.html#t:guards/0","title":"Registry.guards/0","type":"type"},{"doc":"The type of keys allowed on registration","ref":"Registry.html#t:key/0","title":"Registry.key/0","type":"type"},{"doc":"The type of the registry","ref":"Registry.html#t:keys/0","title":"Registry.keys/0","type":"type"},{"doc":"A pattern to match on objects in a registry","ref":"Registry.html#t:match_pattern/0","title":"Registry.match_pattern/0","type":"type"},{"doc":"The type of registry metadata keys","ref":"Registry.html#t:meta_key/0","title":"Registry.meta_key/0","type":"type"},{"doc":"The type of registry metadata values","ref":"Registry.html#t:meta_value/0","title":"Registry.meta_value/0","type":"type"},{"doc":"The registry identifier","ref":"Registry.html#t:registry/0","title":"Registry.registry/0","type":"type"},{"doc":"A full match spec used when selecting objects in the registry","ref":"Registry.html#t:spec/0","title":"Registry.spec/0","type":"type"},{"doc":"Options used for child_spec/1 and start_link/1","ref":"Registry.html#t:start_option/0","title":"Registry.start_option/0","type":"type"},{"doc":"The type of values allowed on registration","ref":"Registry.html#t:value/0","title":"Registry.value/0","type":"type"},{"doc":"A behaviour module for implementing supervisors. A supervisor is a process which supervises other processes, which we refer to as child processes . Supervisors are used to build a hierarchical process structure called a supervision tree . Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown. A supervisor may be started directly with a list of children via start_link/2 or you may define a module-based supervisor that implements the required callbacks. The sections below use start_link/2 to start supervisors in most examples, but it also includes a specific section on module-based ones. Examples In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack: defmodule Stack do use GenServer def start_link ( state ) do GenServer . start_link ( __MODULE__ , state , name : __MODULE__ ) end ## Callbacks @impl true def init ( stack ) do { :ok , stack } end @impl true def handle_call ( :pop , _from , [ head | tail ] ) do { :reply , head , tail } end @impl true def handle_cast ( { :push , head } , tail ) do { :noreply , [ head | tail ] } end end The stack is a small wrapper around lists. It allows us to put an element on the top of the stack, by prepending to the list, and to get the top of the stack by pattern matching. We can now start a supervisor that will start and supervise our stack process. The first step is to define a list of child specifications that control how each child behaves. Each child specification is a map, as shown below: children = [ # The Stack is a child started via Stack.start_link([:hello]) %{ id : Stack , start : { Stack , :start_link , [ [ :hello ] ] } } ] # Now we start the supervisor with the children and a strategy { :ok , pid } = Supervisor . start_link ( children , strategy : :one_for_one ) # After started, we can query the supervisor for information Supervisor . count_children ( pid ) #=&gt; %{active: 1, specs: 1, supervisors: 0, workers: 1} Note that when starting the GenServer, we are registering it with name Stack , which allows us to call it directly and get what is on the stack: GenServer . call ( Stack , :pop ) #=&gt; :hello GenServer . cast ( Stack , { :push , :world } ) #=&gt; :ok GenServer . call ( Stack , :pop ) #=&gt; :world However, there is a bug in our stack server. If we call :pop and the stack is empty, it is going to crash because no clause matches: GenServer . call ( Stack , :pop ) ** (exit) exited in: GenServer.call(Stack, :pop, 5000) Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of [:hello] : GenServer . call ( Stack , :pop ) #=&gt; :hello Supervisors support different strategies; in the example above, we have chosen :one_for_one . Furthermore, each supervisor can have many workers and/or supervisors as children, with each one having its own configuration (as outlined in the &quot;Child specification&quot; section). The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more. Child specification The child specification describes how the supervisor starts, shuts down, and restarts child processes. The child specification is a map containing up to 6 elements. The first two keys in the following list are required, and the remaining ones are optional: :id - any term used to identify the child specification internally by the supervisor; defaults to the given module. In the case of conflicting :id values, the supervisor will refuse to initialize and require explicit IDs. This key is required. :start - a tuple with the module-function-args to be invoked to start the child process. This key is required. :restart - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below). This key is optional and defaults to :permanent . :shutdown - an integer or atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below). This key is optional and defaults to 5_000 if the type is :worker or :infinity if the type is :supervisor . :type - specifies that the child process is a :worker or a :supervisor . This key is optional and defaults to :worker . There is a sixth key, :modules , which is optional and is rarely changed. It is set automatically based on the :start value. Let's understand what the :shutdown and :restart options control. Shutdown values (:shutdown) The following shutdown values are supported in the :shutdown option: :brutal_kill - the child process is unconditionally and immediately terminated using Process.exit(child, :kill) . any integer &gt;= 0 - the amount of time in milliseconds that the supervisor will wait for its children to terminate after emitting a Process.exit(child, :shutdown) signal. If the child process is not trapping exits, the initial :shutdown signal will terminate the child process immediately. If the child process is trapping exits, it has the given amount of time to terminate. If it doesn't terminate within the specified time, the child process is unconditionally terminated by the supervisor via Process.exit(child, :kill) . :infinity - works as an integer except the supervisor will wait indefinitely for the child to terminate. If the child process is a supervisor, the recommended value is :infinity to give the supervisor and its children enough time to shut down. This option can be used with regular workers but doing so is discouraged and requires extreme care. If not used carefully, the child process will never terminate, preventing your application from terminating as well. Restart values (:restart) The :restart option controls what the supervisor should consider to be a successful termination or not. If the termination is successful, the supervisor won't restart the child. If the child process crashed, the supervisor will start a new one. The following restart values are supported in the :restart option: :permanent - the child process is always restarted. :temporary - the child process is never restarted, regardless of the supervision strategy: any termination (even abnormal) is considered successful. :transient - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal , :shutdown , or {:shutdown, term} . For a more complete understanding of the exit reasons and their impact, see the &quot;Exit reasons and restarts&quot; section. child_spec/1 When starting a supervisor, we pass a list of child specifications. Those specifications are maps that tell how the supervisor should start, stop and restart each of its children: %{ id : Stack , start : { Stack , :start_link , [ [ :hello ] ] } } The map above defines a child with :id of Stack that is started by calling Stack.start_link([:hello]) . However, specifying the child specification for each child as a map can be quite error prone, as we may change the Stack implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the start_link argument instead of the specification: children = [ { Stack , [ :hello ] } ] The supervisor will then invoke Stack.child_spec([:hello]) to retrieve a child specification. Now the Stack module is responsible for building its own specification, for example, we could write: def child_spec ( arg ) do %{ id : Stack , start : { Stack , :start_link , [ arg ] } } end Luckily for us, use GenServer already defines a Stack.child_spec/1 exactly like above. If you need to customize the GenServer , you can pass the options directly to use GenServer : use GenServer , restart : :transient Finally, note it is also possible to simply pass the Stack module as a child: children = [ Stack ] When only the module name is given, it is equivalent to {Stack, []} . By replacing the map specification by {Stack, [:hello]} or Stack , we keep the child specification encapsulated in the Stack module, using the default implementation defined by use GenServer . We can now share our Stack worker with other developers and they can add it directly to their supervision tree without worrying about the low-level details of the worker. Overall, the child specification can be one of the following: a map representing the child specification itself - as outlined in the &quot;Child specification&quot; section a tuple with a module as first element and the start argument as second - such as {Stack, [:hello]} . In this case, Stack.child_spec([:hello]) is called to retrieve the child specification a module - such as Stack . In this case, Stack.child_spec([]) is called to retrieve the child specification If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the Supervisor.child_spec/2 function. For example, to run the stack with a different :id and a :shutdown value of 10 seconds (10_000 milliseconds): children = [ Supervisor . child_spec ( { Stack , [ :hello ] } , id : MyStack , shutdown : 10_000 ) ] Module-based supervisors In the example above, a supervisor was started by passing the supervision structure to start_link/2 . However, supervisors can also be created by explicitly defining a supervision module: defmodule MyApp.Supervisor do # Automatically defines child_spec/1 use Supervisor def start_link ( init_arg ) do Supervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end @impl true def init ( _init_arg ) do children = [ { Stack , [ :hello ] } ] Supervisor . init ( children , strategy : :one_for_one ) end end The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling Supervisor.start_link/2 with a list of children that are automatically initialized, we manually initialized the children by calling Supervisor.init/2 inside its init/1 callback. use Supervisor also defines a child_spec/1 function which allows us to run MyApp.Supervisor as a child of another supervisor or at the top of your supervision tree as: children = [ MyApp.Supervisor ] Supervisor . start_link ( children , strategy : :one_for_one ) A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the Application.start/2 callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The child_spec/1 generated automatically by Supervisor can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the supervisor should be restarted, defaults to :permanent The @doc annotation immediately preceding use Supervisor will be attached to the generated child_spec/1 function. start_link/2 , init/2 , and strategies So far we have started the supervisor passing a single child as a tuple as well as a strategy called :one_for_one : children = [ { Stack , [ :hello ] } ] Supervisor . start_link ( children , strategy : :one_for_one ) or from inside the init/1 callback: children = [ { Stack , [ :hello ] } ] Supervisor . init ( children , strategy : :one_for_one ) The first argument given to start_link/2 and init/2 is a list of child specifications as defined in the &quot;child_spec/1&quot; section above. The second argument is a keyword list of options: :strategy - the supervision strategy option. It can be either :one_for_one , :rest_for_one or :one_for_all . Required. See the &quot;Strategies&quot; section. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . :name - a name to register the supervisor process. Supported values are explained in the &quot;Name registration&quot; section in the documentation for GenServer . Optional. Strategies Supervisors support different supervision strategies (through the :strategy option, as seen above): :one_for_one - if a child process terminates, only that process is restarted. :one_for_all - if a child process terminates, all other child processes are terminated and then all child processes (including the terminated one) are restarted. :rest_for_one - if a child process terminates, the terminated child process and the rest of the children started after it, are terminated and restarted. In the above, process termination refers to unsuccessful termination, which is determined by the :restart option. To dynamically supervise children, see DynamicSupervisor . Name registration A supervisor is bound to the same name registration rules as a GenServer . Read more about these rules in the documentation for GenServer . Start and shutdown When the supervisor starts, it traverses all child specifications and then starts each child in the order they are defined. This is done by calling the function defined under the :start key in the child specification and typically defaults to start_link/1 . The start_link/1 (or a custom) is then called for each child process. The start_link/1 function must return {:ok, pid} where pid is the process identifier of a new process that is linked to the supervisor. The child process usually starts its work by executing the init/1 callback. Generally speaking, the init callback is where we initialize and configure the child process. The shutdown process happens in reverse order. When a supervisor shuts down, it terminates all children in the opposite order they are listed. The termination happens by sending a shutdown exit signal, via Process.exit(child_pid, :shutdown) , to the child process and then awaiting for a time interval for the child process to terminate. This interval defaults to 5000 milliseconds. If the child process does not terminate in this interval, the supervisor abruptly terminates the child with reason :kill . The shutdown time can be configured in the child specification which is fully detailed in the next section. If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the terminate callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor. In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper :shutdown value, ensuring it terminates within a reasonable interval. Exit reasons and restarts A supervisor restarts a child process depending on its :restart configuration. For example, when :restart is set to :transient , the supervisor does not restart the child in case it exits with reason :normal , :shutdown or {:shutdown, term} . So one may ask: which exit reason should I choose when exiting? There are three options: :normal - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes do not exit :shutdown or {:shutdown, term} - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes exit with the same reason unless they're trapping exits any other term - in such cases, the exit will be logged, there are restarts in transient mode, and linked processes exit with the same reason unless they're trapping exits Note that the supervisor that reaches maximum restart intensity will exit with :shutdown reason. In this case the supervisor will only be restarted if its child specification was defined with the :restart option set to :permanent (the default).","ref":"Supervisor.html","title":"Supervisor","type":"behaviour"},{"doc":"Builds and overrides a child specification. Similar to start_link/2 and init/2 , it expects a module , {module, arg} or a map as the child specification. If a module is given, the specification is retrieved by calling module.child_spec(arg) . After the child specification is retrieved, the fields on overrides are directly applied on the child spec. If overrides has keys that do not map to any child specification field, an error is raised. See the &quot;Child specification&quot; section in the module documentation for all of the available keys for overriding. Examples This function is often used to set an :id option when the same module needs to be started multiple times in the supervision tree: Supervisor . child_spec ( { Agent , fn -&gt; :ok end } , id : { Agent , 1 } ) #=&gt; %{id: {Agent, 1}, #=&gt; start: {Agent, :start_link, [fn -&gt; :ok end]}}","ref":"Supervisor.html#child_spec/2","title":"Supervisor.child_spec/2","type":"function"},{"doc":"Returns a map containing count values for the given supervisor. The map contains the following keys: :specs - the total count of children, dead or alive :active - the count of all actively running child processes managed by this supervisor :supervisors - the count of all supervisors whether or not these child supervisors are still alive :workers - the count of all workers, whether or not these child workers are still alive","ref":"Supervisor.html#count_children/1","title":"Supervisor.count_children/1","type":"function"},{"doc":"Deletes the child specification identified by child_id . The corresponding child process must not be running; use terminate_child/2 to terminate it if it's running. If successful, this function returns :ok . This function may return an error with an appropriate error tuple if the child_id is not found, or if the current process is running or being restarted.","ref":"Supervisor.html#delete_child/2","title":"Supervisor.delete_child/2","type":"function"},{"doc":"Callback invoked to start the supervisor and during hot code upgrades. Developers typically invoke Supervisor.init/2 at the end of their init callback to return the proper supervision flags.","ref":"Supervisor.html#c:init/1","title":"Supervisor.init/1","type":"callback"},{"doc":"Receives a list of children to initialize and a set of options . This is typically invoked at the end of the init/1 callback of module-based supervisors. See the sections &quot;Module-based supervisors&quot; and &quot;start_link/2, init/2, and strategies&quot; in the module documentation for more information. This function returns a tuple containing the supervisor flags and child specifications. Examples def init ( _init_arg ) do children = [ { Stack , [ :hello ] } ] Supervisor . init ( children , strategy : :one_for_one ) end Options :strategy - the supervision strategy option. It can be either :one_for_one , :rest_for_one , or :one_for_all :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in seconds in which :max_restarts applies. Defaults to 5 . The :strategy option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the Supervisor module for a detailed description of the available strategies.","ref":"Supervisor.html#init/2","title":"Supervisor.init/2","type":"function"},{"doc":"Restarts a child process identified by child_id . The child specification must exist and the corresponding child process must not be running. Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children. If the child process start function returns {:ok, child} or {:ok, child, info} , the PID is added to the supervisor and this function returns the same value. If the child process start function returns :ignore , the PID remains set to :undefined and this function returns {:ok, :undefined} . This function may return an error with an appropriate error tuple if the child_id is not found, or if the current process is running or being restarted. If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns {:error, error} .","ref":"Supervisor.html#restart_child/2","title":"Supervisor.restart_child/2","type":"function"},{"doc":"Adds a child specification to supervisor and starts that child. child_spec should be a valid child specification. The child process will be started as defined in the child specification. If a child specification with the specified ID already exists, child_spec is discarded and this function returns an error with :already_started or :already_present if the corresponding child process is running or not, respectively. If the child process start function returns {:ok, child} or {:ok, child, info} , then child specification and PID are added to the supervisor and this function returns the same value. If the child process start function returns :ignore , the child specification is added to the supervisor, the PID is set to :undefined and this function returns {:ok, :undefined} . If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns {:error, error} where error is a term containing information about the error and child specification.","ref":"Supervisor.html#start_child/2","title":"Supervisor.start_child/2","type":"function"},{"doc":"Starts a supervisor with the given children. The children is a list of modules, two-element tuples with module and arguments or a map with the child specification. A strategy is required to be provided through the :strategy option. See &quot;start_link/2, init/2, and strategies&quot; for examples and other options. The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the GenServer module docs. If the supervisor and its child processes are successfully spawned (if the start function of each child process returns {:ok, child} , {:ok, child, info} , or :ignore ) this function returns {:ok, pid} , where pid is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns {:error, {:already_started, pid}} , where pid is the PID of that process. If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason :shutdown all the child processes that have already been started, and then terminates itself and returns {:error, {:shutdown, reason}} . Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with :normal reason.","ref":"Supervisor.html#start_link/2","title":"Supervisor.start_link/2","type":"function"},{"doc":"Starts a module-based supervisor process with the given module and init_arg . To start the supervisor, the init/1 callback will be invoked in the given module , with init_arg as its argument. The init/1 callback must return a supervisor specification which can be created with the help of the init/2 function. If the init/1 callback returns :ignore , this function returns :ignore as well and the supervisor terminates with reason :normal . If it fails or returns an incorrect value, this function returns {:error, term} where term is a term with information about the error, and the supervisor terminates with reason term . The :name option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the GenServer module docs.","ref":"Supervisor.html#start_link/3","title":"Supervisor.start_link/3","type":"function"},{"doc":"Synchronously stops the given supervisor with the given reason . It returns :ok if the supervisor terminates with the given reason. If it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"Supervisor.html#stop/3","title":"Supervisor.stop/3","type":"function"},{"doc":"Terminates the given child identified by child_id . The process is terminated, if there's one. The child specification is kept unless the child is temporary. A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling restart_child/2 . Use delete_child/2 to remove the child specification. If successful, this function returns :ok . If there is no child specification for the given child ID, this function returns {:error, :not_found} .","ref":"Supervisor.html#terminate_child/2","title":"Supervisor.terminate_child/2","type":"function"},{"doc":"Returns a list with information about all children of the given supervisor. Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception. This function returns a list of {id, child, type, modules} tuples, where: id - as defined in the child specification child - the PID of the corresponding child process, :restarting if the process is about to be restarted, or :undefined if there is no such process type - :worker or :supervisor , as specified by the child specification modules - as specified by the child specification","ref":"Supervisor.html#which_children/1","title":"Supervisor.which_children/1","type":"function"},{"doc":"","ref":"Supervisor.html#t:child/0","title":"Supervisor.child/0","type":"type"},{"doc":"The supervisor specification","ref":"Supervisor.html#t:child_spec/0","title":"Supervisor.child_spec/0","type":"type"},{"doc":"Options given to start_link/2 and init/2","ref":"Supervisor.html#t:init_option/0","title":"Supervisor.init_option/0","type":"type"},{"doc":"The Supervisor name","ref":"Supervisor.html#t:name/0","title":"Supervisor.name/0","type":"type"},{"doc":"Return values of start_link functions","ref":"Supervisor.html#t:on_start/0","title":"Supervisor.on_start/0","type":"type"},{"doc":"Return values of start_child functions","ref":"Supervisor.html#t:on_start_child/0","title":"Supervisor.on_start_child/0","type":"type"},{"doc":"Option values used by the start* functions","ref":"Supervisor.html#t:option/0","title":"Supervisor.option/0","type":"type"},{"doc":"Supported strategies","ref":"Supervisor.html#t:strategy/0","title":"Supervisor.strategy/0","type":"type"},{"doc":"The supervisor reference","ref":"Supervisor.html#t:supervisor/0","title":"Supervisor.supervisor/0","type":"type"},{"doc":"Conveniences for spawning and awaiting tasks. Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously: task = Task . async ( fn -&gt; do_some_work ( ) end ) res = do_some_other_work ( ) res + Task . await ( task ) Tasks spawned with async can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed. Besides async/1 and await/2 , tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. We will explore these scenarios next. async and await One of the common uses of tasks is to convert sequential code into concurrent code with Task.async/1 while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result. Task.await/2 is used to read the message sent by the task. There are two important things to consider when using async : If you are using async tasks, you must await a reply as they are always sent. If you are not expecting a reply, consider using Task.start_link/1 detailed below. async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation. If this is not desired, you will want to use supervised tasks, described next. Dynamically supervised tasks The Task.Supervisor module allows developers to dynamically create multiple supervised tasks. A short example is: { :ok , pid } = Task.Supervisor . start_link ( ) task = Task.Supervisor . async ( pid , fn -&gt; # Do something end ) Task . await ( task ) However, in the majority of cases, you want to add the task supervisor to your supervision tree: Supervisor . start_link ( [ { Task.Supervisor , name : MyApp.TaskSupervisor } ] , strategy : :one_for_one ) And now you can use async/await once again passig the name of the supervisor isntead of the pid: Task.Supervisor . async ( MyApp.TaskSupervisor , fn -&gt; # Do something end ) |&gt; Task . await ( ) We encourage developers to rely on supervised tasks as much as possible. Supervised tasks enable a huge variety of patterns which allows you explicit control on how to handle the results, errors, and timeouts. Here is a summary: Use Task.Supervisor.start_child/2 to start a fire-and-forget task and you don't care about its results nor about if it completes successfully Use Task.Supervisor.async/2 + Task.await/2 allows you to execute tasks concurrently and retrieve its result. If the task fails, the caller will also fail Use Task.Supervisor.async_nolink/2 + Task.yield/2 + Task.shutdown/2 allows you to execute tasks concurrently and retrieve their results or the reason they failed within a given time frame. If the task fails, the caller won't fail: you will receive the error reason either on yield or shutdown See the Task.Supervisor module for details on the supported operations. Distributed tasks Since Elixir provides a Task.Supervisor , it is easy to use one to dynamically start tasks across nodes: # On the remote node Task.Supervisor . start_link ( name : MyApp.DistSupervisor ) # On the client supervisor = { MyApp.DistSupervisor , :remote@local } Task.Supervisor . async ( supervisor , MyMod , :my_fun , [ arg1 , arg2 , arg3 ] ) Note that, when working with distributed tasks, one should use the Task.Supervisor.async/4 function that expects explicit module, function, and arguments, instead of Task.Supervisor.async/2 that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the Agent module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem. Statically supervised tasks The Task module implements the child_spec/1 function, which allows it to be started directly under a regular Supervisor - instead of a Task.Supervisor - by passing a tuple with a function to run: Supervisor . start_link ( [ { Task , fn -&gt; :some_work end } ] , strategy : :one_for_one ) This is often useful when you need to execute some steps while setting up your supervision tree. For example: to warm up caches, log the initialization status, etc. If you don't want to put the Task code directly under the Supervisor , you can wrap the Task in its own module, similar to how you would do with a GenServer or an Agent : defmodule MyTask do use Task def start_link ( arg ) do Task . start_link ( __MODULE__ , :run , [ arg ] ) end def run ( arg ) do # ... end end And then passing it to the supervisor: Supervisor . start_link ( [ { MyTask , arg } ] , strategy : :one_for_one ) Since these tasks are supervised and not directly linked to the caller, they cannot be awaited on. By default, the functions Task.start and Task.start_link are for fire-and-forget tasks, where you don't care about the results or if it completes successfully or not. use Task defines a child_spec/1 function, allowing the defined module to be put under a supervision tree. The generated child_spec/1 can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the child should be restarted, defaults to :temporary :shutdown - how to shut down the child, either immediately or by giving it time to shut down Opposite to GenServer , Agent and Supervisor , a Task has a default :restart of :temporary . This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do: use Task , restart : :transient If you want the task to always be restarted: use Task , restart : :permanent See the &quot;Child specification&quot; section in the Supervisor module for more detailed information. The @doc annotation immediately preceding use Task will be attached to the generated child_spec/1 function. Ancestor and Caller Tracking Whenever you start a new process, Elixir annotates the parent of that process through the $ancestors key in the process dictionary. This is often used to track the hierarchy inside a supervision tree. For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like Task.Supervisor.start_child(MySupervisor, task_specification) . This means that, although your code is the one who invokes the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it. To track the relationship between your code and the task, we use the $callers key in the process dictionary. Therefore, assuming the Task.Supervisor call above, we have: [ your code ] -- calls -- &gt; [ supervisor ] -- -- spawns -- &gt; [ task ] Which means we store the following relationships: [ your code ] [ supervisor ] &lt;- - ancestor -- [ task ] ^ | | -- -- -- -- -- -- -- -- -- -- - caller -- -- -- -- -- -- -- -- -- -- - | The list of callers of the current process can be retrieved from the Process dictionary with Process.get(:&quot;$callers&quot;) . This will return either nil or a list [pid_n, ..., pid2, pid1] with at least one entry Where pid_n is the PID that called the current process, pid2 called pid_n , and pid2 was called by pid1 . If a task crashes, the callers field is included as part of the log message metadata under the :callers key.","ref":"Task.html","title":"Task","type":"module"},{"doc":"The Task struct. It contains these fields: :pid - the PID of the task process; nil if the task does not use a task process :ref - the task monitor reference :owner - the PID of the process that started the task","ref":"Task.html#__struct__/0","title":"Task.__struct__/0","type":"function"},{"doc":"Starts a task that must be awaited on. fun must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A Task struct is returned containing the relevant information. Developers must eventually call Task.await/2 or Task.yield/2 followed by Task.shutdown/2 on the returned task. Read the Task module documentation for more information about the general usage of async tasks. Linking This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this: x = heavy_fun ( ) y = some_fun ( ) x + y Now you want to make the heavy_fun() async: x = Task . async ( &amp; heavy_fun / 0 ) y = some_fun ( ) Task . await ( x ) + y As before, if heavy_fun/0 fails, the whole computation will fail, including the parent process. If you don't want the task to fail then you must change the heavy_fun/0 code in the same way you would achieve it if you didn't have the async call. For example, to either return {:ok, val} | :error results or, in more extreme cases, by using try/rescue . In other words, an asynchronous task should be thought of as an extension of a process rather than a mechanism to isolate it from all errors. If you don't want to link the caller to the task, then you must use a supervised task with Task.Supervisor and call Task.Supervisor.async_nolink/2 . In any case, avoid any of the following: Setting :trap_exit to true - trapping exits should be used only in special circumstances as it would make your process immune to not only exits from the task but from any other processes. Moreover, even when trapping exits, calling await will still exit if the task has terminated without sending its result back. Unlinking the task process started with async / await . If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the parent dies.","ref":"Task.html#async/1","title":"Task.async/1","type":"function"},{"doc":"Starts a task that must be awaited on. Similar to async/1 except the function to be started is specified by the given module , function_name , and args .","ref":"Task.html#async/3","title":"Task.async/3","type":"function"},{"doc":"Returns a stream that runs the given function fun concurrently on each element in enumerable . Works the same as async_stream/5 but with an anonymous function instead of a module-function-arguments tuple. fun must be a one-arity anonymous function. Each enumerable element is passed as argument to the given function fun and processed by its own task. The tasks will be linked to the current process, similarly to async/1 . Example Count the code points in each string asynchronously, then add the counts together using reduce. iex&gt; strings = [ &quot;long string&quot; , &quot;longer string&quot; , &quot;there are many of these&quot; ] iex&gt; stream = Task . async_stream ( strings , fn text -&gt; text |&gt; String . codepoints ( ) |&gt; Enum . count ( ) end ) iex&gt; Enum . reduce ( stream , 0 , fn { :ok , num } , acc -&gt; num + acc end ) 47 See async_stream/5 for discussion, options, and more examples.","ref":"Task.html#async_stream/3","title":"Task.async_stream/3","type":"function"},{"doc":"Returns a stream where the given function ( module and function_name ) is mapped concurrently on each element in enumerable . Each element of enumerable will be prepended to the given args and processed by its own task. The tasks will be linked to an intermediate process that is then linked to the current process. This means a failure in a task terminates the current process and a failure in the current process terminates all tasks. When streamed, each task will emit {:ok, value} upon successful completion or {:exit, reason} if the caller is trapping exits. The order of results depends on the value of the :ordered option. The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below). Consider using Task.Supervisor.async_stream/6 to start tasks under a supervisor. If you find yourself trapping exits to handle exits inside the async stream, consider using Task.Supervisor.async_stream_nolink/6 to start tasks that are not linked to the calling process. Options :max_concurrency - sets the maximum number of tasks to run at the same time. Defaults to System.schedulers_online/0 . :ordered - whether the results should be returned in the same order as the input stream. When the output is ordered, Elixir may need to buffer results to emit them in the original order. Setting this option to false disables the need to buffer at the cost of removing ordering. This is also useful when you're using the tasks only for the side effects. Note that regardless of what :ordered is set to, the tasks will process asynchronously. If you need to process elements in order, consider using Enum.map/2 or Enum.each/2 instead. Defaults to true . :timeout - the maximum amount of time (in milliseconds or :infinity ) each task is allowed to execute for. Defaults to 5000 . :on_timeout - what to do when a task times out. The possible values are: :exit (default) - the process that spawned the tasks exits. :kill_task - the task that timed out is killed. The value emitted for that task is {:exit, :timeout} . Example Let's build a stream and then enumerate it: stream = Task . async_stream ( collection , Mod , :expensive_fun , [ ] ) Enum . to_list ( stream ) The concurrency can be increased or decreased using the :max_concurrency option. For example, if the tasks are IO heavy, the value can be increased: max_concurrency = System . schedulers_online ( ) * 2 stream = Task . async_stream ( collection , Mod , :expensive_fun , [ ] , max_concurrency : max_concurrency ) Enum . to_list ( stream ) If you do not care about the results of the computation, you can run the stream with Stream.run/1 . Also set ordered: false , as you don't care about the order of the results either: stream = Task . async_stream ( collection , Mod , :expensive_fun , [ ] , ordered : false ) Stream . run ( stream ) Attention: async + take Given items in an async stream are processed concurrently, doing async_stream followed by Enum.take/2 may cause more items than requested to be processed. Let's see an example: 1 . . 100 |&gt; Task . async_stream ( fn i -&gt; Process . sleep ( 100 ) IO . puts ( to_string ( i ) ) end ) |&gt; Enum . take ( 10 ) For a machine with 8 cores, the above will process 16 items instead of 10. The reason is that async_stream/5 always have 8 elements processing at once. So by the time Enum says it got all elements it needed, there are still 6 elements left to be processed. The solution here is to use Stream.take/2 instead of Enum.take/2 to filter elements before-hand: 1 . . 100 |&gt; Stream . take ( 10 ) |&gt; Task . async_stream ( fn i -&gt; Process . sleep ( 100 ) IO . puts ( to_string ( i ) ) end ) |&gt; Enum . to_list ( ) If for some reason you cannot take the elements before hand, you can use :max_concurrency to limit how many elements may be over processed at the cost of reducing concurrency.","ref":"Task.html#async_stream/5","title":"Task.async_stream/5","type":"function"},{"doc":"Awaits a task reply and returns it. In case the task process dies, the current process will exit with the same reason as the task. A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with async , then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run. This function assumes the task's monitor is still active or the monitor's :DOWN message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message. This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use yield/2 instead. Examples iex&gt; task = Task . async ( fn -&gt; 1 + 1 end ) iex&gt; Task . await ( task ) 2 Compatibility with OTP behaviours It is not recommended to await a long-running task inside an OTP behaviour such as GenServer . Instead, you should match on the message coming from a task inside your GenServer.handle_info/2 callback. A GenServer will receive two messages on handle_info/2 : {ref, result} - the reply message where ref is the monitor reference returned by the task.ref and result is the task result {:DOWN, ref, :process, pid, reason} - since all tasks are also monitored, you will also receive the :DOWN message delivered by Process.monitor/1 . If you receive the :DOWN message without a a reply, it means the task crashed Another consideration to have in mind is that tasks started by Task.async/1 are always linked to their callers and you may not want the GenServer to crash if the task crashes. Therefore, it is preferable to instead use Task.Supervisor.async_nolink/3 inside OTP behaviours. For completeness, here is an example of a GenServer that start tasks and handles their results: defmodule GenServerTaskExample do use GenServer def start_link ( opts ) do GenServer . start_link ( __MODULE__ , :ok , opts ) end def init ( _opts ) do # We will keep all running tasks in a map { :ok , %{ tasks : %{ } } } end # Imagine we invoke a task from the GenServer to access a URL... def handle_call ( :some_message , _from , state ) do url = ... task = Task.Supervisor . async_nolink ( MyApp.TaskSupervisor , fn -&gt; fetch_url ( url ) end ) # After we start the task, we store its reference and the url it is fetching state = put_in ( state . tasks [ task . ref ] , url ) { :reply , :ok , state } end # If the task succeeds... def handle_info ( { ref , result } , state ) do # The task succeed so we can cancel the monitoring and discard the DOWN message Process . demonitor ( ref , [ :flush ] ) { url , state } = pop_in ( state . tasks [ ref ] ) IO . puts &quot;Got \#{ inspect ( result ) } for URL \#{ inspect url } &quot; { :noreply , state } end # If the task fails... def handle_info ( { :DOWN , ref , _ , _ , reason } , state ) do { url , state } = pop_in ( state . tasks [ ref ] ) IO . puts &quot;URL \#{ inspect url } failed with reason \#{ inspect ( reason ) } &quot; { :noreply , state } end end With the server defined, you will want to start the task supervisor above and the GenServer in your supervision tree: children = [ { Task.Supervisor , name : MyApp.TaskSupervisor } , { GenServerTaskExample , name : MyApp.GenServerTaskExample } ] Supervisor . start_link ( children , strategy : :one_for_one )","ref":"Task.html#await/2","title":"Task.await/2","type":"function"},{"doc":"Awaits replies from multiple tasks and returns them. This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of the results, in the same order as the tasks supplied in the tasks input argument. If any of the task processes dies, the current process will exit with the same reason as that task. A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . If the timeout is exceeded, then the current process will exit. Any task processes that are linked to the current process (which is the case when a task is started with async ) will also exit. Any task processes that are trapping exits or not linked to the current process will continue to run. This function assumes the tasks' monitors are still active or the monitors' :DOWN message is in the message queue. If any tasks have been demonitored, or the message already received, this function will wait for the duration of the timeout. This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use yield_many/2 instead. Compatibility with OTP behaviours It is not recommended to await long-running tasks inside an OTP behaviour such as GenServer . See await/2 for more information. Examples iex&gt; tasks = [ ...&gt; Task . async ( fn -&gt; 1 + 1 end ) , ...&gt; Task . async ( fn -&gt; 2 + 3 end ) ...&gt; ] iex&gt; Task . await_many ( tasks ) [ 2 , 5 ]","ref":"Task.html#await_many/2","title":"Task.await_many/2","type":"function"},{"doc":"Returns a specification to start a task under a supervisor. arg is passed as the argument to Task.start_link/1 in the :start field of the spec. For more information, see the Supervisor module, the Supervisor.child_spec/2 function and the Supervisor.child_spec/0 type.","ref":"Task.html#child_spec/1","title":"Task.child_spec/1","type":"function"},{"doc":"Unlinks and shuts down the task, and then checks for a reply. Returns {:ok, reply} if the reply is received while shutting down the task, {:exit, reason} if the task died, otherwise nil . The second argument is either a timeout or :brutal_kill . In case of a timeout, a :shutdown exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With :brutal_kill the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason. It is not required to call this function when terminating the caller, unless exiting with reason :normal or if the task is trapping exits. If the caller is exiting with a reason other than :normal and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason :shutdown to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages. If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return {:exit, :noproc} as the result or exit reason can not be determined.","ref":"Task.html#shutdown/2","title":"Task.shutdown/2","type":"function"},{"doc":"Starts a task. fun must be a zero-arity anonymous function. This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully. If the current node is shutdown, the node will terminate even if the task was not completed. For this reason, we recommend to use Task.Supervisor.start_child/2 instead, which allows you to control the shutdown time via the :shutdown option.","ref":"Task.html#start/1","title":"Task.start/1","type":"function"},{"doc":"Starts a task. This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully. If the current node is shutdown, the node will terminate even if the task was not completed. For this reason, we recommend to use Task.Supervisor.start_child/2 instead, which allows you to control the shutdown time via the :shutdown option.","ref":"Task.html#start/3","title":"Task.start/3","type":"function"},{"doc":"Starts a task as part of a supervision tree with the given fun . fun must be a zero-arity anonymous function. This is used to start a statically supervised task under a supervision tree.","ref":"Task.html#start_link/1","title":"Task.start_link/1","type":"function"},{"doc":"Starts a task as part of a supervision tree with the given module , function , and args . This is used to start a statically supervised task under a supervision tree.","ref":"Task.html#start_link/3","title":"Task.start_link/3","type":"function"},{"doc":"Temporarily blocks the current process waiting for a task reply. Returns {:ok, reply} if the reply is received, nil if no reply has arrived, or {:exit, reason} if the task has already exited. Keep in mind that normally a task failure also causes the process owning the task to exit. Therefore this function can return {:exit, reason} only if the task process exited with the reason :normal it isn't linked to the caller the caller is trapping exits A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . If the time runs out before a message from the task is received, this function will return nil and the monitor will remain active. Therefore yield/2 can be called multiple times on the same task. This function assumes the task's monitor is still active or the monitor's :DOWN message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message. If you intend to shut the task down if it has not responded within timeout milliseconds, you should chain this together with shutdown/1 , like so: case Task . yield ( task , timeout ) || Task . shutdown ( task ) do { :ok , result } -&gt; result nil -&gt; Logger . warn ( &quot;Failed to get a result in \#{ timeout } ms&quot; ) nil end That ensures that if the task completes after the timeout but before shutdown/1 has been called, you will still get the result, since shutdown/1 is designed to handle this case and return the result.","ref":"Task.html#yield/2","title":"Task.yield/2","type":"function"},{"doc":"Yields to multiple tasks in the given time interval. This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the tasks input argument. Similarly to yield/2 , each task's result will be {:ok, term} if the task has successfully reported its result back in the given time interval {:exit, reason} if the task has died nil if the task keeps running past the timeout A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . Check yield/2 for more information. Example Task.yield_many/2 allows developers to spawn multiple tasks and retrieve the results received in a given timeframe. If we combine it with Task.shutdown/2 , it allows us to gather those results and cancel the tasks that have not replied in time. Let's see an example. tasks = for i &lt;- 1 . . 10 do Task . async ( fn -&gt; Process . sleep ( i * 1000 ) i end ) end tasks_with_results = Task . yield_many ( tasks , 5000 ) results = Enum . map ( tasks_with_results , fn { task , res } -&gt; # Shut down the tasks that did not reply nor exit res || Task . shutdown ( task , :brutal_kill ) end ) # Here we are matching only on {:ok, value} and # ignoring {:exit, _} (crashed tasks) and `nil` (no replies) for { :ok , value } &lt;- results do IO . inspect ( value ) end In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the Task.shutdown/2 call.","ref":"Task.html#yield_many/2","title":"Task.yield_many/2","type":"function"},{"doc":"The Task type. See %Task{} for information about each field of the structure.","ref":"Task.html#t:t/0","title":"Task.t/0","type":"type"},{"doc":"A task supervisor. This module defines a supervisor which can be used to dynamically supervise tasks. A task supervisor is started with no children, often under a supervisor and a name: children = [ { Task.Supervisor , name : MyApp.TaskSupervisor } ] Supervisor . start_link ( children , strategy : :one_for_one ) The options given in the child specification are documented in start_link/1 . See the Task module for more examples. Name registration A Task.Supervisor is bound to the same name registration rules as a GenServer . Read more about them in the GenServer docs.","ref":"Task.Supervisor.html","title":"Task.Supervisor","type":"module"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task will still be linked to the caller, see Task.async/3 for more information and async_nolink/2 for a non-linked variant. Raises an error if supervisor has reached the maximum number of children. Options :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.","ref":"Task.Supervisor.html#async/3","title":"Task.Supervisor.async/3","type":"function"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task will still be linked to the caller, see Task.async/3 for more information and async_nolink/2 for a non-linked variant. Raises an error if supervisor has reached the maximum number of children. Options :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.","ref":"Task.Supervisor.html#async/5","title":"Task.Supervisor.async/5","type":"function"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task won't be linked to the caller, see Task.async/3 for more information. Raises an error if supervisor has reached the maximum number of children. Options :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds. Compatibility with OTP behaviours If you create a task using async_nolink inside an OTP behaviour like GenServer , you should match on the message coming from the task inside your GenServer.handle_info/2 callback. The reply sent by the task will be in the format {ref, result} , where ref is the monitor reference held by the task struct and result is the return value of the task function. Keep in mind that, regardless of how the task created with async_nolink terminates, the caller's process will always receive a :DOWN message with the same ref value that is held by the task struct. If the task terminates normally, the reason in the :DOWN message will be :normal . Examples Typically, you use async_nolink/3 when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a GenServer is meant to run a single task and track its status: defmodule MyApp.Server do use GenServer # ... def start_task do GenServer . call ( __MODULE__ , :start_task ) end # In this case the task is already running, so we just return :ok. def handle_call ( :start_task , _from , %{ ref : ref } = state ) when is_reference ( ref ) do { :reply , :ok , state } end # The task is not running yet, so let&#39;s start it. def handle_call ( :start_task , _from , %{ ref : nil } = state ) do task = Task.Supervisor . async_nolink ( MyApp.TaskSupervisor , fn -&gt; ... end ) # We return :ok and the server will continue running { :reply , :ok , %{ state | ref : task . ref } } end # The task completed successfully def handle_info ( { ref , answer } , %{ ref : ref } = state ) do # We don&#39;t care about the DOWN message now, so let&#39;s demonitor and flush it Process . demonitor ( ref , [ :flush ] ) # Do something with the result and then return { :noreply , %{ state | ref : nil } } end # The task failed def handle_info ( { :DOWN , ref , :process , _pid , _reason } , %{ ref : ref } = state ) do # Log and possibly restart the task... { :noreply , %{ state | ref : nil } } end end","ref":"Task.Supervisor.html#async_nolink/3","title":"Task.Supervisor.async_nolink/3","type":"function"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task won't be linked to the caller, see Task.async/3 for more information. Raises an error if supervisor has reached the maximum number of children. Note this function requires the task supervisor to have :temporary as the :restart option (the default), as async_nolink/4 keeps a direct reference to the task which is lost if the task is restarted.","ref":"Task.Supervisor.html#async_nolink/5","title":"Task.Supervisor.async_nolink/5","type":"function"},{"doc":"Returns a stream that runs the given function fun concurrently on each element in enumerable . Each element in enumerable is passed as argument to the given function fun and processed by its own task. The tasks will be spawned under the given supervisor and linked to the current process, similarly to async/2 . See async_stream/6 for discussion, options, and examples.","ref":"Task.Supervisor.html#async_stream/4","title":"Task.Supervisor.async_stream/4","type":"function"},{"doc":"Returns a stream where the given function ( module and function ) is mapped concurrently on each element in enumerable . Each element will be prepended to the given args and processed by its own task. The tasks will be spawned under the given supervisor and linked to the current process, similarly to async/4 . When streamed, each task will emit {:ok, value} upon successful completion or {:exit, reason} if the caller is trapping exits. The order of results depends on the value of the :ordered option. The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below). If you find yourself trapping exits to handle exits inside the async stream, consider using async_stream_nolink/6 to start tasks that are not linked to the calling process. Options :max_concurrency - sets the maximum number of tasks to run at the same time. Defaults to System.schedulers_online/0 . :ordered - whether the results should be returned in the same order as the input stream. This option is useful when you have large streams and don't want to buffer results before they are delivered. This is also useful when you're using the tasks for side effects. Defaults to true . :timeout - the maximum amount of time to wait (in milliseconds) without receiving a task reply (across all running tasks). Defaults to 5000 . :on_timeout - what do to when a task times out. The possible values are: :exit (default) - the process that spawned the tasks exits. :kill_task - the task that timed out is killed. The value emitted for that task is {:exit, :timeout} . :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value. Defaults to 5000 milliseconds. Examples Let's build a stream and then enumerate it: stream = Task.Supervisor . async_stream ( MySupervisor , collection , Mod , :expensive_fun , [ ] ) Enum . to_list ( stream )","ref":"Task.Supervisor.html#async_stream/6","title":"Task.Supervisor.async_stream/6","type":"function"},{"doc":"Returns a stream that runs the given function concurrently on each element in enumerable . Each element in enumerable is passed as argument to the given function fun and processed by its own task. The tasks will be spawned under the given supervisor and will not be linked to the current process, similarly to async_nolink/2 . See async_stream/6 for discussion and examples.","ref":"Task.Supervisor.html#async_stream_nolink/4","title":"Task.Supervisor.async_stream_nolink/4","type":"function"},{"doc":"Returns a stream where the given function ( module and function ) is mapped concurrently on each element in enumerable . Each element in enumerable will be prepended to the given args and processed by its own task. The tasks will be spawned under the given supervisor and will not be linked to the current process, similarly to async_nolink/4 . See async_stream/6 for discussion, options, and examples.","ref":"Task.Supervisor.html#async_stream_nolink/6","title":"Task.Supervisor.async_stream_nolink/6","type":"function"},{"doc":"Returns all children PIDs.","ref":"Task.Supervisor.html#children/1","title":"Task.Supervisor.children/1","type":"function"},{"doc":"Starts a task as a child of the given supervisor . Task.Supervisor . start_child ( MyTaskSupervisor , fn -&gt; IO . puts &quot;I am running in a task&quot; end ) Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and you have no interest on its results nor if it completes successfully. Options :restart - the restart strategy, may be :temporary (the default), :transient or :permanent . :temporary means the task is never restarted, :transient means it is restarted if the exit is not :normal , :shutdown or {:shutdown, reason} . A :permanent restart strategy means it is always restarted. It defaults to :temporary . :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.","ref":"Task.Supervisor.html#start_child/3","title":"Task.Supervisor.start_child/3","type":"function"},{"doc":"Starts a task as a child of the given supervisor . Similar to start_child/2 except the task is specified by the given module , fun and args .","ref":"Task.Supervisor.html#start_child/5","title":"Task.Supervisor.start_child/5","type":"function"},{"doc":"Starts a new supervisor. Examples A task supervisor is typically started under a supervision tree using the tuple format: { Task.Supervisor , name : MyApp.TaskSupervisor } You can also start it by calling start_link/1 directly: Task.Supervisor . start_link ( name : MyApp.TaskSupervisor ) But this is recommended only for scripting and should be avoided in production code. Generally speaking, processes should always be started inside supervision trees. Options :name - used to register a supervisor name, the supported values are described under the Name Registration section in the GenServer module docs; :max_restarts , :max_seconds , and :max_children - as specified in DynamicSupervisor ; This function could also receive :restart and :shutdown as options but those two options have been deprecated and it is now preferred to give them directly to start_child and async .","ref":"Task.Supervisor.html#start_link/1","title":"Task.Supervisor.start_link/1","type":"function"},{"doc":"Terminates the child with the given pid .","ref":"Task.Supervisor.html#terminate_child/2","title":"Task.Supervisor.terminate_child/2","type":"function"},{"doc":"Option values used by start_link","ref":"Task.Supervisor.html#t:option/0","title":"Task.Supervisor.option/0","type":"type"},{"doc":"A protocol to traverse data structures. The Enum.into/2 function uses this protocol to insert an enumerable into a collection: iex&gt; Enum . into ( [ a : 1 , b : 2 ] , %{ } ) %{ a : 1 , b : 2 } Why Collectable? The Enumerable protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the Enumerable protocol do not keep shape. For example, passing a map to Enum.map/2 always returns a list. This design is intentional. Enumerable was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored. The Collectable module was designed to fill the gap left by the Enumerable protocol. Collectable.into/1 can be seen as the opposite of Enumerable.reduce/3 . If the functions in Enumerable are about taking values out, then Collectable.into/1 is about collecting those values into a structure. Examples To show how to manually use the Collectable protocol, let's play with a simplified implementation for MapSet . iex&gt; { initial_acc , collector_fun } = Collectable . into ( MapSet . new ( ) ) iex&gt; updated_acc = Enum . reduce ( [ 1 , 2 , 3 ] , initial_acc , fn elem , acc -&gt; ...&gt; collector_fun . ( acc , { :cont , elem } ) ...&gt; end ) iex&gt; collector_fun . ( updated_acc , :done ) # MapSet &lt; [ 1 , 2 , 3 ] &gt; To show how the protocol can be implemented, we can again look at the simplified implementation for MapSet . In this implementation &quot;collecting&quot; elements simply means inserting them in the set through MapSet.put/2 . defimpl Collectable , for : MapSet do def into ( map_set ) do collector_fun = fn map_set_acc , { :cont , elem } -&gt; MapSet . put ( map_set_acc , elem ) map_set_acc , :done -&gt; map_set_acc _map_set_acc , :halt -&gt; :ok end initial_acc = map_set { initial_acc , collector_fun } end end So now we can call Enum.into/2 : iex&gt; Enum . into ( [ 1 , 2 , 3 ] , MapSet . new ( ) ) # MapSet &lt; [ 1 , 2 , 3 ] &gt;","ref":"Collectable.html","title":"Collectable","type":"protocol"},{"doc":"Returns an initial accumulator and a &quot;collector&quot; function. Receives a collectable which can be used as the initial accumulator that will be passed to the function. The collector function receives a term and a command and injects the term into the collectable accumulator on every {:cont, term} command. :done is passed as a command when no further values will be injected. This is useful when there's a need to close resources or normalizing values. A collectable must be returned when the command is :done . If injection is suddenly interrupted, :halt is passed and the function can return any value as it won't be used. For examples on how to use the Collectable protocol and into/1 see the module documentation.","ref":"Collectable.html#into/1","title":"Collectable.into/1","type":"function"},{"doc":"","ref":"Collectable.html#t:command/0","title":"Collectable.command/0","type":"type"},{"doc":"","ref":"Collectable.html#t:t/0","title":"Collectable.t/0","type":"type"},{"doc":"Enumerable protocol used by Enum and Stream modules. When you invoke a function in the Enum module, the first argument is usually a collection that must implement this protocol. For example, the expression: Enum . map ( [ 1 , 2 , 3 ] , &amp; ( &amp;1 * 2 ) ) invokes Enumerable.reduce/3 to perform the reducing operation that builds a mapped list by calling the mapping function &amp;(&amp;1 * 2) on every element in the collection and consuming the element with an accumulated list. Internally, Enum.map/2 is implemented as follows: def map ( enumerable , fun ) do reducer = fn x , acc -&gt; { :cont , [ fun . ( x ) | acc ] } end Enumerable . reduce ( enumerable , { :cont , [ ] } , reducer ) |&gt; elem ( 1 ) |&gt; :lists . reverse ( ) end Note that the user-supplied function is wrapped into a reducer/0 function. The reducer/0 function must return a tagged tuple after each step, as described in the acc/0 type. At the end, Enumerable.reduce/3 returns result/0 . This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the zip/1 and zip/2 functions). This protocol requires four functions to be implemented, reduce/3 , count/1 , member?/2 , and slice/1 . The core of the protocol is the reduce/3 function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.","ref":"Enumerable.html","title":"Enumerable","type":"protocol"},{"doc":"Retrieves the number of elements in the enumerable . It should return {:ok, count} if you can count the number of elements in enumerable without traversing it. Otherwise it should return {:error, __MODULE__} and a default algorithm built on top of reduce/3 that runs in linear time will be used.","ref":"Enumerable.html#count/1","title":"Enumerable.count/1","type":"function"},{"doc":"Checks if an element exists within the enumerable . It should return {:ok, boolean} if you can check the membership of a given element in enumerable with ===/2 without traversing the whole of it. Otherwise it should return {:error, __MODULE__} and a default algorithm built on top of reduce/3 that runs in linear time will be used. When called outside guards, the in and not in operators work by using this function.","ref":"Enumerable.html#member?/2","title":"Enumerable.member?/2","type":"function"},{"doc":"Reduces the enumerable into an element. Most of the operations in Enum are implemented in terms of reduce. This function should apply the given reducer/0 function to each element in the enumerable and proceed as expected by the returned accumulator. See the documentation of the types result/0 and acc/0 for more information. Examples As an example, here is the implementation of reduce for lists: def reduce ( _list , { :halt , acc } , _fun ) , do : { :halted , acc } def reduce ( list , { :suspend , acc } , fun ) , do : { :suspended , acc , &amp; reduce ( list , &amp;1 , fun ) } def reduce ( [ ] , { :cont , acc } , _fun ) , do : { :done , acc } def reduce ( [ head | tail ] , { :cont , acc } , fun ) , do : reduce ( tail , fun . ( head , acc ) , fun )","ref":"Enumerable.html#reduce/3","title":"Enumerable.reduce/3","type":"function"},{"doc":"Returns a function that slices the data structure contiguously. It should return {:ok, size, slicing_fun} if the enumerable has a known bound and can access a position in the enumerable without traversing all previous elements. Otherwise it should return {:error, __MODULE__} and a default algorithm built on top of reduce/3 that runs in linear time will be used. Differences to count/1 The size value returned by this function is used for boundary checks, therefore it is extremely important that this function only returns :ok if retrieving the size of the enumerable is cheap, fast and takes constant time. Otherwise the simplest of operations, such as Enum.at(enumerable, 0) , will become too expensive. On the other hand, the count/1 function in this protocol should be implemented whenever you can count the number of elements in the collection without traversing it.","ref":"Enumerable.html#slice/1","title":"Enumerable.slice/1","type":"function"},{"doc":"The accumulator value for each step. It must be a tagged tuple with one of the following &quot;tags&quot;: :cont - the enumeration should continue :halt - the enumeration should halt immediately :suspend - the enumeration should be suspended immediately Depending on the accumulator value, the result returned by Enumerable.reduce/3 will change. Please check the result/0 type documentation for more information. In case a reducer/0 function returns a :suspend accumulator, it must be explicitly handled by the caller and never leak.","ref":"Enumerable.html#t:acc/0","title":"Enumerable.acc/0","type":"type"},{"doc":"A partially applied reduce function. The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result. A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.","ref":"Enumerable.html#t:continuation/0","title":"Enumerable.continuation/0","type":"type"},{"doc":"The reducer function. Should be called with the enumerable element and the accumulator contents. Returns the accumulator for the next enumeration step.","ref":"Enumerable.html#t:reducer/0","title":"Enumerable.reducer/0","type":"type"},{"doc":"The result of the reduce operation. It may be done when the enumeration is finished by reaching its end, or halted / suspended when the enumeration was halted or suspended by the reducer/0 function. In case a reducer/0 function returns the :suspend accumulator, the :suspended tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about :done and :halted results. Furthermore, a :suspend call must always be followed by another call, eventually halting or continuing until the end.","ref":"Enumerable.html#t:result/0","title":"Enumerable.result/0","type":"type"},{"doc":"A slicing function that receives the initial position and the number of elements in the slice. The start position is a number &gt;= 0 and guaranteed to exist in the enumerable . The length is a number &gt;= 1 in a way that start + length &lt;= count , where count is the maximum amount of elements in the enumerable. The function should return a non empty list where the amount of elements is equal to length .","ref":"Enumerable.html#t:slicing_fun/0","title":"Enumerable.slicing_fun/0","type":"type"},{"doc":"","ref":"Enumerable.html#t:t/0","title":"Enumerable.t/0","type":"type"},{"doc":"The Inspect protocol converts an Elixir data structure into an algebra document. This documentation refers to implementing the Inspect protocol for your own data structures. To learn more about using inspect, see Kernel.inspect/2 and IO.inspect/2 . The inspect/2 function receives the entity to be inspected followed by the inspecting options, represented by the struct Inspect.Opts . Building of the algebra document is done with Inspect.Algebra . Examples Many times, inspecting a structure can be implemented in function of existing entities. For example, here is MapSet 's inspect/2 implementation: defimpl Inspect , for : MapSet do import Inspect.Algebra def inspect ( map_set , opts ) do concat ( [ &quot;#MapSet&lt;&quot; , to_doc ( MapSet . to_list ( map_set ) , opts ) , &quot;&gt;&quot; ] ) end end The concat/1 function comes from Inspect.Algebra and it concatenates algebra documents together. In the example above it is concatenating the string &quot;#MapSet&lt;&quot; , the document returned by Inspect.Algebra.to_doc/2 , and the final string &quot;&gt;&quot; . We prefix the module name # to denote the inspect presentation is not actually valid Elixir syntax. Finally, note strings themselves are valid algebra documents that keep their formatting when pretty printed. This means your Inspect implementation may simply return a string, although that will devoid it of any pretty-printing. Error handling In case there is an error while your structure is being inspected, Elixir will raise an ArgumentError error and will automatically fall back to a raw representation for printing the structure. You can however access the underlying error by invoking the Inspect implementation directly. For example, to test Inspect.MapSet above, you can invoke it as: Inspect.MapSet . inspect ( MapSet . new ( ) , % Inspect.Opts { } ) Deriving The Inspect protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. This is especially useful for fields containing private information. The options :only and :except can be used with @derive to specify which fields should and should not appear in the algebra document: defmodule User do @derive { Inspect , only : [ :id , :name ] } defstruct [ :id , :name , :address ] end inspect ( % User { id : 1 , name : &quot;Homer&quot; , address : &quot;742 Evergreen Terrace&quot; } ) #=&gt; #User&lt;id: 1, name: &quot;Homer&quot;, ...&gt;","ref":"Inspect.html","title":"Inspect","type":"protocol"},{"doc":"Converts term into an algebra document. This function shouldn't be invoked directly, unless when implementing a custom inspect_fun to be given to Inspect.Opts . Everywhere else, Inspect.Algebra.to_doc/2 should be preferred as it handles structs and exceptions.","ref":"Inspect.html#inspect/2","title":"Inspect.inspect/2","type":"function"},{"doc":"","ref":"Inspect.html#t:t/0","title":"Inspect.t/0","type":"type"},{"doc":"A set of functions for creating and manipulating algebra documents. This module implements the functionality described in &quot;Strictly Pretty&quot; (2000) by Christian Lindig with small additions, like support for binary nodes and a break mode that maximises use of horizontal space. iex&gt; Inspect.Algebra . empty ( ) :doc_nil iex&gt; &quot;foo&quot; &quot;foo&quot; With the functions in this module, we can concatenate different elements together and render them: iex&gt; doc = Inspect.Algebra . concat ( Inspect.Algebra . empty ( ) , &quot;foo&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;foo&quot; ] The functions nest/2 , space/2 and line/2 help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like glue/3 and group/1 . A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it: iex&gt; doc = Inspect.Algebra . glue ( &quot;a&quot; , &quot; &quot; , &quot;b&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;a&quot; , &quot; &quot; , &quot;b&quot; ] Note that the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline: iex&gt; doc = Inspect.Algebra . glue ( String . duplicate ( &quot;a&quot; , 20 ) , &quot; &quot; , &quot;b&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 10 ) [ &quot;aaaaaaaaaaaaaaaaaaaa&quot; , &quot; \\n &quot; , &quot;b&quot; ] This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in string/1 , which then relies on String.length/1 to precompute the document size. Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, such as to_doc/2 . Implementation details The implementation of Inspect.Algebra is based on the Strictly Pretty paper by Lindig which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines). This implementation provides two types of breaks: :strict and :flex . When a group does not fit, all strict breaks are treated as newlines. Flex breaks however are re-evaluated on every occurrence and may still be rendered flat. See break/1 and flex_break/1 for more information. This implementation also adds force_unfit/1 and next_break_fits/2 which give more control over the document fitting.","ref":"Inspect.Algebra.html","title":"Inspect.Algebra","type":"module"},{"doc":"Returns a break document based on the given string . This break can be rendered as a linebreak or as the given string , depending on the mode of the chosen layout. Examples Let's create a document by concatenating two strings with a break between them: iex&gt; doc = Inspect.Algebra . concat ( [ &quot;a&quot; , Inspect.Algebra . break ( &quot; \\t &quot; ) , &quot;b&quot; ] ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;a&quot; , &quot; \\t &quot; , &quot;b&quot; ] Note that the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline: iex&gt; break = Inspect.Algebra . break ( &quot; \\t &quot; ) iex&gt; doc = Inspect.Algebra . concat ( [ String . duplicate ( &quot;a&quot; , 20 ) , break , &quot;b&quot; ] ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 10 ) [ &quot;aaaaaaaaaaaaaaaaaaaa&quot; , &quot; \\n &quot; , &quot;b&quot; ]","ref":"Inspect.Algebra.html#break/1","title":"Inspect.Algebra.break/1","type":"function"},{"doc":"Collapse any new lines and whitespace following this node, emitting up to max new lines.","ref":"Inspect.Algebra.html#collapse_lines/1","title":"Inspect.Algebra.collapse_lines/1","type":"function"},{"doc":"Colors a document if the color_key has a color in the options.","ref":"Inspect.Algebra.html#color/3","title":"Inspect.Algebra.color/3","type":"function"},{"doc":"Concatenates a list of documents returning a new document. Examples iex&gt; doc = Inspect.Algebra . concat ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ]","ref":"Inspect.Algebra.html#concat/1","title":"Inspect.Algebra.concat/1","type":"function"},{"doc":"Concatenates two document entities returning a new document. Examples iex&gt; doc = Inspect.Algebra . concat ( &quot;hello&quot; , &quot;world&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;hello&quot; , &quot;world&quot; ]","ref":"Inspect.Algebra.html#concat/2","title":"Inspect.Algebra.concat/2","type":"function"},{"doc":"Wraps collection in left and right according to limit and contents. It uses the given left and right documents as surrounding and the separator document separator to separate items in docs . If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit. The limit in the given inspect_opts is respected and when reached this function stops processing and outputs &quot;...&quot; instead. Options :separator - the separator used between each doc :break - If :strict , always break between each element. If :flex , breaks only when necessary. If :maybe , chooses :flex only if all elements are text-based, otherwise is :strict Examples iex&gt; inspect_opts = % Inspect.Opts { limit : :infinity } iex&gt; fun = fn i , _opts -&gt; to_string ( i ) end iex&gt; doc = Inspect.Algebra . container_doc ( &quot;[&quot; , Enum . to_list ( 1 . . 5 ) , &quot;]&quot; , inspect_opts , fun ) iex&gt; Inspect.Algebra . format ( doc , 5 ) |&gt; IO . iodata_to_binary ( ) &quot;[1, \\n 2, \\n 3, \\n 4, \\n 5]&quot; iex&gt; inspect_opts = % Inspect.Opts { limit : 3 } iex&gt; fun = fn i , _opts -&gt; to_string ( i ) end iex&gt; doc = Inspect.Algebra . container_doc ( &quot;[&quot; , Enum . to_list ( 1 . . 5 ) , &quot;]&quot; , inspect_opts , fun ) iex&gt; Inspect.Algebra . format ( doc , 20 ) |&gt; IO . iodata_to_binary ( ) &quot;[1, 2, 3, ...]&quot; iex&gt; inspect_opts = % Inspect.Opts { limit : 3 } iex&gt; fun = fn i , _opts -&gt; to_string ( i ) end iex&gt; opts = [ separator : &quot;!&quot; ] iex&gt; doc = Inspect.Algebra . container_doc ( &quot;[&quot; , Enum . to_list ( 1 . . 5 ) , &quot;]&quot; , inspect_opts , fun , opts ) iex&gt; Inspect.Algebra . format ( doc , 20 ) |&gt; IO . iodata_to_binary ( ) &quot;[1! 2! 3! ...]&quot;","ref":"Inspect.Algebra.html#container_doc/6","title":"Inspect.Algebra.container_doc/6","type":"function"},{"doc":"Returns a document entity used to represent nothingness. Examples iex&gt; Inspect.Algebra . empty ( ) :doc_nil","ref":"Inspect.Algebra.html#empty/0","title":"Inspect.Algebra.empty/0","type":"function"},{"doc":"Returns a flex break document based on the given string . A flex break still causes a group to break, like break/1 , but it is re-evaluated when the documented is rendered. For example, take a group document represented as [1, 2, 3] where the space after every comma is a break. When the document above does not fit a single line, all breaks are enabled, causing the document to be rendered as: [ 1 , 2 , 3 ] However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as: [ 1 , 2 , 3 ] Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated. This function is used by container_doc/6 and friends to the maximum number of entries on the same line.","ref":"Inspect.Algebra.html#flex_break/1","title":"Inspect.Algebra.flex_break/1","type":"function"},{"doc":"Glues two documents ( doc1 and doc2 ) inserting a flex_break/1 given by break_string between them. This function is used by container_doc/6 and friends to the maximum number of entries on the same line.","ref":"Inspect.Algebra.html#flex_glue/3","title":"Inspect.Algebra.flex_glue/3","type":"function"},{"doc":"Folds a list of documents into a document using the given folder function. The list of documents is folded &quot;from the right&quot;; in that, this function is similar to List.foldr/3 , except that it doesn't expect an initial accumulator and uses the last element of docs as the initial accumulator. Examples iex&gt; docs = [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ] iex&gt; docs = ...&gt; Inspect.Algebra . fold_doc ( docs , fn doc , acc -&gt; ...&gt; Inspect.Algebra . concat ( [ doc , &quot;!&quot; , acc ] ) ...&gt; end ) iex&gt; Inspect.Algebra . format ( docs , 80 ) [ &quot;A&quot; , &quot;!&quot; , &quot;B&quot; , &quot;!&quot; , &quot;C&quot; ]","ref":"Inspect.Algebra.html#fold_doc/2","title":"Inspect.Algebra.fold_doc/2","type":"function"},{"doc":"Forces the current group to be unfit.","ref":"Inspect.Algebra.html#force_unfit/1","title":"Inspect.Algebra.force_unfit/1","type":"function"},{"doc":"Formats a given document for a given width. Takes the maximum width and a document to print as its arguments and returns an IO data representation of the best layout for the document to fit in the given width. The document starts flat (without breaks) until a group is found. Examples iex&gt; doc = Inspect.Algebra . glue ( &quot;hello&quot; , &quot; &quot; , &quot;world&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; doc |&gt; Inspect.Algebra . format ( 30 ) |&gt; IO . iodata_to_binary ( ) &quot;hello world&quot; iex&gt; doc |&gt; Inspect.Algebra . format ( 10 ) |&gt; IO . iodata_to_binary ( ) &quot;hello \\n world&quot;","ref":"Inspect.Algebra.html#format/2","title":"Inspect.Algebra.format/2","type":"function"},{"doc":"Glues two documents ( doc1 and doc2 ) inserting the given break break_string between them. For more information on how the break is inserted, see break/1 . Examples iex&gt; doc = Inspect.Algebra . glue ( &quot;hello&quot; , &quot;world&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;hello&quot; , &quot; &quot; , &quot;world&quot; ] iex&gt; doc = Inspect.Algebra . glue ( &quot;hello&quot; , &quot; \\t &quot; , &quot;world&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;hello&quot; , &quot; \\t &quot; , &quot;world&quot; ]","ref":"Inspect.Algebra.html#glue/3","title":"Inspect.Algebra.glue/3","type":"function"},{"doc":"Returns a group containing the specified document doc . Documents in a group are attempted to be rendered together to the best of the renderer ability. The group mode can also be set to :inherit , which means it automatically breaks if the parent group has broken too. Examples iex&gt; doc = ...&gt; Inspect.Algebra . group ( ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . group ( ...&gt; Inspect.Algebra . concat ( ...&gt; &quot;Hello,&quot; , ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . break ( ) , ...&gt; &quot;A&quot; ...&gt; ) ...&gt; ) ...&gt; ) , ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . break ( ) , ...&gt; &quot;B&quot; ...&gt; ) ...&gt; ) ...&gt; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;Hello,&quot; , &quot; &quot; , &quot;A&quot; , &quot; &quot; , &quot;B&quot; ] iex&gt; Inspect.Algebra . format ( doc , 6 ) [ &quot;Hello,&quot; , &quot; \\n &quot; , &quot;A&quot; , &quot; \\n &quot; , &quot;B&quot; ]","ref":"Inspect.Algebra.html#group/2","title":"Inspect.Algebra.group/2","type":"function"},{"doc":"","ref":"Inspect.Algebra.html#is_doc/1","title":"Inspect.Algebra.is_doc/1","type":"macro"},{"doc":"A mandatory linebreak. A group with linebreaks will fit if all lines in the group fit. Examples iex&gt; doc = ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . concat ( ...&gt; &quot;Hughes&quot; , ...&gt; Inspect.Algebra . line ( ) ...&gt; ) , ...&gt; &quot;Wadler&quot; ...&gt; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;Hughes&quot; , &quot; \\n &quot; , &quot;Wadler&quot; ]","ref":"Inspect.Algebra.html#line/0","title":"Inspect.Algebra.line/0","type":"function"},{"doc":"Inserts a mandatory linebreak between two documents. See line/0 . Examples iex&gt; doc = Inspect.Algebra . line ( &quot;Hughes&quot; , &quot;Wadler&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;Hughes&quot; , &quot; \\n &quot; , &quot;Wadler&quot; ]","ref":"Inspect.Algebra.html#line/2","title":"Inspect.Algebra.line/2","type":"function"},{"doc":"Nests the given document at the given level . If level is an integer, that's the indentation appended to line breaks whenever they occur. If the level is :cursor , the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is :reset , it is set back to 0. mode can be :always , which means nesting always happen, or :break , which means nesting only happens inside a group that has been broken. Examples iex&gt; doc = Inspect.Algebra . nest ( Inspect.Algebra . glue ( &quot;hello&quot; , &quot;world&quot; ) , 5 ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 5 ) [ &quot;hello&quot; , &quot; \\n &quot; , &quot;world&quot; ]","ref":"Inspect.Algebra.html#nest/3","title":"Inspect.Algebra.nest/3","type":"function"},{"doc":"Considers the next break as fit. mode can be :enabled or :disabled . When :enabled , it will consider the document as fit as soon as it finds the next break, effectively cancelling the break. It will also ignore any force_unfit/1 in search of the next break. When disabled, it behaves as usual and it will ignore any further next_break_fits/2 instruction. Examples This is used by Elixir's code formatter to avoid breaking code at some specific locations. For example, consider this code: some_function_call ( %{ ... , key : value , ... } ) Now imagine that this code does not fit its line. The code formatter introduces breaks inside ( and ) and inside %{ and } . Therefore the document would break as: some_function_call ( %{ ... , key : value , ... } ) The formatter wraps the algebra document representing the map in next_break_fits/1 so the code is formatted as: some_function_call ( %{ ... , key : value , ... } )","ref":"Inspect.Algebra.html#next_break_fits/2","title":"Inspect.Algebra.next_break_fits/2","type":"function"},{"doc":"Inserts a mandatory single space between two documents. Examples iex&gt; doc = Inspect.Algebra . space ( &quot;Hughes&quot; , &quot;Wadler&quot; ) iex&gt; Inspect.Algebra . format ( doc , 5 ) [ &quot;Hughes&quot; , &quot; &quot; , &quot;Wadler&quot; ]","ref":"Inspect.Algebra.html#space/2","title":"Inspect.Algebra.space/2","type":"function"},{"doc":"Creates a document represented by string. While Inspect.Algebra accepts binaries as documents, those are counted by binary size. On the other hand, string documents are measured in terms of graphemes towards the document size. Examples The following document has 10 bytes and therefore it does not format to width 9 without breaks: iex&gt; doc = Inspect.Algebra . glue ( &quot;olá&quot; , &quot; &quot; , &quot;mundo&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 9 ) [ &quot;olá&quot; , &quot; \\n &quot; , &quot;mundo&quot; ] However, if we use string , then the string length is used, instead of byte size, correctly fitting: iex&gt; string = Inspect.Algebra . string ( &quot;olá&quot; ) iex&gt; doc = Inspect.Algebra . glue ( string , &quot; &quot; , &quot;mundo&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 9 ) [ &quot;olá&quot; , &quot; &quot; , &quot;mundo&quot; ]","ref":"Inspect.Algebra.html#string/1","title":"Inspect.Algebra.string/1","type":"function"},{"doc":"Converts an Elixir term to an algebra document according to the Inspect protocol.","ref":"Inspect.Algebra.html#to_doc/2","title":"Inspect.Algebra.to_doc/2","type":"function"},{"doc":"","ref":"Inspect.Algebra.html#t:t/0","title":"Inspect.Algebra.t/0","type":"type"},{"doc":"Defines the options used by the Inspect protocol. The following fields are available: :base - prints integers as :binary , :octal , :decimal , or :hex , defaults to :decimal . When inspecting binaries any :base other than :decimal implies binaries: :as_binaries . :binaries - when :as_binaries all binaries will be printed in bit syntax. When :as_strings all binaries will be printed as strings, non-printable bytes will be escaped. When the default :infer , the binary will be printed as a string if it is printable, otherwise in bit syntax. See String.printable?/1 to learn when a string is printable. :charlists - when :as_charlists all lists will be printed as charlists, non-printable elements will be escaped. When :as_lists all lists will be printed as lists. When the default :infer , the list will be printed as a charlist if it is printable, otherwise as list. See List.ascii_printable?/1 to learn when a charlist is printable. :custom_options (since v1.9.0) - a keyword list storing custom user-defined options. Useful when implementing the Inspect protocol for nested structs to pass the custom options through. :inspect_fun (since v1.9.0) - a function to build algebra documents. Defaults to Inspect.inspect/2 . :limit - limits the number of items that are inspected for tuples, bitstrings, maps, lists and any other collection of items, with the exception of printable strings and printable charlists which use the :printable_limit option. If you don't want to limit the number of items to a particular number, use :infinity . It accepts a positive integer or :infinity . Defaults to 50 . :pretty - if set to true enables pretty printing. Defaults to false . :printable_limit - limits the number of characters that are inspected on printable strings and printable charlists. You can use String.printable?/1 and List.ascii_printable?/1 to check if a given string or charlist is printable. If you don't want to limit the number of characters to a particular number, use :infinity . It accepts a positive integer or :infinity . Defaults to 4096 . :safe - when false , failures while inspecting structs will be raised as errors instead of being wrapped in the Inspect.Error exception. This is useful when debugging failures and crashes for custom inspect implementations. :structs - when false , structs are not formatted by the inspect protocol, they are instead printed as maps. Defaults to true . :syntax_colors - when set to a keyword list of colors the output is colorized. The keys are types and the values are the colors to use for each type (for example, [number: :red, atom: :blue] ). Types can include :atom , :binary , :boolean , :list , :map , :number , :regex , :string , and :tuple . Custom data types may provide their own options. Colors can be any IO.ANSI.ansidata/0 as accepted by IO.ANSI.format/1 . :width - number of characters per line used when pretty is true or when printing to IO devices. Set to 0 to force each item to be printed on its own line. If you don't want to limit the number of items to a particular number, use :infinity . Defaults to 80 .","ref":"Inspect.Opts.html","title":"Inspect.Opts","type":"module"},{"doc":"","ref":"Inspect.Opts.html#t:color_key/0","title":"Inspect.Opts.color_key/0","type":"type"},{"doc":"","ref":"Inspect.Opts.html#t:t/0","title":"Inspect.Opts.t/0","type":"type"},{"doc":"The List.Chars protocol is responsible for converting a structure to a charlist (only if applicable). The only function that must be implemented is to_charlist/1 which does the conversion. The to_charlist/1 function automatically imported by Kernel invokes this protocol.","ref":"List.Chars.html","title":"List.Chars","type":"protocol"},{"doc":"Converts term to a charlist.","ref":"List.Chars.html#to_charlist/1","title":"List.Chars.to_charlist/1","type":"function"},{"doc":"","ref":"List.Chars.html#t:t/0","title":"List.Chars.t/0","type":"type"},{"doc":"Reference and functions for working with protocols. A protocol specifies an API that should be defined by its implementations. A protocol is defined with Kernel.defprotocol/2 and its implementations with Kernel.defimpl/3 . A real case In Elixir, we have two nouns for checking how many items there are in a data structure: length and size . length means the information must be computed. For example, length(list) needs to traverse the whole list to calculate its length. On the other hand, tuple_size(tuple) and byte_size(binary) do not depend on the tuple and binary size as the size information is precomputed in the data structure. Although Elixir includes specific functions such as tuple_size , binary_size and map_size , sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows: defprotocol Size do @doc &quot;Calculates the size (and not the length!) of a data structure&quot; def size ( data ) end Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for: defimpl Size , for : BitString do def size ( binary ) , do : byte_size ( binary ) end defimpl Size , for : Map do def size ( map ) , do : map_size ( map ) end defimpl Size , for : Tuple do def size ( tuple ) , do : tuple_size ( tuple ) end Note that we didn't implement it for lists as we don't have the size information on lists, rather its value needs to be computed with length . The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol. It is possible to implement protocols for all Elixir types: Structs (see the &quot;Protocols and Structs&quot; section below) Tuple Atom List BitString Integer Float Function PID Map Port Reference Any (see the &quot;Fallback to Any &quot; section below) Protocols and Structs The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like MapSet . We can implement the Size protocol for those types as well: defimpl Size , for : MapSet do def size ( map_set ) , do : MapSet . size ( map_set ) end When implementing a protocol for a struct, the :for option can be omitted if the defimpl/3 call is inside the module that defines the struct: defmodule User do defstruct [ :email , :name ] defimpl Size do # two fields def size ( % User { } ) , do : 2 end end If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to Any . Conveniences for building implementations on top of existing ones are also available, look at defstruct/1 for more information about deriving protocols. Fallback to Any In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the @fallback_to_any attribute to true in the protocol definition: defprotocol Size do @fallback_to_any true def size ( data ) end The Size protocol can now be implemented for Any : defimpl Size , for : Any do def size ( _ ) , do : 0 end Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integer have a size of 0 . That's one of the reasons why @fallback_to_any is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour. Multiple implementations Protocols can also be implemented for multiple types at once: defprotocol Reversible do def reverse ( term ) end defimpl Reversible , for : [ Map , List ] do def reverse ( term ) , do : Enum . reverse ( term ) end Inside defimpl/3 , you can use @protocol to access the protocol being implemented and @for to access the module it is being defined for. Types Defining a protocol automatically defines a zero-arity type named t , which can be used as follows: @spec print_size ( Size . t ( ) ) :: :ok def print_size ( data ) do result = case Size . size ( data ) do 0 -&gt; &quot;data has no items&quot; 1 -&gt; &quot;data has one item&quot; n -&gt; &quot;data has \#{ n } items&quot; end IO . puts ( result ) end The @spec above expresses that all types allowed to implement the given protocol are valid argument types for the given function. Reflection Any protocol module contains three extra functions: __protocol__/1 - returns the protocol information. The function takes one of the following atoms: :consolidated? - returns whether the protocol is consolidated :functions - returns a keyword list of protocol functions and their arities :impls - if consolidated, returns {:consolidated, modules} with the list of modules implementing the protocol, otherwise :not_consolidated :module - the protocol module atom name impl_for/1 - returns the module that implements the protocol for the given argument, nil otherwise impl_for!/1 - same as above but raises Protocol.UndefinedError if an implementation is not found For example, for the Enumerable protocol we have: iex&gt; Enumerable . __protocol__ ( :functions ) [ count : 1 , member? : 2 , reduce : 3 , slice : 1 ] iex&gt; Enumerable . impl_for ( [ ] ) Enumerable.List iex&gt; Enumerable . impl_for ( 42 ) nil In addition, every protocol implementation module contains the __impl__/1 function. The function takes one of the following atoms: :for - returns the module responsible for the data structure of the protocol implementation :protocol - returns the protocol module for which this implementation is provided For example, the module implementing the Enumerable protocol for lists is Enumerable.List . Therefore, we can invoke __impl__/1 on this module: iex(1)&gt; Enumerable.List . __impl__ ( :for ) List iex(2)&gt; Enumerable.List . __impl__ ( :protocol ) Enumerable Consolidation In order to speed up protocol dispatching, whenever all protocol implementations are known up-front, typically after all Elixir code in a project is compiled, Elixir provides a feature called protocol consolidation . Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions. Protocol consolidation is applied by default to all Mix projects during compilation. This may be an issue during test. For instance, if you want to implement a protocol during test, the implementation will have no effect, as the protocol has already been consolidated. One possible solution is to include compilation directories that are specific to your test environment in your mix.exs: def project do ... elixirc_paths : elixirc_paths ( Mix . env ( ) ) ... end defp elixirc_paths ( :test ) , do : [ &quot;lib&quot; , &quot;test/support&quot; ] defp elixirc_paths ( _ ) , do : [ &quot;lib&quot; ] And then you can define the implementations specific to the test environment inside test/support/some_file.ex . Another approach is to disable protocol consolidation during tests in your mix.exs: def project do ... consolidate_protocols : Mix . env ( ) != :test ... end Although doing so is not recommended as it may affect your test suite performance. Finally, note all protocols are compiled with debug_info set to true , regardless of the option set by the elixirc compiler. The debug info is used for consolidation and it is removed after consolidation unless globally set.","ref":"Protocol.html","title":"Protocol","type":"module"},{"doc":"Checks if the given module is loaded and is an implementation of the given protocol. Returns :ok if so, otherwise raises ArgumentError .","ref":"Protocol.html#assert_impl!/2","title":"Protocol.assert_impl!/2","type":"function"},{"doc":"Checks if the given module is loaded and is protocol. Returns :ok if so, otherwise raises ArgumentError .","ref":"Protocol.html#assert_protocol!/1","title":"Protocol.assert_protocol!/1","type":"function"},{"doc":"Receives a protocol and a list of implementations and consolidates the given protocol. Consolidation happens by changing the protocol impl_for in the abstract format to have fast lookup rules. Usually the list of implementations to use during consolidation are retrieved with the help of extract_impls/2 . It returns the updated version of the protocol bytecode. If the first element of the tuple is :ok , it means the protocol was consolidated. A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute: Protocol . consolidated? ( Enumerable ) This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However each implementation must be available and it will be loaded.","ref":"Protocol.html#consolidate/2","title":"Protocol.consolidate/2","type":"function"},{"doc":"Returns true if the protocol was consolidated.","ref":"Protocol.html#consolidated?/1","title":"Protocol.consolidated?/1","type":"function"},{"doc":"Derives the protocol for module with the given options. If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as __deriving__(module, struct, options) to get the options that were passed. Examples defprotocol Derivable do def ok ( arg ) end defimpl Derivable , for : Any do defmacro __deriving__ ( module , struct , options ) do quote do defimpl Derivable , for : unquote ( module ) do def ok ( arg ) do { :ok , arg , unquote ( Macro . escape ( struct ) ) , unquote ( options ) } end end end end def ok ( arg ) do { :ok , arg } end end defmodule ImplStruct do @derive [ Derivable ] defstruct a : 0 , b : 0 end Derivable . ok ( % ImplStruct { } ) #=&gt; {:ok, %ImplStruct{a: 0, b: 0}, %ImplStruct{a: 0, b: 0}, []} Explicit derivations can now be called via __deriving__/3 : # Explicitly derived via `__deriving__/3` Derivable . ok ( % ImplStruct { a : 1 , b : 1 } ) #=&gt; {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, []} # Explicitly derived by API via `__deriving__/3` require Protocol Protocol . derive ( Derivable , ImplStruct , :oops ) Derivable . ok ( % ImplStruct { a : 1 , b : 1 } ) #=&gt; {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, :oops}","ref":"Protocol.html#derive/3","title":"Protocol.derive/3","type":"macro"},{"doc":"Extracts all types implemented for the given protocol from the given paths. The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion. Does not load any of the implementations. Examples # Get Elixir&#39;s ebin directory path and retrieve all protocols iex&gt; path = :code . lib_dir ( :elixir , :ebin ) iex&gt; mods = Protocol . extract_impls ( Enumerable , [ path ] ) iex&gt; List in mods true","ref":"Protocol.html#extract_impls/2","title":"Protocol.extract_impls/2","type":"function"},{"doc":"Extracts all protocols from the given paths. The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion. Does not load any of the protocols. Examples # Get Elixir&#39;s ebin directory path and retrieve all protocols iex&gt; path = :code . lib_dir ( :elixir , :ebin ) iex&gt; mods = Protocol . extract_protocols ( [ path ] ) iex&gt; Enumerable in mods true","ref":"Protocol.html#extract_protocols/1","title":"Protocol.extract_protocols/1","type":"function"},{"doc":"The String.Chars protocol is responsible for converting a structure to a binary (only if applicable). The only function required to be implemented is to_string/1 , which does the conversion. The to_string/1 function automatically imported by Kernel invokes this protocol. String interpolation also invokes to_string/1 in its arguments. For example, &quot;foo\#{bar}&quot; is the same as &quot;foo&quot; &lt;&gt; to_string(bar) .","ref":"String.Chars.html","title":"String.Chars","type":"protocol"},{"doc":"Converts term to a string.","ref":"String.Chars.html#to_string/1","title":"String.Chars.to_string/1","type":"function"},{"doc":"","ref":"String.Chars.html#t:t/0","title":"String.Chars.t/0","type":"type"},{"doc":"Utilities for managing code compilation, code evaluation, and code loading. This module complements Erlang's :code module to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir. Working with files This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour: require_file/2 - compiles a file and tracks its name. It does not compile the file again if it has been previously required. compile_file/2 - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times. eval_file/2 - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section. In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts. compile_file/2 must be used when you are interested in the modules defined in a file, without tracking. eval_file/2 should be used when you are interested in the result of evaluating the file rather than the modules it defines. Code loading on the Erlang VM Erlang has two modes to load code: interactive and embedded. By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly. You can use ensure_loaded/1 (as well as ensure_lodead?/1 and ensure_lodead!/1 ) to check if a module is loaded before using it and act. ensure_compiled/1 and ensure_compiled!/1 Elixir also includes ensure_compiled/1 and ensure_compiled!/1 functions that are a superset of ensure_loaded/1 . Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded. When invoked, ensure_compiled/1 and ensure_compiled!/1 halt the compilation of the caller until the module becomes available. Note the distinction between ensure_compiled/1 and ensure_compiled!/1 is important: if you are using ensure_compiled!/1 , you are indicating to the compiler that you can only continue if said module is available. If you are using Code.ensure_compiled/1 , you are implying you may continue without the module and therefore Elixir may return {:error, :unavailable} for cases where the module is not yet available (but may be available later on). For those reasons, developers must typically use Code.ensure_compiled!/1 . In particular, do not do this: case Code . ensure_compiled ( module ) do { :module , _ } -&gt; module { :error , _ } -&gt; raise ... end Finally, note you only need ensure_compiled!/1 to check for modules being defined within the same project. It does not apply to modules from dependencies as dependencies are always compiled upfront. In most cases, ensure_loaded/1 is enough. ensure_compiled!/1 must be used in rare cases, usually involving macros that need to invoke a module for callback information. The use of ensure_compiled/1 is even less likely. Compilation tracers Elixir supports compilation tracers, which allows modules to observe constructs handled by the Elixir compiler when compiling files. A tracer is a module that implements the trace/2 function. The function receives the event name as first argument and Macro.Env as second and it must return :ok . It is very important for a tracer to do as little work as possible synchronously and dispatch the bulk of the work to a separate process. Slow tracers will slow down compilation . You can configure your list of tracers via put_compiler_option/2 . The following events are available to tracers: :start - (since v1.11.0) invoked whenever the compiler starts to trace a new lexical context, such as a new file. Keep in mind the compiler runs in parallel, so multiple files may invoke :start and run at the same time. The value of the lexical_tracker of the macro environment, albeit opaque, can be used to uniquely identify the environment. :stop - (since v1.11.0) invoked whenever the compiler stops tracing a new lexical context, such as a new file. {:import, meta, module, opts} - traced whenever module is imported. meta is the import AST metadata and opts are the import options. {:imported_function, meta, module, name, arity} and {:imported_macro, meta, module, name, arity} - traced whenever an imported function or macro is invoked. meta is the call AST metadata, module is the module the import is from, followed by the name and arity of the imported function/macro. {:alias, meta, alias, as, opts} - traced whenever alias is aliased to as . meta is the alias AST metadata and opts are the alias options. {:alias_expansion, meta, as, alias} traced whenever there is an alias expansion for a previously defined alias , i.e. when the user writes as which is expanded to alias . meta is the alias expansion AST metadata. {:alias_reference, meta, module} - traced whenever there is an alias in the code, i.e. whenever the user writes MyModule.Foo.Bar in the code, regardless if it was expanded or not. {:require, meta, module, opts} - traced whenever module is required. meta is the require AST metadata and opts are the require options. {:struct_expansion, meta, module, keys} - traced whenever module 's struct is expanded. meta is the struct AST metadata and keys are the keys being used by expansion {:remote_function, meta, module, name, arity} and {:remote_macro, meta, module, name, arity} - traced whenever a remote function or macro is referenced. meta is the call AST metadata, module is the invoked module, followed by the name and arity . {:local_function, meta, name, arity} and {:local_macro, meta, name, arity} - traced whenever a local function or macro is referenced. meta is the call AST metadata, followed by the name and arity . {:compile_env, app, path, return} - traced whenever Application.compile_env/3 or Application.compile_env!/2 are called. app is an atom, path is a list of keys to traverse in the application environment and return is either {:ok, value} or :error . The :tracers compiler option can be combined with the :parser_options compiler option to enrich the metadata of the traced events above. New events may be added at any time in the future, therefore it is advised for the trace/2 function to have a &quot;catch-all&quot; clause. Below is an example tracer that prints all remote function invocations: defmodule MyTracer do def trace ( { :remote_function , _meta , module , name , arity } , env ) do IO . puts &quot; \#{ env . file } : \#{ env . line } \#{ inspect ( module ) } . \#{ name } / \#{ arity } &quot; :ok end def trace ( _event , _env ) do :ok end end","ref":"Code.html","title":"Code","type":"module"},{"doc":"Appends a path to the end of the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The path is expanded with Path.expand/1 before being appended. If this path does not exist, an error is returned. Examples Code . append_path ( &quot;.&quot; ) #=&gt; true Code . append_path ( &quot;/does_not_exist&quot; ) #=&gt; {:error, :bad_directory}","ref":"Code.html#append_path/1","title":"Code.append_path/1","type":"function"},{"doc":"Returns a list with all available compiler options. For a description of all options, see put_compiler_option/2 . Examples Code . available_compiler_options ( ) #=&gt; [:docs, :debug_info, ...]","ref":"Code.html#available_compiler_options/0","title":"Code.available_compiler_options/0","type":"function"},{"doc":"Returns true if the current process can await for module compilation. When compiling Elixir code via Kernel.ParallelCompiler , which is used by Mix and elixirc , calling a module that has not yet been compiled will block the caller until the module becomes available. Executing Elixir scripts, such as passing a filename to elixir , does not await.","ref":"Code.html#can_await_module_compilation?/0","title":"Code.can_await_module_compilation?/0","type":"function"},{"doc":"Compiles the given file. Accepts relative_to as an argument to tell where the file is located. Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). Opposite to require_file/2 , it does not track the filename of the compiled file. If you would like to get the result of evaluating file rather than the modules defined in it, see eval_file/2 . For compiling many files concurrently, see Kernel.ParallelCompiler.compile/2 .","ref":"Code.html#compile_file/2","title":"Code.compile_file/2","type":"function"},{"doc":"Compiles the quoted expression. Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A file can be given as second argument which will be used for reporting warnings and errors.","ref":"Code.html#compile_quoted/2","title":"Code.compile_quoted/2","type":"function"},{"doc":"Compiles the given string. Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A file can be given as second argument which will be used for reporting warnings and errors. Warning : string can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use compile_string/2 with untrusted input (such as strings coming from the network).","ref":"Code.html#compile_string/2","title":"Code.compile_string/2","type":"function"},{"doc":"Gets all compilation options from the code server. To get individual options, see get_compiler_option/1 . For a description of all options, see put_compiler_option/2 . Examples Code . compiler_options ( ) #=&gt; %{debug_info: true, docs: true, ...}","ref":"Code.html#compiler_options/0","title":"Code.compiler_options/0","type":"function"},{"doc":"Stores all given compilation options. To store individual options, see put_compiler_option/2 . For a description of all options, see put_compiler_option/2 . Examples Code . compiler_options ( ) #=&gt; %{debug_info: true, docs: true, ...}","ref":"Code.html#compiler_options/1","title":"Code.compiler_options/1","type":"function"},{"doc":"Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The path is expanded with Path.expand/1 before being deleted. If the path does not exist, this function returns false . Examples Code . prepend_path ( &quot;.&quot; ) Code . delete_path ( &quot;.&quot; ) #=&gt; true Code . delete_path ( &quot;/does_not_exist&quot; ) #=&gt; false","ref":"Code.html#delete_path/1","title":"Code.delete_path/1","type":"function"},{"doc":"Similar to ensure_compiled!/1 but indicates you can continue without said module. While ensure_compiled!/1 indicates to the Elixir compiler you can only continue when said module is available, this function indicates you may continue compilation without said module. If it succeeds in loading the module, it returns {:module, module} . If not, returns {:error, reason} with the error reason. If the module being checked is currently in a compiler deadlock, this function returns {:error, :unavailable} . Unavailable doesn't necessarily mean the module doesn't exist, just that it is not currently available, but it (or may not) become available in the future. Therefore, if you can only continue if the module is available, use ensure_compiled!/1 instead. In particular, do not do this: case Code . ensure_compiled ( module ) do { :module , _ } -&gt; module { :error , _ } -&gt; raise ... end See the module documentation for more information on code loading.","ref":"Code.html#ensure_compiled/1","title":"Code.ensure_compiled/1","type":"function"},{"doc":"Ensures the given module is compiled and loaded. If the module is already loaded, it works as no-op. If the module was not compiled yet, ensure_compiled!/1 halts the compilation of the caller until the module given to ensure_compiled!/1 becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available or is in a deadlock, an error is raised. Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not. See the module documentation for more information on code loading.","ref":"Code.html#ensure_compiled!/1","title":"Code.ensure_compiled!/1","type":"function"},{"doc":"Ensures the given module is loaded. If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it. If it succeeds in loading the module, it returns {:module, module} . If not, returns {:error, reason} with the error reason. See the module documentation for more information on code loading. Examples iex&gt; Code . ensure_loaded ( Atom ) { :module , Atom } iex&gt; Code . ensure_loaded ( DoesNotExist ) { :error , :nofile }","ref":"Code.html#ensure_loaded/1","title":"Code.ensure_loaded/1","type":"function"},{"doc":"Same as ensure_loaded/1 but raises if the module cannot be loaded.","ref":"Code.html#ensure_loaded!/1","title":"Code.ensure_loaded!/1","type":"function"},{"doc":"Ensures the given module is loaded. Similar to ensure_loaded/1 , but returns true if the module is already loaded or was successfully loaded. Returns false otherwise. Examples iex&gt; Code . ensure_loaded? ( Atom ) true","ref":"Code.html#ensure_loaded?/1","title":"Code.ensure_loaded?/1","type":"function"},{"doc":"Evals the given file. Accepts relative_to as an argument to tell where the file is located. While require_file/2 and compile_file/2 return the loaded modules and their bytecode, eval_file/2 simply evaluates the file contents and returns the evaluation result and its binding (exactly the same return value as eval_string/3 ).","ref":"Code.html#eval_file/2","title":"Code.eval_file/2","type":"function"},{"doc":"Evaluates the quoted contents. Warning : Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated). See eval_string/3 for a description of binding and options. Examples iex&gt; contents = quote ( do : var! ( a ) + var! ( b ) ) iex&gt; { result , binding } = Code . eval_quoted ( contents , [ a : 1 , b : 2 ] , file : __ENV__ . file , line : __ENV__ . line ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ] For convenience, you can pass __ENV__/0 as the opts argument and all options will be automatically extracted from the current environment: iex&gt; contents = quote ( do : var! ( a ) + var! ( b ) ) iex&gt; { result , binding } = Code . eval_quoted ( contents , [ a : 1 , b : 2 ] , __ENV__ ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ]","ref":"Code.html#eval_quoted/3","title":"Code.eval_quoted/3","type":"function"},{"doc":"Evaluates the contents given by string . The binding argument is a list of variable bindings. The opts argument is a keyword list of environment options. Warning : string can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use eval_string/3 with untrusted input (such as strings coming from the network). Options Options can be: :file - the file to be considered in the evaluation :line - the line on which the script starts Additionally, the following scope values can be configured: :aliases - a list of tuples with the alias and its target :requires - a list of modules required :functions - a list of tuples where the first element is a module and the second a list of imported function names and arity; the list of function names and arity must be sorted :macros - a list of tuples where the first element is a module and the second a list of imported macro names and arity; the list of function names and arity must be sorted Note that setting any of the values above overrides Elixir's default values. For example, setting :requires to [] will no longer automatically require the Kernel module. In the same way setting :macros will no longer auto-import Kernel macros like Kernel.if/2 , Kernel.SpecialForms.case/2 , and so on. Returns a tuple of the form {value, binding} , where value is the value returned from evaluating string . If an error occurs while evaluating string an exception will be raised. binding is a list with all variable bindings after evaluating string . The binding keys are usually atoms, but they may be a tuple for variables defined in a different context. Examples iex&gt; { result , binding } = Code . eval_string ( &quot;a + b&quot; , [ a : 1 , b : 2 ] , file : __ENV__ . file , line : __ENV__ . line ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ] iex&gt; { result , binding } = Code . eval_string ( &quot;c = a + b&quot; , [ a : 1 , b : 2 ] , __ENV__ ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 , c : 3 ] iex&gt; { result , binding } = Code . eval_string ( &quot;a = a + b&quot; , [ a : 1 , b : 2 ] ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 3 , b : 2 ] For convenience, you can pass __ENV__/0 as the opts argument and all imports, requires and aliases defined in the current environment will be automatically carried over: iex&gt; { result , binding } = Code . eval_string ( &quot;a + b&quot; , [ a : 1 , b : 2 ] , __ENV__ ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ]","ref":"Code.html#eval_string/3","title":"Code.eval_string/3","type":"function"},{"doc":"Returns the docs for the given module or path to .beam file. When given a module name, it finds its BEAM code and reads the docs from it. When given a path to a .beam file, it will load the docs directly from that file. It returns the term stored in the documentation chunk in the format defined by EEP 48 or {:error, reason} if the chunk is not available. Examples # Module documentation of an existing module iex&gt; { :docs_v1 , _ , :elixir , _ , %{ &quot;en&quot; = &gt; module_doc } , _ , _ } = Code . fetch_docs ( Atom ) iex&gt; module_doc |&gt; String . split ( &quot; \\n &quot; ) |&gt; Enum . at ( 0 ) &quot;Atoms are constants whose values are their own name.&quot; # A module that doesn&#39;t exist iex&gt; Code . fetch_docs ( ModuleNotGood ) { :error , :module_not_found }","ref":"Code.html#fetch_docs/1","title":"Code.fetch_docs/1","type":"function"},{"doc":"Formats a file. See format_string!/2 for more information on code formatting and available options.","ref":"Code.html#format_file!/2","title":"Code.format_file!/2","type":"function"},{"doc":"Formats the given code string . The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules. Options :file - the file which contains the string, used for error reporting :line - the line the string starts, used for error reporting :line_length - the line length to aim for when formatting the document. Defaults to 98. Note this value is used as guideline but there are situations where it is not enforced. See the &quot;Line length&quot; section below for more information :locals_without_parens - a keyword list of name and arity pairs that should be kept without parens whenever possible. The arity may be the atom :* , which implies all arities of that name. The formatter already includes a list of functions and this option augments this list. :force_do_end_blocks (since v1.9.0) - when true , converts all inline usages of do: ... , else: ... and friends into do/end blocks. Defaults to false . Note that this option is convergent: once you set it to true , all keywords will be converted. If you set it to false later on, do/end blocks won't be converted back to keywords. Design principles The formatter was designed under three principles. First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent. The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole. The formatter does not hard code names. The formatter will not behave specially because a function is named defmodule , def , or the like. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the :locals_without_parens option. Running the formatter The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot. In some cases, this may lead to undesired formatting. Therefore, some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer . That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file. For example, the formatter may break a long function definition over multiple clauses: def my_function ( % User { name : name , age : age , ... } , arg1 , arg2 ) do ... end While the code above is completely valid, you may prefer to match on the struct variables inside the function body in order to keep the definition on a single line: def my_function ( % User { } = user , arg1 , arg2 ) do %{ name : name , age : age , ... } = user ... end In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code: def board? ( board_id , % User { } = user , available_permissions , required_permissions ) do Tracker.OrganizationMembers . user_in_organization? ( user . id , board . organization_id ) and required_permissions == Enum . to_list ( MapSet . intersection ( MapSet . new ( required_permissions ) , MapSet . new ( available_permissions ) ) ) end The code above has very long lines and running the formatter is not going to address this issue. In fact, the formatter may make it more obvious that you have complex expressions: def board? ( board_id , % User { } = user , available_permissions , required_permissions ) do Tracker.OrganizationMembers . user_in_organization? ( user . id , board . organization_id ) and required_permissions == Enum . to_list ( MapSet . intersection ( MapSet . new ( required_permissions ) , MapSet . new ( available_permissions ) ) ) end Take such cases as a suggestion that your code should be refactored: def board? ( board_id , % User { } = user , available_permissions , required_permissions ) do Tracker.OrganizationMembers . user_in_organization? ( user . id , board . organization_id ) and matching_permissions? ( required_permissions , available_permissions ) end defp matching_permissions? ( required_permissions , available_permissions ) do intersection = required_permissions |&gt; MapSet . new ( ) |&gt; MapSet . intersection ( MapSet . new ( available_permissions ) ) |&gt; Enum . to_list ( ) required_permissions == intersection end To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions. Line length Another point about the formatter is that the :line_length configuration is a guideline. In many cases, it is not possible for the formatter to break your code apart, which means it will go over the line length. For example, if you have a long string: &quot;this is a very long string that will go over the line length&quot; The formatter doesn't know how to break it apart without changing the code underlying syntax representation, so it is up to you to step in: &quot;this is a very long string &quot; &lt;&gt; &quot;that will go over the line length&quot; The string concatenation makes the code fit on a single line and also gives more options to the formatter. This may also appear in do/end blocks, where the do keyword (or -&gt; ) may go over the line lenth because there is no opportunity for the formatter to introduce a line break in a readable way. For example, if you do: case very_long_expression ( ) do And only the do keyword is above the line length, Elixir will not emit this: case very_long_expression ( ) do So it prefers to not touch the line at all and leave do above the line limit. Keeping user's formatting The formatter respects the input format in some cases. Those are listed below: Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input Newlines inside blocks are kept as in the input except for: expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line The choice between :do keyword and do/end blocks is left to the user Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators) The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter. Multi-line lists, maps, tuples, and the like You can force lists, tuples, bitstrings, maps, structs and function calls to have one entry per line by adding a newline after the opening bracket and a new line before the closing bracket lines. For example: [ foo , bar ] If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below [ foo , bar ] will be formatted as [ foo , bar ] You can also force function calls and keywords to be rendered on multiple lines by having each entry on its own line: defstruct name : nil , age : 0 The code above will be kept with one keyword entry per line by the formatter. To avoid that, just squash everything into a single line. Parens and no parens in function calls Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for: calls that have do/end blocks local calls without parens where the name and arity of the local call is also listed under :locals_without_parens (except for calls with arity 0, where the compiler always require parens) The choice of parens and no parens also affects indentation. When a function call with parens doesn't fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces: some_call ( arg1 , arg2 , arg3 ) On the other hand, function calls without parens are always indented by the function call length itself, like this: some_call arg1 , arg2 , arg3 If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this: Enum . reduce ( some_collection , initial_value , fn element , acc -&gt; # code end ) some_function_without_parens %{ foo : :bar , baz : :bat } Code comments The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character. The formatter also extracts all trailing comments to their previous line. For example, the code below hello #world will be rewritten to # world hello Because code comments are handled apart from the code representation (AST), there are some situations where code comments are seen as ambiguous by the code formatter. For example, the comment in the anonymous function below fn arg1 -&gt; body1 # comment arg2 -&gt; body2 end and in this one fn arg1 -&gt; body1 # comment arg2 -&gt; body2 end are considered equivalent (the nesting is discarded alongside most of user formatting). In such cases, the code formatter will always format to the latter. Newlines The formatter converts all newlines in code from \\r\\n to \\n .","ref":"Code.html#format_string!/2","title":"Code.format_string!/2","type":"function"},{"doc":"Returns the value of a given compiler option. For a description of all options, see put_compiler_option/2 . Examples Code . get_compiler_option ( :debug_info ) #=&gt; true","ref":"Code.html#get_compiler_option/1","title":"Code.get_compiler_option/1","type":"function"},{"doc":"Deprecated function to retrieve old documentation format. Elixir v1.7 adopts EEP 48 which is a new documentation format meant to be shared across all BEAM languages. The old format, used by Code.get_docs/2 , is no longer available, and therefore this function always returns nil . Use Code.fetch_docs/1 instead.","ref":"Code.html#get_docs/2","title":"Code.get_docs/2","type":"function"},{"doc":"Prepends a path to the beginning of the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The path is expanded with Path.expand/1 before being prepended. If this path does not exist, an error is returned. Examples Code . prepend_path ( &quot;.&quot; ) #=&gt; true Code . prepend_path ( &quot;/does_not_exist&quot; ) #=&gt; {:error, :bad_directory}","ref":"Code.html#prepend_path/1","title":"Code.prepend_path/1","type":"function"},{"doc":"Purge compiler modules. The compiler utilizes temporary modules to compile code. For example, elixir_compiler_1 , elixir_compiler_2 , and so on. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as elixir_compiler_12345 . This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too. It returns {:ok, number_of_modules_purged} .","ref":"Code.html#purge_compiler_modules/0","title":"Code.purge_compiler_modules/0","type":"function"},{"doc":"Stores a compilation option. These options are global since they are stored by Elixir's code server. Available options are: :docs - when true , retain documentation in the compiled module. Defaults to true . :debug_info - when true , retain debug information in the compiled module. This allows a developer to reconstruct the original source code. Defaults to true . :ignore_module_conflict - when true , override modules that were already defined without raising errors. Defaults to false . :relative_paths - when true , use relative paths in quoted nodes, warnings and errors generated by the compiler. Note disabling this option won't affect runtime warnings and errors. Defaults to true . :warnings_as_errors - causes compilation to fail when warnings are generated. Defaults to false . :no_warn_undefined (since v1.10.0) - list of modules and {Mod, fun, arity} tuples that will not emit warnings that the module or function does not exist at compilation time. Pass atom :all to skip warning for all undefined functions. This can be useful when doing dynamic compilation. Defaults to [] . :tracers (since v1.10.0) - a list of tracers (modules) to be used during compilation. See the module docs for more information. Defaults to [] . :parser_options (since v1.10.0) - a keyword list of options to be given to the parser when compiling files. It accepts the same options as string_to_quoted/2 (except by the options that change the AST itself). This can be used in combination with the tracer to retrieve localized information about events happening during compilation. Defaults to [] . It always returns :ok . Raises an error for invalid options. Examples Code . put_compiler_option ( :debug_info , true ) #=&gt; :ok","ref":"Code.html#put_compiler_option/2","title":"Code.put_compiler_option/2","type":"function"},{"doc":"Requires the given file . Accepts relative_to as an argument to tell where the file is located. If the file was already required, require_file/2 doesn't do anything and returns nil . Note that if require_file/2 is invoked by different processes concurrently, the first process to invoke require_file/2 acquires a lock and the remaining ones will block until the file is available. This means that if require_file/2 is called more than once with a given file, that file will be compiled only once. The first process to call require_file/2 will get the list of loaded modules, others will get nil . See compile_file/2 if you would like to compile a file without tracking its filenames. Finally, if you would like to get the result of evaluating a file rather than the modules defined in it, see eval_file/2 . Examples If the file has not been required, it returns the list of modules: modules = Code . require_file ( &quot;eex_test.exs&quot; , &quot;../eex/test&quot; ) List . first ( modules ) #=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;} If the file has been required, it returns nil : Code . require_file ( &quot;eex_test.exs&quot; , &quot;../eex/test&quot; ) #=&gt; nil","ref":"Code.html#require_file/2","title":"Code.require_file/2","type":"function"},{"doc":"Lists all required files. Examples Code . require_file ( &quot;../eex/test/eex_test.exs&quot; ) List . first ( Code . required_files ( ) ) =~ &quot;eex_test.exs&quot; #=&gt; true","ref":"Code.html#required_files/0","title":"Code.required_files/0","type":"function"},{"doc":"Converts the given string to its quoted form. Returns {:ok, quoted_form} if it succeeds, {:error, {line, error, token}} otherwise. Options :file - the filename to be reported in case of parsing errors. Defaults to &quot;nofile&quot;. :line - the starting line of the string being parsed. Defaults to 1. :column - (since v1.11.0) the starting column of the string being parsed. Defaults to 1. :columns - when true , attach a :column key to the quoted metadata. Defaults to false . :existing_atoms_only - when true , raises an error when non-existing atoms are found by the tokenizer. Defaults to false . :token_metadata (since v1.10.0) - when true , includes token-related metadata in the expression AST, such as metadata for do and end tokens, for closing tokens, end of expressions, as well as delimiters for sigils. See Macro.metadata/0 . Defaults to false . :literal_encoder (since v1.10.0) - how to encode literals in the AST. It must be a function that receives two arguments, the literal and its metadata, and it must return {:ok, ast :: Macro.t} or {:error, reason :: binary} . If you return anything than the literal itself as the term , then the AST is no longer valid. This option may still useful for textual analysis of the source code. :static_atoms_encoder - the static atom encoder function, see &quot;The :static_atoms_encoder function&quot; section below. Note this option overrides the :existing_atoms_only behaviour for static atoms but :existing_atoms_only is still used for dynamic atoms, such as atoms with interpolations. :warn_on_unnecessary_quotes - when false , does not warn when atoms, keywords or calls have unnecessary quotes on them. Defaults to true . Macro.to_string/2 The opposite of converting a string to its quoted form is Macro.to_string/2 , which converts a quoted form to a string/binary representation. The :static_atoms_encoder function When static_atoms_encoder: &amp;my_encoder/2 is passed as an argument, my_encoder/2 is called every time the tokenizer needs to create a &quot;static&quot; atom. Static atoms are atoms in the AST that function as aliases, remote calls, local calls, variable names, regular atoms and keyword lists. The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return {:ok, token :: term} | {:error, reason :: binary} . The encoder function is supposed to create an atom from the given string. To produce a valid AST, it is required to return {:ok, term} , where term is an atom. It is possible to return something other than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table. The atom encoder is not called for all atoms that are present in the AST. It won't be invoked for the following atoms: operators ( :+ , :- , and so on) syntax keywords ( fn , do , else , and so on) atoms containing interpolation ( :&quot;\#{1 + 1} is two&quot; ), as these atoms are constructed at runtime.","ref":"Code.html#string_to_quoted/2","title":"Code.string_to_quoted/2","type":"function"},{"doc":"Converts the given string to its quoted form. It returns the ast if it succeeds, raises an exception otherwise. The exception is a TokenMissingError in case a token is missing (usually because the expression is incomplete), SyntaxError otherwise. Check string_to_quoted/2 for options information.","ref":"Code.html#string_to_quoted!/2","title":"Code.string_to_quoted!/2","type":"function"},{"doc":"Removes files from the required files list. The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again. Examples # Require EEx test code Code . require_file ( &quot;../eex/test/eex_test.exs&quot; ) # Now unrequire all files Code . unrequire_files ( Code . required_files ( ) ) # Note that modules are still available function_exported? ( EExTest.Compiled , :before_compile , 0 ) #=&gt; true","ref":"Code.html#unrequire_files/1","title":"Code.unrequire_files/1","type":"function"},{"doc":"A list with all variable bindings. The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.","ref":"Code.html#t:binding/0","title":"Code.binding/0","type":"type"},{"doc":"A module responsible for compiling and requiring files in parallel.","ref":"Kernel.ParallelCompiler.html","title":"Kernel.ParallelCompiler","type":"module"},{"doc":"Starts a task for parallel compilation. If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments. See Task.async/1 for more information. The task spawned must be always awaited on by calling Task.await/1","ref":"Kernel.ParallelCompiler.html#async/1","title":"Kernel.ParallelCompiler.async/1","type":"function"},{"doc":"Compiles the given files. Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved. It returns {:ok, modules, warnings} or {:error, errors, warnings} . Both errors and warnings are a list of three-element tuples containing the file, line and the formatted error/warning. Options :each_file - for each file compiled, invokes the callback passing the file :each_long_compilation - for each file that takes more than a given timeout (see the :long_compilation_threshold option) to compile, invoke this callback passing the file as its argument :each_module - for each module compiled, invokes the callback passing the file, module and the module bytecode :each_cycle - after the given files are compiled, invokes this function that should return the following values: {:compile, modules, warnings} - to continue compilation with a list of further modules to compile {:runtime, modules, warnings} - to stop compilation and verify the list of modules because dependent modules have changed :long_compilation_threshold - the timeout (in seconds) to check for modules taking too long to compile. For each file that exceeds the threshold, the :each_long_compilation callback is invoked. From Elixir v1.11, only the time spent compiling the actual module is taken into account by the threshold, the time spent waiting is not considered. Defaults to 10 seconds. :profile - if set to :time measure the compilation time of each compilation cycle and group pass checker :dest - the destination directory for the BEAM files. When using compile/2 , this information is only used to properly annotate the BEAM files before they are loaded into memory. If you want a file to actually be written to dest , use compile_to_path/3 instead. :beam_timestamp - the modification timestamp to give all BEAM files","ref":"Kernel.ParallelCompiler.html#compile/2","title":"Kernel.ParallelCompiler.compile/2","type":"function"},{"doc":"Compiles the given files and writes resulting BEAM files into path. See compile/2 for more information.","ref":"Kernel.ParallelCompiler.html#compile_to_path/3","title":"Kernel.ParallelCompiler.compile_to_path/3","type":"function"},{"doc":"Requires the given files in parallel. Opposite to compile, dependencies are not attempted to be automatically solved between files. It returns {:ok, modules, warnings} or {:error, errors, warnings} . Both errors and warnings are a list of three-element tuples containing the file, line and the formatted error/warning. Options :each_file - for each file compiled, invokes the callback passing the file :each_module - for each module compiled, invokes the callback passing the file, module and the module bytecode","ref":"Kernel.ParallelCompiler.html#require/2","title":"Kernel.ParallelCompiler.require/2","type":"function"},{"doc":"Macros are compile-time constructs that are invoked with Elixir's AST as input and a superset of Elixir's AST as output. Let's see a simple example that shows the difference between functions and macros: defmodule Example do defmacro macro_inspect ( value ) do IO . inspect ( value ) value end def fun_inspect ( value ) do IO . inspect ( value ) value end end Now let's give it a try: import Example macro_inspect ( 1 ) #=&gt; 1 #=&gt; 1 fun_inspect ( 1 ) #=&gt; 1 #=&gt; 1 So far they behave the same, as we are passing an integer as argument. But what happens when we pass an expression: macro_inspect ( 1 + 2 ) #=&gt; {:+, [line: 3], [1, 2]} #=&gt; 3 fun_inspect ( 1 + 2 ) #=&gt; 3 #=&gt; 3 The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See input/0 and output/0 for more information. To learn more about Elixir's AST and how to build them programmatically, see quote/2 . Custom Sigils Macros are also commonly used to implement custom sigils. To create a custom sigil, define a function with the name sigil_{identifier} that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as sigil_x ) then the string argument will allow interpolation. If the sigil is upper case (such as sigil_X ) then the string will not be interpolated. Valid modifiers include only lower and upper case letters. Other characters will cause a syntax error. The module containing the custom sigil must be imported before the sigil syntax can be used. Examples defmodule MySigils do defmacro sigil_x ( term , [ ?r ] ) do quote do unquote ( term ) |&gt; String . reverse ( ) end end defmacro sigil_x ( term , _modifiers ) do term end defmacro sigil_X ( term , [ ?r ] ) do quote do unquote ( term ) |&gt; String . reverse ( ) end end defmacro sigil_X ( term , _modifiers ) do term end end import MySigils ~x(with \#{ &quot;inter&quot; &lt;&gt; &quot;polation&quot; } ) #=&gt;&quot;with interpolation&quot; ~x(with \#{ &quot;inter&quot; &lt;&gt; &quot;polation&quot; } )r #=&gt;&quot;noitalopretni htiw&quot; ~X(without \#{&quot;interpolation&quot;}) #=&gt;&quot;without \\\#{&quot;interpolation&quot;}&quot; ~X(without \#{&quot;interpolation&quot;})r #=&gt;&quot;}\\&quot;noitalopretni\\&quot;{# tuohtiw&quot;","ref":"Macro.html","title":"Macro","type":"module"},{"doc":"Converts the given string to CamelCase format. This function was designed to camelize language identifiers/tokens, that's why it belongs to the Macro module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers. Examples iex&gt; Macro . camelize ( &quot;foo_bar&quot; ) &quot;FooBar&quot; If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms: iex&gt; Macro . camelize ( &quot;API.V1&quot; ) &quot;API.V1&quot; iex&gt; Macro . camelize ( &quot;API_SPEC&quot; ) &quot;API_SPEC&quot;","ref":"Macro.html#camelize/1","title":"Macro.camelize/1","type":"function"},{"doc":"Decomposes a local or remote call into its remote part (when provided), function name and argument list. Returns :error when an invalid call syntax is provided. Examples iex&gt; Macro . decompose_call ( quote ( do : foo ) ) { :foo , [ ] } iex&gt; Macro . decompose_call ( quote ( do : foo ( ) ) ) { :foo , [ ] } iex&gt; Macro . decompose_call ( quote ( do : foo ( 1 , 2 , 3 ) ) ) { :foo , [ 1 , 2 , 3 ] } iex&gt; Macro . decompose_call ( quote ( do : Elixir.M . foo ( 1 , 2 , 3 ) ) ) { { :__aliases__ , [ ] , [ :Elixir , :M ] } , :foo , [ 1 , 2 , 3 ] } iex&gt; Macro . decompose_call ( quote ( do : 42 ) ) :error iex&gt; Macro . decompose_call ( quote ( do : { :foo , [ ] , [ ] } ) ) :error","ref":"Macro.html#decompose_call/1","title":"Macro.decompose_call/1","type":"function"},{"doc":"Recursively escapes a value so it can be inserted into a syntax tree. Examples iex&gt; Macro . escape ( :foo ) :foo iex&gt; Macro . escape ( { :a , :b , :c } ) { :{} , [ ] , [ :a , :b , :c ] } iex&gt; Macro . escape ( { :unquote , [ ] , [ 1 ] } , unquote : true ) 1 Options :unquote - when true, this function leaves unquote/1 and unquote_splicing/1 statements unescaped, effectively unquoting the contents on escape. This option is useful only when escaping ASTs which may have quoted fragments in them. Defaults to false. :prune_metadata - when true, removes metadata from escaped AST nodes. Note this option changes the semantics of escaped code and it should only be used when escaping ASTs, never values. Defaults to false. As an example, ExUnit stores the AST of every assertion, so when an assertion fails we can show code snippets to users. Without this option, each time the test module is compiled, we get a different MD5 of the module bytecode, because the AST contains metadata, such as counters, specific to the compilation environment. By pruning the metadata, we ensure that the module is deterministic and reduce the amount of data ExUnit needs to keep around. Comparison to Kernel.SpecialForms.quote/2 The escape/2 function is sometimes confused with Kernel.SpecialForms.quote/2 , because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable. iex&gt; Macro . escape ( { :a , :b , :c } ) { :{} , [ ] , [ :a , :b , :c ] } iex&gt; quote do : { :a , :b , :c } { :{} , [ ] , [ :a , :b , :c ] } iex&gt; value = { :a , :b , :c } iex&gt; Macro . escape ( value ) { :{} , [ ] , [ :a , :b , :c ] } iex&gt; quote do : value { :value , [ ] , __MODULE__ } iex&gt; value = { :a , :b , :c } iex&gt; quote do : unquote ( value ) { :a , :b , :c } escape/2 is used to escape values (either directly passed or variable bound), while Kernel.SpecialForms.quote/2 produces syntax trees for expressions.","ref":"Macro.html#escape/2","title":"Macro.escape/2","type":"function"},{"doc":"Receives an AST node and expands it until it can no longer be expanded. Note this function does not traverse the AST, only the root node is expanded. This function uses expand_once/2 under the hood. Check it out for more information and examples.","ref":"Macro.html#expand/2","title":"Macro.expand/2","type":"function"},{"doc":"Receives an AST node and expands it once. The following contents are expanded: Macros (local or remote) Aliases are expanded (if possible) and return atoms Compilation environment macros ( __CALLER__/0 , __DIR__/0 , __ENV__/0 and __MODULE__/0 ) Module attributes reader ( @foo ) If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded. expand_once/2 performs the expansion just once. Check expand/2 to perform expansion until the node can no longer be expanded. Examples In the example below, we have a macro that generates a module with a function named name_length that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime. Consider the implementation below: defmacro defmodule_with_length ( name , do : block ) do length = length ( Atom . to_charlist ( name ) ) quote do defmodule unquote ( name ) do def name_length , do : unquote ( length ) unquote ( block ) end end end When invoked like this: defmodule_with_length My.Module do def other_function , do : ... end The compilation will fail because My.Module when quoted is not an atom, but a syntax tree as follows: { :__aliases__ , [ ] , [ :My , :Module ] } That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example: alias MyHelpers , as : My defmodule_with_length My.Module do def other_function , do : ... end The final module name will be MyHelpers.Module and not My.Module . With Macro.expand/2 , such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as: defmacro defmodule_with_length ( name , do : block ) do expanded = Macro . expand ( name , __CALLER__ ) length = length ( Atom . to_charlist ( expanded ) ) quote do defmodule unquote ( name ) do def name_length , do : unquote ( length ) unquote ( block ) end end end","ref":"Macro.html#expand_once/2","title":"Macro.expand_once/2","type":"function"},{"doc":"Generates AST nodes for a given number of required argument variables using Macro.var/2 . Note the arguments are not unique. If you later on want to access the same variables, you can invoke this function with the same inputs. Use generate_unique_arguments/2 to generate a unique arguments that can't be overridden. Examples iex&gt; Macro . generate_arguments ( 2 , __MODULE__ ) [ { :arg1 , [ ] , __MODULE__ } , { :arg2 , [ ] , __MODULE__ } ]","ref":"Macro.html#generate_arguments/2","title":"Macro.generate_arguments/2","type":"function"},{"doc":"Generates AST nodes for a given number of required argument variables using Macro.unique_var/2 . Examples iex&gt; [ var1 , var2 ] = Macro . generate_unique_arguments ( 2 , __MODULE__ ) iex&gt; { :arg1 , [ counter : c1 ] , __MODULE__ } = var1 iex&gt; { :arg2 , [ counter : c2 ] , __MODULE__ } = var2 iex&gt; is_integer ( c1 ) and is_integer ( c2 ) true","ref":"Macro.html#generate_unique_arguments/2","title":"Macro.generate_unique_arguments/2","type":"function"},{"doc":"Returns true if the given name and arity is an operator.","ref":"Macro.html#operator?/2","title":"Macro.operator?/2","type":"function"},{"doc":"Pipes expr into the call_args at the given position .","ref":"Macro.html#pipe/3","title":"Macro.pipe/3","type":"function"},{"doc":"Performs a depth-first, post-order traversal of quoted expressions.","ref":"Macro.html#postwalk/2","title":"Macro.postwalk/2","type":"function"},{"doc":"Performs a depth-first, post-order traversal of quoted expressions using an accumulator.","ref":"Macro.html#postwalk/3","title":"Macro.postwalk/3","type":"function"},{"doc":"Performs a depth-first, pre-order traversal of quoted expressions.","ref":"Macro.html#prewalk/2","title":"Macro.prewalk/2","type":"function"},{"doc":"Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.","ref":"Macro.html#prewalk/3","title":"Macro.prewalk/3","type":"function"},{"doc":"Returns true if the given quoted expression represents a quoted literal. Atoms, numbers, and functions are always literals. Binaries, lists, tuples, maps, and structs are only literals if all of their terms are also literals. Examples iex&gt; Macro . quoted_literal? ( quote ( do : &quot;foo&quot; ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : { &quot;foo&quot; , 1 } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : { &quot;foo&quot; , 1 , :baz } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : %{ foo : &quot;bar&quot; } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : % URI { path : &quot;/&quot; } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : URI . parse ( &quot;/&quot; ) ) ) false iex&gt; Macro . quoted_literal? ( quote ( do : { foo , var } ) ) false","ref":"Macro.html#quoted_literal?/1","title":"Macro.quoted_literal?/1","type":"function"},{"doc":"Returns true if the given name and arity is a special form.","ref":"Macro.html#special_form?/2","title":"Macro.special_form?/2","type":"function"},{"doc":"Expands the struct given by module in the given env . This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled. It will raise CompileError if the struct is not available. From Elixir v1.12, calling this function also adds an export dependency on the given struct.","ref":"Macro.html#struct!/2","title":"Macro.struct!/2","type":"function"},{"doc":"Converts the given expression AST to a string. The given fun is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node. This function discards all formatting of the original code. Examples iex&gt; Macro . to_string ( quote ( do : foo . bar ( 1 , 2 , 3 ) ) ) &quot;foo.bar(1, 2, 3)&quot; iex&gt; Macro . to_string ( quote ( do : 1 + 2 ) , fn ...&gt; 1 , _string -&gt; &quot;one&quot; ...&gt; 2 , _string -&gt; &quot;two&quot; ...&gt; _ast , string -&gt; string ...&gt; end ) &quot;one + two&quot;","ref":"Macro.html#to_string/2","title":"Macro.to_string/2","type":"function"},{"doc":"Performs a depth-first traversal of quoted expressions using an accumulator.","ref":"Macro.html#traverse/4","title":"Macro.traverse/4","type":"function"},{"doc":"Converts the given atom or binary to underscore format. If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed. This function was designed to underscore language identifiers/tokens, that's why it belongs to the Macro module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers. Examples iex&gt; Macro . underscore ( &quot;FooBar&quot; ) &quot;foo_bar&quot; iex&gt; Macro . underscore ( &quot;Foo.Bar&quot; ) &quot;foo/bar&quot; iex&gt; Macro . underscore ( Foo.Bar ) &quot;foo/bar&quot; In general, underscore can be thought of as the reverse of camelize , however, in some cases formatting may be lost: iex&gt; Macro . underscore ( &quot;SAPExample&quot; ) &quot;sap_example&quot; iex&gt; Macro . camelize ( &quot;sap_example&quot; ) &quot;SapExample&quot; iex&gt; Macro . camelize ( &quot;hello_10&quot; ) &quot;Hello10&quot;","ref":"Macro.html#underscore/1","title":"Macro.underscore/1","type":"function"},{"doc":"Unescapes the given chars. This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check unescape_string/2 for information on how to customize the escaping map. In this setup, Elixir will escape the following: \\0 , \\a , \\b , \\d , \\e , \\f , \\n , \\r , \\s , \\t and \\v . Bytes can be given as hexadecimals via \\xNN and Unicode code points as \\uNNNN escapes. This function is commonly used on sigil implementations (like ~r , ~s and others) which receive a raw, unescaped string. Examples iex&gt; Macro . unescape_string ( &quot;example \\\\ n&quot; ) &quot;example \\n &quot; In the example above, we pass a string with \\n escaped and return a version with it unescaped.","ref":"Macro.html#unescape_string/1","title":"Macro.unescape_string/1","type":"function"},{"doc":"Unescapes the given chars according to the map given. Check unescape_string/1 if you want to use the same map as Elixir single- and double-quoted strings. Map The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir: def unescape_map ( :newline ) , do : true def unescape_map ( :unicode ) , do : true def unescape_map ( :hex ) , do : true def unescape_map ( ?0 ) , do : ?0 def unescape_map ( ?a ) , do : ?\\a def unescape_map ( ?b ) , do : ?\\b def unescape_map ( ?d ) , do : ?\\d def unescape_map ( ?e ) , do : ?\\e def unescape_map ( ?f ) , do : ?\\f def unescape_map ( ?n ) , do : ?\\n def unescape_map ( ?r ) , do : ?\\r def unescape_map ( ?s ) , do : ?\\s def unescape_map ( ?t ) , do : ?\\t def unescape_map ( ?v ) , do : ?\\v def unescape_map ( e ) , do : e If the unescape_map/1 function returns false , the char is not escaped and the backslash is kept in the string. Newlines, Unicode, and hexadecimals code points will be escaped if the map returns true respectively for :newline , :unicode , and :hex . Examples Using the unescape_map/1 function defined above is easy: Macro . unescape_string ( &quot;example \\\\ n&quot; , &amp; unescape_map ( &amp;1 ) )","ref":"Macro.html#unescape_string/2","title":"Macro.unescape_string/2","type":"function"},{"doc":"Generates an AST node representing a unique variable given by the atoms var and context . Examples iex&gt; { :foo , [ counter : c ] , __MODULE__ } = Macro . unique_var ( :foo , __MODULE__ ) iex&gt; is_integer ( c ) true","ref":"Macro.html#unique_var/2","title":"Macro.unique_var/2","type":"function"},{"doc":"Breaks a pipeline expression into a list. The AST for a pipeline (a sequence of applications of |&gt; ) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most :|&gt; (which is the last one to be executed), and its left-hand and right-hand sides are its arguments: quote do : 100 |&gt; div ( 5 ) |&gt; div ( 2 ) #=&gt; {:|&gt;, _, [arg1, arg2]} In the example above, the |&gt; pipe is the right-most pipe; arg1 is the AST for 100 |&gt; div(5) , and arg2 is the AST for div(2) . It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that: Macro . unpipe ( quote do : 100 |&gt; div ( 5 ) |&gt; div ( 2 ) ) #=&gt; [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}] We get a list that follows the pipeline directly: first the 100 , then the div(5) (more precisely, its AST), then div(2) . The 0 as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: {{:div, [], [5]}, 0} means that the previous element ( 100 ) will be inserted as the 0th (first) argument to the div/2 function, so that the AST for that function will become {:div, [], [100, 5]} ( div(100, 5) ).","ref":"Macro.html#unpipe/1","title":"Macro.unpipe/1","type":"function"},{"doc":"Applies the given function to the node metadata if it contains one. This is often useful when used with Macro.prewalk/2 to remove information like lines and hygienic counters from the expression for either storage or comparison. Examples iex&gt; quoted = quote line : 10 , do : sample ( ) { :sample , [ line : 10 ] , [ ] } iex&gt; Macro . update_meta ( quoted , &amp; Keyword . delete ( &amp;1 , :line ) ) { :sample , [ ] , [ ] }","ref":"Macro.html#update_meta/2","title":"Macro.update_meta/2","type":"function"},{"doc":"Validates the given expressions are valid quoted expressions. Checks the Macro.t/0 for the specification of a valid quoted expression. It returns :ok if the expression is valid. Otherwise it returns a tuple in the form of {:error, remainder} where remainder is the invalid part of the quoted expression. Examples iex&gt; Macro . validate ( { :two_element , :tuple } ) :ok iex&gt; Macro . validate ( { :three , :element , :tuple } ) { :error , { :three , :element , :tuple } } iex&gt; Macro . validate ( [ 1 , 2 , 3 ] ) :ok iex&gt; Macro . validate ( [ 1 , 2 , 3 , { 4 } ] ) { :error , { 4 } }","ref":"Macro.html#validate/1","title":"Macro.validate/1","type":"function"},{"doc":"Generates an AST node representing the variable given by the atoms var and context . Note this variable is not unique. If you later on want to access this same variable, you can invoke var/2 again with the same arguments. Use unique_var/2 to generate a unique variable that can't be overridden. Examples In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be __MODULE__/0 : iex&gt; Macro . var ( :foo , __MODULE__ ) { :foo , [ ] , __MODULE__ } However, if there is a need to access the user variable, nil can be given: iex&gt; Macro . var ( :foo , nil ) { :foo , [ ] , nil }","ref":"Macro.html#var/2","title":"Macro.var/2","type":"function"},{"doc":"A captured remote function in the format of &amp;Mod.fun/arity","ref":"Macro.html#t:captured_remote_function/0","title":"Macro.captured_remote_function/0","type":"type"},{"doc":"The inputs of a macro","ref":"Macro.html#t:input/0","title":"Macro.input/0","type":"type"},{"doc":"A keyword list of AST metadata. The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the :line annotation, while the AST emitted by quote/2 will only have the :line annotation if the :line option is provided. The following metadata keys are public: :context - Defines the context in which the AST was generated. For example, quote/2 will include the module calling quote/2 as the context. This is often used to distinguish regular code from code generated by a macro or by quote/2 . :counter - The variable counter used for variable hygiene. In terms of the compiler, each variable is identified by the combination of either name and metadata[:counter] , or name and context . :generated - Whether the code should be considered as generated by the compiler or not. This means the compiler and tools like Dialyzer may not emit certain warnings. :keep - Used by quote/2 with the option location: :keep to annotate the file and the line number of the quoted source. :line - The line number of the AST node. The following metadata keys are enabled by Code.string_to_quoted/2 : :closing - contains metadata about the closing pair, such as a } in a tuple or in a map, or such as the closing ) in a function call with parens. The :closing does not delimit the end of expression if there are :do and :end metadata (when :token_metadata is true) :column - the column number of the AST node (when :columns is true) :delimiter - contains the opening delimiter for sigils, strings, and charlists as a string (such as &quot;{&quot; , &quot;/&quot; , &quot;'&quot; , and the like) :format - set to :keyword when an atom is defined as a keyword :do - contains metadata about the do location in a function call with do/end blocks (when :token_metadata is true) :end - contains metadata about the end location in a function call with do/end blocks (when :token_metadata is true) :end_of_expression - denotes when the end of expression effectively happens. Available for all expressions except the last one inside a __block__ (when :token_metadata is true) :indentation - indentation of a sigil heredoc The following metadata keys are private: :alias - Used for alias hygiene. :ambiguous_op - Used for improved error messages in the compiler. :import - Used for import hygiene. :var - Used for improved error messages on undefined variables. Do not rely on them as they may change or be fully removed in future versions of the language. They are often used by quote/2 and the compiler to provide features like hygiene, better error messages, and so forth. If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.","ref":"Macro.html#t:metadata/0","title":"Macro.metadata/0","type":"type"},{"doc":"The output of a macro","ref":"Macro.html#t:output/0","title":"Macro.output/0","type":"type"},{"doc":"Abstract Syntax Tree (AST)","ref":"Macro.html#t:t/0","title":"Macro.t/0","type":"type"},{"doc":"A struct that holds compile time environment information. The current environment can be accessed at any time as __ENV__/0 . Inside macros, the caller environment can be accessed as __CALLER__/0 . An instance of Macro.Env must not be modified by hand. If you need to create a custom environment to pass to Code.eval_quoted/3 , use the following trick: def make_custom_env do import SomeModule , only : [ some_function : 2 ] alias A.B.C __ENV__ end You may then call make_custom_env() to get a struct with the desired imports and aliases included. It contains the following fields: aliases - a list of two-element tuples, where the first element is the aliased name and the second one the actual name context - the context of the environment; it can be nil (default context), :guard (inside a guard) or :match (inside a match) context_modules - a list of modules defined in the current context file - the current file name as a binary function - a tuple as {atom, integer} , where the first element is the function name and the second its arity; returns nil if not inside a function functions - a list of functions imported from each module line - the current line as an integer macro_aliases - a list of aliases defined inside the current macro macros - a list of macros imported from each module module - the current module name requires - the list of required modules The following fields are private to Elixir's macro expansion mechanism and must not be accessed directly: contextual_vars current_vars lexical_tracker prematch_vars tracers unused_vars The following fields are deprecated and must not be accessed or relied on: vars - a list keeping all defined variables as {var, context}","ref":"Macro.Env.html","title":"Macro.Env","type":"module"},{"doc":"Checks if a variable belongs to the environment.","ref":"Macro.Env.html#has_var?/2","title":"Macro.Env.has_var?/2","type":"function"},{"doc":"Returns whether the compilation environment is currently inside a guard.","ref":"Macro.Env.html#in_guard?/1","title":"Macro.Env.in_guard?/1","type":"function"},{"doc":"Returns whether the compilation environment is currently inside a match clause.","ref":"Macro.Env.html#in_match?/1","title":"Macro.Env.in_match?/1","type":"function"},{"doc":"Returns a keyword list containing the file and line information as keys.","ref":"Macro.Env.html#location/1","title":"Macro.Env.location/1","type":"function"},{"doc":"Returns the environment stacktrace.","ref":"Macro.Env.html#stacktrace/1","title":"Macro.Env.stacktrace/1","type":"function"},{"doc":"Returns a Macro.Env in the match context.","ref":"Macro.Env.html#to_match/1","title":"Macro.Env.to_match/1","type":"function"},{"doc":"Returns a list of variables in the current environment. Each variable is identified by a tuple of two elements, where the first element is the variable name as an atom and the second element is its context, which may be an atom or an integer.","ref":"Macro.Env.html#vars/1","title":"Macro.Env.vars/1","type":"function"},{"doc":"","ref":"Macro.Env.html#t:aliases/0","title":"Macro.Env.aliases/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:context/0","title":"Macro.Env.context/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:context_modules/0","title":"Macro.Env.context_modules/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:file/0","title":"Macro.Env.file/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:functions/0","title":"Macro.Env.functions/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:lexical_tracker/0","title":"Macro.Env.lexical_tracker/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:line/0","title":"Macro.Env.line/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:macro_aliases/0","title":"Macro.Env.macro_aliases/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:macros/0","title":"Macro.Env.macros/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:name_arity/0","title":"Macro.Env.name_arity/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:requires/0","title":"Macro.Env.requires/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:t/0","title":"Macro.Env.t/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:variable/0","title":"Macro.Env.variable/0","type":"type"},{"doc":"Mechanism for handling behaviours. This module is deprecated. Instead of defcallback/1 and defmacrocallback/1 , the @callback and @macrocallback module attributes can be used respectively. See the documentation for Module for more information on these attributes. Instead of MyModule.__behaviour__(:callbacks) , MyModule.behaviour_info(:callbacks) can be used.","ref":"Behaviour.html","title":"Behaviour","type":"module"},{"doc":"Defines a function callback according to the given type specification.","ref":"Behaviour.html#defcallback/1","title":"Behaviour.defcallback/1","type":"macro"},{"doc":"Defines a macro callback according to the given type specification.","ref":"Behaviour.html#defmacrocallback/1","title":"Behaviour.defmacrocallback/1","type":"macro"},{"doc":"Generic API for dictionaries. If you need a general dictionary, use the Map module. If you need to manipulate keyword lists, use Keyword . To convert maps into keywords and vice-versa, use the new function in the respective modules.","ref":"Dict.html","title":"Dict","type":"module"},{"doc":"","ref":"Dict.html#delete/2","title":"Dict.delete/2","type":"function"},{"doc":"","ref":"Dict.html#drop/2","title":"Dict.drop/2","type":"function"},{"doc":"","ref":"Dict.html#empty/1","title":"Dict.empty/1","type":"function"},{"doc":"","ref":"Dict.html#equal?/2","title":"Dict.equal?/2","type":"function"},{"doc":"","ref":"Dict.html#fetch/2","title":"Dict.fetch/2","type":"function"},{"doc":"","ref":"Dict.html#fetch!/2","title":"Dict.fetch!/2","type":"function"},{"doc":"","ref":"Dict.html#get/3","title":"Dict.get/3","type":"function"},{"doc":"","ref":"Dict.html#get_and_update/3","title":"Dict.get_and_update/3","type":"function"},{"doc":"","ref":"Dict.html#get_lazy/3","title":"Dict.get_lazy/3","type":"function"},{"doc":"","ref":"Dict.html#has_key?/2","title":"Dict.has_key?/2","type":"function"},{"doc":"","ref":"Dict.html#keys/1","title":"Dict.keys/1","type":"function"},{"doc":"","ref":"Dict.html#merge/2","title":"Dict.merge/2","type":"function"},{"doc":"","ref":"Dict.html#merge/3","title":"Dict.merge/3","type":"function"},{"doc":"","ref":"Dict.html#pop/3","title":"Dict.pop/3","type":"function"},{"doc":"","ref":"Dict.html#pop_lazy/3","title":"Dict.pop_lazy/3","type":"function"},{"doc":"","ref":"Dict.html#put/3","title":"Dict.put/3","type":"function"},{"doc":"","ref":"Dict.html#put_new/3","title":"Dict.put_new/3","type":"function"},{"doc":"","ref":"Dict.html#put_new_lazy/3","title":"Dict.put_new_lazy/3","type":"function"},{"doc":"","ref":"Dict.html#size/1","title":"Dict.size/1","type":"function"},{"doc":"","ref":"Dict.html#split/2","title":"Dict.split/2","type":"function"},{"doc":"","ref":"Dict.html#take/2","title":"Dict.take/2","type":"function"},{"doc":"","ref":"Dict.html#to_list/1","title":"Dict.to_list/1","type":"function"},{"doc":"","ref":"Dict.html#update/4","title":"Dict.update/4","type":"function"},{"doc":"","ref":"Dict.html#update!/3","title":"Dict.update!/3","type":"function"},{"doc":"","ref":"Dict.html#values/1","title":"Dict.values/1","type":"function"},{"doc":"","ref":"Dict.html#t:key/0","title":"Dict.key/0","type":"type"},{"doc":"","ref":"Dict.html#t:t/0","title":"Dict.t/0","type":"type"},{"doc":"","ref":"Dict.html#t:value/0","title":"Dict.value/0","type":"type"},{"doc":"A event manager with event handlers behaviour. If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use :gen_event instead. Alternatives There are a few suitable alternatives to replace GenEvent. Each of them can be the most beneficial based on the use case. Supervisor and GenServers One alternative to GenEvent is a very minimal solution consisting of using a supervisor and multiple GenServers started under it. The supervisor acts as the &quot;event manager&quot; and the children GenServers act as the &quot;event handlers&quot;. This approach has some shortcomings (it provides no backpressure for example) but can still replace GenEvent for low-profile usages of it. This blog post by José Valim has more detailed information on this approach. GenStage If the use case where you were using GenEvent requires more complex logic, GenStage provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the GenStage documentation for more information. :gen_event If your use case requires exactly what GenEvent provided, or you have to integrate with an existing :gen_event -based system, you can still use the :gen_event Erlang module.","ref":"GenEvent.html","title":"GenEvent","type":"behaviour"},{"doc":"","ref":"GenEvent.html#c:code_change/3","title":"GenEvent.code_change/3","type":"callback"},{"doc":"","ref":"GenEvent.html#c:handle_call/2","title":"GenEvent.handle_call/2","type":"callback"},{"doc":"","ref":"GenEvent.html#c:handle_event/2","title":"GenEvent.handle_event/2","type":"callback"},{"doc":"","ref":"GenEvent.html#c:handle_info/2","title":"GenEvent.handle_info/2","type":"callback"},{"doc":"","ref":"GenEvent.html#c:init/1","title":"GenEvent.init/1","type":"callback"},{"doc":"","ref":"GenEvent.html#c:terminate/2","title":"GenEvent.terminate/2","type":"callback"},{"doc":"","ref":"GenEvent.html#t:handler/0","title":"GenEvent.handler/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:manager/0","title":"GenEvent.manager/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:name/0","title":"GenEvent.name/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:on_start/0","title":"GenEvent.on_start/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:options/0","title":"GenEvent.options/0","type":"type"},{"doc":"Tuple-based HashDict implementation. This module is deprecated. Use the Map module instead.","ref":"HashDict.html","title":"HashDict","type":"module"},{"doc":"","ref":"HashDict.html#delete/2","title":"HashDict.delete/2","type":"function"},{"doc":"","ref":"HashDict.html#drop/2","title":"HashDict.drop/2","type":"function"},{"doc":"","ref":"HashDict.html#equal?/2","title":"HashDict.equal?/2","type":"function"},{"doc":"","ref":"HashDict.html#fetch/2","title":"HashDict.fetch/2","type":"function"},{"doc":"","ref":"HashDict.html#fetch!/2","title":"HashDict.fetch!/2","type":"function"},{"doc":"","ref":"HashDict.html#get/3","title":"HashDict.get/3","type":"function"},{"doc":"","ref":"HashDict.html#get_and_update/3","title":"HashDict.get_and_update/3","type":"function"},{"doc":"","ref":"HashDict.html#get_lazy/3","title":"HashDict.get_lazy/3","type":"function"},{"doc":"","ref":"HashDict.html#has_key?/2","title":"HashDict.has_key?/2","type":"function"},{"doc":"","ref":"HashDict.html#keys/1","title":"HashDict.keys/1","type":"function"},{"doc":"","ref":"HashDict.html#merge/3","title":"HashDict.merge/3","type":"function"},{"doc":"Creates a new empty dict.","ref":"HashDict.html#new/0","title":"HashDict.new/0","type":"function"},{"doc":"","ref":"HashDict.html#pop/3","title":"HashDict.pop/3","type":"function"},{"doc":"","ref":"HashDict.html#pop_lazy/3","title":"HashDict.pop_lazy/3","type":"function"},{"doc":"","ref":"HashDict.html#put/3","title":"HashDict.put/3","type":"function"},{"doc":"","ref":"HashDict.html#put_new/3","title":"HashDict.put_new/3","type":"function"},{"doc":"","ref":"HashDict.html#put_new_lazy/3","title":"HashDict.put_new_lazy/3","type":"function"},{"doc":"","ref":"HashDict.html#size/1","title":"HashDict.size/1","type":"function"},{"doc":"","ref":"HashDict.html#split/2","title":"HashDict.split/2","type":"function"},{"doc":"","ref":"HashDict.html#take/2","title":"HashDict.take/2","type":"function"},{"doc":"","ref":"HashDict.html#to_list/1","title":"HashDict.to_list/1","type":"function"},{"doc":"","ref":"HashDict.html#update/4","title":"HashDict.update/4","type":"function"},{"doc":"","ref":"HashDict.html#update!/3","title":"HashDict.update!/3","type":"function"},{"doc":"","ref":"HashDict.html#values/1","title":"HashDict.values/1","type":"function"},{"doc":"","ref":"HashDict.html#t:t/0","title":"HashDict.t/0","type":"opaque"},{"doc":"Tuple-based HashSet implementation. This module is deprecated. Use the MapSet module instead.","ref":"HashSet.html","title":"HashSet","type":"module"},{"doc":"","ref":"HashSet.html#delete/2","title":"HashSet.delete/2","type":"function"},{"doc":"","ref":"HashSet.html#difference/2","title":"HashSet.difference/2","type":"function"},{"doc":"","ref":"HashSet.html#disjoint?/2","title":"HashSet.disjoint?/2","type":"function"},{"doc":"","ref":"HashSet.html#equal?/2","title":"HashSet.equal?/2","type":"function"},{"doc":"","ref":"HashSet.html#intersection/2","title":"HashSet.intersection/2","type":"function"},{"doc":"","ref":"HashSet.html#member?/2","title":"HashSet.member?/2","type":"function"},{"doc":"","ref":"HashSet.html#new/0","title":"HashSet.new/0","type":"function"},{"doc":"","ref":"HashSet.html#put/2","title":"HashSet.put/2","type":"function"},{"doc":"","ref":"HashSet.html#size/1","title":"HashSet.size/1","type":"function"},{"doc":"","ref":"HashSet.html#subset?/2","title":"HashSet.subset?/2","type":"function"},{"doc":"","ref":"HashSet.html#to_list/1","title":"HashSet.to_list/1","type":"function"},{"doc":"","ref":"HashSet.html#union/2","title":"HashSet.union/2","type":"function"},{"doc":"","ref":"HashSet.html#t:t/0","title":"HashSet.t/0","type":"opaque"},{"doc":"Generic API for sets. This module is deprecated, use the MapSet module instead.","ref":"Set.html","title":"Set","type":"module"},{"doc":"","ref":"Set.html#delete/2","title":"Set.delete/2","type":"function"},{"doc":"","ref":"Set.html#difference/2","title":"Set.difference/2","type":"function"},{"doc":"","ref":"Set.html#disjoint?/2","title":"Set.disjoint?/2","type":"function"},{"doc":"","ref":"Set.html#empty/1","title":"Set.empty/1","type":"function"},{"doc":"","ref":"Set.html#equal?/2","title":"Set.equal?/2","type":"function"},{"doc":"","ref":"Set.html#intersection/2","title":"Set.intersection/2","type":"function"},{"doc":"","ref":"Set.html#member?/2","title":"Set.member?/2","type":"function"},{"doc":"","ref":"Set.html#put/2","title":"Set.put/2","type":"function"},{"doc":"","ref":"Set.html#size/1","title":"Set.size/1","type":"function"},{"doc":"","ref":"Set.html#subset?/2","title":"Set.subset?/2","type":"function"},{"doc":"","ref":"Set.html#to_list/1","title":"Set.to_list/1","type":"function"},{"doc":"","ref":"Set.html#union/2","title":"Set.union/2","type":"function"},{"doc":"","ref":"Set.html#t:t/0","title":"Set.t/0","type":"type"},{"doc":"","ref":"Set.html#t:value/0","title":"Set.value/0","type":"type"},{"doc":"","ref":"Set.html#t:values/0","title":"Set.values/0","type":"type"},{"doc":"Outdated functions for building child specifications. The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the Supervisor documentation instead. Convenience functions for defining supervisor specifications. Example By using the functions in this module one can specify the children to be used under a supervisor, started with Supervisor.start_link/2 : import Supervisor.Spec children = [ worker ( MyWorker , [ arg1 , arg2 , arg3 ] ) , supervisor ( MySupervisor , [ arg1 ] ) ] Supervisor . start_link ( children , strategy : :one_for_one ) Sometimes, it may be handy to define supervisors backed by a module: defmodule MySupervisor do use Supervisor def start_link ( arg ) do Supervisor . start_link ( __MODULE__ , arg ) end def init ( arg ) do children = [ worker ( MyWorker , [ arg ] , restart : :temporary ) ] supervise ( children , strategy : :simple_one_for_one ) end end Note that in this case we don't have to explicitly import Supervisor.Spec since use Supervisor automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the Supervisor.init/1 callback. Supervisor and worker options In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options: :id - a name used to identify the child specification internally by the supervisor; defaults to the given module name for the child worker/supervisor :function - the function to invoke on the child to start it :restart - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below) :shutdown - an atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below) :modules - it should be a list with one element [module] , where module is the name of the callback module only if the child process is a Supervisor or GenServer ; if the child process is a GenEvent , :modules should be :dynamic Restart values (:restart) The following restart values are supported in the :restart option: :permanent - the child process is always restarted :temporary - the child process is never restarted (not even when the supervisor's strategy is :rest_for_one or :one_for_all ) :transient - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal , :shutdown or {:shutdown, term} Note that supervisor that reached maximum restart intensity will exit with :shutdown reason. In this case the supervisor will only restart if its child specification was defined with the :restart option set to :permanent (the default). Shutdown values ( :shutdown ) The following shutdown values are supported in the :shutdown option: :brutal_kill - the child process is unconditionally terminated using Process.exit(child, :kill) :infinity - if the child process is a supervisor, this is a mechanism to give the subtree enough time to shut down; it can also be used with workers with care a non-negative integer - the amount of time in milliseconds that the supervisor tells the child process to terminate by calling Process.exit(child, :shutdown) and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using Process.exit(child, :kill)","ref":"Supervisor.Spec.html","title":"Supervisor.Spec","type":"module"},{"doc":"Receives a list of children (workers or supervisors) to supervise and a set of options . Returns a tuple containing the supervisor specification. This tuple can be used as the return value of the Supervisor.init/1 callback when implementing a module-based supervisor. Examples supervise ( children , strategy : :one_for_one ) Options :strategy - the restart strategy option. It can be either :one_for_one , :rest_for_one , :one_for_all , or :simple_one_for_one . You can learn more about strategies in the Supervisor module docs. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . The :strategy option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the Supervisor module for a detailed description of the available strategies.","ref":"Supervisor.Spec.html#supervise/2","title":"Supervisor.Spec.supervise/2","type":"function"},{"doc":"Defines the given module as a supervisor which will be started with the given arguments. supervisor ( module , [ ] , restart : :permanent ) By default, the function start_link is invoked on the given module. Overall, the default values for the options are: [ id : module , function : :start_link , restart : :permanent , shutdown : :infinity , modules : [ module ] ] See the &quot;Supervisor and worker options&quot; section in the Supervisor.Spec module for more information on the available options.","ref":"Supervisor.Spec.html#supervisor/3","title":"Supervisor.Spec.supervisor/3","type":"function"},{"doc":"Defines the given module as a worker which will be started with the given arguments. worker ( ExUnit.Runner , [ ] , restart : :permanent ) By default, the function start_link is invoked on the given module. Overall, the default values for the options are: [ id : module , function : :start_link , restart : :permanent , shutdown : 5000 , modules : [ module ] ] See the &quot;Supervisor and worker options&quot; section in the Supervisor.Spec module for more information on the available options.","ref":"Supervisor.Spec.html#worker/3","title":"Supervisor.Spec.worker/3","type":"function"},{"doc":"Supported ID values","ref":"Supervisor.Spec.html#t:child_id/0","title":"Supervisor.Spec.child_id/0","type":"type"},{"doc":"Supported module values","ref":"Supervisor.Spec.html#t:modules/0","title":"Supervisor.Spec.modules/0","type":"type"},{"doc":"Supported restart values","ref":"Supervisor.Spec.html#t:restart/0","title":"Supervisor.Spec.restart/0","type":"type"},{"doc":"Supported shutdown values","ref":"Supervisor.Spec.html#t:shutdown/0","title":"Supervisor.Spec.shutdown/0","type":"type"},{"doc":"The supervisor specification","ref":"Supervisor.Spec.html#t:spec/0","title":"Supervisor.Spec.spec/0","type":"type"},{"doc":"Supported strategies","ref":"Supervisor.Spec.html#t:strategy/0","title":"Supervisor.Spec.strategy/0","type":"type"},{"doc":"Supported worker values","ref":"Supervisor.Spec.html#t:worker/0","title":"Supervisor.Spec.worker/0","type":"type"},{"doc":"","ref":"ArgumentError.html","title":"ArgumentError","type":"exception"},{"doc":"","ref":"ArithmeticError.html","title":"ArithmeticError","type":"exception"},{"doc":"","ref":"BadArityError.html","title":"BadArityError","type":"exception"},{"doc":"","ref":"BadBooleanError.html","title":"BadBooleanError","type":"exception"},{"doc":"","ref":"BadFunctionError.html","title":"BadFunctionError","type":"exception"},{"doc":"","ref":"BadMapError.html","title":"BadMapError","type":"exception"},{"doc":"","ref":"BadStructError.html","title":"BadStructError","type":"exception"},{"doc":"","ref":"CaseClauseError.html","title":"CaseClauseError","type":"exception"},{"doc":"","ref":"Code.LoadError.html","title":"Code.LoadError","type":"exception"},{"doc":"","ref":"CompileError.html","title":"CompileError","type":"exception"},{"doc":"","ref":"CondClauseError.html","title":"CondClauseError","type":"exception"},{"doc":"","ref":"Enum.EmptyError.html","title":"Enum.EmptyError","type":"exception"},{"doc":"","ref":"Enum.OutOfBoundsError.html","title":"Enum.OutOfBoundsError","type":"exception"},{"doc":"","ref":"ErlangError.html","title":"ErlangError","type":"exception"},{"doc":"","ref":"File.CopyError.html","title":"File.CopyError","type":"exception"},{"doc":"","ref":"File.Error.html","title":"File.Error","type":"exception"},{"doc":"","ref":"File.LinkError.html","title":"File.LinkError","type":"exception"},{"doc":"","ref":"File.RenameError.html","title":"File.RenameError","type":"exception"},{"doc":"","ref":"FunctionClauseError.html","title":"FunctionClauseError","type":"exception"},{"doc":"","ref":"IO.StreamError.html","title":"IO.StreamError","type":"exception"},{"doc":"Raised when a struct cannot be inspected.","ref":"Inspect.Error.html","title":"Inspect.Error","type":"exception"},{"doc":"","ref":"KeyError.html","title":"KeyError","type":"exception"},{"doc":"","ref":"MatchError.html","title":"MatchError","type":"exception"},{"doc":"","ref":"Module.Types.Error.html","title":"Module.Types.Error","type":"exception"},{"doc":"","ref":"OptionParser.ParseError.html","title":"OptionParser.ParseError","type":"exception"},{"doc":"","ref":"Protocol.UndefinedError.html","title":"Protocol.UndefinedError","type":"exception"},{"doc":"","ref":"Regex.CompileError.html","title":"Regex.CompileError","type":"exception"},{"doc":"","ref":"RuntimeError.html","title":"RuntimeError","type":"exception"},{"doc":"","ref":"SyntaxError.html","title":"SyntaxError","type":"exception"},{"doc":"","ref":"SystemLimitError.html","title":"SystemLimitError","type":"exception"},{"doc":"","ref":"TokenMissingError.html","title":"TokenMissingError","type":"exception"},{"doc":"","ref":"TryClauseError.html","title":"TryClauseError","type":"exception"},{"doc":"","ref":"UndefinedFunctionError.html","title":"UndefinedFunctionError","type":"exception"},{"doc":"","ref":"UnicodeConversionError.html","title":"UnicodeConversionError","type":"exception"},{"doc":"","ref":"Version.InvalidRequirementError.html","title":"Version.InvalidRequirementError","type":"exception"},{"doc":"","ref":"Version.InvalidVersionError.html","title":"Version.InvalidVersionError","type":"exception"},{"doc":"","ref":"WithClauseError.html","title":"WithClauseError","type":"exception"},{"doc":"Compatibility and Deprecations Elixir is versioned according to a vMAJOR.MINOR.PATCH schema. Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches. Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches: Elixir version Support 1.12 Bug fixes and security patches 1.11 Security patches only 1.10 Security patches only 1.9 Security patches only 1.8 Security patches only 1.7 Security patches only New releases are announced in the read-only announcements mailing list . All security releases will be tagged with [security] . There are currently no plans for a major v2 release.","ref":"compatibility-and-deprecations.html","title":"Compatibility and Deprecations","type":"extras"},{"doc":"Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions. Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code: Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues. Bugs: if an API has undesired behaviour, a program that depends on the buggy behaviour may break if the bug is fixed. We reserve the right to fix such bugs. Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with --warning-as-errors ) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements. Imports: new functions may be added to the Kernel module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using import Kernel, except: [...] with a list of all functions you don't want to be imported from Kernel . We reserve the right to do such additions. In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &quot;Deprecations&quot; section . The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.","ref":"compatibility-and-deprecations.html#compatibility-between-non-major-elixir-versions","title":"Compatibility and Deprecations - Compatibility between non-major Elixir versions","type":"extras"},{"doc":"Erlang/OTP versioning is independent from the versioning of Elixir. Each version of Elixir supports a specific range of Erlang/OTP versions. The compatibility table is shown below. Elixir version Supported Erlang/OTP versions 1.12 21 - 24 1.11 21 - 23 1.10 21 - 22 (and Erlang/OTP 23 from v1.10.3) 1.9 20 - 22 1.8 20 - 22 1.7 19 - 22 1.6 19 - 20 (and Erlang/OTP 21 from v1.6.6) 1.5 18 - 20 1.4 18 - 19 (and Erlang/OTP 20 from v1.4.5) 1.3 18 - 19 1.2 18 - 18 (and Erlang/OTP 19 from v1.2.6) 1.1 17 - 18 1.0 17 - 17 (and Erlang/OTP 18 from v1.0.5) While Elixir often adds compatibility to new Erlang/OTP versions on released branches, such as support for Erlang/OTP 20 in v1.4.5, those releases usually contain the minimum changes for Elixir to run without errors. Only the next minor release, in this case v1.5.0, does effectively leverage the new features provided by the latest Erlang/OTP release.","ref":"compatibility-and-deprecations.html#compatibility-between-elixir-and-erlang-otp","title":"Compatibility and Deprecations - Compatibility between Elixir and Erlang/OTP","type":"extras"},{"doc":"Policy Elixir deprecations happen in 3 steps: The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature. The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, Enum.uniq/2 was soft-deprecated in favor of Enum.uniq_by/2 in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later. The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x. Table of deprecations The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from. Version Deprecated feature Replaced by (available since) v1.12 ^^^/2 Use bxor/2 instead (v1.0) v1.12 @foo() to read module attributes Remove the parenthesis (v1.0) v1.12 use EEx.Engine Explicitly delegate to EEx.Engine instead (v1.0) v1.12 :xref compiler in Mix Nothing (it always runs as part of the compiler now) v1.11 Mix.Project.compile/2 Mix.Task.run(&quot;compile&quot;, args) (v1.0) v1.11 Supervisor.Spec.worker/3 and Supervisor.Spec.supervisor/3 The new child specs outlined in Supervisor (v1.5) v1.11 Supervisor.start_child/2 and Supervisor.terminate_child/2 DynamicSupervisor (v1.6) v1.11 System.stacktrace/1 __STACKTRACE__ in try/catch/rescue (v1.7) v1.10 Code.ensure_compiled?/1 Code.ensure_compiled/1 (v1.0) v1.10 Code.load_file/2 Code.require_file/2 (v1.0) or Code.compile_file/2 (v1.7) v1.10 Code.loaded_files/0 Code.required_files/0 (v1.7) v1.10 Code.unload_file/1 Code.unrequire_files/1 (v1.7) v1.10 Passing non-chardata to Logger.log/2 Explicitly convert to string with to_string/1 (v1.0) v1.10 :compile_time_purge_level in Logger app environment :compile_time_purge_matching in Logger app environment (v1.7) v1.10 Supervisor.Spec.supervise/2 The new child specs outlined in Supervisor (v1.5) v1.10 :simple_one_for_one strategy in Supervisor DynamicSupervisor (v1.6) v1.10 :restart and :shutdown in Task.Supervisor.start_link/1 :restart and :shutdown in Task.Supervisor.start_child/3 (v1.6) v1.9 Enumerable keys in Map.drop/2 , Map.split/2 , and Map.take/2 Call Enum.to_list/1 on the second argument before hand (v1.0) v1.9 Mix.Project.load_paths/1 Mix.Project.compile_path/1 (v1.0) v1.9 Passing :insert_replaced to String.replace/4 Use :binary.replace/4 (v1.0) v1.8 Passing a non-empty list to Collectable.into/1 Kernel.++/2 or Keyword.merge/2 (v1.0) v1.8 Passing a non-empty list to :into in for Kernel.++/2 or Keyword.merge/2 (v1.0) v1.8 Passing a non-empty list to Enum.into/2 Kernel.++/2 or Keyword.merge/2 (v1.0) v1.8 Time units in its plural form, such as: :seconds , :milliseconds , and the like Use the singular form, such as: :second , :millisecond , and so on (v1.4) v1.8 Inspect.Algebra.surround/3 Inspect.Algebra.concat/2 and Inspect.Algebra.nest/2 (v1.0) v1.8 Inspect.Algebra.surround_many/6 Inspect.Algebra.container_doc/6 (v1.6) v1.9 --detached in Kernel.CLI --erl &quot;-detached&quot; (v1.0) v1.8 Kernel.ParallelCompiler.files/2 Kernel.ParallelCompiler.compile/2 (v1.6) v1.8 Kernel.ParallelCompiler.files_to_path/2 Kernel.ParallelCompiler.compile_to_path/2 (v1.6) v1.8 Kernel.ParallelRequire.files/2 Kernel.ParallelCompiler.require/2 (v1.6) v1.8 Returning {:ok, contents} or :error from Mix.Compilers.Erlang.compile/6 's callback Return {:ok, contents, warnings} or {:error, errors, warnings} (v1.6) v1.8 System.cwd/0 and System.cwd!/0 File.cwd/0 and File.cwd!/0 (v1.0) v1.7 Code.get_docs/2 Code.fetch_docs/1 (v1.7) v1.7 Enum.chunk/2,3,4 Enum.chunk_every/2 and Enum.chunk_every/3,4 (v1.5) v1.7 Calling super/1 in GenServer callbacks Implementing the behaviour explicitly without calling super/1 (v1.0) v1.7 not left in right left not in right (v1.5) v1.7 Registry.start_link/3 Registry.start_link/1 (v1.5) v1.7 Stream.chunk/2,3,4 Stream.chunk_every/2 and Stream.chunk_every/3,4 (v1.5) v1.6 Enum.partition/2 Enum.split_with/2 (v1.4) v1.6 Macro.unescape_tokens/1,2 Use Enum.map/2 to traverse over the arguments (v1.0) v1.6 Module.add_doc/6 @doc module attribute (v1.0) v1.6 Range.range?/1 Pattern match on _.._ (v1.0) v1.5 () to mean nil nil (v1.0) v1.5 char_list/0 type charlist/0 type (v1.3) v1.5 Atom.to_char_list/1 Atom.to_charlist/1 (v1.3) v1.5 Enum.filter_map/3 Enum.filter/2 + Enum.map/2 or for comprehensions (v1.0) v1.5 Float.to_char_list/1 Float.to_charlist/1 (v1.3) v1.5 GenEvent module Supervisor and GenServer (v1.0);&lt;br/&gt; GenStage (v1.3);&lt;br/&gt; :gen_event (Erlang/OTP 17) v1.5 &lt;%= in middle and end expressions in EEx Use &lt;% ( &lt;%= is allowed only in start expressions) (v1.0) v1.5 :as_char_lists value in Inspect.Opts.t/0 type :as_charlists value (v1.3) v1.5 :char_lists key in Inspect.Opts.t/0 type :charlists key (v1.3) v1.5 Integer.to_char_list/1,2 Integer.to_charlist/1 and Integer.to_charlist/2 (v1.3) v1.5 Kernel.to_char_list/1 Kernel.to_charlist/1 (v1.3) v1.5 List.Chars.to_char_list/1 List.Chars.to_charlist/1 (v1.3) v1.5 @compile {:parse_transform, _} in Module None v1.5 Stream.filter_map/3 Stream.filter/2 + Stream.map/2 (v1.0) v1.5 String.ljust/3 and String.rjust/3 Use String.pad_leading/3 and String.pad_trailing/3 with a binary padding (v1.3) v1.5 String.lstrip/1 and String.rstrip/1 String.trim_leading/1 and String.trim_trailing/1 (v1.3) v1.5 String.lstrip/2 and String.rstrip/2 Use String.trim_leading/2 and String.trim_trailing/2 with a binary as second argument (v1.3) v1.5 String.strip/1 and String.strip/2 String.trim/1 and String.trim/2 (v1.3) v1.5 String.to_char_list/1 String.to_charlist/1 (v1.3) v1.4 Anonymous functions with no expression after -&gt; Use an expression or explicitly return nil (v1.0) v1.4 Support for making private functions overridable Use public functions (v1.0) v1.4 Variable used as function call Use parentheses (v1.0) v1.4 Access.key/1 Access.key/2 (v1.3) v1.4 Behaviour module @callback module attribute (v1.0) v1.4 Enum.uniq/2 Enum.uniq_by/2 (v1.2) v1.4 Float.to_char_list/2 :erlang.float_to_list/2 (Erlang/OTP 17) v1.4 Float.to_string/2 :erlang.float_to_binary/2 (Erlang/OTP 17) v1.4 HashDict module Map (v1.2) v1.4 HashSet module MapSet (v1.1) v1.4 IEx.Helpers.import_file/2 IEx.Helpers.import_file_if_available/1 (v1.3) v1.4 Mix.Utils.camelize/1 Macro.camelize/1 (v1.2) v1.4 Mix.Utils.underscore/1 Macro.underscore/1 (v1.2) v1.4 Multi-letter aliases in OptionParser Use single-letter aliases (v1.0) v1.4 Set module MapSet (v1.1) v1.4 Stream.uniq/2 Stream.uniq_by/2 (v1.2) v1.3 \\x{X*} inside strings/sigils/charlists \\uXXXX or \\u{X*} (v1.1) v1.3 Dict module Keyword (v1.0) or Map (v1.2) v1.3 :append_first option in Kernel.defdelegate/2 Define the function explicitly (v1.0) v1.3 Map/dictionary as 2nd argument in Enum.group_by/3 Enum.reduce/3 (v1.0) v1.3 Keyword.size/1 Kernel.length/1 (v1.0) v1.3 Map.size/1 Kernel.map_size/1 (v1.0) v1.3 /r option in Regex /U (v1.1) v1.3 Set behaviour MapSet data structure (v1.1) v1.3 String.valid_character?/1 String.valid?/1 (v1.0) v1.3 Task.find/2 Use direct message matching (v1.0) v1.3 Non-map as 2nd argument in URI.decode_query/2 Use a map (v1.0) v1.2 Dict behaviour MapSet data structure (v1.1) v1.1 ?\\xHEX 0xHEX (v1.0) v1.1 Access protocol Access behaviour (v1.1) v1.1 as: true | false in alias/2 and require/2 None","ref":"compatibility-and-deprecations.html#deprecations","title":"Compatibility and Deprecations - Deprecations","type":"extras"},{"doc":"Library Guidelines This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.","ref":"library-guidelines.html","title":"Library Guidelines","type":"extras"},{"doc":"You can create a new Elixir library by running the mix new command: $ mix new my_library The project name is given in the snake_case convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the Naming Conventions document for more information. Every project has a mix.exs file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a lib directory, which includes Elixir source code, and a test directory. A src directory may also exist for Erlang sources. For more information on running your project, see the official Mix &amp; OTP guide or Mix documentation . Applications with supervision tree The mix new command also allows the --sup option to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.","ref":"library-guidelines.html#getting-started","title":"Library Guidelines - Getting started","type":"extras"},{"doc":"Writing code is only the first of many steps to publish a package. We strongly recommend developers to: Choose a versioning schema. Elixir requires versions to be in the format MAJOR.MINOR.PATCH but the meaning of those numbers is up to you. Most projects choose Semantic Versioning . Choose a license . The most common licenses in the Elixir community are the MIT License and the Apache License 2.0 . The latter is also the one used by Elixir itself. Run the code formatter . The code formatter formats your code according to a consistent style shared by your library and the whole community, making it easier for other developers to understand your code and contribute. Write tests. Elixir ships with a test-framework named ExUnit . The project generated by mix new includes sample tests and doctests. Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the Writing Documentation guide for more information. Projects like ExDoc can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports &quot;extra pages&quot;, like this one that you are reading. Such pages augment the documentation with tutorials, guides and references. Projects are often made available to other developers by publishing a Hex package . Hex also supports private packages for organizations . If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to HexDocs .","ref":"library-guidelines.html#publishing","title":"Library Guidelines - Publishing","type":"extras"},{"doc":"When your library is published and used as a dependency, its lockfile (usually named mix.lock ) is ignored by the host project . Running mix deps.get in the host project attempts to get the latest possible versions of your library’s dependencies, as specified by the requirements in the deps section of your mix.exs . These versions might be greater than those stored in your mix.lock (and hence used in your tests / CI). On the other hand, contributors of your library, need a deterministic build, which implies the presence of mix.lock in your Version Control System (VCS). The best practice of handling mix.lock file therefore would be to keep it in VCS, and run two different Continuous Integration (CI) workflows: the usual deterministic one, and another one, that starts with mix deps.unlock --all and always compiles your library and runs tests against latest versions of dependencies. The latter one might be even run nightly or otherwise recurrently to stay notified about any possible issue in regard to dependencies updates.","ref":"library-guidelines.html#dependency-handling","title":"Library Guidelines - Dependency handling","type":"extras"},{"doc":"In this section we document common anti-patterns to avoid when writing libraries. Avoid using exceptions for control-flow You should avoid using exceptions for control-flow. For example, instead of: try do contents = File . read! ( &quot;some_path_that_may_or_may_not_exist&quot; ) { :it_worked , contents } rescue File.Error -&gt; :it_failed end you should prefer: case File . read ( &quot;some_path_that_may_or_may_not_exist&quot; ) do { :ok , contents } -&gt; { :it_worked , contents }   { :error , _ } -&gt; :it_failed end As a library author, it is your responsibility to make sure users are not required to use exceptions for control-flow in their applications. You can follow the same convention as Elixir here, using the name without ! for returning :ok / :error tuples and appending ! for a version of the function which raises an exception. It is important to note that a name without ! does not mean a function will never raise. For example, even File.read/1 can fail in case of bad arguments: iex&gt; File . read ( 1 ) ** (FunctionClauseError) no function clause matching in IO.chardata_to_string/1 The usage of :ok / :error tuples is about the domain that the function works on, in this case, file system access. Bad arguments, logical errors, invalid options should raise regardless of the function name. If in doubt, prefer to return tuples instead of raising, as users of your library can always match on the results and raise if necessary. Avoid working with invalid data Elixir programs should prefer to validate data as close to the end user as possible, so the errors are easy to locate and fix. This practice also saves you from writing defensive code in the internals of the library. For example, imagine you have an API that receives a filename as a binary. At some point you will want to write to this file. You could have a function like this: def my_fun ( some_arg , file_to_write_to , options \\\\ [ ] ) do ... some code ... AnotherModuleInLib . invoke_something_that_will_eventually_write_to_file ( file_to_write_to ) ... more code ... end The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with. A better function definition would be: def my_fun ( some_arg , file_to_write_to , options \\\\ [ ] ) when is_binary ( file_to_write_to ) do Elixir also leverages pattern matching and guards in function clauses to provide clear error messages in case invalid arguments are given. This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a GenServer that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms. Avoid application configuration You should avoid using the application environment (see Application.get_env/2 ) as the configuration mechanism for libraries. The application environment is global which means it becomes impossible for two dependencies to use your library in two different ways. Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash - character: defmodule DashSplitter do def split ( string ) when is_binary ( string ) do String . split ( string , &quot;-&quot; , parts : 2 ) end end Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment: def split ( string ) when is_binary ( string ) do parts = Application . get_env ( :dash_splitter , :parts , 2 ) String . split ( string , &quot;-&quot; , parts : parts ) end Now users can configure your library in their config/config.exs file as follows: config :dash_splitter , :parts , 3 Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts. The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could expect keyword lists as a new argument: def split ( string , opts \\\\ [ ] ) when is_binary ( string ) and is_list ( opts ) do parts = Keyword . get ( opts , :parts , 2 ) String . split ( string , &quot;-&quot; , parts : parts ) end In case you need to configure a process, the options should be passed when starting that process. The application environment should be reserved only for configurations that are truly global, for example, to control your application boot process and its supervision tree. For all remaining scenarios, libraries should not force their users to use the application environment for configuration. If the user of a library believes that certain parameter should be configured globally, then they can wrap the library functionality with their own application environment configuration. Avoid compile-time application configuration Assuming you need to use the application configuration and you cannot avoid it as explained in the previous section, you should also avoid compile-time application configuration. For example, instead of doing this: @http_client Application . fetch_env! ( :my_app , :http_client ) def request ( path ) do @http_client . request ( path ) end you should do this: def request ( path ) do http_client ( ) . request ( path ) end defp http_client ( ) do Application . fetch_env! ( :my_app , :http_client ) end That's because by reading the application in the module body and storing it in a module attribute, we are effectively reading the configuration at compile-time, which may become an issue when configuring the system later. If, for some reason, you must read the application environment at compile time, use Application.compile_env/2 . Read the &quot;Compile-time environment&quot; section of the Application module documentation for more information. Avoid defining modules that are not in your &quot;namespace&quot; Even though Elixir does not formally have the concept of namespaces, a library should use its name as a &quot;prefix&quot; for all of its modules (except for special cases like mix tasks). For example if the library's OTP application name is :my_lib , then all of its modules should start with the MyLib prefix, for example MyLib.User , MyLib.SubModule , and MyLib.Application . This is important because the Erlang VM can only load one instance of a module at a time. So if there are multiple libraries that define the same module, then they are incompatible with each other due to this limitation. By always using the library name as a prefix, it avoids module name clashes due to the unique prefix. Furthermore, when writing a library that is an extension of another library, you should avoid defining modules inside the parent's library namespace. For example, if you are writing a package that adds authentication to Plug called plug_auth , its modules should be namespaced under PlugAuth instead of Plug.Auth , so it avoid conflicts with Plug if it were to ever define its own authentication functionality. Avoid use when an import is enough A library should not provide use MyLib functionality if all use MyLib does is to import / alias the module itself. For example, this is an anti-pattern: defmodule MyLib do defmacro __using__ ( _ ) do quote do import MyLib end end def some_fun ( arg1 , arg2 ) do ... end end The reason why defining the __using__ macro above should be avoided is because when a developer writes: defmodule MyApp do use MyLib end it allows use MyLib to run any code into the MyApp module. For someone reading the code, it is impossible to assess the impact that use MyLib has in a module without looking at the implementation of __using__ . The following code is clearer: defmodule MyApp do import MyLib end The code above says we are only bringing in the functions from MyLib so we can invoke some_fun(arg1, arg2) directly without the MyLib. prefix. Even more important, import MyLib says that we have an option to not import MyLib at all as we can simply invoke the function as MyLib.some_fun(arg1, arg2) . If the module you want to invoke a function on has a long name, such as SomeLibrary.Namespace.MyLib , and you find it verbose, you can leverage the alias/2 special form and still refer to the module as MyLib . While there are situations where use SomeModule is necessary, use should be skipped when all it does is to import or alias other modules. In a nutshell, alias should be preferred, as it is simpler and clearer than import , while import is simpler and clearer than use . Avoid macros Although the previous section could be summarized as &quot;avoid macros&quot;, both topics are important enough to deserve their own sections. To quote the official guide on macros : Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it's considered to be bad style to use them when they're not necessary. So write macros responsibly. Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that explicit is better than implicit . Clear code is better than concise code . When you absolutely have to use a macro, make sure that a macro is not the only way the user can interface with your library and keep the amount of code generated by a macro to a minimum. For example, the Logger module provides Logger.debug/2 , Logger.info/2 and friends as macros that are capable of extracting environment information, but a low-level mechanism for logging is still available with Logger.bare_log/3 . Avoid using processes for code organization A developer must never use a process for code organization purposes. A process must be used to model runtime properties such as: Mutable state and access to shared resources (such as ETS, files, and others) Concurrency and distribution Initialization, shutdown and restart logic (as seen in supervisors) System messages such as timer messages and monitoring events In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer : def add ( a , b ) do GenServer . call ( __MODULE__ , { :add , a , b } ) end def handle_call ( { :add , a , b } , _from , state ) do { :reply , a + b , state } end def handle_call ( { :subtract , a , b } , _from , state ) do { :reply , a - b , state } end This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly: def add ( a , b ) do a + b end def subtract ( a , b ) do a - b end Use processes only to model runtime properties, never for code organization. And even when you think something could be done in parallel with processes, often it is best to let the callers of your library decide how to parallelize, rather than impose a certain execution flow in users of your code. Avoid spawning unsupervised processes You should avoid spawning processes outside of a supervision tree, especially long-running ones. Instead, processes must be started inside supervision trees. This guarantees developers have full control over the initialization, restarts, and shutdown of the system. If your application does not have a supervision tree, one can be added by changing def application inside mix.exs to include a :mod key with the application callback name: def application do [ extra_applications : [ :logger ] , mod : { MyApp.Application , [ ] } ] end and then defining a my_app/application.ex file with the following template: defmodule MyApp.Application do # See https://hexdocs.pm/elixir/Application.html # for more information on OTP Applications @moduledoc false use Application def start ( _type , _args ) do children = [ # Starts a worker by calling: MyApp.Worker.start_link(arg) # {MyApp.Worker, arg} ] # See https://hexdocs.pm/elixir/Supervisor.html # for other strategies and supported options opts = [ strategy : :one_for_one , name : MyApp.Supervisor ] Supervisor . start_link ( children , opts ) end end This is the same template generated by mix new --sup . Each process started with the application must be listed as a child under the Supervisor above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the DynamicSupervisor module. One of the few times where it is acceptable to start a process outside of a supervision tree is with Task.async/1 and Task.await/2 . Opposite to Task.start_link/1 , the async/await mechanism gives you full control over the spawned process life cycle - which is also why you must always call Task.await/2 after starting a task with Task.async/1 . Even though, if your application is spawning multiple async processes, you should consider using Task.Supervisor for better visibility when instrumenting and monitoring the system.","ref":"library-guidelines.html#anti-patterns","title":"Library Guidelines - Anti-patterns","type":"extras"},{"doc":"Naming Conventions This document covers some naming conventions in Elixir code, from casing to punctuation characters.","ref":"naming-conventions.html","title":"Naming Conventions","type":"extras"},{"doc":"Elixir developers must use snake_case when defining variables, function names, module attributes, and the like: some_map = %{ this_is_a_key : &quot;and a value&quot; } is_map ( some_map ) Aliases, commonly used as module names, are an exception as they must be capitalized and written in CamelCase , like OptionParser . For aliases, capital letters are kept in acronyms, like ExUnit.CaptureIO or Mix.SCM . Atoms can be written either in :snake_case or :CamelCase , although the convention is to use the snake case version throughout Elixir. Generally speaking, filenames follow the snake_case convention of the module they define. For example, MyApp should be defined inside the my_app.ex file. However, this is only a convention. At the end of the day, any filename can be used as they do not affect the compiled code in any way.","ref":"naming-conventions.html#casing","title":"Naming Conventions - Casing","type":"extras"},{"doc":"Elixir relies on underscores in different situations. For example, a value that is not meant to be used must be assigned to _ or to a variable starting with underscore: iex&gt; { :ok , _contents } = File . read ( &quot;README.md&quot; ) Function names may also start with an underscore. Such functions are never imported by default: iex&gt; defmodule Example do ...&gt; def _wont_be_imported do ...&gt; :oops ...&gt; end ...&gt; end iex&gt; import Example iex&gt; _wont_be_imported ( ) ** (CompileError) iex:1: undefined function _wont_be_imported/0 Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the __foo__ format. For example, every module in Elixir has an __info__/1 function: iex&gt; String . __info__ ( :functions ) [ at : 2 , capitalize : 1 , chunk : 2 , ... ] Elixir also includes five special forms that follow the double underscore format: __CALLER__/0 , __DIR__/0 , __ENV__/0 and __MODULE__/0 retrieve compile-time information about the current environment, while __STACKTRACE__/0 retrieves the stacktrace for the current exception.","ref":"naming-conventions.html#underscore-_foo","title":"Naming Conventions - Underscore (_foo)","type":"extras"},{"doc":"A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception. Many functions come in pairs, such as File.read/1 and File.read!/1 . File.read/1 will return a success or failure tuple, whereas File.read!/1 will return a plain value or else raise an exception: iex&gt; File . read ( &quot;file.txt&quot; ) { :ok , &quot;file contents&quot; } iex&gt; File . read ( &quot;no_such_file.txt&quot; ) { :error , :enoent } iex&gt; File . read! ( &quot;file.txt&quot; ) &quot;file contents&quot; iex&gt; File . read! ( &quot;no_such_file.txt&quot; ) ** (File.Error) could not read file no_such_file.txt: no such file or directory The version without ! is preferred when you want to handle different outcomes using pattern matching: case File . read ( file ) do { :ok , body } -&gt; # do something with the `body` { :error , reason } -&gt; # handle the error caused by `reason` end However, if you expect the outcome to always to be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure. More examples of paired functions: Base.decode16/2 and Base.decode16!/2 , File.cwd/0 and File.cwd!/0 . There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: Protocol.assert_protocol!/1 . In macro code, the bang on Kernel.alias!/1 and Kernel.var!/2 signifies that macro hygiene is set aside.","ref":"naming-conventions.html#trailing-bang-foo","title":"Naming Conventions - Trailing bang (foo!)","type":"extras"},{"doc":"Functions that return a boolean are named with a trailing question mark. Examples: Keyword.keyword?/1 , Mix.debug?/0 , String.contains?/2 However, functions that return booleans and are valid in guards follow another convention, described next.","ref":"naming-conventions.html#trailing-question-mark-foo","title":"Naming Conventions - Trailing question mark (foo?)","type":"extras"},{"doc":"Type checks and other boolean checks that are allowed in guard clauses are named with an is_ prefix. Examples: Integer.is_even/1 , Kernel.is_list/1 These functions and macros follow the Erlang convention of an is_ prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses. Note that type checks that are not valid in guard clauses do not follow this convention. For example: Keyword.keyword?/1 .","ref":"naming-conventions.html#is_-prefix-is_foo","title":"Naming Conventions - is_ prefix (is_foo)","type":"extras"},{"doc":"Some names have specific meaning in Elixir. We detail those cases below. length and size When you see size in a function name, it means the operation runs in constant time (also written as &quot;O(1) time&quot;) because the size is stored alongside the data structure. Examples: Kernel.map_size/1 , Kernel.tuple_size/1 When you see length , the operation runs in linear time (&quot;O(n) time&quot;) because the entire data structure has to be traversed. Examples: Kernel.length/1 , String.length/1 In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.","ref":"naming-conventions.html#special-names","title":"Naming Conventions - Special names","type":"extras"},{"doc":"Operators This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.","ref":"operators.html","title":"Operators","type":"extras"},{"doc":"The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity: Operator | Associativity ------------------------------------------------------| ------------- @ | Unary . | Left + - ! ^ not ~~~ | Unary * / | Left + - | Left ++ -- +++ --- .. &lt;&gt; | Right in not in | Left \\|&gt; &lt;&lt;&lt; &gt;&gt;&gt; &lt;&lt;~ ~&gt;&gt; &lt;~ ~&gt; &lt;~&gt; &lt;\\|&gt; | Left &lt; &gt; &lt;= &gt;= | Left == != =~ === !== | Left &amp;&amp; &amp;&amp;&amp; and | Left \\|\\| \\|\\|\\| or | Left = | Right &amp; | Unary =&gt; (valid only inside %{} ) | Right \\| | Right :: | Right when | Right &lt;- \\\\ | Left","ref":"operators.html#operator-precedence-and-associativity","title":"Operators - Operator precedence and associativity","type":"extras"},{"doc":"Elixir provides the following built-in operators that are defined as functions that can be overridden: + and - - unary positive/negative + , - , * , and / - basic arithmetic operations ++ and -- - list concatenation and subtraction and and &amp;&amp; - strict and relaxed boolean &quot;and&quot; or and || - strict and relaxed boolean &quot;or&quot; not and ! - strict and relaxed boolean &quot;not&quot; in and not in - membership @ - module attribute .. - range creation &lt;&gt; - binary concatenation |&gt; - pipeline =~ - text-based match Many of those can be used in guards; consult the list of allowed guard functions and operators . Additionally, there are a few other operators that Elixir parses but doesn't actually use. See Custom and overridden operators below for a list and for guidelines about their use. Some other operators are special forms and cannot be overridden: ^ - pin operator . - dot operator = - match operator &amp; - capture operator :: - type operator Finally, these operators appear in the precedence table above but are only meaningful within certain constructs: =&gt; - see %{} when - see Guards &lt;- - see for and with \\\\ - see Default arguments","ref":"operators.html#general-operators","title":"Operators - General operators","type":"extras"},{"doc":"Elixir provides the following built-in comparison operators (all of which can be used in guards): == - equal to === - strictly equal to != - inequal to !== - strictly inequal to &lt; - less-than &gt; - greater-than &lt;= - less-than or equal to &gt;= - greater-than or equal to The only difference between == and === is that === is strict when it comes to comparing integers and floats: iex&gt; 1 == 1.0 true iex&gt; 1 === 1.0 false != and !== act as the negation of == and === , respectively. Term ordering In Elixir, different data types can be compared using comparison operators: iex&gt; 1 &lt; :an_atom true The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below: number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either === or !== . A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive. The collection types are compared using the following rules: Tuples are compared by size, then element by element. Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats. Lists are compared element by element. Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit. Atoms are compared using their string value, codepoint by codepoint.","ref":"operators.html#comparison-operators","title":"Operators - Comparison operators","type":"extras"},{"doc":"Defining custom operators Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are used by Elixir: for example, + and || are used by Elixir for addition and boolean or , but &lt;~&gt; is not used (but valid). To define an operator, you can use the usual def* constructs ( def , defp , defmacro , and so on) but with a syntax similar to how the operator is used: defmodule MyOperators do # We define ~&gt; to return the maximum of the given two numbers, # and &lt;~ to return the minimum. def a ~&gt; b , do : max ( a , b ) def a &lt;~ b , do : min ( a , b ) end To use the newly defined operators, we have to import the module that defines them: iex&gt; import MyOperators iex&gt; 1 ~&gt; 2 2 iex&gt; 1 &lt;~ 2 1 The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default: ||| &amp;&amp;&amp; &lt;&lt;&lt; &gt;&gt;&gt; &lt;&lt;~ ~&gt;&gt; &lt;~ ~&gt; &lt;~&gt; &lt;|&gt; +++ --- ~~~ The following operators are used by the Bitwise module when imported: &amp;&amp;&amp; , &lt;&lt;&lt; , &gt;&gt;&gt; , ||| , ~~~ . See the documentation for Bitwise for more information. Note the Elixir community generally discourages custom operators. They can be hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices. It is also possible replace predefined operators, such as + , but doing so is extremely discouraged.","ref":"operators.html#custom-and-overridden-operators","title":"Operators - Custom and overridden operators","type":"extras"},{"doc":"Patterns and Guards Elixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited. This page describes the semantics of patterns and guards, where they are all allowed, and how to extend them.","ref":"patterns-and-guards.html","title":"Patterns and Guards","type":"extras"},{"doc":"Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator ( = ): iex&gt; x = 1 1 iex&gt; 1 = x 1 In the example above, x starts without a value and has 1 assigned to it. Then, we compare the value of x to the literal 1 , which succeeds as they are both 1 . Matching x against 2 would raise: iex&gt; 2 = x ** (MatchError) no match of right hand side value: 1 Patterns are not bidirectional. If you have a variable y that was never assigned to (often called an unbound variable) and you write 1 = y , an error will be raised: iex&gt; 1 = y ** (CompileError) iex:2: undefined function y/0 In other words, patterns are allowed only on the left side of = . The right side of = follows the regular evaluation semantics of the language. Now let's cover the pattern matching rules for each construct and then for each relevant data types. Variables Variables in patterns are always assigned to: iex&gt; x = 1 1 iex&gt; x = 2 2 iex&gt; x 2 In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator ( ^ ): iex&gt; x = 1 1 iex&gt; ^ x = 2 ** (MatchError) no match of right hand side value: 2 If the same variable appears twice in the same pattern, then they must be bound to the same value: iex&gt; { x , x } = { 1 , 1 } { 1 , 1 } iex&gt; { x , x } = { 1 , 2 } ** (MatchError) no match of right hand side value: {1, 2} The underscore variable ( _ ) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern: iex&gt; { _ , integer } = { :not_important , 1 } { :not_important , 1 } iex&gt; integer 1 iex&gt; _ ** (CompileError) iex:3: invalid use of _ Literals (numbers and atoms) Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom: iex&gt; :atom = :atom :atom iex&gt; :atom = :another_atom ** (MatchError) no match of right hand side value: :another_atom Similar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats: iex&gt; 1 = 1.0 ** (MatchError) no match of right hand side value: 1.0 Tuples Tuples may appear in patterns using the curly brackets syntax ( {} ). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match: iex&gt; { :ok , integer } = { :ok , 13 } { :ok , 13 } # won&#39;t match due to different size iex&gt; { :ok , integer } = { :ok , 11 , 13 } ** (MatchError) no match of right hand side value: {:ok, 11, 13} # won&#39;t match due to mismatch on first element iex&gt; { :ok , binary } = { :error , :enoent } ** (MatchError) no match of right hand side value: {:error, :enoent} Lists Lists may appear in patterns using the square brackets syntax ( [] ). A list in a pattern will match only lists of the same size, where each individual list element must also match: iex&gt; [ :ok , integer ] = [ :ok , 13 ] [ :ok , 13 ] # won&#39;t match due to different size iex&gt; [ :ok , integer ] = [ :ok , 11 , 13 ] ** (MatchError) no match of right hand side value: [:ok, 11, 13] # won&#39;t match due to mismatch on first element iex&gt; [ :ok , binary ] = [ :error , :enoent ] ** (MatchError) no match of right hand side value: [:error, :enoent] Opposite to tuples, lists also allow matching on non-empty lists by using the [head | tail] notation, which matches on the head and tail of a list: iex&gt; [ head | tail ] = [ 1 , 2 , 3 ] [ 1 , 2 , 3 ] iex&gt; head 1 iex&gt; tail [ 2 , 3 ] Multiple elements may prefix the | tail construct: iex&gt; [ first , second | tail ] = [ 1 , 2 , 3 ] [ 1 , 2 , 3 ] iex&gt; tail [ 3 ] Note [head | tail] does not match empty lists: iex&gt; [ head | tail ] = [ ] ** (MatchError) no match of right hand side value: [] Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator ( ++ ): iex&gt; &#39;hello &#39; ++ world = &#39;hello world&#39; &#39;hello world&#39; iex&gt; world &#39;world&#39; Which is equivalent to matching on [?h, ?e, ?l, ?l, ?o, ?\\s | world] . Suffix matches ( hello ++ ' world' ) are not valid patterns. Maps Maps may appear in patterns using the percentage sign followed by the curly brackets syntax ( %{} ). Opposite to lists and tuples, maps perform a subset match. This means a map pattern will match any other map that has at least all of the keys in the pattern. Here is an example where all keys match: iex&gt; %{ name : name } = %{ name : &quot;meg&quot; } %{ name : &quot;meg&quot; } iex&gt; name &quot;meg&quot; Here is when a subset of the keys match: iex&gt; %{ name : name } = %{ name : &quot;meg&quot; , age : 23 } %{ age : 23 , name : &quot;meg&quot; } iex&gt; name &quot;meg&quot; If a key in the pattern is not available in the map, then they won't match: iex&gt; %{ name : name , age : age } = %{ name : &quot;meg&quot; } ** (MatchError) no match of right hand side value: %{name: &quot;meg&quot;} Note that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively: iex&gt; %{ } = %{ name : &quot;meg&quot; } %{ name : &quot;meg&quot; } Finally, note map keys in patterns must always be literals or previously bound variables matched with the pin operator. Binaries Binaries may appear in patterns using the double less-than/greater-than syntax ( &lt;&lt;&gt;&gt; ). A binary in a pattern can match multiple segments at the same, each with different type, size, and unit: iex&gt; &lt;&lt; val :: unit ( 8 ) - size ( 2 ) - integer &gt;&gt; = &lt;&lt; 123 , 56 &gt;&gt; &quot;{8&quot; iex&gt; val 31544 See the documentation for &lt;&lt;&gt;&gt; for a complete definition of pattern matching for binaries. Finally, remember that strings in Elixir are UTF-8 encoded binaries. This means that, similar to charlists, prefix matches on strings are also possible with the binary concatenation operator ( &lt;&gt; ): iex&gt; &quot;hello &quot; &lt;&gt; world = &quot;hello world&quot; &quot;hello world&quot; iex&gt; world &quot;world&quot; Suffix matches ( hello &lt;&gt; &quot; world&quot; ) are not valid patterns.","ref":"patterns-and-guards.html#patterns","title":"Patterns and Guards - Patterns","type":"extras"},{"doc":"Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others. Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently. List of allowed functions and operators You can find the built-in list of guards in the Kernel module . Here is an overview: comparison operators ( == , != , === , !== , &lt; , &lt;= , &gt; , &gt;= ) strictly boolean operators ( and , or , not ). Note &amp;&amp; , || , and ! sibling operators are not allowed as they're not strictly boolean - meaning they don't require arguments to be booleans arithmetic unary operators ( + , - ) arithmetic binary operators + , - , * , / ) in and not in operators (as long as the right-hand side is a list or a range) &quot;type-check&quot; functions ( is_list/1 , is_number/1 , and the like) functions that work on built-in datatypes ( abs/1 , hd/1 , map_size/1 , and others) The module Bitwise also includes a handful of Erlang bitwise operations as guards . Macros constructed out of any combination of the above guards are also valid guards - for example, Integer.is_even/1 . For more information, see the &quot;Defining custom guard expressions&quot; section shown below. Why guards Let's see an example of a guard used in a function clause: def empty_map? ( map ) when map_size ( map ) == 0 , do : true def empty_map? ( map ) when is_map ( map ) , do : false Guards start with the when operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns true . Multiple boolean conditions can be combined with the and and or operators. Writing the empty_map?/1 function by only using pattern matching would not be possible (as pattern matching on %{} would match any map, not only the empty ones). Failing guards A function clause will be executed if and only if its guard expression evaluates to true . If any other value is returned, the function clause will be skipped. In particular, guards have no concept of &quot;truthy&quot; or &quot;falsey&quot;. For example, imagine a function that checks that the head of a list is not nil : def not_nil_head? ( [ head | _ ] ) when head , do : true def not_nil_head? ( _ ) , do : false not_nil_head? ( [ &quot;some_value&quot; , &quot;another_value&quot; ] ) #=&gt; false Even though the head of the list is not nil , the first clause for not_nil_head?/1 fails because the expression does not evaluate to true , but to &quot;some_value&quot; , therefore triggering the second clause which returns false . To make the guard behave correctly, you must ensure that the guard evaluates to true , like so: def not_nil_head? ( [ head | _ ] ) when head != nil , do : true def not_nil_head? ( _ ) , do : false not_nil_head? ( [ &quot;some_value&quot; , &quot;another_value&quot; ] ) #=&gt; true Errors in guards In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the tuple_size/1 function only works with tuples. If we use it with anything else, an argument error is raised: iex&gt; tuple_size ( &quot;hello&quot; ) ** (ArgumentError) argument error However, when used in guards, the corresponding clause will fail to match instead of raising an error: iex&gt; case &quot;hello&quot; do ...&gt; something when tuple_size ( something ) == 2 -&gt; ...&gt; :worked ...&gt; _anything_else -&gt; ...&gt; :failed ...&gt; end :failed In many cases, we can take advantage of this. In the code above, we used tuple_size/1 to both check that the given value is a tuple and check its size (instead of using is_tuple(something) and tuple_size(something) == 2 ). However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like is_tuple/1 before tuple_size/1 , otherwise the whole guard will fail if a tuple is not given. Alternatively your function clause can use multiple guards as shown in the following section. Multiple guards in the same clause There exists an additional way to simplify a chain of or expressions in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. The following code: def is_number_or_nil ( term ) when is_integer ( term ) or is_float ( term ) or is_nil ( term ) , do : :maybe_number def is_number_or_nil ( _other ) , do : :something_else can be alternatively written as: def is_number_or_nil ( term ) when is_integer ( term ) when is_float ( term ) when is_nil ( term ) do :maybe_number end def is_number_or_nil ( _other ) do :something_else end If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples: defmodule Check do # If given a tuple, map_size/1 will raise, and tuple_size/1 will not be evaluated def empty? ( val ) when map_size ( val ) == 0 or tuple_size ( val ) == 0 , do : true def empty? ( _val ) , do : false end Check . empty? ( %{ } ) #=&gt; true Check . empty? ( { } ) #=&gt; false # true was expected! This could be corrected by ensuring that no exception is raised, either via type checks like is_map(val) and map_size(val) == 0 , or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated. defmodule Check do # If given a tuple, map_size/1 will raise, and the second guard will be evaluated def empty? ( val ) when map_size ( val ) == 0 when tuple_size ( val ) == 0 , do : true def empty? ( _val ) , do : false end Check . empty? ( %{ } ) #=&gt; true Check . empty? ( { } ) #=&gt; true","ref":"patterns-and-guards.html#guards","title":"Patterns and Guards - Guards","type":"extras"},{"doc":"In the examples above, we have used the match operator ( = ) and function clauses to showcase patterns and guards respectively. Here is the list of the built-in constructs in Elixir that support patterns and guards. match?/2 : match? ( { :ok , value } when value &gt; 0 , { :ok , 13 } ) function clauses: def type ( term ) when is_integer ( term ) , do : :integer def type ( term ) when is_float ( term ) , do : :float case expressions: case x do 1 -&gt; :one 2 -&gt; :two n when is_integer ( n ) and n &gt; 2 -&gt; :larger_than_two end anonymous functions ( fn/1 ): larger_than_two? = fn n when is_integer ( n ) and n &gt; 2 -&gt; true n when is_integer ( n ) -&gt; false end for and with support patterns and guards on the left side of &lt;- : for x when x &gt;= 0 &lt;- [ 1 , - 2 , 3 , - 4 ] , do : x with also supports the else keyword, which supports patterns matching and guards. try supports patterns and guards on catch and else receive supports patterns and guards to match on the received messages. custom guards can also be defined with defguard/1 and defguardp/1 . A custom guard can only be defined based on existing guards. Note that the match operator ( = ) does not support guards: { :ok , binary } = File . read ( &quot;some/file&quot; )","ref":"patterns-and-guards.html#where-patterns-and-guards-can-be-used","title":"Patterns and Guards - Where patterns and guards can be used","type":"extras"},{"doc":"Only the constructs listed in this page are allowed in patterns and guards. However, we can take advantage of macros to write custom patterns guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the output of the macros boils down to a combination of the constructs above. For example, the Record module in Elixir provides a series of macros to be used in patterns and guards that allows tuples to have named fields during compilation. For defining your own guards, Elixir even provides conveniences in defguard and defguardp . Let's look at a quick case study: we want to check whether an argument is an even or an odd integer. With pattern matching this is impossible because there is an infinite number of integers, and therefore we can't pattern match on every single one of them. Therefore we must use guards. We will just focus on checking for even numbers since checking for the odd ones is almost identical. Such a guard would look like this: def my_function ( number ) when is_integer ( number ) and rem ( number , 2 ) == 0 do # do stuff end It would be repetitive to write every time we need this check. Instead you can use defguard/1 and defguardp/1 to create guard macros. Here's an example how: defmodule MyInteger do defguard is_even ( term ) when is_integer ( term ) and rem ( term , 2 ) == 0 end and then: import MyInteger , only : [ is_even : 1 ] def my_function ( number ) when is_even ( number ) do # do stuff end While it's possible to create custom guards with macros, it's recommended to define them using defguard/1 and defguardp/1 which perform additional compile-time checks.","ref":"patterns-and-guards.html#custom-patterns-and-guards-expressions","title":"Patterns and Guards - Custom patterns and guards expressions","type":"extras"},{"doc":"Syntax reference Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of &quot;syntax sugar&quot; constructs to reduce the noise in common Elixir idioms. This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.","ref":"syntax-reference.html","title":"Syntax reference","type":"extras"},{"doc":"These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience: true , false , nil - used as atoms when , and , or , not , in - used as operators fn - used for anonymous function definitions do , end , catch , rescue , after , else - used in do/end blocks","ref":"syntax-reference.html#reserved-words","title":"Syntax reference - Reserved words","type":"extras"},{"doc":"Numbers Integers ( 1234 ) and floats ( 123.4 ) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as 1_000_000 . Integers never contain a dot ( . ) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as 123.4e10 or 123.4E10 . Atoms Unquoted atoms start with a colon ( : ) which must be immediately followed by a Unicode letter or an underscore. The atom may continue using a sequence of Unicode letters, numbers, underscores, and @ . Atoms may end in ! or ? . See Unicode syntax for a formal specification. Valid unquoted atoms are: :ok , :ISO8601 , and :integer? . If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as :'🌢 Elixir' , :&quot;++olá++&quot; , and :&quot;123&quot; . Quoted and unquoted atoms with the same name are considered equivalent, so :atom , :&quot;atom&quot; , and :'atom' represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted. All operators in Elixir are also valid atoms. Valid examples are :foo , :FOO , :foo_42 , :foo@bar , and :++ . Invalid examples are :@foo ( @ is not allowed at start), :123 (numbers are not allowed at start), and :(*) (not a valid operator). true , false , and nil are reserved words that are represented by the atoms :true , :false and :nil respectively. Strings Single-line strings in Elixir are written between double-quotes, such as &quot;foo&quot; . Any double-quote inside the string must be escaped with \\ . Strings support Unicode characters and are stored as UTF-8 encoded binaries. Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &quot;&quot;&quot; is used to strip indentation from the inner string. For example: iex&gt; test = &quot;&quot;&quot; ...&gt; this ...&gt; is ...&gt; a ...&gt; test ...&gt; &quot;&quot;&quot; &quot; this \\n is \\n a \\n test \\n &quot; iex&gt; test = &quot;&quot;&quot; ...&gt; This ...&gt; Is ...&gt; A ...&gt; Test ...&gt; &quot;&quot;&quot; &quot;This \\n Is \\n A \\n Test \\n &quot; Strings are always represented as themselves in the AST. Charlists Charlists in Elixir are written in single-quotes, such as 'foo' . Any single-quote inside the string must be escaped with \\ . Charlists are made of non-negative integers, where each integer represents a Unicode code point. Multi-line charlists are written with three single-quotes ( ''' ), the same way multi-line strings are. Charlists are always represented as themselves in the AST. For more in-depth information, please read the &quot;Charlists&quot; section in the List module. Lists, tuples and binaries Data structures such as lists, tuples, and binaries are marked respectively by the delimiters [...] , {...} , and &lt;&lt;...&gt;&gt; . Each element is separated by comma. A trailing comma is also allowed, such as in [1, 2, 3,] . Maps and keyword lists Maps use the %{...} notation and each key-value is given by pairs marked with =&gt; , such as %{&quot;hello&quot; =&gt; 1, 2 =&gt; &quot;world&quot;} . Both keyword lists (list of two-element tuples where the first element is atom) and maps with atom keys support a keyword notation where the colon character : is moved to the end of the atom. %{hello: &quot;world&quot;} is equivalent to %{:hello =&gt; &quot;world&quot;} and [foo: :bar] is equivalent to [{:foo, :bar}] . This notation is a syntax sugar that emits the same AST representation. It will be explained in later sections. Structs Structs built on the map syntax by passing the struct name between % and { . For example, %User{...} .","ref":"syntax-reference.html#data-types","title":"Syntax reference - Data types","type":"extras"},{"doc":"Variables Variables in Elixir must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The variable may continue using a sequence of Unicode letters, numbers, and underscores. Variables may end in ? or ! . See Unicode syntax for a formal specification. Elixir's naming conventions recommend variables to be in snake_case format. Non-qualified calls (local calls) Non-qualified calls, such as add(1, 2) , must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscore. Calls may end in ? or ! . See Unicode syntax for a formal specification. Parentheses for non-qualified calls are optional, except for zero-arity calls, which would then be ambiguous with variables. If parentheses are used, they must immediately follow the function name without spaces . For example, add (1, 2) is a syntax error, since (1, 2) is treated as an invalid block which is attempted to be given as a single argument to add . Elixir's naming conventions recommend calls to be in snake_case format. Operators As many programming languages, Elixir also support operators as non-qualified calls with their precedence and associativity rules. Constructs such as = , when , &amp; and @ are simply treated as operators. See the Operators page for a full reference. Qualified calls (remote calls) Qualified calls, such as Math.add(1, 2) , must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscores. Calls may end in ? or ! . See Unicode syntax for a formal specification. Elixir's naming conventions recommend calls to be in snake_case format. For qualified calls, Elixir also allows the function name to be written between double- or single-quotes, allowing calls such as Math.&quot;++add++&quot;(1, 2) . Operators can be used as qualified calls without a need for quote, such as Kernel.+(1, 2) . Parentheses for qualified calls are optional. If parentheses are used, they must immediately follow the function name without spaces . Aliases Aliases are constructs that expand to atoms at compile-time. The alias String expands to the atom :&quot;Elixir.String&quot; . Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases. Elixir's naming conventions recommend aliases to be in CamelCase format. Blocks Blocks are multiple Elixir expressions separated by newlines or semi-colons. A new block may be created at any moment by using parentheses. Left to right arrow The left to right arrow ( -&gt; ) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The -&gt; may appear one or more times between one of the following terminators: do / end , fn / end or ( / ) . When -&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax. It is seen on case and cond constructs between do / end : case 1 do 2 -&gt; 3 4 -&gt; 5 end cond do true -&gt; false end Seen in typespecs between ( / ) : ( integer ( ) , boolean ( ) -&gt; integer ( ) ) It is also used between fn/end for building anonymous functions: fn x , y -&gt; x + y end Sigils Sigils start with ~ and are followed by a letter and one of the following pairs: ( and ) { and } [ and ] &lt; and &gt; &quot; and &quot; ' and ' | and | / and / After closing the pair, zero or more ASCII letters can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with sigil_ where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers: If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information: ~s/f \#{ &quot;o&quot; } o/ ~S/f\#{&quot;o&quot;}o/ Sigils are useful to encode text with their own escaping rules, such as regular expressions, datetimes, and others.","ref":"syntax-reference.html#expressions","title":"Syntax reference - Expressions","type":"extras"},{"doc":"Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements: atoms - such as :foo integers - such as 42 floats - such as 13.1 strings - such as &quot;hello&quot; lists - such as [1, 2, 3] tuples with two elements - such as {&quot;hello&quot;, :world} tuples with three elements, representing calls or variables, as explained next The building block of Elixir's AST is a call, such as: sum ( 1 , 2 , 3 ) which is represented as a tuple with three elements: { :sum , meta , [ 1 , 2 , 3 ] } the first element is an atom (or another tuple), the second element is a list of two-element tuples with metadata (such as line numbers) and the third is a list of arguments. We can retrieve the AST for any Elixir expression by calling quote : quote do sum ( ) end #=&gt; {:sum, [], []} Variables are also represented using a tuple with three elements and a combination of lists and atoms, for example: quote do sum end #=&gt; {:sum, [], Elixir} You can see that variables are also represented with a tuple, except the third element is an atom expressing the variable context. Over the course of this section, we will explore many Elixir syntax constructs alongside their AST representations. Operators Operators are treated as non-qualified calls: quote do 1 + 2 end #=&gt; {:+, [], [1, 2]} Note that . is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom: quote do foo . bar ( 1 , 2 , 3 ) end #=&gt; {{:., [], [{:foo, [], Elixir}, :bar]}, [], [1, 2, 3]} Calling anonymous functions uses the dot in the AST with a single argument, mirroring the fact the function name is &quot;missing&quot; from right side of the dot: quote do foo . ( 1 , 2 , 3 ) end #=&gt; {{:., [], [{:foo, [], Elixir}]}, [], [1, 2, 3]} Aliases Aliases are represented by an __aliases__ call with each segment separated by dot as an argument: quote do Foo.Bar.Baz end #=&gt; {:__aliases__, [], [:Foo, :Bar, :Baz]} quote do __MODULE__ . Bar.Baz end #=&gt; {:__aliases__, [], [{:__MODULE__, [], Elixir}, :Bar, :Baz]} All arguments, except the first, are guaranteed to be atoms. Data structures Remember lists are literals, so they are represented as themselves in the AST: quote do [ 1 , 2 , 3 ] end #=&gt; [1, 2, 3] Tuples have their own representation, except for two-element tuples, which are represented as themselves: quote do { 1 , 2 } end #=&gt; {1, 2} quote do { 1 , 2 , 3 } end #=&gt; {:{}, [], [1, 2, 3]} Binaries have a representation similar to tuples, except they are tagged with :&lt;&lt;&gt;&gt; instead of :{} : quote do &lt;&lt; 1 , 2 , 3 &gt;&gt; end #=&gt; {:&lt;&lt;&gt;&gt;, [], [1, 2, 3]} The same applies to maps where each pair is treated as a list of tuples with two elements: quote do %{ 1 = &gt; 2 , 3 = &gt; 4 } end #=&gt; {:%{}, [], [{1, 2}, {3, 4}]} Blocks Blocks are represented as a __block__ call with each line as a separate argument: quote do 1 2 3 end #=&gt; {:__block__, [], [1, 2, 3]} quote do 1 ; 2 ; 3 ; end #=&gt; {:__block__, [], [1, 2, 3]} Left to right arrow The left to right arrow ( -&gt; ) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression. For example, in case and cond : quote do case 1 do 2 -&gt; 3 4 -&gt; 5 end end #=&gt; {:case, [], [1, [do: [{:-&gt;, [], [[2], 3]}, {:-&gt;, [], [[4], 5]}]]]} quote do cond do true -&gt; false end end #=&gt; {:cond, [], [[do: [{:-&gt;, [], [[true], false]}]]]} Between ( / ) : quote do ( 1 , 2 -&gt; 3 4 , 5 -&gt; 6 ) end #=&gt; [{:-&gt;, [], [[1, 2], 3]}, {:-&gt;, [], [[4, 5], 6]}] Between fn/end : quote do fn 1 , 2 -&gt; 3 4 , 5 -&gt; 6 end end #=&gt; {:fn, [], [{:-&gt;, [], [[1, 2], 3]}, {:-&gt;, [], [[4, 5], 6]}]}","ref":"syntax-reference.html#the-elixir-ast","title":"Syntax reference - The Elixir AST","type":"extras"},{"doc":"All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that &quot;desugar&quot; to one of the constructs explored above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence. Integers in other bases and Unicode code points Elixir allows integers to contain _ to separate digits and provides conveniences to represent integers in other bases: 1_000_000 #=&gt; 1000000 0xABCD #=&gt; 43981 (Hexadecimal base) 0o01234567 #=&gt; 342391 (Octal base) 0b10101010 #=&gt; 170 (Binary base) ?é #=&gt; 233 (Unicode code point) Those constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST. Access syntax The access syntax is represented as a call to Access.get/2 : quote do opts [ arg ] end #=&gt; {{:., [], [Access, :get]}, [], [{:opts, [], Elixir}, {:arg, [], Elixir}]} Optional parentheses Elixir provides optional parentheses for non-qualified and qualified calls. quote do sum 1 , 2 , 3 end #=&gt; {:sum, [], [1, 2, 3]} The above is treated the same as sum(1, 2, 3) by the parser. The same applies to qualified calls such as Foo.bar(1, 2, 3) , which is equivalent to Foo.bar 1, 2, 3 . There are, however, some situations where parentheses are required: when calling anonymous functions, such as f.(1, 2) ; for non-qualified calls with no arguments, such as sum() . Removing the parentheses for sum causes it to be represented as the variable sum ; for dynamic qualified calls with no arguments. data.key means accessing a field named key in the map given by data . mod.fun() , with parens, means calling a function named fun in the module mod ; In practice, developers prefer to add parentheses to most of their calls. They are skipped mainly in Elixir's control-flow constructs, such as defmodule , if , case , etc, and in certain DSLs. Keywords Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as: [ { :foo , 1 } , { :bar , 2 } ] However Elixir introduces a syntax sugar where the keywords above may be written as follows: [ foo : 1 , bar : 2 ] Atoms with foreign characters, such as whitespace, must be wrapped in quotes. This rule applies to keywords as well: [ { :&quot;foo bar&quot; , 1 } , { :&quot;bar baz&quot; , 2 } ] == [ &quot;foo bar&quot; : 1 , &quot;bar baz&quot; : 2 ] Remember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals). Keywords as last arguments Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following: if ( condition , do : this , else : that ) is the same as if ( condition , [ do : this , else : that ] ) which in turn is the same as if ( condition , [ { :do , this } , { :else , that } ] ) do / end blocks The last syntax convenience are do / end blocks. do / end blocks are equivalent to keywords as the last argument of a function call where the block contents are wrapped in parentheses. For example: if true do this else that end is the same as: if ( true , do : ( this ) , else : ( that ) ) which we have explored in the previous section. Parentheses are important to support multiple expressions. This: if true do this that end is the same as: if ( true , do : ( this that ) ) Inside do / end blocks you may introduce other keywords, such as else used in the if above. The supported keywords between do / end are static and are: after catch else rescue You can see them being used in constructs such as receive , try , and others.","ref":"syntax-reference.html#syntactic-sugar","title":"Syntax reference - Syntactic sugar","type":"extras"},{"doc":"This document provides a reference to Elixir syntax, exploring its constructs and their AST equivalents. We have also discussed a handful of syntax conveniences provided by Elixir. Those conveniences are what allow us to write defmodule Math do def add ( a , b ) do a + b end end instead of defmodule ( Math , [ { :do , def ( add ( a , b ) , [ { :do , a + b } ] ) } ] ) The mapping between code and data (the underlying AST) is what allows Elixir to implement defmodule , def , if , and others in Elixir itself. Elixir makes the constructs available for building the language accessible to developers who want to extend the language to new domains.","ref":"syntax-reference.html#summary","title":"Syntax reference - Summary","type":"extras"},{"doc":"Typespecs Elixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because: they provide documentation (for example, tools such as ExDoc show type specifications in the documentation) they're used by tools such as Dialyzer , that can analyze code with typespec to find type inconsistencies and possible bugs Type specifications (sometimes referred to as typespecs ) are defined in different contexts using the following attributes: @type @opaque @typep @spec @callback @macrocallback See the &quot;User-defined types&quot; and &quot;Defining a specification&quot; sub-sections below for more information on defining types and typespecs.","ref":"typespecs.html","title":"Typespecs","type":"extras"},{"doc":"defmodule StringHelpers do @type word ( ) :: String . t ( ) @spec long_word? ( word ( ) ) :: boolean ( ) def long_word? ( word ) when is_binary ( word ) do String . length ( word ) &gt; 8 end end In the example above, this happens: we declare a new type ( word() ) that is equivalent to the string type ( String.t() ); we specify that the long_word?/1 function takes an argument of type word() and returns a boolean ( boolean() ), that is, either true or false .","ref":"typespecs.html#a-simple-example","title":"Typespecs - A simple example","type":"extras"},{"doc":"The syntax Elixir provides for type specifications is similar to the one in Erlang . Most of the built-in types provided in Erlang (for example, pid() ) are expressed in the same way: pid() (or simply pid ). Parameterized types (such as list(integer) ) are supported as well and so are remote types (such as Enum.t ). Integers and atom literals are allowed as types (for example, 1 , :atom , or false ). All other types are built out of unions of predefined types. Some shorthands are allowed, such as [...] , &lt;&lt;&gt;&gt; , and {...} . The notation to represent the union of types is the pipe | . For example, the typespec type :: atom() | pid() | tuple() creates a type type that can be either an atom , a pid , or a tuple . This is usually called a sum type in other languages Basic types type :: any ( ) # the top type, the set of all terms | none ( ) # the bottom type, contains no terms | atom ( ) | map ( ) # any map | pid ( ) # process identifier | port ( ) # port identifier | reference ( ) | tuple ( ) # tuple of any size ## Numbers | float ( ) | integer ( ) | neg_integer ( ) # ..., -3, -2, -1 | non_neg_integer ( ) # 0, 1, 2, 3, ... | pos_integer ( ) # 1, 2, 3, ... ## Lists | list ( type ) # proper list ([]-terminated) | nonempty_list ( type ) # non-empty proper list | maybe_improper_list ( content_type , termination_type ) # proper or improper list | nonempty_improper_list ( content_type , termination_type ) # improper list | nonempty_maybe_improper_list ( content_type , termination_type ) # non-empty proper or improper list | Literals # Described in section &quot;Literals&quot; | BuiltIn # Described in section &quot;Built-in types&quot; | Remotes # Described in section &quot;Remote types&quot; | UserDefined # Described in section &quot;User-defined types&quot; Literals The following literals are also supported in typespecs: type :: ## Atoms :atom # atoms: :foo, :bar, ... | true | false | nil # special atom literals ## Bitstrings | &lt;&lt; &gt;&gt; # empty bitstring | &lt;&lt; _ :: size &gt;&gt; # size is 0 or a positive integer | &lt;&lt; _ :: _ * unit &gt;&gt; # unit is an integer from 1 to 256 | &lt;&lt; _ :: size , _ :: _ * unit &gt;&gt; ## (Anonymous) Functions | ( -&gt; type ) # 0-arity, returns type | ( type1 , type2 -&gt; type ) # 2-arity, returns type | ( ... -&gt; type ) # any arity, returns type ## Integers | 1 # integer | 1 . . 10 # integer from 1 to 10 ## Lists | [ type ] # list with any number of type elements | [ ] # empty list | [ ... ] # shorthand for nonempty_list(any()) | [ type , ... ] # shorthand for nonempty_list(type) | [ key : value_type ] # keyword list with key :key of value_type ## Maps | %{ } # empty map | %{ key : value_type } # map with required key :key of value_type | %{ key_type = &gt; value_type } # map with required pairs of key_type and value_type | %{ required ( key_type ) = &gt; value_type } # map with required pairs of key_type and value_type | %{ optional ( key_type ) = &gt; value_type } # map with optional pairs of key_type and value_type | % SomeStruct { } # struct with all fields of any type | % SomeStruct { key : value_type } # struct with required key :key of value_type ## Tuples | { } # empty tuple | { :ok , type } # two-element tuple with an atom and any type Built-in types The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above. Built-in type Defined as term() any() arity() 0..255 as_boolean(t) t binary() &lt;&lt;_::_*8&gt;&gt; bitstring() &lt;&lt;_::_*1&gt;&gt; boolean() true | false byte() 0..255 char() 0..0x10FFFF charlist() [char()] nonempty_charlist() [char(), ...] fun() (... -&gt; any) function() fun() identifier() pid() | port() | reference() iodata() iolist() | binary() iolist() maybe_improper_list(byte() | binary() | iolist(), binary() | []) keyword() [{atom(), any()}] keyword(t) [{atom(), t}] list() [any()] nonempty_list() nonempty_list(any()) maybe_improper_list() maybe_improper_list(any(), any()) nonempty_maybe_improper_list() nonempty_maybe_improper_list(any(), any()) mfa() {module(), atom(), arity()} module() atom() no_return() none() node() atom() number() integer() | float() struct() %{:__struct__ =&gt; atom(), optional(atom()) =&gt; any()} timeout() :infinity | non_neg_integer() as_boolean(t) exists to signal users that the given value will be treated as a boolean, where nil and false will be evaluated as false and everything else is true . For example, Enum.filter/2 has the following specification: filter(t, (element -&gt; as_boolean(term))) :: list . Remote types Any module is also able to define its own types and the modules in Elixir are no exception. For example, the Range module defines a t/0 type that represents a range: this type can be referred to as Range.t/0 . In a similar fashion, a string is String.t/0 , any enumerable can be Enum.t/0 , and so on. Maps The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys. If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with optional(any) =&gt; any . Note that the syntactic representation of map() is %{optional(any) =&gt; any} , not %{} . The notation %{} specifies the singleton type for the empty map. User-defined types The @type , @typep , and @opaque module attributes can be used to define new types: @type type_name :: type @typep type_name :: type @opaque type_name :: type A type defined with @typep is private. An opaque type, defined with @opaque is a type where the internal structure of the type will not be visible, but the type is still public. Types can be parameterized by defining variables as parameters; these variables can then be used to define the type. @type dict ( key , value ) :: [ { key , value } ]","ref":"typespecs.html#types-and-their-syntax","title":"Typespecs - Types and their syntax","type":"extras"},{"doc":"A specification for a function can be defined as follows: @spec function_name ( type1 , type2 ) :: return_type Guards can be used to restrict type variables given as arguments to the function. @spec function ( arg ) :: [ arg ] when arg : atom If you want to specify more than one variable, you separate them by a comma. @spec function ( arg1 , arg2 ) :: { arg1 , arg2 } when arg1 : atom , arg2 : integer Type variables with no restriction can also be defined using var . @spec function ( arg ) :: [ arg ] when arg : var You can also name your arguments in a typespec using arg_name :: arg_type syntax. This is particularly useful in documentation as a way to differentiate multiple arguments of the same type (or multiple elements of the same type in a type definition): @spec days_since_epoch ( year :: integer , month :: integer , day :: integer ) :: integer @type color :: { red :: integer , green :: integer , blue :: integer } Specifications can be overloaded just like ordinary functions. @spec function ( integer ) :: atom @spec function ( atom ) :: integer","ref":"typespecs.html#defining-a-specification","title":"Typespecs - Defining a specification","type":"extras"},{"doc":"Behaviours in Elixir (and Erlang) are a way to separate and abstract the generic part of a component (which becomes the behaviour module ) from the specific part (which becomes the callback module ). A behaviour module defines a set of functions and macros (referred to as callbacks ) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the GenServer behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform. To define a behaviour module, it's enough to define one or more callbacks in that module. To define callbacks, the @callback and @macrocallback module attributes can be used (for function callbacks and macro callbacks respectively). defmodule MyBehaviour do @callback my_fun ( arg :: any ) :: any @macrocallback my_macro ( arg :: any ) :: Macro . t end As seen in the example above, defining a callback is a matter of defining a specification for that callback, made of: the callback name ( my_fun or my_macro in the example) the arguments that the callback must accept ( arg :: any in the example) the expected type of the callback return value Optional callbacks Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with function_exported?/3 or macro_exported?/3 . Optional callbacks can be defined through the @optional_callbacks module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example: defmodule MyBehaviour do @callback vital_fun ( ) :: any @callback non_vital_fun ( ) :: any @macrocallback non_vital_macro ( arg :: any ) :: Macro . t @optional_callbacks non_vital_fun : 0 , non_vital_macro : 1 end One example of optional callback in Elixir's standard library is GenServer.format_status/2 . Implementing behaviours To specify that a module implements a given behaviour, the @behaviour attribute must be used: defmodule MyBehaviour do @callback my_fun ( arg :: any ) :: any end defmodule MyCallbackModule do @behaviour MyBehaviour def my_fun ( arg ) , do : arg end If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen). Elixir's standard library contains a few frequently used behaviours such as GenServer , Supervisor , and Application . Inspecting behaviours The @callback and @optional_callbacks attributes are used to create a behaviour_info/1 function available on the defining module. This function can be used to retrieve the callbacks and optional callbacks defined by that module. For example, for the MyBehaviour module defined in &quot;Optional callbacks&quot; above: MyBehaviour . behaviour_info ( :callbacks ) #=&gt; [vital_fun: 0, &quot;MACRO-non_vital_macro&quot;: 2, non_vital_fun: 0] MyBehaviour . behaviour_info ( :optional_callbacks ) #=&gt; [&quot;MACRO-non_vital_macro&quot;: 2, non_vital_fun: 0] When using iex , the IEx.Helpers.b/1 helper is also available.","ref":"typespecs.html#behaviours","title":"Typespecs - Behaviours","type":"extras"},{"doc":"Elixir discourages the use of the string() type. The string() type refers to Erlang strings, which are known as &quot;charlists&quot; in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type string() , Elixir will emit a warning. You should use charlist() , nonempty_charlist() , binary() or String.t() accordingly, or any of the several literal representations for these types. Note that String.t() and binary() are equivalent to analysis tools. Although, for those reading the documentation, String.t() implies it is a UTF-8 encoded binary.","ref":"typespecs.html#the-string-type","title":"Typespecs - The string() type","type":"extras"},{"doc":"Unicode Syntax Elixir supports Unicode throughout the language. Quoted identifiers, such as strings ( &quot;olá&quot; ) and charlists ( 'olá' ), support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation. Elixir also supports Unicode in identifiers since Elixir v1.5, as defined in the Unicode Annex #31 . The focus of this document is to describe how Elixir implements the requirements outlined in the Unicode Annex. These requirements are referred to as R1, R6 and so on. To check the Unicode version of your current Elixir installation, run String.Unicode.version() .","ref":"unicode-syntax.html","title":"Unicode Syntax","type":"extras"},{"doc":"The general Elixir identifier rule is specified as: &lt; Identifier &gt; := &lt; Start &gt; &lt; Continue &gt; * &lt; Ending &gt; ? where &lt;Start&gt; uses the same categories as the spec but restricts them to the NFC form (see R6): characters derived from the Unicode General Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus Other_ID_Start , minus Pattern_Syntax and Pattern_White_Space code points In set notation: [\\p{L}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}] . and &lt;Continue&gt; uses the same categories as the spec but restricts them to the NFC form (see R6): ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus Other_ID_Continue , minus Pattern_Syntax and Pattern_White_Space code points. In set notation: [\\p{ID_Start}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\p{Other_ID_Continue}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}] . &lt;Ending&gt; is an addition specific to Elixir that includes only the code points ? (003F) and ! (0021). The spec also provides a &lt;Medial&gt; set but Elixir does not include any character on this set. Therefore the identifier rule has been simplified to consider this. Elixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. R1b is guaranteed for backwards compatibility purposes. Atoms Unicode atoms in Elixir follow the identifier rule above with the following modifications: &lt;Start&gt; additionally includes the code point _ (005F) &lt;Continue&gt; additionally includes the code point @ (0040) Note atoms can also be quoted, which allows any characters, such as :&quot;hello elixir&quot; . All Elixir operators are also valid atoms ( :+ , :@ , :|&gt; , etc.). The full description of valid atoms is available in the &quot;Atoms&quot; section in the syntax reference . Variables Variables in Elixir follow the identifier rule above with the following modifications: &lt;Start&gt; additionally includes the code point _ (005F) &lt;Start&gt; additionally excludes Lu (letter uppercase) and Lt (letter titlecase) characters In set notation: [\\u{005F}\\p{Ll}\\p{Lm}\\p{Lo}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}] .","ref":"unicode-syntax.html#r1-default-identifiers","title":"Unicode Syntax - R1. Default Identifiers","type":"extras"},{"doc":"Elixir supports only code points \\t (0009), \\n (000A), \\r (000D) and \\s (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported.","ref":"unicode-syntax.html#r3-pattern_white_space-and-pattern_syntax-characters","title":"Unicode Syntax - R3. Pattern_White_Space and Pattern_Syntax Characters","type":"extras"},{"doc":"Identifiers in Elixir are case sensitive. Elixir requires all atoms and variables to be in NFC form. Any other form will fail with a relevant error message. Quoted-atoms and strings can, however, be in any form and are not verified by the parser. In other words, the atom :josé can only be written with the code points 006A 006F 0073 00E9 . Using another normalization form will lead to a tokenizer error. On the other hand, :&quot;josé&quot; may be written as 006A 006F 0073 00E9 or 006A 006F 0073 0065 0301 , since it is written between quotes. Choosing requirement R6 automatically excludes requirements R4, R5 and R7.","ref":"unicode-syntax.html#r6-filtered-normalized-identifiers","title":"Unicode Syntax - R6. Filtered Normalized Identifiers","type":"extras"},{"doc":"Writing Documentation Elixir treats documentation as a first-class citizen. This means documentation should be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices and doctests.","ref":"writing-documentation.html","title":"Writing Documentation","type":"extras"},{"doc":"Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the ones available at GitHub as a getting started point: Basic writing and formatting syntax Mastering Markdown","ref":"writing-documentation.html#markdown","title":"Writing Documentation - Markdown","type":"extras"},{"doc":"Documentation in Elixir is usually attached to module attributes. Let's see an example: defmodule MyApp.Hello do @moduledoc &quot;&quot;&quot; This is the Hello module. &quot;&quot;&quot; @moduledoc since : &quot;1.0.0&quot; @doc &quot;&quot;&quot; Says hello to the given `name`. Returns `:ok`. ## Examples iex&gt; MyApp.Hello.world(:john) :ok &quot;&quot;&quot; @doc since : &quot;1.3.0&quot; def world ( name ) do IO . puts ( &quot;hello \#{ name } &quot; ) end end The @moduledoc attribute is used to add documentation to the module. @doc is used before a function to provide documentation for it. Besides the attributes above, @typedoc can also be used to attach documentation to types defined as part of typespecs. Elixir also allows metadata to be attached to documentation, by passing a keyword list to @doc and friends.","ref":"writing-documentation.html#module-attributes","title":"Writing Documentation - Module Attributes","type":"extras"},{"doc":"When documenting a function, argument names are inferred by the compiler. For example: def size ( %{ size : size } ) do size end The compiler will infer this argument as map . Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation: def size ( map_with_size ) def size ( %{ size : size } ) do size end","ref":"writing-documentation.html#function-arguments","title":"Writing Documentation - Function Arguments","type":"extras"},{"doc":"Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as @moduledoc , @typedoc , and @doc ). A commonly used metadata is :since , which annotates in which version that particular module, function, type, or callback was added, as shown in the example above. Another common metadata is :deprecated , which emits a warning in the documentation, explaining that its usage is discouraged: @doc deprecated : &quot;Use Foo.bar/2 instead&quot; Note the :deprecated key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the @deprecated attribute: @deprecated &quot;Use Foo.bar/2 instead&quot; Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.","ref":"writing-documentation.html#documentation-metadata","title":"Writing Documentation - Documentation metadata","type":"extras"},{"doc":"When writing documentation: Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like ExDoc use the first line to generate a summary. Reference modules by their full name. Markdown uses backticks ( ` ) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called MyApp.Hello , always reference it as `MyApp.Hello` and never as `Hello` . Reference functions by name and arity if they are local, as in `world/1` , or by module, name and arity if pointing to an external module: `MyApp.Hello.world/1` . Reference a @callback by prepending c: , as in `c:world/1` . Reference a @type by prepending t: , as in `t:values/0` . Start new sections with second level Markdown headers ## . First level headers are reserved for module and function names. Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause. Use the :since key in the documentation metadata to annotate whenever new functions or modules are added to your API.","ref":"writing-documentation.html#recommendations","title":"Writing Documentation - Recommendations","type":"extras"},{"doc":"We recommend that developers include examples in their documentation, often under their own ## Examples heading. To ensure examples do not get out of date, Elixir's test framework (ExUnit) provides a feature called doctests that allows developers to test the examples in their documentation. Doctests work by parsing out code samples starting with iex&gt; from the documentation. You can read more about it at ExUnit.DocTest . Note that doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the iex&gt; prompt.","ref":"writing-documentation.html#doctests","title":"Writing Documentation - Doctests","type":"extras"},{"doc":"Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API. Code comments are aimed at developers reading the code. They are useful for marking improvements, leaving notes (for example, why you had to resort to a workaround due to a bug in a library), and so forth. They are tied to the source code: you can completely rewrite a function and remove all existing code comments, and it will continue to behave the same, with no change to either its behaviour or its documentation. Because private functions cannot be accessed externally, Elixir will warn if a private function has a @doc attribute and will discard its content. However, you can add code comments to private functions, as with any other piece of code, and we recommend developers to do so whenever they believe it will add relevant information to the readers and maintainers of such code. Finally, beware of redundant code comments, such as the ones describing the exact same that the code does: # Total is the sum of the batch and individual entries total = batch_sum + individual_sum In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.","ref":"writing-documentation.html#documentation-code-comments","title":"Writing Documentation - Documentation != Code comments","type":"extras"},{"doc":"Besides the modules and functions libraries provide as part of their public interface, libraries may also implement important functionality that is not part of their API. While these modules and functions can be accessed, they are meant to be internal to the library and thus should not have documentation for end users. Conveniently, Elixir allows developers to hide modules and functions from the documentation, by setting @doc false to hide a particular function, or @moduledoc false to hide the whole module. If a module is hidden, you may even document the functions in the module, but the module itself won't be listed in the documentation: defmodule MyApp.Hidden do @moduledoc false @doc &quot;&quot;&quot; This function won&#39;t be listed in docs. &quot;&quot;&quot; def function_that_wont_be_listed_in_docs do # ... end end In case you don't want to hide a whole module, you can hide functions individually: defmodule MyApp.Sample do @doc false def add ( a , b ) , do : a + b end However, keep in mind @moduledoc false or @doc false do not make a function private. The function above can still be invoked as MyApp.Sample.add(1, 2) . Not only that, if MyApp.Sample is imported, the add/2 function will also be imported into the caller. For those reasons, be cautious when adding @doc false to functions, instead use one of these two options: Move the undocumented function to a module with @moduledoc false , like MyApp.Hidden , ensuring the function won't be accidentally exposed or imported. Remember you can use @moduledoc false to hide a whole module and still document each function with @doc . Tools will still ignore the module. Start the function name with one or two underscores, for example, __add__/2 . Functions starting with underscore are automatically treated as hidden, although you can also be explicit and add @doc false . The compiler does not import functions with leading underscores and they hint to anyone reading the code of their intended private usage.","ref":"writing-documentation.html#hiding-internal-modules-and-functions","title":"Writing Documentation - Hiding Internal Modules and Functions","type":"extras"},{"doc":"Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the Code.fetch_docs/1 function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.","ref":"writing-documentation.html#code-fetch_docs-1","title":"Writing Documentation - Code.fetch_docs/1","type":"extras"},{"doc":"Changelog for Elixir v1.12 Elixir v1.12 is out with improvements to scripting, tighter Erlang/OTP 24 integration, stepped ranges, and dozen of new functions across the standard library. Overall this is a small release, which continues our tradition of bringing Elixir developers quality of live improvements every 6 months. This is the last release to support Erlang/OTP 21.","ref":"changelog.html","title":"Changelog for Elixir v1.12","type":"extras"},{"doc":"Elixir v1.12 brings new conveniences for those using Elixir for scripting (via .exs files). Elixir has been capable of managing dependencies for a quite long time, but it could only be done within Mix projects. In particular, the Elixir team is wary of global dependencies as any scripts that rely on system packages are brittle and hard to reproduce whenever your system changes. Mix.install/2 is meant to be a sweetspot between single-file scripts and full-blown Mix projects. With Mix.install/2 , you can list your dependencies on top of your scripts. When you execute the script for the first time, Elixir will download, compile, and cache your dependencies before running your script. Future invocations of the script will simply read the compiled artefacts from the cache: Mix . install ( [ :jason ] ) IO . puts Jason . encode! ( %{ hello : :world } ) Mix.install/2 also performs protocol consolidation, which gives script developers an option to execute their code in the most performant format possible. Note: Mix.install/2 is currently experimental and it may change in future releases. Another improvement to scripting is the ability to trap exit signals via System.trap_signal/3 . All you need is the signal name and a callback that will be invoked when the signal triggers. For example, ExUnit leverages this functionality to print all currently running tests when you abort the test suite via SIGQUIT ( Ctrl+\\\\ ): $ mix test ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... . . ... ... ... ... ... ... ... ^ \\ Aborting test suite , the following have not completed : * test query building [ test / ecto / query_test . exs : 48 ] * test placeholders in Repo . insert_all [ test / ecto / repo_test . exs : 502 ] Showing results so far ... 78 doctests , 1042 tests , 0 failures This is particularly useful when your tests get stuck and you want to know which one is the culprit. Important : Trapping signals may have strong implications on how a system shuts down and behave in production and therefore it is extremely discouraged for libraries to set their own traps. Instead, they should redirect users to configure them themselves. The only cases where it is acceptable for libraries to set their own traps is when using Elixir in script mode, such as in .exs files and via Mix tasks.","ref":"changelog.html#scripting-improvements-mix-install-2-and-system-trap_signal-3","title":"Changelog for Elixir v1.12 - Scripting improvements: Mix.install/2 and System.trap_signal/3","type":"extras"},{"doc":"Erlang/OTP 24 ships with JIT compilation support and Elixir developers don't have to do anything to reap its benefits. There are many other features in Erlang/OTP 24 to look forwards to and Elixir v1.12 provides integration with many of them: such as support for 16bit floats in bitstrings as well as performance improvements in the compiler and during code evaluation. Another excellent feature in Erlang/OTP 24 is the implementation of EEP 54 , which provides extended error information for many functions in Erlang's stdlib. Elixir v1.12 fully leverages this feature to improve reporting for errors coming from Erlang. For example, in earlier OTP versions, inserting an invalid argument into a ETS table that no longer exists would simply error with ArgumentError : Interactive Elixir ( 1.11 . 0 ) iex(1)&gt; ets = :ets . new ( :example , [ ] ) # Reference &lt; 0.3845811859 . 2669281281.223553 &gt; iex(2)&gt; :ets . delete ( ets ) true iex(3)&gt; :ets . insert ( ets , :should_be_a_tuple ) ** (ArgumentError) argument error (stdlib 3.15) :ets.insert(#Reference&lt;0.3845811859.2669281281.223553&gt;, :should_be_a_tuple) However, in Elixir v1.12 with Erlang/OTP 24: Interactive Elixir ( 1.12 . 0 ) iex(1)&gt; ets = :ets . new ( :example , [ ] ) # Reference &lt; 0.105641012 . 1058144260.76455 &gt; iex(2)&gt; :ets . delete ( ets ) true iex(3)&gt; :ets . insert ( ets , :should_be_a_tuple ) ** (ArgumentError) errors were found at the given arguments: * 1 st argument : the table identifier does not refer to an existing ETS table * 2 nd argument : not a tuple ( stdlib 3.15 ) :ets . insert ( # Reference &lt; 0.105641012 . 1058144260.76455 &gt; , :should_be_a_tuple )","ref":"changelog.html#tighter-erlang-otp-24-integration","title":"Changelog for Elixir v1.12 - Tighter Erlang/OTP 24 integration","type":"extras"},{"doc":"Elixir has support for ranges from before its v1.0 release. Ranges support only integers and are inclusive, using the mathematic notation a..b . Ranges in Elixir are either increasing 1..10 or decreasing 10..1 and the direction of the range was always inferred from the starting and stop positions. Ranges are always lazy as its values are emitted as they are enumerated rather than being computed upfront. Unfortunately, due to this inference, it is not possible to have empty ranges. For example, if you want to create a list of n elements, you can express it with a range from 1..n , as 1..0 is a decreasing range with two elements. Elixir v1.12 supports stepped ranges via the first..last//step notation. For example: 1..10//2 will emit the numbers 1 , 3 , 5 , 7 , and 9 . You can consider the // operator to perform &quot;range division&quot;, as it effectively divides and rounds up the number of elements in the range by step . Steps can be either positive (increasing ranges) or negative (decreasing ranges). Stepped ranges bring more expressive power to Elixir ranges and they elegantly solve the empty range problem, as they allow the direction of the steps to be explicitly declared instead of inferred. As of Elixir v1.12, implicitly decreasing ranges are soft-deprecated and warnings will be emitted in future Elixir versions based on our deprecation policy .","ref":"changelog.html#stepped-ranges","title":"Changelog for Elixir v1.12 - Stepped ranges","type":"extras"},{"doc":"Elixir v1.12 has the additional of many functions across the standard library. The Enum module received additions such as Enum.count_until/2 , Enum.product/1 , Enum.zip_with/2 , and more. The Integer module now includes Integer.pow/2 and Integer.extended_gcd/2 . Finally, the Kernel module got two new functions, Kernel.then/2 and Kernel.tap/2 , which are specially useful in |&gt; pipelines.","ref":"changelog.html#additional-functions","title":"Changelog for Elixir v1.12 - Additional functions","type":"extras"},{"doc":"1. Enhancements EEx [EEx.Engine] Add EEx.Engine.handle_text/3 callback that receives text metadata [EEx.Engine] Emit warnings for unused &quot;do&quot; expression in EEx Elixir [Code] Do not add newlines around interpolation on code formatting. Note this means formatted code that has interpolation after the line length on Elixir v1.12 won't be considered as formatted on earlier Elixir versions [Calendar] Support basic datetime format in Calendar.ISO parsing functions [Code] Improve evaluation performance on systems running on Erlang/OTP 24+ [Date] Support steps via Date.range/3 [DateTime] Add offset to DateTime.to_iso8601/2 (now to_iso8601/3 ) [Enum] Add Enum.count_until/2 and Enum.count_until/3 [Enum] Add Enum.product/1 [Enum] Add Enum.zip_with/2 , Enum.zip_with/3 , Enum.zip_reduce/3 , and Enum.zip_reduce/4 [Enum] Add support for functions as the second argument of Enum.with_index/2 [Exception] Show error_info data for exceptions coming from Erlang [Float] Add Float.pow/2 [Integer] Add Integer.pow/2 and Integer.extended_gcd/2 [List] Add default value for List.first/1 and List.last/1 [Kernel] Add start..stop//step as support for stepped ranges [Kernel] Also warn for literal structs on min/2 and max/2 [Kernel] Add Kernel.tap/2 and Kernel.then/2 [Kernel] Do not add runtime dependencies to remotes in typespecs [Kernel] When there is an unused variable warning and there is a variable with the same name previously defined, suggest the user may have wanted to use the pin operator [Kernel] Improve error messages on invalid character right after a number [Kernel] Show removal and deprecated tips from Erlang/OTP [Macro] Add export dependencies on Macro.struct!/2 [Macro] Support :newline to customize newlines escaping in Macro.unescape_string/2 [Module] Raise on invalid @dialyzer attributes [Module] Add Module.get_definition/2 and Module.delete_definition/2 [Module] Allow @on_load to be a private function [Module] Validate @dialyzer related module attributes [Range] Add Range.new/3 and Range.size/1 [Regex] Add offset option to Regex.scan/3 and Regex.run/3 [Registry] Support :compression on Registry tables [Registry] Support Registry.values/3 for reading values under a given key-pid pair [Stream] Add Stream.zip_with/2 and Stream.zip_with/3 [String] Add :turkic mode option to String case functions [System] Add System.trap_signal/3 and System.untrap_signal/2 [Tuple] Add Tuple.sum/1 and Tuple.product/1 [URI] Support RFC3986 compliant encoding and decoding of queries via the :rfc3986 option ExUnit [ExUnit] Intercept SIGQUIT (via Ctrl+\\) and show a list of all aborted tests as well as intermediate test results [ExUnit] Interpolate module attributes in match assertions diffs [ExUnit] Print how much time is spent on async vs sync tests [ExUnit] Improve error messages for doctests [ExUnit] Compile doctests faster (often by two times) IEx [IEx] Make IEx' parser configurable to allow special commands [IEx] Show function signature when pressing tab after the opening parens of a function [IEx] If an IEx expression starts with a binary operator, such as |&gt; , automatically pipe in the result of the last expression Mix [Mix] Add Mix.install/2 for dynamically installing a list of dependencies [Mix] Support :exit_code option in Mix.raise/2 [Mix] Discard MIX_ENV and MIX_TARGET values if they are empty strings [Mix] Print the time taken to execute a task with on MIX_DEBUG=1 [mix compile.erlang] Compile multiple files in parallel [mix escript.build] Deep merge configuration and ensure argv is set when executing config/runtime.exs [mix release] Add RELEASE_PROG to releases with the name of the executable starting the release [mix release] Support remote.vm.args to customize how the connecting VM boots [mix test] Run all available tests if there are no pending --failed tests. This provides a better workflow as you no longer need to toggle the --failed flag between runs 2. Bug fixes Elixir [CLI] Ensure -e &quot;&quot; (with an empty string) parses correctly on Windows [Inspect] Do not override user supplied :limit option for derived implementations [Kernel] Allow heredoc inside a heredoc interpolation [Kernel] Preserve CRLF on heredocs [Kernel] Public functions without documentation now appear as an empty map on Code.fetch_docs/1 , unless they start with underscore, where they remain as :none . This aligns Elixir's implementation with EEP48 [Kernel] Do not crash when complex literals (binaries and maps) are used in guards [Kernel] Properly parse keywords (such as end ) followed by the :: operator [Macro] Macro.decompose_call/1 now also consider tuples with more than 2 elements to not be valid calls [Macro] Fix Macro.to_string/1 double-escaping of escape characters in sigils [Macro] Fix Macro.underscore/1 on digits preceded by capitals: &quot;FOO10&quot; now becomes &quot;foo10&quot; instead of &quot;fo_o10&quot; [Macro] Preserve underscores between digits on Macro.underscore/1 [OptionParser] Properly parse when numbers follow-up aliases, for example, -ab3 is now parsed as -a -b 3 [Path] Fix Path.relative_to/2 when referencing self [Task] Ensure Task.async_stream/2 with ordered: false discard results as they are emitted, instead of needlessly accumulating inside the stream manager [URI] Do not discard empty paths on URI.merge/2 ExUnit [ExUnit.Case] Make @tag tmp_dir an absolute directory, avoiding inconsistencies if the test changes the current working directory [ExUnit.Diff] Fix cases where the diffing algorithm would fail to print a pattern correct IEx [IEx] Fix auto-completion inside remote shells Mix [mix app.config] Do not emit false positive warnings when configured dependencies that have runtime: false set [mix compile.elixir] Ensure that a manifest is generated even with no source code [mix compile.elixir] Make sure export dependencies trigger recompilation when the dependency is removed as well as when the whole file is removed [mix compile.elixir] Do not emit false positive warnings when a path dependency adds a module that is then used by the current application in the same mix compile cycle [mix test] Ensure protocols within the current project are consolidated when --cover is given [mix release] Improve compliance of release scripts with stripped down Linux installations [mix release] Preserve file mode when copying non-beam ebin files [mix xref] Ensure args are passed to the underlying mix compile call 3. Soft-deprecations (no warnings emitted) Elixir [Kernel] Using start..stop to match on ranges is soft-deprecated and will warn on future Elixir versions. Use start..stop//step instead [Kernel] Using start..stop to create decreasing ranges is soft-deprecated and will warn on future versions. Use start..stop//-1 instead 4. Hard-deprecations EEx [EEx.Engine] use EEx.Engine is deprecated in favor of explicit delegation Elixir [Kernel] The binary operator ^^^ is deprecated. If you are using Bitwise.^^^/2 , use Bitwise.bxor/2 instead [Kernel] Deprecate @foo() in favor of @foo [System] Deprecate System.stacktrace/0 (it was already deprecated outside of catch/rescue and now it is deprecated everywhere) Mix [mix compile] The :xref compiler is deprecated and it has no effect. Please remove it from your mix.exs file.","ref":"changelog.html#v1-12-0-2021-04-03","title":"Changelog for Elixir v1.12 - v1.12.0 (2021-04-03)","type":"extras"},{"doc":"The CHANGELOG for v1.11 releases can be found in the v1.11 branch .","ref":"changelog.html#v1-11","title":"Changelog for Elixir v1.12 - v1.11","type":"extras"}]