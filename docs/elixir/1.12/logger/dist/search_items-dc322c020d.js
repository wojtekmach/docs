searchNodes=[{"doc":"A logger for Elixir applications. It includes many features: Provides debug, info, warn, and error levels. Supports multiple backends which are automatically supervised when plugged into Logger . Formats and truncates messages on the client to avoid clogging Logger backends. Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress. Integrates with Erlang's :logger to convert terms to Elixir syntax. Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted. def delete_user ( user ) do Logger . info ( &quot;Deleting user from the system: \#{ inspect ( user ) } &quot; ) # ... end The Logger.info/2 macro emits the provided message at the :info level. Note the arguments given to info/2 will only be evaluated if a message is logged. For instance, if the Logger level is set to :warning , :info messages are never logged and therefore the arguments given above won't even be executed. There are additional macros for other levels. Logger also allows log commands to be removed altogether via the :compile_time_purge_matching option (see below). For dynamically logging messages, see bare_log/3 . But note that bare_log/3 always evaluates its arguments (unless the argument is an anonymous function). Levels The supported levels, ordered by importance, are: :emergency - when system is unusable, panics :alert - for alerts, actions that must be taken immediately, ex. corrupted database :critical - for critical conditions :error - for errors :warning - for warnings :notice - for normal, but significant, messages :info - for information of any kind :debug - for debug-related messages For example, :info takes precedence over :debug . If your log level is set to :info , then all :info , :notice and above will be passed to backends. If your log level is set to :alert , only :alert and :emergency will be printed. Metadata Whenever a message is logged, additional information can be given via metadata. Each log operation, such as Logger.info/2 , allows metadata to be given as argument. Furthermore, metadata can be set per process with Logger.metadata/1 . Some metadata, however, is always added automatically by Logger whenever possible. Those are: :application - the current application :mfa - the current module, function and arity :file - the current file :line - the current line :pid - the current process identifier :initial_call - the initial call that started the process :registered_name - the process registered name as an atom :domain - a list of domains for the logged message. For example, all Elixir reports default to [:elixir] . Erlang reports may start with [:otp] or [:sasl] :crash_reason - a two-element tuple with the throw/error/exit reason as first argument and the stacktrace as second. A throw will always be {:nocatch, term} . An error is always an Exception struct. All other entries are exits. The console backend ignores this metadata by default but it can be useful to other backends, such as the ones that report errors to third-party services Note that all metadata is optional and may not always be available. The :mfa , :file , :line , and similar metadata are automatically included when using Logger macros. Logger.bare_log/3 does not include any metadata beyond the :pid by default. Other metadata, such as :crash_reason , :initial_call , and :registered_name are available only inside behaviours such as GenServer, Supervisor, and others. For example, you might wish to include a custom :error_code metadata in your logs: Logger . error ( &quot;We have a problem&quot; , [ error_code : :pc_load_letter ] ) In your app's logger configuration, you would need to include the :error_code key and you would need to include $metadata as part of your log format template: config :logger , :console , format : &quot;[$level] $message $metadata \\n &quot; , metadata : [ :error_code , :file ] Your logs might then receive lines like this: [ error ] We have a problem error_code = pc_load_letter file = lib / app . ex Configuration Logger supports a wide range of configurations. This configuration is split in three categories: Application configuration - must be set before the :logger application is started Runtime configuration - can be set before the :logger application is started, but may be changed during runtime Erlang configuration - options that handle integration with Erlang's logging facilities Application configuration The following configuration must be set via config files (such as config/config.exs ) before the :logger application is started. :backends - the backends to be used. Defaults to [:console] . See the &quot;Backends&quot; section for more information. :compile_time_application - sets the :application metadata value to the configured value at compilation time. This configuration is automatically set by Mix and made available as metadata when logging. :compile_time_purge_matching - purges at compilation time all calls that match the given conditions. This means that Logger calls with level lower than this option will be completely removed at compile time, accruing no overhead at runtime. This configuration expects a list of keyword lists. Each keyword list contains a metadata key and the matching value that should be purged. Some special keys are supported: :level_lower_than - purges all messages with a lower logger level :module - purges all messages with the matching module :function - purges all messages with the &quot;function/arity&quot; Remember that if you want to purge log calls from a dependency, the dependency must be recompiled. :start_options - passes start options to Logger's main process, such as :spawn_opt and :hibernate_after . All options in GenServer.option/0 are accepted, except :name . For example, to configure the :backends and purge all calls that happen at compile time with level lower than :info in a config/config.exs file: config :logger , backends : [ :console ] , compile_time_purge_matching : [ [ level_lower_than : :info ] ] If you want to purge all log calls from an application named :foo and only keep errors from Bar.foo/3 , you can set up two different matches: config :logger , compile_time_purge_matching : [ [ application : :foo ] , [ module : Bar , function : &quot;foo/3&quot; , level_lower_than : :error ] ] Runtime Configuration All configuration below can be set via config files (such as config/config.exs ) but also changed dynamically during runtime via Logger.configure/1 . :level - the logging level. Attempting to log any message with severity less than the configured level will simply cause the message to be ignored. Keep in mind that each backend may have its specific level, too. In addition to levels mentioned above it also support 2 &quot;meta-levels&quot;: :all - all messages will be logged, conceptually identical to :debug :none - no messages will be logged at all :utc_log - when true , uses UTC in logs. By default it uses local time (i.e., it defaults to false ). :truncate - the maximum message size to be logged (in bytes). Defaults to 8192 bytes. Note this configuration is approximate. Truncated messages will have &quot; (truncated)&quot; at the end. The atom :infinity can be passed to disable this behavior. :sync_threshold - if the Logger manager has more than :sync_threshold messages in its queue, Logger will change to sync mode , to apply backpressure to the clients. Logger will return to async mode once the number of messages in the queue is reduced to one below the sync_threshold . Defaults to 20 messages. :sync_threshold can be set to 0 to force sync mode . :discard_threshold - if the Logger manager has more than :discard_threshold messages in its queue, Logger will change to discard mode and messages will be discarded directly in the clients. Logger will return to sync mode once the number of messages in the queue is reduced to one below the discard_threshold . Defaults to 500 messages. :discard_threshold_periodic_check - a periodic check that checks and reports if logger is discarding messages. It logs a warning message whenever the system is (or continues) in discard mode and it logs a warning message whenever if the system was discarding messages but stopped doing so after the previous check. By default it runs every 30_000 milliseconds. :translator_inspect_opts - when translating OTP reports and errors, the last message and state must be inspected in the error reports. This configuration allow developers to change how much and how the data should be inspected. For example, to configure the :level and :truncate options in a config/config.exs file: config :logger , level : :warning , truncate : 4096 Erlang/OTP integration From Elixir v1.10, Elixir's Logger is fully integrated with Erlang's logger. They share the same Logger.level/0 , any metadata set with Logger.metadata/1 applies to both, and so on. Elixir also supports formatting Erlang reports using Elixir syntax. This can be controlled with two configurations: :handle_otp_reports - redirects OTP reports to Logger so they are formatted in Elixir terms. This effectively disables Erlang standard logger. Defaults to true . :handle_sasl_reports - redirects supervisor, crash and progress reports to Logger so they are formatted in Elixir terms. Your application must guarantee :sasl is started before :logger . This means you may see some initial reports written in Erlang syntax until the Logger application kicks in. Defaults to false . This option only has an effect if :handle_otp_reports is true. For example, to configure Logger to redirect all Erlang messages using a config/config.exs file: config :logger , handle_otp_reports : true , handle_sasl_reports : true Furthermore, Logger allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the add_translator/1 and remove_translator/1 APIs. Check Logger.Translator for more information. Backends Logger supports different backends where log messages are written to. The available backends by default are: :console - logs messages to the console (enabled by default). :console is simply a shortcut for Logger.Backends.Console . Developers may also implement their own backends, an option that is explored in more detail below. The initial backends are loaded via the :backends configuration, which must be set before the :logger application is started. Backends can also be added dynamically through add_backend/2 . For example, to add multiple backends to your application, modify your configuration: config :logger , backends : [ :console , MyCustomBackend ] Multiple instances of the same backend can be specified by adding tuples in the format {BackendModuleName, :backend_name} : config :logger , backends : [ :console , { MyCustomBackend , :error_backend } , { MyCustomBackend , :debug_backend } ] config :logger , :error_backend , level : :error # other options config :logger , :debug_backend , level : :debug # other options Elixir custom backends Any developer can create their own Logger backend. Since Logger is an event manager powered by :gen_event , writing a new backend is a matter of creating an event handler, as described in the :gen_event documentation. From now on, we will be using the term &quot;event handler&quot; to refer to your custom backend, as we head into implementation details. Once the :logger application starts, it installs all event handlers listed under the :backends configuration into the Logger event manager. The event manager and all added event handlers are automatically supervised by Logger . Note that if a backend fails to start by returning {:error, :ignore} from its init/1 callback, then it's not added to the backends but nothing fails. If a backend fails to start by returning {:error, reason} from its init/1 callback, the :logger application will fail to start. Once initialized, the handler should be designed to handle the following events: {level, group_leader, {Logger, message, timestamp, metadata}} where: level is one of :debug , :info , :warn , or :error , as previously described (for compatibility with pre 1.10 backends the :notice will be translated to :info and all messages above :error will be translated to :error ) group_leader is the group leader of the process which logged the message {Logger, message, timestamp, metadata} is a tuple containing information about the logged message: the first element is always the atom Logger message is the actual message (as chardata) timestamp is the timestamp for when the message was logged, as a {{year, month, day}, {hour, minute, second, millisecond}} tuple metadata is a keyword list of metadata used when logging the message :flush It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example: def handle_event ( { _level , gl , { Logger , _ , _ , _ } } , state ) when node ( gl ) != node ( ) do { :ok , state } end In the case of the event :flush handlers should flush any pending data. This event is triggered by Logger.flush/0 . Furthermore, backends can be configured via the configure_backend/2 function which requires event handlers to handle calls of the following format: { :configure , options } where options is a keyword list. The result of the call is the result returned by configure_backend/2 . The recommended return value for successful configuration is :ok . For example: def handle_call ( { :configure , options } , state ) do new_state = reconfigure_state ( state , options ) { :ok , :ok , new_state } end It is recommended that backends support at least the following configuration options: :level - the logging level for that backend :format - the logging format for that backend :metadata - the metadata to include in that backend Check the Logger.Backends.Console implementation in Elixir's codebase for examples on how to handle the recommendations in this section and how to process the existing options. Erlang/OTP handlers While Elixir Logger provides backends, Erlang/OTP logger provides handlers. They represent the same concept: the ability to integrate into the logging system to handle each logged message/event. However, implementation-wise, they have the following differences: Elixir backends run in a separate process which comes with overload protection. However, because this process is a single GenEvent, any long running action should be avoided, as it can lead to bottlenecks in the system Erlang handlers run in the same process as the process logging the message/event. This gives developers more flexibility but they should avoid performing any long running action in such handlers, as it may slow down the action being executed considerably. At the moment, there is no built-in overload protection for Erlang handlers, so it is your responsibility to implement it The good news is that developers can use third-party implementations of both Elixir backends and Erlang handlers. Elixir backends can be configured directly under the :logger application in your config/config.exs : config :logger , backends : [ ACustomBackend ] Erlang/OTP handlers must be listed under your own application: config :my_app , :logger , [ { :handler , :name_of_the_handler , ACustomHandler , configuration = %{ } } ] And then, explicitly attached in your Application.start/2 callback: :logger . add_handlers ( :my_app ) Note we do not recommend configuring Erlang/OTP's logger directly under the :kernel application in your config/config.exs , like this: # Not recommended: config :kernel , :logger , ... This is because by the time Elixir starts, Erlang's kernel has already been started, which means the configuration above would have no effect.","ref":"Logger.html","title":"Logger","type":"module"},{"doc":"Adds a new backend. Adding a backend calls the init/1 function in that backend with the name of the backend as its argument. For example, calling Logger . add_backend ( MyBackend ) will call MyBackend.init(MyBackend) to initialize the new backend. If the backend's init/1 callback returns {:ok, _} , then this function returns {:ok, pid} . If the handler returns {:error, :ignore} from init/1 , this function still returns {:ok, pid} but the handler is not started. If the handler returns {:error, reason} from init/1 , this function returns {:error, {reason, info}} where info is more information on the backend that failed to start. Backends added by this function are not persisted. Therefore if the Logger application or supervision tree is restarted, the backend won't be available. If you need this guarantee, then configure the backend via the application environment: config :logger , :backends , [ MyBackend ] Options :flush - when true , guarantees all messages currently sent to Logger are processed before the backend is added Examples { :ok , _pid } = Logger . add_backend ( MyBackend , flush : true )","ref":"Logger.html#add_backend/2","title":"Logger.add_backend/2","type":"function"},{"doc":"Adds a new translator.","ref":"Logger.html#add_translator/1","title":"Logger.add_translator/1","type":"function"},{"doc":"Logs a alert message. Returns :ok . This is reported as &quot;error&quot; in Elixir's logger backends for backwards compatibility reasons. Examples Logging a message (string or iodata): Logger . alert ( &quot;this is a alert message&quot; ) Report message (maps or keywords): # as keyword list Logger . alert ( [ something : :reported , this : :alert ] ) # as map Logger . alert ( %{ something : :reported , this : :alert } )","ref":"Logger.html#alert/2","title":"Logger.alert/2","type":"macro"},{"doc":"Logs a message dynamically. Opposite to log/3 , debug/2 , info/2 , and friends, the arguments given to bare_log/3 are always evaluated. However, you can pass anonymous functions to bare_log/3 and they will only be evaluated if there is something to be logged.","ref":"Logger.html#bare_log/3","title":"Logger.bare_log/3","type":"function"},{"doc":"Compares log levels. Receives two log levels and compares the left level against the right level and returns: :lt if left is less than right :eq if left and right are equal :gt if left is greater than right Examples iex&gt; Logger . compare_levels ( :debug , :warning ) :lt iex&gt; Logger . compare_levels ( :error , :info ) :gt","ref":"Logger.html#compare_levels/2","title":"Logger.compare_levels/2","type":"function"},{"doc":"Configures the logger. See the &quot;Runtime Configuration&quot; section in the Logger module documentation for the available options. The changes done here are automatically persisted to the :logger application environment.","ref":"Logger.html#configure/1","title":"Logger.configure/1","type":"function"},{"doc":"Configures the given backend. The backend needs to be started and running in order to be configured at runtime.","ref":"Logger.html#configure_backend/2","title":"Logger.configure_backend/2","type":"function"},{"doc":"Logs a critical message. Returns :ok . This is reported as &quot;error&quot; in Elixir's logger backends for backwards compatibility reasons. Examples Logging a message (string or iodata): Logger . critical ( &quot;this is a critical message&quot; ) Report message (maps or keywords): # as keyword list Logger . critical ( [ something : :reported , this : :critical ] ) # as map Logger . critical ( %{ something : :reported , this : :critical } )","ref":"Logger.html#critical/2","title":"Logger.critical/2","type":"macro"},{"doc":"Logs a debug message. Returns :ok . Examples Logging a message (string or iodata): Logger . debug ( &quot;this is a debug message&quot; ) Report message (maps or keywords): # as keyword list Logger . debug ( [ something : :reported , this : :debug ] ) # as map Logger . debug ( %{ something : :reported , this : :debug } )","ref":"Logger.html#debug/2","title":"Logger.debug/2","type":"macro"},{"doc":"Deletes logging level for all modules to primary level","ref":"Logger.html#delete_all_module_levels/0","title":"Logger.delete_all_module_levels/0","type":"function"},{"doc":"Deletes logging level for given module to primary level.","ref":"Logger.html#delete_module_level/1","title":"Logger.delete_module_level/1","type":"function"},{"doc":"Disables logging for the current process. Currently the only accepted PID is self() .","ref":"Logger.html#disable/1","title":"Logger.disable/1","type":"function"},{"doc":"Logs a emergency message. Returns :ok . This is reported as &quot;error&quot; in Elixir's logger backends for backwards compatibility reasons. Examples Logging a message (string or iodata): Logger . emergency ( &quot;this is a emergency message&quot; ) Report message (maps or keywords): # as keyword list Logger . emergency ( [ something : :reported , this : :emergency ] ) # as map Logger . emergency ( %{ something : :reported , this : :emergency } )","ref":"Logger.html#emergency/2","title":"Logger.emergency/2","type":"macro"},{"doc":"Enables logging for the current process. Currently the only accepted PID is self() .","ref":"Logger.html#enable/1","title":"Logger.enable/1","type":"function"},{"doc":"Returns whether the logging is enabled for given process. Currently the only accepted PID is self() .","ref":"Logger.html#enabled?/1","title":"Logger.enabled?/1","type":"function"},{"doc":"Logs a error message. Returns :ok . Examples Logging a message (string or iodata): Logger . error ( &quot;this is a error message&quot; ) Report message (maps or keywords): # as keyword list Logger . error ( [ something : :reported , this : :error ] ) # as map Logger . error ( %{ something : :reported , this : :error } )","ref":"Logger.html#error/2","title":"Logger.error/2","type":"macro"},{"doc":"Flushes the logger. This guarantees all messages sent to Logger prior to this call will be processed. This is useful for testing and it should not be called in production code.","ref":"Logger.html#flush/0","title":"Logger.flush/0","type":"function"},{"doc":"Gets logging level for given module. Returned value will be the effective value used. If no value was set for given module, then it will not be present in the returned list.","ref":"Logger.html#get_module_level/1","title":"Logger.get_module_level/1","type":"function"},{"doc":"Logs a info message. Returns :ok . Examples Logging a message (string or iodata): Logger . info ( &quot;this is a info message&quot; ) Report message (maps or keywords): # as keyword list Logger . info ( [ something : :reported , this : :info ] ) # as map Logger . info ( %{ something : :reported , this : :info } )","ref":"Logger.html#info/2","title":"Logger.info/2","type":"macro"},{"doc":"Retrieves the Logger level. The Logger level can be changed via configure/1 .","ref":"Logger.html#level/0","title":"Logger.level/0","type":"function"},{"doc":"Logs a message with the given level . Returns :ok . The macros debug/2 , info/2 , notice/2 , warning/2 , error/2 , critical/2 , alert/2 , and emergency/2 are preferred over this macro as they can automatically eliminate the call to Logger altogether at compile time if desired (see the documentation for the Logger module).","ref":"Logger.html#log/3","title":"Logger.log/3","type":"macro"},{"doc":"Reads the current process metadata.","ref":"Logger.html#metadata/0","title":"Logger.metadata/0","type":"function"},{"doc":"Alters the current process metadata according the given keyword list. This function will merge the given keyword list into the existing metadata, with the exception of setting a key to nil , which will remove that key from the metadata.","ref":"Logger.html#metadata/1","title":"Logger.metadata/1","type":"function"},{"doc":"Logs a notice message. Returns :ok . This is reported as &quot;info&quot; in Elixir's logger backends for backwards compatibility reasons. Examples Logging a message (string or iodata): Logger . notice ( &quot;this is a notice message&quot; ) Report message (maps or keywords): # as keyword list Logger . notice ( [ something : :reported , this : :notice ] ) # as map Logger . notice ( %{ something : :reported , this : :notice } )","ref":"Logger.html#notice/2","title":"Logger.notice/2","type":"macro"},{"doc":"Puts logging level for given module. This will take priority over the primary level set, so it can be used to increase or decrease verbosity of some parts of the project. Example defmodule Foo do require Logger def log , do : Logger . debug ( &quot;foo&quot; ) end Logger . configure ( level : :error ) Logger . put_module_level ( Foo , :all ) Foo . log ( ) # This will print the message even if global level is :error","ref":"Logger.html#put_module_level/2","title":"Logger.put_module_level/2","type":"function"},{"doc":"Removes a backend. Options :flush - when true , guarantees all messages currently sent to Logger are processed before the backend is removed","ref":"Logger.html#remove_backend/2","title":"Logger.remove_backend/2","type":"function"},{"doc":"Removes a translator.","ref":"Logger.html#remove_translator/1","title":"Logger.remove_translator/1","type":"function"},{"doc":"Resets the current process metadata to the given keyword list.","ref":"Logger.html#reset_metadata/1","title":"Logger.reset_metadata/1","type":"function"},{"doc":"Logs a warning message. Returns :ok . This macro is deprecated in favour of warning/2 . Examples Logger . warn ( &quot;knob turned too far to the right&quot; )","ref":"Logger.html#warn/2","title":"Logger.warn/2","type":"macro"},{"doc":"Logs a warning message. Returns :ok . This is reported as &quot;warn&quot; in Elixir's logger backends for backwards compatibility reasons. Examples Logging a message (string or iodata): Logger . warning ( &quot;this is a warning message&quot; ) Report message (maps or keywords): # as keyword list Logger . warning ( [ something : :reported , this : :warning ] ) # as map Logger . warning ( %{ something : :reported , this : :warning } )","ref":"Logger.html#warning/2","title":"Logger.warning/2","type":"macro"},{"doc":"","ref":"Logger.html#t:backend/0","title":"Logger.backend/0","type":"type"},{"doc":"","ref":"Logger.html#t:level/0","title":"Logger.level/0","type":"type"},{"doc":"","ref":"Logger.html#t:message/0","title":"Logger.message/0","type":"type"},{"doc":"","ref":"Logger.html#t:metadata/0","title":"Logger.metadata/0","type":"type"},{"doc":"","ref":"Logger.html#t:report/0","title":"Logger.report/0","type":"type"},{"doc":"A logger backend that logs messages by printing them to the console. Options :level - the level to be logged by this backend. Note that messages are filtered by the general :level configuration for the :logger application first. :format - the format message used to print logs. Defaults to: &quot;\\n$time $metadata[$level] $levelpad$message\\n&quot; . It may also be a {module, function} tuple that is invoked with the log level, the message, the current timestamp and the metadata. :metadata - the metadata to be printed by $metadata . Defaults to an empty list (no metadata). Setting :metadata to :all prints all metadata. See the &quot;Metadata&quot; section for more information. :colors - a keyword list of coloring options. :device - the device to log error messages to. Defaults to :user but can be changed to something else such as :standard_error . :max_buffer - maximum events to buffer while waiting for a confirmation from the IO device (default: 32). Once the buffer is full, the backend will block until a confirmation is received. The supported keys in the :colors keyword list are: :enabled - boolean value that allows for switching the coloring on and off. Defaults to: IO.ANSI.enabled?/0 :debug - color for debug messages. Defaults to: :cyan :info - color for info and notice messages. Defaults to: :normal :warn - color for warning messages. Defaults to: :yellow :error - color for error and higher messages. Defaults to: :red See the IO.ANSI module for a list of colors and attributes. Here is an example of how to configure the :console backend in a config/config.exs file: config :logger , :console , format : &quot; \\n $time $metadata[$level] $levelpad$message \\n &quot; , metadata : [ :user_id ] Custom formatting The console backend allows you to customize the format of your log messages with the :format option. You may set :format to either a string or a {module, function} tuple if you wish to provide your own format function. Here is an example of how to configure the :console backend in a config/config.exs file: config :logger , :console , format : { MyConsoleLogger , :format } And here is an example of how you can define MyConsoleLogger.format/4 from the above configuration: defmodule MyConsoleLogger do def format ( level , message , timestamp , metadata ) do # Custom formatting logic... end end It is extremely important that the formatting function does not fail , as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a rescue and log a default message instead: defmodule MyConsoleLogger do def format ( level , message , timestamp , metadata ) do # Custom formatting logic... rescue _ -&gt; &quot;could not format: \#{ inspect ( { level , message , metadata } ) } &quot; end end The {module, function} will be invoked with four arguments: the log level: an atom the message: this is usually chardata, but in some cases it may contain invalid data. Since the formatting function should never fail, you need to prepare for the message being anything the current timestamp: a term of type Logger.Formatter.time/0 the metadata: a keyword list You can read more about formatting in Logger.Formatter , especially if you want to support custom formatting in a custom backend.","ref":"Logger.Backends.Console.html","title":"Logger.Backends.Console","type":"module"},{"doc":"Conveniences for formatting data for logs. This module allows developers to specify a string that serves as template for log messages, for example: $ time $ metadata [ $ level ] $ message \\ n Will print error messages as: 18 : 43 : 12.439 user_id = 13 [ error ] Hello \\ n The valid parameters you can use are: $time - the time the log message was sent $date - the date the log message was sent $message - the log message $level - the log level $node - the node that prints the message $metadata - user controlled data presented in &quot;key=val key2=val2 &quot; format $levelpad - sets to a single space if level is 4 characters long, otherwise set to the empty space. Used to align the message after level. Backends typically allow developers to supply such control strings via configuration files. This module provides compile/1 , which compiles the string into a format for fast operations at runtime and format/5 to format the compiled pattern into an actual IO data. Metadata Metadata to be sent to the logger can be read and written with the Logger.metadata/0 and Logger.metadata/1 functions. For example, you can set Logger.metadata([user_id: 13]) to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the $metadata value.","ref":"Logger.Formatter.html","title":"Logger.Formatter","type":"module"},{"doc":"Compiles a format string into a data structure that format/5 can handle. Check the module doc for documentation on the valid parameters that will be interpolated in the pattern. If you pass nil as the pattern, the pattern defaults to: &quot; \\n $time $metadata[$level] $levelpad$message \\n &quot; If you want to customize formatting through a custom formatter, you can pass a {module, function} tuple as the pattern . iex&gt; Logger.Formatter . compile ( &quot;$time $metadata [$level] $message \\n &quot; ) [ :time , &quot; &quot; , :metadata , &quot; [&quot; , :level , &quot;] &quot; , :message , &quot; \\n &quot; ] iex&gt; Logger.Formatter . compile ( { MyLoggerFormatter , :format } ) { MyLoggerFormatter , :format }","ref":"Logger.Formatter.html#compile/1","title":"Logger.Formatter.compile/1","type":"function"},{"doc":"Takes a compiled format and injects the level, timestamp, message, and metadata keyword list and returns a properly formatted string. Examples iex&gt; pattern = Logger.Formatter . compile ( &quot;[$level] $message&quot; ) iex&gt; timestamp = { { 1977 , 01 , 28 } , { 13 , 29 , 00 , 000 } } iex&gt; formatted = Logger.Formatter . format ( pattern , :info , &quot;hello&quot; , timestamp , [ ] ) iex&gt; IO . chardata_to_string ( formatted ) &quot;[info] hello&quot;","ref":"Logger.Formatter.html#format/5","title":"Logger.Formatter.format/5","type":"function"},{"doc":"Formats date as chardata.","ref":"Logger.Formatter.html#format_date/1","title":"Logger.Formatter.format_date/1","type":"function"},{"doc":"Formats time as chardata.","ref":"Logger.Formatter.html#format_time/1","title":"Logger.Formatter.format_time/1","type":"function"},{"doc":"Prunes invalid Unicode code points from lists and invalid UTF-8 bytes. Typically called after formatting when the data cannot be printed.","ref":"Logger.Formatter.html#prune/1","title":"Logger.Formatter.prune/1","type":"function"},{"doc":"","ref":"Logger.Formatter.html#t:pattern/0","title":"Logger.Formatter.pattern/0","type":"type"},{"doc":"","ref":"Logger.Formatter.html#t:time/0","title":"Logger.Formatter.time/0","type":"type"},{"doc":"Default translation for Erlang log messages. Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator. A translator is simply a tuple containing a module and a function that can be added and removed via the Logger.add_translator/1 and Logger.remove_translator/1 functions and is invoked for every Erlang message above the minimum log level with four arguments: min_level - the current Logger level level - the level of the message being translated kind - if the message is a :report or :format message - the message to format. If it is :report , it is a tuple with {report_type, report_data} , if it is :format , it is a tuple with {format_message, format_args} . The function must return: {:ok, chardata, metadata} - if the message translation with its metadata {:ok, chardata} - the translated message :skip - if the message is not meant to be translated nor logged :none - if there is no translation, which triggers the next translator See the function translate/4 in this module for an example implementation and the default messages translated by Logger.","ref":"Logger.Translator.html","title":"Logger.Translator","type":"module"},{"doc":"Built-in translation function.","ref":"Logger.Translator.html#translate/4","title":"Logger.Translator.translate/4","type":"function"}]