searchNodes=[{"doc":"Elixir's interactive shell. Some of the functionalities described here will not be available depending on your terminal. In particular, if you get a message saying that the smart terminal could not be run, some of the features described here won't work. Helpers IEx provides a bunch of helpers. They can be accessed by typing h() into the shell or as a documentation for the IEx.Helpers module. Autocomplete To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example: Enum . A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with @doc false , @impl true , or functions that aren't explicitly documented and where the function name is in the form of __foo__ . Autocomplete may not be available on some Windows shells. You may need to pass the --werl option when starting IEx, as in iex --werl for it to work. --werl may be permanently enabled by setting the IEX_WITH_WERL environment variable. Coloring Coloring is enabled by default on most Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command: reg add HKCU \\ Console / v VirtualTerminalLevel / t REG_DWORD / d 1 After running the command above, you must restart your current console. Shell history It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx: iex -- erl &quot;-kernel shell_history enabled&quot; If you would rather enable it on your system as a whole, you can use the ERL_AFLAGS environment variable and make sure that it is set accordingly on your terminal/shell configuration. On Unix-like / Bash: export ERL_AFLAGS = &quot;-kernel shell_history enabled&quot; On Windows: set ERL_AFLAGS &quot;-kernel shell_history enabled&quot; On Windows 10 / PowerShell: $ env :ERL_AFLAGS = &quot;-kernel shell_history enabled&quot; Expressions in IEx As an interactive shell, IEx evaluates expressions. This has some interesting consequences that are worth discussing. The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell. Second, IEx allows you to break an expression into many lines, since this is common in Elixir. For example: iex(1)&gt; &quot;ab ...(1)&gt; c&quot; &quot;ab \\n c&quot; In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell. For such cases, there is a special break-trigger ( #iex:break ) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state: iex(1)&gt; [ &quot;ab ...(1)&gt; c&quot; ...(1)&gt; &quot; ...(1)&gt; ] ...(1)&gt; #iex:break ** (TokenMissingError) iex:1: incomplete expression Pasting multiline expressions into IEx IEx evaluates its input line by line in an eager fashion. If at the end of a line the code seen so far is a complete expression, IEx will evaluate it at that point. iex(1)&gt; [ 1 , [ 2 ] , 3 ] [ 1 , [ 2 ] , 3 ] To prevent this behaviour breaking valid code where the subsequent line begins with a binary operator, such as |&gt;/2 or ++/2 , IEx automatically treats such lines as if they were prepended with IEx.Helpers.v/0 , which returns the value of the previous expression, if available. iex(1)&gt; [ 1 , [ 2 ] , 3 ] [ 1 , [ 2 ] , 3 ] iex(2)&gt; |&gt; List . flatten ( ) [ 1 , 2 , 3 ] The above is equivalent to: iex(1)&gt; [ 1 , [ 2 ] , 3 ] [ 1 , [ 2 ] , 3 ] iex(2)&gt; v ( ) |&gt; List . flatten ( ) [ 1 , 2 , 3 ] If there are no previous expressions in the history, the pipe operator will fail: iex(1)&gt; |&gt; List . flatten ( ) ** (RuntimeError) v(-1) is out of bounds Note however the above does not work for +/2 and -/2 , as they are ambiguous with the unary +/1 and -/1 : iex(1)&gt; 1 1 iex(2)&gt; + 2 2 The BREAK menu Inside IEx, hitting Ctrl+C will open up the BREAK menu. In this menu you can quit the shell, see process and ETS tables information and much more. Exiting the shell There are a few ways to quit the IEx shell: via the BREAK menu (available via Ctrl+C ) by typing q , pressing enter by hitting Ctrl+C , Ctrl+C by hitting Ctrl+\\ If you are connected to remote shell, it remains alive after disconnection. Prying and breakpoints IEx also has the ability to set breakpoints on Elixir code and &quot;pry&quot; into running processes. This allows the developer to have an IEx session run inside a given function. IEx.pry/0 can be used when you are able to modify the source code directly and recompile it: def my_fun ( arg1 , arg2 ) do require IEx ; IEx . pry ( ) ... implementation ... end When the code is executed, it will ask you for permission to be introspected. Alternatively, you can use IEx.break!/4 to setup a breakpoint on a given module, function and arity you have no control of. While IEx.break!/4 is more flexible, it does not contain information about imports and aliases from the source code. The User switch command Besides the BREAK menu, one can type Ctrl+G to get to the User switch command menu. When reached, you can type h to get more information. In this menu, developers are able to start new shells and alternate between them. Let's give it a try: User switch command -- &gt; s &#39;Elixir.IEx&#39; -- &gt; c The command above will start a new shell and connect to it. Create a new variable called hello and assign some value to it: hello = :world Now, let's roll back to the first shell: User switch command -- &gt; c 1 Now, try to access the hello variable again: hello ** (UndefinedFunctionError) undefined function hello/0 The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one. The User switch command can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression: User switch command -- &gt; i -- &gt; c The User switch command menu also allows developers to connect to remote shells using the r command. A topic which we will discuss next. Remote shells IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to. Let's give it a try. First, start a new shell: $ iex -- sname foo iex ( foo @ HOST ) 1 &gt; The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the node/0 function: iex ( foo @ HOST ) 1 &gt; node ( ) :&quot;foo@HOST&quot; iex ( foo @ HOST ) 2 &gt; Node . alive? ( ) true For fun, let's define a simple module in this shell too: iex ( foo @ HOST ) 3 &gt; defmodule Hello do ... ( foo @ HOST ) 3 &gt; def world , do : &quot;it works!&quot; ... ( foo @ HOST ) 3 &gt; end Now, let's start another shell, giving it a name as well: $ iex -- sname bar iex ( bar @ HOST ) 1 &gt; If we try to dispatch to Hello.world , it won't be available as it was defined only in the other shell: iex ( bar @ HOST ) 1 &gt; Hello . world ( ) ** (UndefinedFunctionError) undefined function Hello.world/0 However, we can connect to the other shell remotely. Open up the User switch command prompt (Ctrl+G) and type: User switch command -- &gt; r &#39;foo@HOST&#39; &#39;Elixir.IEx&#39; -- &gt; c Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there: iex ( foo @ HOST ) 1 &gt; Hello . world ( ) &quot;it works!&quot; In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well: $ iex -- sname baz -- remsh foo @ HOST Where &quot;remsh&quot; means &quot;remote shell&quot;. In general, Elixir supports: remsh from an Elixir node to an Elixir node remsh from a plain Erlang node to an Elixir node (through the ^G menu) remsh from an Elixir node to a plain Erlang node (and get an erl shell there) Connecting an Elixir shell to a remote node without Elixir is not supported. The .iex.exs file When starting, IEx looks for a local .iex.exs file (located in the current working directory), then a global one (located at ~/.iex.exs ) and loads the first one it finds (if any). Note the location of the .iex.exs files, both in the current directory and the global one, are taken relative to the user that started the application, not to the user that is connecting to the node in case of remote IEx connections. The code in the loaded .iex.exs file is evaluated in the shell's context. For instance, any modules that are loaded or variables that are bound in the .iex.exs file will be available in the shell after it has booted. Take the following .iex.exs file: # Load another &quot;.iex.exs&quot; file import_file ( &quot;~/.iex.exs&quot; ) # Import some module from lib that may not yet have been defined import_if_available ( MyApp.Mod ) # Print something before the shell starts IO . puts ( &quot;hello world&quot; ) # Bind a variable that&#39;ll be accessible in the shell value = 13 Running IEx in the directory where the above .iex.exs file is located results in: $ iex Erlang / OTP 21 [ ... ] hello world Interactive Elixir - press Ctrl + C to exit ( type h ( ) ENTER for help ) iex(1)&gt; value 13 It is possible to load another file by supplying the --dot-iex option to IEx. See iex --help . Configuring the shell There are a number of customization options provided by IEx. Take a look at the docs for the IEx.configure/1 function by typing h IEx.configure/1 . Those options can be configured in your project configuration file or globally by calling IEx.configure/1 from your ~/.iex.exs file. For example: # .iex.exs IEx . configure ( inspect : [ limit : 3 ] ) Now run the shell: $ iex Erlang / OTP 21 [ ... ] Interactive Elixir - press Ctrl + C to exit ( type h ( ) ENTER for help ) iex(1)&gt; [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , ... ]","ref":"IEx.html","title":"IEx","type":"module"},{"doc":"Returns registered after_spawn callbacks.","ref":"IEx.html#after_spawn/0","title":"IEx.after_spawn/0","type":"function"},{"doc":"Registers a function to be invoked after the IEx process is spawned.","ref":"IEx.html#after_spawn/1","title":"IEx.after_spawn/1","type":"function"},{"doc":"Macro-based shortcut for IEx.break!/4 .","ref":"IEx.html#break!/2","title":"IEx.break!/2","type":"macro"},{"doc":"Sets up a breakpoint in module , function and arity with the given number of stops . This function will instrument the given module and load a new version in memory with breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost. When a breakpoint is reached, IEx will ask if you want to pry the given function and arity. In other words, this works similar to IEx.pry/0 as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from IEx.pry/0 , aliases and imports from the source code won't be available in the shell. IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as IEx.Helpers.breaks/0 , but remember it can be called directly as breaks() inside IEx. They are: IEx.Helpers.break!/2 - sets up a breakpoint for a given Mod.fun/arity IEx.Helpers.break!/4 - sets up a breakpoint for the given module, function, arity IEx.Helpers.breaks/0 - prints all breakpoints and their IDs IEx.Helpers.continue/0 - continues until the next breakpoint in the same shell IEx.Helpers.open/0 - opens editor on the current breakpoint IEx.Helpers.remove_breaks/0 - removes all breakpoints in all modules IEx.Helpers.remove_breaks/1 - removes all breakpoints in a given module IEx.Helpers.reset_break/1 - sets the number of stops on the given ID to zero IEx.Helpers.reset_break/3 - sets the number of stops on the given module, function, arity to zero IEx.Helpers.respawn/0 - starts a new shell (breakpoints will ask for permission once more) IEx.Helpers.whereami/1 - shows the current location By default, the number of stops in a breakpoint is 1. Any follow-up call won't stop the code execution unless another breakpoint is set. Alternatively, the number of stops can be increased by passing the stops argument. IEx.Helpers.reset_break/1 and IEx.Helpers.reset_break/3 can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling IEx.Helpers.remove_breaks/1 and on all modules by calling IEx.Helpers.remove_breaks/0 . To exit a breakpoint, the developer can either invoke continue() , which will block the shell until the next breakpoint is found or the process terminates, or invoke respawn() , which starts a new IEx shell, freeing up the pried one. Examples The examples below will use break! , assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name IEx.break! . The following sets up a breakpoint on URI.decode_query/2 : break! URI , :decode_query , 2 This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times: break! URI , :decode_query , 2 , 10 IEx.break!/2 is a convenience macro that allows breakpoints to be given in the Mod.fun/arity format: break! URI . decode_query / 2 Or to set a breakpoint that will stop 10 times: break! URI . decode_query / 2 , 10 This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint. Patterns and guards IEx.break!/2 allows patterns to be given, triggering the breakpoint only in some occasions. For example, to trigger the breakpoint only when the first argument is the &quot;foo=bar&quot; string: break! URI . decode_query ( &quot;foo=bar&quot; , _ ) Or to trigger it whenever the second argument is a map with more than one element: break! URI . decode_query ( _ , map ) when map_size ( map ) &gt; 0 Only a single break point can be set per function. So if you call IEx.break! multiple times with different patterns, only the last pattern is kept. Note that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern: break! MyModule . some_macro ( pid ) when pid == self ( ) This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as MyModule.some_macro(self()) , the macro will receive the AST representing the self() call, and not the PID itself. Breaks and mix test To use IEx.break!/4 during tests, you need to run mix inside the iex command and pass the --trace to mix test to avoid running into timeouts: iex - S mix test -- trace iex - S mix test path / to / file :line -- trace","ref":"IEx.html#break!/4","title":"IEx.break!/4","type":"function"},{"doc":"Returns string escaped using the specified color . ANSI escapes in string are not processed in any way.","ref":"IEx.html#color/2","title":"IEx.color/2","type":"function"},{"doc":"Returns IEx configuration.","ref":"IEx.html#configuration/0","title":"IEx.configuration/0","type":"function"},{"doc":"Configures IEx. The supported options are: :colors :inspect :width :history_size :default_prompt :continuation_prompt :alive_prompt :alive_continuation_prompt :parser They are discussed individually in the sections below. Colors A keyword list that encapsulates all color settings used by the shell. See documentation for the IO.ANSI module for the list of supported colors and attributes. List of supported keys in the keyword list: :enabled - boolean value that allows for switching the coloring on and off :eval_result - color for an expression's resulting value :eval_info - ... various informational messages :eval_error - ... error messages :eval_interrupt - ... interrupt messages :stack_info - ... the stacktrace color :blame_diff - ... when blaming source with no match :ls_directory - ... for directory entries (ls helper) :ls_device - ... device entries (ls helper) When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Colors for this can be configured via: :doc_code - the attributes for code blocks (cyan, bright) :doc_inline_code - inline code (cyan) :doc_headings - h1 and h2 (yellow, bright) :doc_title - the overall heading for the output (reverse, yellow, bright) :doc_bold - (bright) :doc_underline - (underline) IEx will also color inspected expressions using the :syntax_colors option. Such can be disabled with: IEx . configure ( colors : [ syntax_colors : false ] ) You can also configure the syntax colors, however, as desired: IEx . configure ( colors : [ syntax_colors : [ atom : :red ] ] ) Configuration for most built-in data types are supported: :atom , :string , :binary , :list , :number , :boolean , :nil , and others. The default is: [ number : :magenta , atom : :cyan , string : :green , boolean : :magenta , nil : :magenta ] Inspect A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries. To show all entries, configure the limit to :infinity : IEx . configure ( inspect : [ limit : :infinity ] ) See Inspect.Opts for the full list of options. Width An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of :io.columns . This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen. History size Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited. Prompt This is an option determining the prompt displayed to the user when awaiting input. The value is a keyword list with two possible keys representing prompt types: :default_prompt - used when Node.alive?/0 returns false :continuation_prompt - used when Node.alive?/0 returns false and more input is expected :alive_prompt - used when Node.alive?/0 returns true :alive_continuation_prompt - used when Node.alive?/0 returns true and more input is expected The following values in the prompt string will be replaced appropriately: %counter - the index of the history %prefix - a prefix given by IEx.Server %node - the name of the local node Parser This is an option determining the parser to use for IEx. The parser is a &quot;mfargs&quot;, which is a tuple with three elements: the module name, the function name, and extra arguments to be appended. The parser receives at least three arguments, the current input as a string, the parsing options as a keyword list, and the buffer as a string. It must return {:ok, expr, buffer} or {:incomplete, buffer} . If the parser raises, the buffer is reset to an empty string.","ref":"IEx.html#configure/1","title":"IEx.configure/1","type":"function"},{"doc":"Returns the options used for inspecting.","ref":"IEx.html#inspect_opts/0","title":"IEx.inspect_opts/0","type":"function"},{"doc":"Pries into the process environment. This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling IEx.Helpers.respawn/0 , which starts a new IEx shell, freeing up the pried one. When a process is pried, all code runs inside IEx and has access to all imports and aliases from the original code. However, the code is evaluated and therefore cannot access private functions of the module being pried. Module functions still need to be accessed via Mod.fun(args) . Alternatively, you can use IEx.break!/4 to setup a breakpoint on a given module, function and arity you have no control of. While IEx.break!/4 is more flexible, it does not contain information about imports and aliases from the source code. Examples Let's suppose you want to investigate what is happening with some particular function. By invoking IEx.pry/0 from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example: import Enum , only : [ map : 2 ] defmodule Adder do def add ( a , b ) do c = a + b require IEx ; IEx . pry ( ) end end When invoking Adder.add(1, 2) , you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above: pry ( 1 ) &gt; map ( [ a , b , c ] , &amp; IO . inspect ( &amp;1 ) ) 1 2 3 Keep in mind that IEx.pry/0 runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling respawn/0 , which starts a new IEx evaluation cycle, letting this one go: pry ( 2 ) &gt; respawn ( ) true Interactive Elixir - press Ctrl + C to exit ( type h ( ) ENTER for help ) Setting variables or importing modules in IEx does not affect the caller's environment. However, sending and receiving messages will change the process state. Pry and macros When setting up Pry inside a code defined by macros, such as: defmacro __using__ ( _ ) do quote do def add ( a , b ) do c = a + b require IEx ; IEx . pry ( ) end end end The variables defined inside quote won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available. Pry and mix test To use IEx.pry/0 during tests, you need to run mix inside the iex command and pass the --trace to mix test to avoid running into timeouts: iex - S mix test -- trace iex - S mix test path / to / file :line -- trace","ref":"IEx.html#pry/0","title":"IEx.pry/0","type":"macro"},{"doc":"Returns true if IEx was started, false otherwise.","ref":"IEx.html#started?/0","title":"IEx.started?/0","type":"function"},{"doc":"Returns the IEx width for printing. Used by helpers and it has a default maximum cap of 80 chars.","ref":"IEx.html#width/0","title":"IEx.width/0","type":"function"},{"doc":"Welcome to Interactive Elixir. You are currently seeing the documentation for the module IEx.Helpers which provides many helpers to make Elixir's shell more joyful to work with. This message was triggered by invoking the helper h() , usually referred to as h/0 (since it expects 0 arguments). You can use the h/1 function to invoke the documentation for any Elixir module or function: iex&gt; h ( Enum ) iex&gt; h ( Enum . map ) iex&gt; h ( Enum . reverse / 1 ) You can also use the i/1 function to introspect any value you have in the shell: iex&gt; i ( &quot;hello&quot; ) There are many other helpers available, here are some examples: b/1 - prints callbacks info and docs for a given module c/1 - compiles a file c/2 - compiles a file and writes bytecode to the given path cd/1 - changes the current directory clear/0 - clears the screen exports/1 - shows all exports (functions + macros) in a module flush/0 - flushes all messages sent to the shell h/0 - prints this help message h/1 - prints help for the given module, function or macro i/0 - prints information about the last value i/1 - prints information about the given term ls/0 - lists the contents of the current directory ls/1 - lists the contents of the specified directory open/1 - opens the source for the given module or function in your editor pid/1 - creates a PID from a string pid/3 - creates a PID with the 3 integer arguments passed port/1 - creates a port from a string port/2 - creates a port with the 2 non-negative integers passed ref/1 - creates a reference from a string ref/4 - creates a reference with the 4 integer arguments passed pwd/0 - prints the current working directory r/1 - recompiles the given module's source file recompile/0 - recompiles the current project runtime_info/0 - prints runtime info (versions, memory usage, stats) v/0 - retrieves the last value from the history v/1 - retrieves the nth value from the history Help for all of those functions can be consulted directly from the command line using the h/1 helper itself. Try: iex&gt; h ( v / 0 ) To list all IEx helpers available, which is effectively all exports (functions and macros) in the IEx.Helpers module: iex&gt; exports ( IEx.Helpers ) This module also includes helpers for debugging purposes, see IEx.break!/4 for more information. To learn more about IEx as a whole, type h(IEx) .","ref":"IEx.Helpers.html","title":"IEx.Helpers","type":"module"},{"doc":"Prints the documentation for the given callback function. It also accepts single module argument to list all available behaviour callbacks. Examples iex&gt; b ( Mix.Task . run / 1 ) iex&gt; b ( Mix.Task . run ) iex&gt; b ( GenServer )","ref":"IEx.Helpers.html#b/1","title":"IEx.Helpers.b/1","type":"macro"},{"doc":"Macro-based shortcut for IEx.break!/4 .","ref":"IEx.Helpers.html#break!/2","title":"IEx.Helpers.break!/2","type":"macro"},{"doc":"Sets up a breakpoint in module , function and arity with the given number of stops . See IEx.break!/4 for a complete description of breakpoints in IEx.","ref":"IEx.Helpers.html#break!/4","title":"IEx.Helpers.break!/4","type":"function"},{"doc":"Prints all breakpoints to the terminal.","ref":"IEx.Helpers.html#breaks/0","title":"IEx.Helpers.breaks/0","type":"function"},{"doc":"Compiles the given files. It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given. It returns the names of the compiled modules. If you want to recompile an existing module, check r/1 instead. Examples In the example below, we pass a directory to where the c/2 function will write the compiled .beam files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems: iex&gt; c ( [ &quot;foo.ex&quot; , &quot;bar.ex&quot; ] , &quot;ebin&quot; ) [ Foo , Bar ] When compiling one file, there is no need to wrap it in a list: iex&gt; c ( &quot;baz.ex&quot; ) [ Baz ]","ref":"IEx.Helpers.html#c/2","title":"IEx.Helpers.c/2","type":"function"},{"doc":"Changes the current working directory to the given path.","ref":"IEx.Helpers.html#cd/1","title":"IEx.Helpers.cd/1","type":"function"},{"doc":"Clears the console screen. This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.","ref":"IEx.Helpers.html#clear/0","title":"IEx.Helpers.clear/0","type":"function"},{"doc":"Continues execution of the current process. This is usually called by sessions started with IEx.pry/0 or IEx.break!/4 . This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry. If the running process terminates, a new IEx session is started. While the process executes, the user will no longer have control of the shell. If you would rather start a new shell, use respawn/0 instead.","ref":"IEx.Helpers.html#continue/0","title":"IEx.Helpers.continue/0","type":"function"},{"doc":"Prints a list of all the functions and macros exported by the given module.","ref":"IEx.Helpers.html#exports/1","title":"IEx.Helpers.exports/1","type":"function"},{"doc":"Clears out all messages sent to the shell's inbox and prints them out.","ref":"IEx.Helpers.html#flush/0","title":"IEx.Helpers.flush/0","type":"function"},{"doc":"Prints the documentation for IEx.Helpers .","ref":"IEx.Helpers.html#h/0","title":"IEx.Helpers.h/0","type":"function"},{"doc":"Prints the documentation for the given module or for the given function/arity pair. Examples iex&gt; h ( Enum ) It also accepts functions in the format function/arity and module.function/arity , for example: iex&gt; h ( receive / 1 ) iex&gt; h ( Enum . all? / 2 ) iex&gt; h ( Enum . all? )","ref":"IEx.Helpers.html#h/1","title":"IEx.Helpers.h/1","type":"macro"},{"doc":"Prints information about the data type of any given term. If no argument is given, the value of the previous expression is used. Examples iex&gt; i ( 1 . . 5 ) Will print: Term 1 . . 5 Data type Range Description This is a struct . Structs are maps with a __struct__ key . Reference modules Range , Map","ref":"IEx.Helpers.html#i/1","title":"IEx.Helpers.i/1","type":"function"},{"doc":"Injects the contents of the file at path as if it was typed into the shell. This would be the equivalent of getting all of the file contents and packing it all into a single line in IEx and executing it. By default, the contents of a .iex.exs file in the same directory as you are starting IEx are automatically imported. See the section for &quot;.iex.exs&quot; in the IEx module docs for more information. path has to be a literal string and is automatically expanded via Path.expand/1 . Examples # ~/file.exs value = 13 # in the shell iex(1)&gt; import_file ( &quot;~/file.exs&quot; ) 13 iex(2)&gt; value 13","ref":"IEx.Helpers.html#import_file/1","title":"IEx.Helpers.import_file/1","type":"macro"},{"doc":"Similar to import_file but only imports the file if it is available. By default, import_file/1 fails when the given file does not exist. However, since import_file/1 is expanded at compile-time, it's not possible to conditionally import a file since the macro is always expanded: # This raises a File.Error if ~/.iex.exs doesn&#39;t exist. if &quot;~/.iex.exs&quot; |&gt; Path . expand ( ) |&gt; File . exists? ( ) do import_file ( &quot;~/.iex.exs&quot; ) end This macro addresses this issue by checking if the file exists or not in behalf of the user.","ref":"IEx.Helpers.html#import_file_if_available/1","title":"IEx.Helpers.import_file_if_available/1","type":"macro"},{"doc":"Calls import/2 with the given arguments, but only if the module is available. This lets you put imports in .iex.exs files (including ~/.iex.exs ) without getting compile errors if you open a console where the module is not available. Example # In ~/.iex.exs import_if_available ( Ecto.Query )","ref":"IEx.Helpers.html#import_if_available/2","title":"IEx.Helpers.import_if_available/2","type":"macro"},{"doc":"Loads the given module's BEAM code (and ensures any previous old version was properly purged before). This function is useful when you know the bytecode for module has been updated in the file system and you want to tell the VM to load it.","ref":"IEx.Helpers.html#l/1","title":"IEx.Helpers.l/1","type":"function"},{"doc":"Prints a list of the given directory's contents. If path points to a file, prints its full path.","ref":"IEx.Helpers.html#ls/1","title":"IEx.Helpers.ls/1","type":"function"},{"doc":"Deploys a given module's BEAM code to a list of nodes. This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes. The node list defaults to a list of all connected nodes. Returns {:error, :nofile} if the object code (i.e. &quot;.beam&quot; file) for the module could not be found locally. Examples iex&gt; nl ( HelloWorld ) { :ok , [ { :node1@easthost , :loaded , HelloWorld } , { :node1@westhost , :loaded , HelloWorld } ] } iex&gt; nl ( NoSuchModuleExists ) { :error , :nofile }","ref":"IEx.Helpers.html#nl/2","title":"IEx.Helpers.nl/2","type":"function"},{"doc":"Opens the current prying location. This command only works inside a pry session started manually via IEx.pry/0 or a breakpoint set via IEx.break!/4 . Calling this function during a regular IEx session will print an error. Keep in mind the open/0 location may not exist when prying precompiled source code, such as Elixir itself. For more information and to open any module or function, see open/1 .","ref":"IEx.Helpers.html#open/0","title":"IEx.Helpers.open/0","type":"function"},{"doc":"Opens the given module , module.function/arity , or {file, line} . This function uses the ELIXIR_EDITOR environment variable and falls back to EDITOR if the former is not available. By default, it attempts to open the file and line using the file:line notation. For example, if your editor is called subl , it will open the file as: subl path / to / file :line It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window. Custom editors are supported by using the __FILE__ and __LINE__ notations, for example: ELIXIR_EDITOR = &quot;my_editor +__LINE__ __FILE__&quot; and Elixir will properly interpolate values. Since this function prints the result returned by the editor, ELIXIR_EDITOR can be set &quot;echo&quot; if you prefer to display the location rather than opening it. Keep in mind the location may not exist when opening precompiled source code. Examples iex&gt; open ( MyApp ) iex&gt; open ( MyApp . fun / 2 ) iex&gt; open ( { &quot;path/to/file&quot; , 1 } )","ref":"IEx.Helpers.html#open/1","title":"IEx.Helpers.open/1","type":"macro"},{"doc":"Creates a PID from string . Examples iex&gt; pid ( &quot;0.21.32&quot; ) # PID &lt; 0 . 21 . 32 &gt;","ref":"IEx.Helpers.html#pid/1","title":"IEx.Helpers.pid/1","type":"function"},{"doc":"Creates a PID with 3 non-negative integers passed as arguments to the function. Examples iex&gt; pid ( 0 , 21 , 32 ) # PID &lt; 0 . 21 . 32 &gt; iex&gt; pid ( 0 , 64 , 2048 ) # PID &lt; 0 . 64 . 2048 &gt;","ref":"IEx.Helpers.html#pid/3","title":"IEx.Helpers.pid/3","type":"function"},{"doc":"Creates a Port from string . Examples iex&gt; port ( &quot;0.4&quot; ) # Port &lt; 0.4 &gt;","ref":"IEx.Helpers.html#port/1","title":"IEx.Helpers.port/1","type":"function"},{"doc":"Creates a Port from two non-negative integers. Examples iex&gt; port ( 0 , 8080 ) # Port &lt; 0.8080 &gt; iex&gt; port ( 0 , 443 ) # Port &lt; 0.443 &gt;","ref":"IEx.Helpers.html#port/2","title":"IEx.Helpers.port/2","type":"function"},{"doc":"Prints the current working directory.","ref":"IEx.Helpers.html#pwd/0","title":"IEx.Helpers.pwd/0","type":"function"},{"doc":"Recompiles and reloads the given module . Please note that all the modules defined in the same file as module are recompiled and reloaded. This function is meant to be used for development and debugging purposes. Do not depend on it in production code. In-memory reloading When we reload the module in IEx, we recompile the module source code, updating its contents in memory. The original .beam file in disk, probably the one where the first definition of the module came from, does not change at all. Since typespecs and docs are loaded from the .beam file (they are not loaded in memory with the module because there is no need for them to be in memory), they are not reloaded when you reload the module.","ref":"IEx.Helpers.html#r/1","title":"IEx.Helpers.r/1","type":"function"},{"doc":"Recompiles the current Mix application. This helper only works when IEx is started with a Mix project, for example, iex -S mix . Note this function simply recompiles Elixir modules, without reloading configuration and without restarting applications. Therefore, any long running process may crash on recompilation, as changed modules will be temporarily removed and recompiled, without going through the proper code change callback. If you want to reload a single module, consider using r(ModuleName) instead. This function is meant to be used for development and debugging purposes. Do not depend on it in production code. Options :force - when true , forces the application to recompile","ref":"IEx.Helpers.html#recompile/1","title":"IEx.Helpers.recompile/1","type":"function"},{"doc":"Creates a Reference from string . Examples iex&gt; ref ( &quot;0.1.2.3&quot; ) # Reference &lt; 0.1 . 2.3 &gt;","ref":"IEx.Helpers.html#ref/1","title":"IEx.Helpers.ref/1","type":"function"},{"doc":"Creates a Reference from its 4 non-negative integers components. Examples iex&gt; ref ( 0 , 1 , 2 , 3 ) # Reference &lt; 0.1 . 2.3 &gt;","ref":"IEx.Helpers.html#ref/4","title":"IEx.Helpers.ref/4","type":"function"},{"doc":"Removes all breakpoints and instrumentation from all modules.","ref":"IEx.Helpers.html#remove_breaks/0","title":"IEx.Helpers.remove_breaks/0","type":"function"},{"doc":"Removes all breakpoints and instrumentation from module .","ref":"IEx.Helpers.html#remove_breaks/1","title":"IEx.Helpers.remove_breaks/1","type":"function"},{"doc":"Sets the number of pending stops in the breakpoint with the given id to zero. Returns :ok if there is such breakpoint ID. :not_found otherwise. Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use remove_breaks/1 instead.","ref":"IEx.Helpers.html#reset_break/1","title":"IEx.Helpers.reset_break/1","type":"function"},{"doc":"Sets the number of pending stops in the given module, function and arity to zero. If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns :not_found . Otherwise it returns :ok . Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use remove_breaks/1 instead.","ref":"IEx.Helpers.html#reset_break/3","title":"IEx.Helpers.reset_break/3","type":"function"},{"doc":"Respawns the current shell by starting a new shell process.","ref":"IEx.Helpers.html#respawn/0","title":"IEx.Helpers.respawn/0","type":"function"},{"doc":"Prints VM/runtime information such as versions, memory usage and statistics. Additional topics are available via runtime_info/1 . For more metrics, info, and debugging facilities, see the Recon project.","ref":"IEx.Helpers.html#runtime_info/0","title":"IEx.Helpers.runtime_info/0","type":"function"},{"doc":"Just like runtime_info/0 , except accepts topic or a list of topics. For example, topic :applications will list the applications loaded.","ref":"IEx.Helpers.html#runtime_info/1","title":"IEx.Helpers.runtime_info/1","type":"function"},{"doc":"Prints the types for the given module or for the given function/arity pair. Examples iex&gt; t ( Enum ) @type t ( ) :: Enumerable . t ( ) @type acc ( ) :: any ( ) @type element ( ) :: any ( ) @type index ( ) :: integer ( ) @type default ( ) :: any ( ) iex&gt; t ( Enum . t / 0 ) @type t ( ) :: Enumerable . t ( ) iex&gt; t ( Enum . t ) @type t ( ) :: Enumerable . t ( )","ref":"IEx.Helpers.html#t/1","title":"IEx.Helpers.t/1","type":"macro"},{"doc":"Calls use/2 with the given arguments, but only if the module is available. This lets you use the module in .iex.exs files (including ~/.iex.exs ) without getting compile errors if you open a console where the module is not available. Example # In ~/.iex.exs use_if_available ( Phoenix.HTML )","ref":"IEx.Helpers.html#use_if_available/2","title":"IEx.Helpers.use_if_available/2","type":"macro"},{"doc":"Returns the value of the n th expression in the history. n can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, v(-2) returns the value of the expression evaluated before the last evaluated expression. In particular, v(-1) returns the result of the last evaluated expression and v() does the same. Examples iex(1)&gt; &quot;hello&quot; &lt;&gt; &quot; world&quot; &quot;hello world&quot; iex(2)&gt; 40 + 2 42 iex(3)&gt; v ( - 2 ) &quot;hello world&quot; iex(4)&gt; v ( 2 ) 42 iex(5)&gt; v ( ) 42","ref":"IEx.Helpers.html#v/1","title":"IEx.Helpers.v/1","type":"function"},{"doc":"Prints the current location and stacktrace in a pry session. It expects a radius which chooses how many lines before and after the current line we should print. By default the radius is of two lines: Location : lib / iex / lib / iex / helpers . ex : 79 77 : 78 : def recompile do 79 : require IEx ; IEx . pry ( ) 80 : if mix_started? ( ) do 81 : config = Mix.Project . config ( IEx.Helpers ) lib / iex / lib / iex / helpers . ex : 78 : IEx.Helpers . recompile / 0 This command only works inside a pry session started manually via IEx.pry/0 or a breakpoint set via IEx.break!/4 . Calling this function during a regular IEx session will print an error. Keep in mind the whereami/1 location may not exist when prying precompiled source code, such as Elixir itself.","ref":"IEx.Helpers.html#whereami/1","title":"IEx.Helpers.whereami/1","type":"function"},{"doc":"","ref":"IEx.Info.html","title":"IEx.Info","type":"protocol"},{"doc":"","ref":"IEx.Info.html#info/1","title":"IEx.Info.info/1","type":"function"},{"doc":"","ref":"IEx.Info.html#t:t/0","title":"IEx.Info.t/0","type":"type"},{"doc":"The low-level API for prying sessions and setting up breakpoints.","ref":"IEx.Pry.html","title":"IEx.Pry","type":"module"},{"doc":"Sets up a breakpoint on the given module/function/arity.","ref":"IEx.Pry.html#break/4","title":"IEx.Pry.break/4","type":"function"},{"doc":"Sets up a breakpoint on the given module/function/args with the given guard . It requires an env to be given to make the expansion of the guards.","ref":"IEx.Pry.html#break/6","title":"IEx.Pry.break/6","type":"function"},{"doc":"Raising variant of break/4 .","ref":"IEx.Pry.html#break!/4","title":"IEx.Pry.break!/4","type":"function"},{"doc":"Raising variant of break/6 .","ref":"IEx.Pry.html#break!/6","title":"IEx.Pry.break!/6","type":"function"},{"doc":"Returns all breakpoints.","ref":"IEx.Pry.html#breaks/0","title":"IEx.Pry.breaks/0","type":"function"},{"doc":"Callback for IEx.pry/0 . You can invoke this function directly when you are not able to invoke IEx.pry/0 as a macro. This function expects the binding (from Kernel.binding/0 ) and the environment (from __ENV__/0 ).","ref":"IEx.Pry.html#pry/2","title":"IEx.Pry.pry/2","type":"function"},{"doc":"Removes all breakpoints on all modules. This effectively loads the non-instrumented version of currently instrumented modules into memory.","ref":"IEx.Pry.html#remove_breaks/0","title":"IEx.Pry.remove_breaks/0","type":"function"},{"doc":"Removes breakpoints in the given module. This effectively loads the non-instrumented version of the module into memory.","ref":"IEx.Pry.html#remove_breaks/1","title":"IEx.Pry.remove_breaks/1","type":"function"},{"doc":"Resets the breaks on a given breakpoint ID.","ref":"IEx.Pry.html#reset_break/1","title":"IEx.Pry.reset_break/1","type":"function"},{"doc":"Resets the breaks for the given module , function and arity . If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns :not_found . Otherwise it returns :ok .","ref":"IEx.Pry.html#reset_break/3","title":"IEx.Pry.reset_break/3","type":"function"},{"doc":"Formats the location for whereami/3 prying. It receives the file , line and the snippet radius and returns {:ok, lines} , where lines is a list of chardata containing each formatted line, or :error . The actual line is especially formatted in bold.","ref":"IEx.Pry.html#whereami/3","title":"IEx.Pry.whereami/3","type":"function"},{"doc":"","ref":"IEx.Pry.html#t:break/0","title":"IEx.Pry.break/0","type":"type"},{"doc":"","ref":"IEx.Pry.html#t:break_error/0","title":"IEx.Pry.break_error/0","type":"type"},{"doc":"","ref":"IEx.Pry.html#t:id/0","title":"IEx.Pry.id/0","type":"type"},{"doc":"The IEx.Server. The server responsibilities include: reading input from the group leader and writing to the group leader sending messages to the evaluator taking over the evaluator process when using IEx.pry/0 or setting up breakpoints","ref":"IEx.Server.html","title":"IEx.Server","type":"module"},{"doc":"Starts a new IEx server session. The accepted options are: :prefix - the IEx prefix :env - the Macro.Env used for the evaluator :binding - an initial set of variables for the evaluator :on_eof - if it should :stop_evaluator (default) or :halt the system","ref":"IEx.Server.html#run/1","title":"IEx.Server.run/1","type":"function"}]