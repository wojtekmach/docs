searchNodes=[{"doc":"Elixir's interactive shell. Some of the functionalities described here will not be available depending on your terminal. In particular, if you get a message saying that the smart terminal could not be run, some of the features described here won't work. Helpers IEx provides a bunch of helpers. They can be accessed by typing h() into the shell or as a documentation for the IEx.Helpers module. Autocomplete To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example: Enum . A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with @doc false , @impl true , or functions that aren't explicitly documented and where the function name is in the form of __foo__ . Autocomplete is available by default on Windows shells from Erlang/OTP 26. In earlier versions, you may need to pass the --werl option when starting IEx, such as iex --werl (or iex.bat --werl if using PowerShell). --werl may be permanently enabled by setting the IEX_WITH_WERL environment variable to 1 . Encoding and coloring IEx expects inputs and outputs to be in UTF-8 encoding. This is the default for most Unix terminals but it may not be the case on Windows. If you are running on Windows and you see incorrect values printed, you may need change the encoding of your current session by running chcp 65001 before calling iex (or before calling iex.bat if using PowerShell). Similarly, ANSI coloring is enabled by default on most Unix terminals. They are also available on Windows consoles from Windows 10 and on Erlang/OTP 26 or later. For earlier Erlang/OTP versions, you can explicitly enable it for the current user in the registry by running the following command: $ reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1 After running the command above, you must restart your current console. Shell history It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx: $ iex --erl &quot;-kernel shell_history enabled&quot; If you would rather enable it on your system as a whole, you can use the ERL_AFLAGS environment variable and make sure that it is set accordingly on your terminal/shell configuration. On Unix-like / Bash: $ export ERL_AFLAGS=&quot;-kernel shell_history enabled&quot; On Windows: $ set ERL_AFLAGS &quot;-kernel shell_history enabled&quot; On Windows 10 / PowerShell: $ $env:ERL_AFLAGS = &quot;-kernel shell_history enabled&quot; Expressions in IEx As an interactive shell, IEx evaluates expressions. This has some interesting consequences that are worth discussing. The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell. Second, IEx allows you to break an expression into many lines, since this is common in Elixir. For example: iex(1)&gt; &quot;ab ...(1)&gt; c&quot; &quot;ab \\n c&quot; In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell. For such cases, there is a special break-trigger ( #iex:break ) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state: iex(1)&gt; [ &quot;ab ...(1)&gt; c&quot; ...(1)&gt; &quot; ...(1)&gt; ] ...(1)&gt; #iex:break ** (TokenMissingError) iex:1: incomplete expression Pasting multiline expressions into IEx IEx evaluates its input line by line in an eager fashion. If at the end of a line the code seen so far is a complete expression, IEx will evaluate it at that point. iex(1)&gt; [ 1 , [ 2 ] , 3 ] [ 1 , [ 2 ] , 3 ] To prevent this behaviour breaking valid code where the subsequent line begins with a binary operator, such as |&gt;/2 or ++/2 , IEx automatically treats such lines as if they were prepended with IEx.Helpers.v/0 , which returns the value of the previous expression, if available. iex(1)&gt; [ 1 , [ 2 ] , 3 ] [ 1 , [ 2 ] , 3 ] iex(2)&gt; |&gt; List . flatten ( ) [ 1 , 2 , 3 ] The above is equivalent to: iex(1)&gt; [ 1 , [ 2 ] , 3 ] [ 1 , [ 2 ] , 3 ] iex(2)&gt; v ( ) |&gt; List . flatten ( ) [ 1 , 2 , 3 ] If there are no previous expressions in the history, the pipe operator will fail: iex(1)&gt; |&gt; List . flatten ( ) ** (RuntimeError) v(-1) is out of bounds If the previous expression was a match operation, the pipe operator will also fail, to prevent an unsolicited break of the match: iex(1)&gt; x = 42 iex(2)&gt; |&gt; IO . puts ( ) ** (SyntaxError) iex:2:1: pipe shorthand is not allowed immediately after a match expression in IEx. To make it work, surround the whole pipeline with parentheses (&#39;|&gt;&#39;) | 2 | |&gt; IO . puts ( ) | ^ Note, however, the above does not work for +/2 and -/2 , as they are ambiguous with the unary +/1 and -/1 : iex(1)&gt; 1 1 iex(2)&gt; + 2 2 The BREAK menu Inside IEx, hitting Ctrl+C will open up the BREAK menu. In this menu you can quit the shell, see process and ETS tables information and much more. Exiting the shell There are a few ways to quit the IEx shell: via the BREAK menu (available via Ctrl+C ) by typing q , pressing enter by hitting Ctrl+C , Ctrl+C by hitting Ctrl+\\ If you are connected to remote shell, it remains alive after disconnection. dbg and breakpoints IEx integrates with Kernel.dbg/2 and introduces a backend that can pause code execution. To enable it, you must pass --dbg pry : $ iex --dbg pry For example, take the following function: def my_fun ( arg1 , arg2 ) do dbg ( arg1 + arg2 ) ... implementation ... end When the code is executed with iex (most often by calling iex --dbg pry -S mix ), it will ask you permission to use &quot;pry&quot;. If you agree, it will start an IEx shell in the context of the function above, with access to its variables, imports, and aliases. However, you can only access existing values, it is not possible to access private functions nor change the execution itself (hence the name &quot;pry&quot;). When using |&gt; dbg() at the end of a pipeline, you can pry each step of the pipeline. You can type n whenever you want to jump into the next pipe. Type continue when you want to execute all of the steps but stay within the pried process. Type respawn when you want to leave the pried process and start a new shell. Alternatively, you can start a pry session directly, without dbg/2 by calling IEx.pry/0 . IEx also allows you to set breakpoints to start pry sessions on a given module, function, and arity you have no control of via IEx.break!/4 . Similar to pipelines in dbg() , IEx.break!/4 allows you to debug a function line by line and access its variables. However, breakpoints do not contain information about imports and aliases from the source code. When using dbg or breakpoints with tests, remember to pass the --trace to mix test to avoid running into timeouts: $ iex -S mix test --trace $ iex -S mix test path/to/file:line --trace The User switch command Besides the BREAK menu, one can type Ctrl+G to get to the User switch command menu. When reached, you can type h to get more information. In this menu, developers are able to start new shells and alternate between them. Let's give it a try: User switch command -- &gt; s &#39;Elixir.IEx&#39; -- &gt; c The command above will start a new shell and connect to it. Create a new variable called hello and assign some value to it: hello = :world Now, let's roll back to the first shell: User switch command -- &gt; c 1 Now, try to access the hello variable again: hello ** (UndefinedFunctionError) undefined function hello/0 The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one. The User switch command can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression: User switch command -- &gt; i -- &gt; c The User switch command menu also allows developers to connect to remote shells using the r command. A topic which we will discuss next. Remote shells IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to. Let's give it a try. First, start a new shell: $ iex --sname foo iex(foo@HOST)1&gt; The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the node/0 function: iex ( foo @ HOST ) 1 &gt; node ( ) :&quot;foo@HOST&quot; iex ( foo @ HOST ) 2 &gt; Node . alive? ( ) true For fun, let's define a simple module in this shell too: iex ( foo @ HOST ) 3 &gt; defmodule Hello do ... ( foo @ HOST ) 3 &gt; def world , do : &quot;it works!&quot; ... ( foo @ HOST ) 3 &gt; end Now, let's start another shell, giving it a name as well: $ iex --sname bar iex(bar@HOST)1&gt; If we try to dispatch to Hello.world/0 , it won't be available as it was defined only in the other shell: iex ( bar @ HOST ) 1 &gt; Hello . world ( ) ** (UndefinedFunctionError) undefined function Hello.world/0 However, we can connect to the other shell remotely. Open up the User switch command prompt (Ctrl+G) and type: User switch command -- &gt; r &#39;foo@HOST&#39; &#39;Elixir.IEx&#39; -- &gt; c Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there: iex ( foo @ HOST ) 1 &gt; Hello . world ( ) &quot;it works!&quot; In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well: $ iex --sname baz --remsh foo@HOST Where &quot;remsh&quot; means &quot;remote shell&quot;. In general, Elixir supports: remsh from an Elixir node to an Elixir node remsh from a plain Erlang node to an Elixir node (through the ^G menu) remsh from an Elixir node to a plain Erlang node (and get an erl shell there) Connecting an Elixir shell to a remote node without Elixir is not supported. The .iex.exs file When starting, IEx looks for a local .iex.exs file (located in the current working directory), then for a global .iex.exs file located inside the directory pointed by the IEX_HOME environment variable (which defaults to ~ ) and loads the first one it finds (if any). The code in the chosen .iex.exs file is evaluated line by line in the shell's context, as if each line were being typed in the shell. For instance, any modules that are loaded or variables that are bound in the .iex.exs file will be available in the shell after it has booted. Take the following .iex.exs file: # Load another &quot;.iex.exs&quot; file import_file ( &quot;~/.iex.exs&quot; ) # Import some module from lib that may not yet have been defined import_if_available ( MyApp.Mod ) # Print something before the shell starts IO . puts ( &quot;hello world&quot; ) # Bind a variable that&#39;ll be accessible in the shell value = 13 Running IEx in the directory where the above .iex.exs file is located results in: $ iex Erlang/OTP 24 [...] hello world Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help) iex(1)&gt; value 13 It is possible to load another file by supplying the --dot-iex option to IEx. See iex --help . In case of remote nodes, the location of the .iex.exs files are taken relative to the user that started the application, not to the user that is connecting to the node in case of remote IEx connections. Configuring the shell There are a number of customization options provided by IEx. Take a look at the docs for the IEx.configure/1 function by typing h IEx.configure/1 . Those options can be configured in your project configuration file or globally by calling IEx.configure/1 from your ~/.iex.exs file. For example: # .iex.exs IEx . configure ( inspect : [ limit : 3 ] ) Now run the shell: $ iex Erlang/OTP 24 [...] Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help) iex(1)&gt; [1, 2, 3, 4, 5] [1, 2, 3, ...]","ref":"IEx.html","source_doc":"Elixir's interactive shell.\n\nSome of the functionalities described here will not be available\ndepending on your terminal. In particular, if you get a message\nsaying that the smart terminal could not be run, some of the\nfeatures described here won't work.\n\n## Helpers\n\nIEx provides a bunch of helpers. They can be accessed by typing\n`h()` into the shell or as a documentation for the `IEx.Helpers` module.\n\n## Autocomplete\n\nTo discover a module's public functions or other modules, type the module name\nfollowed by a dot, then press tab to trigger autocomplete. For example:\n\n    Enum.\n\nA module may export functions that are not meant to be used directly:\nthese functions won't be autocompleted by IEx. IEx will not autocomplete\nfunctions annotated with `@doc false`, `@impl true`, or functions that\naren't explicitly documented and where the function name is in the form\nof `__foo__`.\n\nAutocomplete is available by default on Windows shells from Erlang/OTP 26.\nIn earlier versions, you may need to pass the `--werl` option when starting\nIEx, such as `iex --werl` (or `iex.bat --werl` if using PowerShell).\n`--werl` may be permanently enabled by setting the `IEX_WITH_WERL`\nenvironment variable to `1`.\n\n## Encoding and coloring\n\nIEx expects inputs and outputs to be in UTF-8 encoding. This is the\ndefault for most Unix terminals but it may not be the case on Windows.\nIf you are running on Windows and you see incorrect values printed,\nyou may need change the encoding of your current session by running\n`chcp 65001` before calling `iex` (or before calling `iex.bat` if using\nPowerShell).\n\nSimilarly, ANSI coloring is enabled by default on most Unix terminals.\nThey are also available on Windows consoles from Windows 10 and on\nErlang/OTP 26 or later. For earlier Erlang/OTP versions, you can\nexplicitly enable it for the current user in the registry by running\nthe following command:\n\n    $ reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1\n\nAfter running the command above, you must restart your current console.\n\n## Shell history\n\nIt is possible to get shell history by passing some options that enable it\nin the VM. This can be done on a per-need basis when starting IEx:\n\n    $ iex --erl \"-kernel shell_history enabled\"\n\nIf you would rather enable it on your system as a whole, you can use\nthe `ERL_AFLAGS` environment variable and make sure that it is set\naccordingly on your terminal/shell configuration.\n\nOn Unix-like / Bash:\n\n    $ export ERL_AFLAGS=\"-kernel shell_history enabled\"\n\nOn Windows:\n\n    $ set ERL_AFLAGS \"-kernel shell_history enabled\"\n\nOn Windows 10 / PowerShell:\n\n    $ $env:ERL_AFLAGS = \"-kernel shell_history enabled\"\n\n## Expressions in IEx\n\nAs an interactive shell, IEx evaluates expressions. This has some\ninteresting consequences that are worth discussing.\n\nThe first one is that the code is truly evaluated and not compiled.\nThis means that any benchmarking done in the shell is going to have\nskewed results. So never run any profiling nor benchmarks in the shell.\n\nSecond, IEx allows you to break an expression into many lines,\nsince this is common in Elixir. For example:\n\n    iex(1)> \"ab\n    ...(1)> c\"\n    \"ab\\nc\"\n\nIn the example above, the shell will be expecting more input until it\nfinds the closing quote. Sometimes it is not obvious which character\nthe shell is expecting, and the user may find themselves trapped in\nthe state of incomplete expression with no ability to terminate it other\nthan by exiting the shell.\n\nFor such cases, there is a special break-trigger (`#iex:break`) that when\nencountered on a line by itself will force the shell to break out of any\npending expression and return to its normal state:\n\n    iex(1)> [\"ab\n    ...(1)> c\"\n    ...(1)> \"\n    ...(1)> ]\n    ...(1)> #iex:break\n    ** (TokenMissingError) iex:1: incomplete expression\n\n## Pasting multiline expressions into IEx\n\nIEx evaluates its input line by line in an eager fashion. If at the end of a\nline the code seen so far is a complete expression, IEx will evaluate it at\nthat point.\n\n    iex(1)> [1, [2], 3]\n    [1, [2], 3]\n\nTo prevent this behaviour breaking valid code where the subsequent line\nbegins with a binary operator, such as `|>/2` or `++/2` , IEx automatically\ntreats such lines as if they were prepended with `IEx.Helpers.v/0`, which\nreturns the value of the previous expression, if available.\n\n    iex(1)> [1, [2], 3]\n    [1, [2], 3]\n    iex(2)> |> List.flatten()\n    [1, 2, 3]\n\nThe above is equivalent to:\n\n    iex(1)> [1, [2], 3]\n    [1, [2], 3]\n    iex(2)> v() |> List.flatten()\n    [1, 2, 3]\n\nIf there are no previous expressions in the history, the pipe operator will\nfail:\n\n    iex(1)> |> List.flatten()\n    ** (RuntimeError) v(-1) is out of bounds\n\nIf the previous expression was a match operation, the pipe operator will also\nfail, to prevent an unsolicited break of the match:\n\n    iex(1)> x = 42\n    iex(2)> |> IO.puts()\n    ** (SyntaxError) iex:2:1: pipe shorthand is not allowed immediately after a match expression in IEx. To make it work, surround the whole pipeline with parentheses ('|>')\n        |\n      2 | |> IO.puts()\n        | ^\n\nNote, however, the above does not work for `+/2` and `-/2`, as they\nare ambiguous with the unary `+/1` and `-/1`:\n\n    iex(1)> 1\n    1\n    iex(2)> + 2\n    2\n\n## The BREAK menu\n\nInside IEx, hitting `Ctrl+C` will open up the `BREAK` menu. In this\nmenu you can quit the shell, see process and ETS tables information\nand much more.\n\n## Exiting the shell\n\nThere are a few ways to quit the IEx shell:\n\n  * via the `BREAK` menu (available via `Ctrl+C`) by typing `q`, pressing enter\n  * by hitting `Ctrl+C`, `Ctrl+C`\n  * by hitting `Ctrl+\\ `\n\nIf you are connected to remote shell, it remains alive after disconnection.\n\n## `dbg` and breakpoints\n\nIEx integrates with `Kernel.dbg/2` and introduces a backend that\ncan pause code execution. To enable it, you must pass `--dbg pry`:\n\n    $ iex --dbg pry\n\nFor example, take the following function:\n\n    def my_fun(arg1, arg2) do\n      dbg(arg1 + arg2)\n      ... implementation ...\n    end\n\nWhen the code is executed with `iex` (most often by calling\n`iex --dbg pry -S mix`), it will ask you permission to use \"pry\".\nIf you agree, it will start an IEx shell in the context of the function\nabove, with access to its variables, imports, and aliases. However,\nyou can only access existing values, it is not possible to access\nprivate functions nor change the execution itself (hence the name\n\"pry\").\n\nWhen using `|> dbg()` at the end of a pipeline, you can pry each\nstep of the pipeline. You can type `n` whenever you want to jump\ninto the next pipe. Type `continue` when you want to execute all\nof the steps but stay within the pried process. Type `respawn` when\nyou want to leave the pried process and start a new shell.\n\nAlternatively, you can start a pry session directly, without `dbg/2`\nby calling `IEx.pry/0`.\n\nIEx also allows you to set breakpoints to start pry sessions\non a given module, function, and arity you have no control of\nvia `IEx.break!/4`. Similar to pipelines in `dbg()`, `IEx.break!/4`\nallows you to debug a function line by line and access its variables.\nHowever, breakpoints do not contain information about imports and\naliases from the source code.\n\nWhen using `dbg` or breakpoints with tests, remember to pass the\n`--trace` to `mix test` to avoid running into timeouts:\n\n    $ iex -S mix test --trace\n    $ iex -S mix test path/to/file:line --trace\n\n## The User switch command\n\nBesides the `BREAK` menu, one can type `Ctrl+G` to get to the\n`User switch command` menu. When reached, you can type `h` to\nget more information.\n\nIn this menu, developers are able to start new shells and\nalternate between them. Let's give it a try:\n\n    User switch command\n     --> s 'Elixir.IEx'\n     --> c\n\nThe command above will start a new shell and connect to it.\nCreate a new variable called `hello` and assign some value to it:\n\n    hello = :world\n\nNow, let's roll back to the first shell:\n\n    User switch command\n     --> c 1\n\nNow, try to access the `hello` variable again:\n\n    hello\n    ** (UndefinedFunctionError) undefined function hello/0\n\nThe command above fails because we have switched shells.\nSince shells are isolated from each other, you can't access the\nvariables defined in one shell from the other one.\n\nThe `User switch command` can also be used to terminate an existing\nsession, for example when the evaluator gets stuck in an infinite\nloop or when you are stuck typing an expression:\n\n    User switch command\n     --> i\n     --> c\n\nThe `User switch command` menu also allows developers to connect to\nremote shells using the `r` command. A topic which we will discuss next.\n\n## Remote shells\n\nIEx allows you to connect to another node in two fashions.\nFirst of all, we can only connect to a shell if we give names\nboth to the current shell and the shell we want to connect to.\n\nLet's give it a try. First, start a new shell:\n\n    $ iex --sname foo\n    iex(foo@HOST)1>\n\nThe string between the parentheses in the prompt is the name\nof your node. We can retrieve it by calling the `node/0`\nfunction:\n\n    iex(foo@HOST)1> node()\n    :\"foo@HOST\"\n    iex(foo@HOST)2> Node.alive?()\n    true\n\nFor fun, let's define a simple module in this shell too:\n\n    iex(foo@HOST)3> defmodule Hello do\n    ...(foo@HOST)3>   def world, do: \"it works!\"\n    ...(foo@HOST)3> end\n\nNow, let's start another shell, giving it a name as well:\n\n    $ iex --sname bar\n    iex(bar@HOST)1>\n\nIf we try to dispatch to `Hello.world/0`, it won't be available\nas it was defined only in the other shell:\n\n    iex(bar@HOST)1> Hello.world()\n    ** (UndefinedFunctionError) undefined function Hello.world/0\n\nHowever, we can connect to the other shell remotely. Open up\nthe `User switch command` prompt (Ctrl+G) and type:\n\n    User switch command\n     --> r 'foo@HOST' 'Elixir.IEx'\n     --> c\n\nNow we are connected into the remote node, as the prompt shows us,\nand we can access the information and modules defined over there:\n\n    iex(foo@HOST)1> Hello.world()\n    \"it works!\"\n\nIn fact, connecting to remote shells is so common that we provide\na shortcut via the command line as well:\n\n    $ iex --sname baz --remsh foo@HOST\n\nWhere \"remsh\" means \"remote shell\". In general, Elixir supports:\n\n  * remsh from an Elixir node to an Elixir node\n  * remsh from a plain Erlang node to an Elixir node (through the ^G menu)\n  * remsh from an Elixir node to a plain Erlang node (and get an `erl` shell there)\n\nConnecting an Elixir shell to a remote node without Elixir is\n**not** supported.\n\n## The .iex.exs file\n\nWhen starting, IEx looks for a local `.iex.exs` file (located in the current\nworking directory), then for a global `.iex.exs` file located inside the\ndirectory pointed by the `IEX_HOME` environment variable (which defaults\nto `~`) and loads the first one it finds (if any).\n\nThe code in the chosen `.iex.exs` file is evaluated line by line in the shell's\ncontext, as if each line were being typed in the shell. For instance, any modules\nthat are loaded or variables that are bound in the `.iex.exs` file will be available\nin the shell after it has booted.\n\nTake the following `.iex.exs` file:\n\n    # Load another \".iex.exs\" file\n    import_file(\"~/.iex.exs\")\n\n    # Import some module from lib that may not yet have been defined\n    import_if_available(MyApp.Mod)\n\n    # Print something before the shell starts\n    IO.puts(\"hello world\")\n\n    # Bind a variable that'll be accessible in the shell\n    value = 13\n\nRunning IEx in the directory where the above `.iex.exs` file is located\nresults in:\n\n    $ iex\n    Erlang/OTP 24 [...]\n\n    hello world\n    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n    iex(1)> value\n    13\n\nIt is possible to load another file by supplying the `--dot-iex` option\nto IEx. See `iex --help`.\n\nIn case of remote nodes, the location of the `.iex.exs` files are taken\nrelative to the user that started the application, not to the user that\nis connecting to the node in case of remote IEx connections.\n\n## Configuring the shell\n\nThere are a number of customization options provided by IEx. Take a look\nat the docs for the `IEx.configure/1` function by typing `h IEx.configure/1`.\n\nThose options can be configured in your project configuration file or globally\nby calling `IEx.configure/1` from your `~/.iex.exs` file. For example:\n\n    # .iex.exs\n    IEx.configure(inspect: [limit: 3])\n\nNow run the shell:\n\n    $ iex\n    Erlang/OTP 24 [...]\n\n    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n    iex(1)> [1, 2, 3, 4, 5]\n    [1, 2, 3, ...]\n\n","title":"IEx","type":"module"},{"doc":"Macro-based shortcut for IEx.break!/4 .","ref":"IEx.html#break!/2","source_doc":"Macro-based shortcut for `IEx.break!/4`.\n","title":"IEx.break!/2","type":"macro"},{"doc":"Sets up a breakpoint in module , function and arity with the given number of stops . This function will instrument the given module and load a new version in memory with line by line breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost. When a breakpoint is reached, IEx will ask if you want to pry the given function and arity. In other words, this works similar to IEx.pry/0 as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from IEx.pry/0 , aliases and imports from the source code won't be available in the shell. IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as IEx.Helpers.breaks/0 , but remember it can be called directly as breaks() inside IEx. They are: IEx.Helpers.break!/2 - sets up a breakpoint for a given Mod.fun/arity IEx.Helpers.break!/4 - sets up a breakpoint for the given module, function, arity IEx.Helpers.breaks/0 - prints all breakpoints and their IDs IEx.Helpers.continue/0 - continues until the next breakpoint in the same shell IEx.Helpers.n/0 - goes to the next line of the current breakpoint IEx.Helpers.next/0 - same as above IEx.Helpers.open/0 - opens editor on the current breakpoint IEx.Helpers.remove_breaks/0 - removes all breakpoints in all modules IEx.Helpers.remove_breaks/1 - removes all breakpoints in a given module IEx.Helpers.reset_break/1 - sets the number of stops on the given ID to zero IEx.Helpers.reset_break/3 - sets the number of stops on the given module, function, arity to zero IEx.Helpers.respawn/0 - starts a new shell (breakpoints will ask for permission once more) IEx.Helpers.whereami/1 - shows the current location By default, the number of stops in a breakpoint is 1. Any follow-up call won't stop the code execution unless another breakpoint is set. Alternatively, the number of stops can be increased by passing the stops argument. IEx.Helpers.reset_break/1 and IEx.Helpers.reset_break/3 can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling IEx.Helpers.remove_breaks/1 and on all modules by calling IEx.Helpers.remove_breaks/0 . Within a breakpoint, you can call n to jump to the next line. To exit a breakpoint, you can either invoke continue , which will block the shell until the next breakpoint is found or the process terminates, or invoke respawn , which starts a new IEx shell, freeing up the pried one. Examples The examples below will use break! , assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name IEx.break! . The following sets up a breakpoint on URI.parse/1 : break! URI , :parse , 1 This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times: break! URI , :parse , 1 , 10 IEx.break!/2 is a convenience macro that allows breakpoints to be given in the Mod.fun/arity format: break! URI . parse / 1 Or to set a breakpoint that will stop 10 times: break! URI . parse / 1 , 10 This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint. Patterns and guards IEx.break!/2 allows patterns to be given, triggering the breakpoint only in some occasions. For example, to trigger the breakpoint only when the first argument starts with the &quot;https&quot; string: break! URI . parse ( &quot;https&quot; &lt;&gt; _ , _ ) Only a single break point can be set per function. So if you call IEx.break! multiple times with different patterns, only the last pattern is kept. Macros While it is possible to set breakpoint in macros, remember that macros are generally expanded at compilation time, and therefore they may never be invoked during runtime. Similarly, while patterns may be given to macros, macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern: break! MyModule . some_macro ( pid ) when pid == self ( ) This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as MyModule.some_macro(self()) , the macro will receive the AST representing the self() call, and not the PID itself. Breaks and mix test To use IEx.break!/4 during tests, you need to run mix inside the iex command and pass the --trace to mix test to avoid running into timeouts: $ iex -S mix test --trace $ iex -S mix test path/to/file:line --trace","ref":"IEx.html#break!/4","source_doc":"Sets up a breakpoint in `module`, `function` and `arity` with\nthe given number of `stops`.\n\nThis function will instrument the given module and load a new\nversion in memory with line by line breakpoints at the given\nfunction and arity. If the module is recompiled, all breakpoints\nare lost.\n\nWhen a breakpoint is reached, IEx will ask if you want to `pry`\nthe given function and arity. In other words, this works similar\nto `IEx.pry/0` as the running process becomes the evaluator of\nIEx commands and is temporarily changed to have a custom group\nleader. However, differently from `IEx.pry/0`, aliases and imports\nfrom the source code won't be available in the shell.\n\nIEx helpers includes many conveniences related to breakpoints.\nBelow they are listed with the full module, such as `IEx.Helpers.breaks/0`,\nbut remember it can be called directly as `breaks()` inside IEx.\nThey are:\n\n  * `IEx.Helpers.break!/2` - sets up a breakpoint for a given `Mod.fun/arity`\n  * `IEx.Helpers.break!/4` - sets up a breakpoint for the given module, function, arity\n  * `IEx.Helpers.breaks/0` - prints all breakpoints and their IDs\n  * `IEx.Helpers.continue/0` - continues until the next breakpoint in the same shell\n  * `IEx.Helpers.n/0` - goes to the next line of the current breakpoint\n  * `IEx.Helpers.next/0` - same as above\n  * `IEx.Helpers.open/0` - opens editor on the current breakpoint\n  * `IEx.Helpers.remove_breaks/0` - removes all breakpoints in all modules\n  * `IEx.Helpers.remove_breaks/1` - removes all breakpoints in a given module\n  * `IEx.Helpers.reset_break/1` - sets the number of stops on the given ID to zero\n  * `IEx.Helpers.reset_break/3` - sets the number of stops on the given module, function, arity to zero\n  * `IEx.Helpers.respawn/0` - starts a new shell (breakpoints will ask for permission once more)\n  * `IEx.Helpers.whereami/1` - shows the current location\n\nBy default, the number of stops in a breakpoint is 1. Any follow-up\ncall won't stop the code execution unless another breakpoint is set.\n\nAlternatively, the number of stops can be increased by passing the `stops`\nargument. `IEx.Helpers.reset_break/1` and `IEx.Helpers.reset_break/3`\ncan be used to reset the number back to zero. Note the module remains\n\"instrumented\" even after all stops on all breakpoints are consumed.\nYou can remove the instrumentation in a given module by calling\n`IEx.Helpers.remove_breaks/1` and on all modules by calling\n`IEx.Helpers.remove_breaks/0`.\n\nWithin a breakpoint, you can call `n` to jump to the next line.\nTo exit a breakpoint, you can either invoke `continue`, which will\nblock the shell until the next breakpoint is found or the process\nterminates, or invoke `respawn`, which starts a new IEx shell,\nfreeing up the pried one.\n\n## Examples\n\nThe examples below will use `break!`, assuming that you are setting\na breakpoint directly from your IEx shell. But you can set up a break\nfrom anywhere by using the fully qualified name `IEx.break!`.\n\nThe following sets up a breakpoint on `URI.parse/1`:\n\n    break! URI, :parse, 1\n\nThis call will setup a breakpoint that stops once.\nTo set a breakpoint that will stop 10 times:\n\n    break! URI, :parse, 1, 10\n\n`IEx.break!/2` is a convenience macro that allows breakpoints\nto be given in the `Mod.fun/arity` format:\n\n    break! URI.parse/1\n\nOr to set a breakpoint that will stop 10 times:\n\n    break! URI.parse/1, 10\n\nThis function returns the breakpoint ID and will raise if there\nis an error setting up the breakpoint.\n\n## Patterns and guards\n\n`IEx.break!/2` allows patterns to be given, triggering the\nbreakpoint only in some occasions. For example, to trigger\nthe breakpoint only when the first argument starts with the\n\"https\" string:\n\n    break! URI.parse(\"https\" <> _, _)\n\nOnly a single break point can be set per function. So if you call\n`IEx.break!` multiple times with different patterns, only the last\npattern is kept.\n\n## Macros\n\nWhile it is possible to set breakpoint in macros, remember that macros\nare generally expanded at compilation time, and therefore they may never\nbe invoked during runtime. Similarly, while patterns may be given to\nmacros, macros receive ASTs as arguments, and not values. For example,\nif you try to break on a macro with the following pattern:\n\n    break! MyModule.some_macro(pid) when pid == self()\n\nThis breakpoint will never be reached, because a macro never receives\na PID. Even if you call the macro as `MyModule.some_macro(self())`,\nthe macro will receive the AST representing the `self()` call, and not\nthe PID itself.\n\n## Breaks and `mix test`\n\nTo use `IEx.break!/4` during tests, you need to run `mix` inside\nthe `iex` command and pass the `--trace` to `mix test` to avoid running\ninto timeouts:\n\n    $ iex -S mix test --trace\n    $ iex -S mix test path/to/file:line --trace\n\n","title":"IEx.break!/4","type":"function"},{"doc":"Returns string escaped using the specified color . ANSI escapes in string are not processed in any way.","ref":"IEx.html#color/2","source_doc":"Returns `string` escaped using the specified `color`.\n\nANSI escapes in `string` are not processed in any way.\n","title":"IEx.color/2","type":"function"},{"doc":"Returns IEx configuration.","ref":"IEx.html#configuration/0","source_doc":"Returns IEx configuration.\n","title":"IEx.configuration/0","type":"function"},{"doc":"Configures IEx. The supported options are: :colors :inspect :width :history_size :default_prompt :continuation_prompt :alive_prompt :alive_continuation_prompt :parser They are discussed individually in the sections below. Colors A keyword list that encapsulates all color settings used by the shell. See documentation for the IO.ANSI module for the list of supported colors and attributes. List of supported keys in the keyword list: :enabled - boolean value that allows for switching the coloring on and off :eval_result - color for an expression's resulting value :eval_info - ... various informational messages :eval_error - ... error messages :eval_interrupt - ... interrupt messages :stack_info - ... the stacktrace color :blame_diff - ... when blaming source with no match :ls_directory - ... for directory entries (ls helper) :ls_device - ... device entries (ls helper) When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Colors for this can be configured via: :doc_code - the attributes for code blocks (cyan, bright) :doc_inline_code - inline code (cyan) :doc_headings - h1 and h2 (yellow, bright) :doc_title - the overall heading for the output (reverse, yellow, bright) :doc_bold - (bright) :doc_underline - (underline) IEx will also color inspected expressions using the :syntax_colors option. Such can be disabled with: IEx . configure ( colors : [ syntax_colors : false ] ) You can also configure the syntax colors, however, as desired. The below will format atoms in red and remove the coloring for all other data types: IEx . configure ( colors : [ syntax_colors : [ atom : :red ] ] ) The default values can be found in IO.ANSI.syntax_colors/0 . Inspect A keyword list containing inspect options used by the shell when printing results of expression evaluation. Defaults to pretty formatting with a limit of 50 entries. To show all entries, configure the limit to :infinity : IEx . configure ( inspect : [ limit : :infinity ] ) See Inspect.Opts for the full list of options. Width An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of :io.columns . This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen. History size Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited. Prompt This is an option determining the prompt displayed to the user when awaiting input. The value is a keyword list with two possible keys representing prompt types: :default_prompt - used when Node.alive?/0 returns false :continuation_prompt - used when Node.alive?/0 returns false and more input is expected :alive_prompt - used when Node.alive?/0 returns true :alive_continuation_prompt - used when Node.alive?/0 returns true and more input is expected The following values in the prompt string will be replaced appropriately: %counter - the index of the history %prefix - a prefix given by IEx.Server %node - the name of the local node Parser This is an option determining the parser to use for IEx. The parser is a &quot;mfargs&quot;, which is a tuple with three elements: the module name, the function name, and extra arguments to be appended. The parser receives at least three arguments, the current input as a string, the parsing options as a keyword list, and the buffer as a string. It must return {:ok, expr, buffer} or {:incomplete, buffer} . If the parser raises, the buffer is reset to an empty string.","ref":"IEx.html#configure/1","source_doc":"Configures IEx.\n\nThe supported options are:\n\n  * `:colors`\n  * `:inspect`\n  * `:width`\n  * `:history_size`\n  * `:default_prompt`\n  * `:continuation_prompt`\n  * `:alive_prompt`\n  * `:alive_continuation_prompt`\n  * `:parser`\n\nThey are discussed individually in the sections below.\n\n## Colors\n\nA keyword list that encapsulates all color settings used by the\nshell. See documentation for the `IO.ANSI` module for the list of\nsupported colors and attributes.\n\nList of supported keys in the keyword list:\n\n  * `:enabled` - boolean value that allows for switching the coloring on and off\n  * `:eval_result` - color for an expression's resulting value\n  * `:eval_info` - ... various informational messages\n  * `:eval_error` - ... error messages\n  * `:eval_interrupt` - ... interrupt messages\n  * `:stack_info` - ... the stacktrace color\n  * `:blame_diff` - ... when blaming source with no match\n  * `:ls_directory` - ... for directory entries (ls helper)\n  * `:ls_device` - ... device entries (ls helper)\n\nWhen printing documentation, IEx will convert the Markdown\ndocumentation to ANSI as well. Colors for this can be configured\nvia:\n\n  * `:doc_code`        - the attributes for code blocks (cyan, bright)\n  * `:doc_inline_code` - inline code (cyan)\n  * `:doc_headings`    - h1 and h2 (yellow, bright)\n  * `:doc_title`       - the overall heading for the output (reverse, yellow, bright)\n  * `:doc_bold`        - (bright)\n  * `:doc_underline`   - (underline)\n\nIEx will also color inspected expressions using the `:syntax_colors`\noption. Such can be disabled with:\n\n    IEx.configure(colors: [syntax_colors: false])\n\nYou can also configure the syntax colors, however, as desired.\nThe below will format atoms in red and remove the coloring for\nall other data types:\n\n    IEx.configure(colors: [syntax_colors: [atom: :red]])\n\nThe default values can be found in `IO.ANSI.syntax_colors/0`.\n\n## Inspect\n\nA keyword list containing inspect options used by the shell\nwhen printing results of expression evaluation. Defaults to\npretty formatting with a limit of 50 entries.\n\nTo show all entries, configure the limit to `:infinity`:\n\n    IEx.configure(inspect: [limit: :infinity])\n\nSee `Inspect.Opts` for the full list of options.\n\n## Width\n\nAn integer indicating the maximum number of columns to use in output.\nThe default value is 80 columns. The actual output width is the minimum\nof this number and result of `:io.columns`. This way you can configure IEx\nto be your largest screen size and it should always take up the full width\nof your current terminal screen.\n\n## History size\n\nNumber of expressions and their results to keep in the history.\nThe value is an integer. When it is negative, the history is unlimited.\n\n## Prompt\n\nThis is an option determining the prompt displayed to the user\nwhen awaiting input.\n\nThe value is a keyword list with two possible keys representing prompt types:\n\n  * `:default_prompt` - used when `Node.alive?/0` returns `false`\n\n  * `:continuation_prompt` - used when `Node.alive?/0` returns `false`\n    and more input is expected\n\n  * `:alive_prompt` - used when `Node.alive?/0` returns `true`\n\n  * `:alive_continuation_prompt` - used when `Node.alive?/0` returns\n    `true` and more input is expected\n\nThe following values in the prompt string will be replaced appropriately:\n\n  * `%counter` - the index of the history\n  * `%prefix`  - a prefix given by `IEx.Server`\n  * `%node`    - the name of the local node\n\n## Parser\n\nThis is an option determining the parser to use for IEx.\n\nThe parser is a \"mfargs\", which is a tuple with three elements:\nthe module name, the function name, and extra arguments to\nbe appended. The parser receives at least three arguments, the\ncurrent input as a string, the parsing options as a keyword list,\nand the buffer as a string. It must return `{:ok, expr, buffer}`\nor `{:incomplete, buffer}`.\n\nIf the parser raises, the buffer is reset to an empty string.\n","title":"IEx.configure/1","type":"function"},{"doc":"Returns the options used for inspecting.","ref":"IEx.html#inspect_opts/0","source_doc":"Returns the options used for inspecting.\n","title":"IEx.inspect_opts/0","type":"function"},{"doc":"Pries into the process environment. When you start iex , IEx will set this function to be the default dbg/2 backend unless the --no-pry flag is given. This function is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling IEx.Helpers.respawn/0 , which starts a new IEx shell, freeing up the pried one. When a process is pried, all code runs inside IEx and has access to all imports and aliases from the original code. However, you cannot change the execution of the code nor access private functions of the module being pried. Module functions still need to be accessed via Mod.fun(args) . See also break!/4 for others ways to pry. Examples Let's suppose you want to investigate what is happening with some particular function. By invoking IEx.pry/0 from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example: import Enum , only : [ map : 2 ] defmodule Adder do def add ( a , b ) do c = a + b require IEx ; IEx . pry ( ) end end When invoking Adder.add(1, 2) , you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above: iex(1)&gt; map ( [ a , b , c ] , &amp; IO . inspect ( &amp;1 ) ) 1 2 3 Keep in mind that IEx.pry/0 runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling respawn/0 , which starts a new IEx evaluation cycle, letting this one go: iex(2)&gt; respawn ( ) true Interactive Elixir - press Ctrl + C to exit ( type h ( ) ENTER for help ) Setting variables or importing modules in IEx does not affect the caller's environment. However, sending and receiving messages will change the process state. Pry and macros When setting up Pry inside a code defined by macros, such as: defmacro __using__ ( _ ) do quote do def add ( a , b ) do c = a + b require IEx ; IEx . pry ( ) end end end The variables defined inside quote won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available. Pry and mix test To use IEx.pry/0 during tests, you need to run mix inside the iex command and pass the --trace to mix test to avoid running into timeouts: $ iex -S mix test --trace $ iex -S mix test path/to/file:line --trace","ref":"IEx.html#pry/0","source_doc":"Pries into the process environment.\n\nWhen you start `iex`, IEx will set this function to be the\ndefault `dbg/2` backend unless the `--no-pry` flag is given.\n\nThis function is useful for debugging a particular chunk of code\nwhen executed by a particular process. The process becomes\nthe evaluator of IEx commands and is temporarily changed to\nhave a custom group leader. Those values are reverted by\ncalling `IEx.Helpers.respawn/0`, which starts a new IEx shell,\nfreeing up the pried one.\n\nWhen a process is pried, all code runs inside IEx and has\naccess to all imports and aliases from the original code.\nHowever, you cannot change the execution of the code nor\naccess private functions of the module being pried. Module\nfunctions still need to be accessed via `Mod.fun(args)`.\n\nSee also `break!/4` for others ways to pry.\n\n## Examples\n\nLet's suppose you want to investigate what is happening\nwith some particular function. By invoking `IEx.pry/0` from\nthe function, IEx will allow you to access its binding\n(variables), verify its lexical information and access\nthe process information. Let's see an example:\n\n    import Enum, only: [map: 2]\n\n    defmodule Adder do\n      def add(a, b) do\n        c = a + b\n        require IEx; IEx.pry()\n      end\n    end\n\nWhen invoking `Adder.add(1, 2)`, you will receive a message in\nyour shell to pry the given environment. By allowing it,\nthe shell will be reset and you gain access to all variables\nand the lexical scope from above:\n\n    iex(1)> map([a, b, c], &IO.inspect(&1))\n    1\n    2\n    3\n\nKeep in mind that `IEx.pry/0` runs in the caller process,\nblocking the caller during the evaluation cycle. The caller\nprocess can be freed by calling [`respawn/0`](`IEx.Helpers.respawn/0`), which starts a\nnew IEx evaluation cycle, letting this one go:\n\n    iex(2)> respawn()\n    true\n\n    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n\nSetting variables or importing modules in IEx does not\naffect the caller's environment. However, sending and\nreceiving messages will change the process state.\n\n## Pry and macros\n\nWhen setting up Pry inside a code defined by macros, such as:\n\n    defmacro __using__(_) do\n      quote do\n        def add(a, b) do\n          c = a + b\n          require IEx; IEx.pry()\n        end\n      end\n    end\n\nThe variables defined inside `quote` won't be available during\nprying due to the hygiene mechanism in quoted expressions. The\nhygiene mechanism changes the variable names in quoted expressions\nso they don't collide with variables defined by the users of the\nmacros. Therefore the original names are not available.\n\n## Pry and `mix test`\n\nTo use `IEx.pry/0` during tests, you need to run `mix` inside\nthe `iex` command and pass the `--trace` to `mix test` to avoid running\ninto timeouts:\n\n    $ iex -S mix test --trace\n    $ iex -S mix test path/to/file:line --trace\n\n","title":"IEx.pry/0","type":"macro"},{"doc":"Returns true if IEx was started, false otherwise.","ref":"IEx.html#started?/0","source_doc":"Returns `true` if IEx was started, `false` otherwise.\n","title":"IEx.started?/0","type":"function"},{"doc":"Returns the IEx width for printing. Used by helpers and it has a default maximum cap of 80 chars.","ref":"IEx.html#width/0","source_doc":"Returns the IEx width for printing.\n\nUsed by helpers and it has a default maximum cap of 80 chars.\n","title":"IEx.width/0","type":"function"},{"doc":"Welcome to Interactive Elixir. You are currently seeing the documentation for the module IEx.Helpers which provides many helpers to make Elixir's shell more joyful to work with. This message was triggered by invoking the helper h() , usually referred to as h/0 (since it expects 0 arguments). You can use the h/1 function to invoke the documentation for any Elixir module or function: iex&gt; h ( Enum ) iex&gt; h ( Enum . map ) iex&gt; h ( Enum . reverse / 1 ) You can also use the i/1 function to introspect any value you have in the shell: iex&gt; i ( &quot;hello&quot; ) There are many other helpers available, here are some examples: b/1 - prints callbacks info and docs for a given module c/1 - compiles a file c/2 - compiles a file and writes bytecode to the given path cd/1 - changes the current directory clear/0 - clears the screen exports/1 - shows all exports (functions + macros) in a module flush/0 - flushes all messages sent to the shell h/0 - prints this help message h/1 - prints help for the given module, function or macro i/0 - prints information about the last value i/1 - prints information about the given term ls/0 - lists the contents of the current directory ls/1 - lists the contents of the specified directory open/1 - opens the source for the given module or function in your editor pid/1 - creates a PID from a string pid/3 - creates a PID with the 3 integer arguments passed port/1 - creates a port from a string port/2 - creates a port with the 2 non-negative integers passed pwd/0 - prints the current working directory r/1 - recompiles the given module's source file recompile/0 - recompiles the current project ref/1 - creates a reference from a string ref/4 - creates a reference with the 4 integer arguments passed runtime_info/0 - prints runtime info (versions, memory usage, stats) t/1 - prints the types for the given module or function v/0 - retrieves the last value from the history v/1 - retrieves the nth value from the history Help for all of those functions can be consulted directly from the command line using the h/1 helper itself. Try: iex&gt; h ( v / 0 ) To list all IEx helpers available, which is effectively all exports (functions and macros) in the IEx.Helpers module: iex&gt; exports ( IEx.Helpers ) This module also includes helpers for debugging purposes, see IEx.break!/4 for more information. To learn more about IEx as a whole, type h(IEx) .","ref":"IEx.Helpers.html","source_doc":"Welcome to Interactive Elixir. You are currently\nseeing the documentation for the module `IEx.Helpers`\nwhich provides many helpers to make Elixir's shell\nmore joyful to work with.\n\nThis message was triggered by invoking the helper `h()`,\nusually referred to as `h/0` (since it expects 0 arguments).\n\nYou can use the `h/1` function to invoke the documentation\nfor any Elixir module or function:\n\n    iex> h(Enum)\n    iex> h(Enum.map)\n    iex> h(Enum.reverse/1)\n\nYou can also use the `i/1` function to introspect any value\nyou have in the shell:\n\n    iex> i(\"hello\")\n\nThere are many other helpers available, here are some examples:\n\n  * `b/1`            - prints callbacks info and docs for a given module\n  * `c/1`            - compiles a file\n  * `c/2`            - compiles a file and writes bytecode to the given path\n  * `cd/1`           - changes the current directory\n  * `clear/0`        - clears the screen\n  * `exports/1`      - shows all exports (functions + macros) in a module\n  * `flush/0`        - flushes all messages sent to the shell\n  * `h/0`            - prints this help message\n  * `h/1`            - prints help for the given module, function or macro\n  * `i/0`            - prints information about the last value\n  * `i/1`            - prints information about the given term\n  * `ls/0`           - lists the contents of the current directory\n  * `ls/1`           - lists the contents of the specified directory\n  * `open/1`         - opens the source for the given module or function in your editor\n  * `pid/1`          - creates a PID from a string\n  * `pid/3`          - creates a PID with the 3 integer arguments passed\n  * `port/1`         - creates a port from a string\n  * `port/2`         - creates a port with the 2 non-negative integers passed\n  * `pwd/0`          - prints the current working directory\n  * `r/1`            - recompiles the given module's source file\n  * `recompile/0`    - recompiles the current project\n  * `ref/1`          - creates a reference from a string\n  * `ref/4`          - creates a reference with the 4 integer arguments passed\n  * `runtime_info/0` - prints runtime info (versions, memory usage, stats)\n  * `t/1`            - prints the types for the given module or function\n  * `v/0`            - retrieves the last value from the history\n  * `v/1`            - retrieves the nth value from the history\n\nHelp for all of those functions can be consulted directly from\nthe command line using the `h/1` helper itself. Try:\n\n    iex> h(v/0)\n\nTo list all IEx helpers available, which is effectively all\nexports (functions and macros) in the `IEx.Helpers` module:\n\n    iex> exports(IEx.Helpers)\n\nThis module also includes helpers for debugging purposes, see\n`IEx.break!/4` for more information.\n\nTo learn more about IEx as a whole, type `h(IEx)`.\n","title":"IEx.Helpers","type":"module"},{"doc":"Prints the documentation for the given callback function. It also accepts single module argument to list all available behaviour callbacks. Examples iex&gt; b ( Mix.Task . run / 1 ) iex&gt; b ( Mix.Task . run ) iex&gt; b ( GenServer )","ref":"IEx.Helpers.html#b/1","source_doc":"Prints the documentation for the given callback function.\n\nIt also accepts single module argument to list\nall available behaviour callbacks.\n\n## Examples\n\n    iex> b(Mix.Task.run/1)\n    iex> b(Mix.Task.run)\n    iex> b(GenServer)\n\n","title":"IEx.Helpers.b/1","type":"macro"},{"doc":"Sets up a breakpoint in the AST of shape Module.function/arity with the given number of stops . See IEx.break!/4 for a complete description of breakpoints in IEx. Examples break! URI . decode_query / 2","ref":"IEx.Helpers.html#break!/2","source_doc":"Sets up a breakpoint in the AST of shape `Module.function/arity`\nwith the given number of `stops`.\n\nSee `IEx.break!/4` for a complete description of breakpoints\nin IEx.\n\n## Examples\n\n    break! URI.decode_query/2\n\n","title":"IEx.Helpers.break!/2","type":"macro"},{"doc":"Sets up a breakpoint in module , function and arity with the given number of stops . See IEx.break!/4 for a complete description of breakpoints in IEx. Examples break! URI , :decode_query , 2","ref":"IEx.Helpers.html#break!/4","source_doc":"Sets up a breakpoint in `module`, `function` and `arity`\nwith the given number of `stops`.\n\nSee `IEx.break!/4` for a complete description of breakpoints\nin IEx.\n\n## Examples\n\n    break! URI, :decode_query, 2\n\n","title":"IEx.Helpers.break!/4","type":"function"},{"doc":"Prints all breakpoints to the terminal.","ref":"IEx.Helpers.html#breaks/0","source_doc":"Prints all breakpoints to the terminal.\n","title":"IEx.Helpers.breaks/0","type":"function"},{"doc":"Compiles the given files. It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given. It returns the names of the compiled modules. If you want to recompile an existing module, check r/1 instead. Examples In the example below, we pass a directory to where the c/2 function will write the compiled .beam files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems: iex&gt; c ( [ &quot;foo.ex&quot; , &quot;bar.ex&quot; ] , &quot;ebin&quot; ) [ Foo , Bar ] When compiling one file, there is no need to wrap it in a list: iex&gt; c ( &quot;baz.ex&quot; ) [ Baz ]","ref":"IEx.Helpers.html#c/2","source_doc":"Compiles the given files.\n\nIt expects a list of files to compile and an optional path to write\nthe compiled code to. By default files are in-memory compiled.\nTo write compiled files to the current directory, an empty string\ncan be given.\n\nIt returns the names of the compiled modules.\n\nIf you want to recompile an existing module, check `r/1` instead.\n\n## Examples\n\nIn the example below, we pass a directory to where the `c/2` function will\nwrite the compiled `.beam` files to. This directory is typically named \"ebin\"\nin Erlang/Elixir systems:\n\n    iex> c([\"foo.ex\", \"bar.ex\"], \"ebin\")\n    [Foo, Bar]\n\nWhen compiling one file, there is no need to wrap it in a list:\n\n    iex> c(\"baz.ex\")\n    [Baz]\n\n","title":"IEx.Helpers.c/2","type":"function"},{"doc":"Changes the current working directory to the given path.","ref":"IEx.Helpers.html#cd/1","source_doc":"Changes the current working directory to the given path.\n","title":"IEx.Helpers.cd/1","type":"function"},{"doc":"Clears the console screen. This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.","ref":"IEx.Helpers.html#clear/0","source_doc":"Clears the console screen.\n\nThis function only works if ANSI escape codes are enabled\non the shell, which means this function is by default\nunavailable on Windows machines.\n","title":"IEx.Helpers.clear/0","type":"function"},{"doc":"Continues execution of the current process. This is usually called by sessions started with IEx.pry/0 or IEx.break!/4 . This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry. If you simply want to move to the next line of the current breakpoint, use n/0 or next/0 instead. If the running process terminates, a new IEx session is started. While the process executes, the user will no longer have control of the shell. If you would rather start a new shell, use respawn/0 instead.","ref":"IEx.Helpers.html#continue/0","source_doc":"Continues execution of the current process.\n\nThis is usually called by sessions started with `IEx.pry/0`\nor `IEx.break!/4`. This allows the current process to execute\nuntil the next breakpoint, which will automatically yield control\nback to IEx without requesting permission to pry.\n\nIf you simply want to move to the next line of the current breakpoint,\nuse `n/0` or `next/0` instead.\n\nIf the running process terminates, a new IEx session is\nstarted.\n\nWhile the process executes, the user will no longer have\ncontrol of the shell. If you would rather start a new shell,\nuse `respawn/0` instead.\n","title":"IEx.Helpers.continue/0","type":"function"},{"doc":"Prints a list of all the functions and macros exported by the given module.","ref":"IEx.Helpers.html#exports/1","source_doc":"Prints a list of all the functions and macros exported by the given module.\n","title":"IEx.Helpers.exports/1","type":"function"},{"doc":"Clears out all messages sent to the shell's inbox and prints them out.","ref":"IEx.Helpers.html#flush/0","source_doc":"Clears out all messages sent to the shell's inbox and prints them out.\n","title":"IEx.Helpers.flush/0","type":"function"},{"doc":"Prints the documentation for IEx.Helpers .","ref":"IEx.Helpers.html#h/0","source_doc":"Prints the documentation for `IEx.Helpers`.\n","title":"IEx.Helpers.h/0","type":"function"},{"doc":"Prints the documentation for the given module or for the given function/arity pair. Examples iex&gt; h ( Enum ) It also accepts functions in the format function/arity and module.function/arity , for example: iex&gt; h ( receive / 1 ) iex&gt; h ( Enum . all? / 2 ) iex&gt; h ( Enum . all? )","ref":"IEx.Helpers.html#h/1","source_doc":"Prints the documentation for the given module\nor for the given `function/arity` pair.\n\n## Examples\n\n    iex> h(Enum)\n\nIt also accepts functions in the format `function/arity`\nand `module.function/arity`, for example:\n\n    iex> h(receive/1)\n    iex> h(Enum.all?/2)\n    iex> h(Enum.all?)\n\n","title":"IEx.Helpers.h/1","type":"macro"},{"doc":"Prints information about the data type of any given term. If no argument is given, the value of the previous expression is used. Examples iex&gt; i ( 1 .. 5 ) Will print: Term 1 .. 5 Data type Range Description This is a struct . Structs are maps with a __struct__ key . Reference modules Range , Map","ref":"IEx.Helpers.html#i/1","source_doc":"Prints information about the data type of any given term.\n\nIf no argument is given, the value of the previous expression\nis used.\n\n## Examples\n\n    iex> i(1..5)\n\nWill print:\n\n    Term\n      1..5\n    Data type\n      Range\n    Description\n      This is a struct. Structs are maps with a __struct__ key.\n    Reference modules\n      Range, Map\n\n","title":"IEx.Helpers.i/1","type":"function"},{"doc":"Injects the contents of the file at path . This would be the equivalent of getting all of the file contents and pasting it all at once in IEx and executing it. By default, the contents of a .iex.exs file in the same directory as you are starting IEx are automatically imported. See the section for &quot;.iex.exs&quot; in the IEx module docs for more information. path has to be a literal string and is automatically expanded via Path.expand/1 . Examples # ~/file.exs value = 13 # in the shell iex(1)&gt; import_file ( &quot;~/file.exs&quot; ) 13 iex(2)&gt; value 13","ref":"IEx.Helpers.html#import_file/1","source_doc":"Injects the contents of the file at `path`.\n\nThis would be the equivalent of getting all of the file contents and\npasting it all at once in IEx and executing it.\n\nBy default, the contents of a `.iex.exs` file in the same directory\nas you are starting IEx are automatically imported. See the section\nfor \".iex.exs\" in the `IEx` module docs for more information.\n\n`path` has to be a literal string and is automatically expanded via\n`Path.expand/1`.\n\n## Examples\n\n    # ~/file.exs\n    value = 13\n\n    # in the shell\n    iex(1)> import_file(\"~/file.exs\")\n    13\n    iex(2)> value\n    13\n\n","title":"IEx.Helpers.import_file/1","type":"macro"},{"doc":"Similar to import_file but only imports the file if it is available. By default, import_file/1 fails when the given file does not exist. However, since import_file/1 is expanded at compile-time, it's not possible to conditionally import a file since the macro is always expanded: # This raises a File.Error if ~/.iex.exs doesn&#39;t exist. if &quot;~/.iex.exs&quot; |&gt; Path . expand ( ) |&gt; File . exists? ( ) do import_file ( &quot;~/.iex.exs&quot; ) end This macro addresses this issue by checking if the file exists or not in behalf of the user.","ref":"IEx.Helpers.html#import_file_if_available/1","source_doc":"Similar to `import_file` but only imports the file if it is available.\n\nBy default, `import_file/1` fails when the given file does not exist.\nHowever, since `import_file/1` is expanded at compile-time, it's not\npossible to conditionally import a file since the macro is always\nexpanded:\n\n    # This raises a File.Error if ~/.iex.exs doesn't exist.\n    if \"~/.iex.exs\" |> Path.expand() |> File.exists?() do\n      import_file(\"~/.iex.exs\")\n    end\n\nThis macro addresses this issue by checking if the file exists or not\nin behalf of the user.\n","title":"IEx.Helpers.import_file_if_available/1","type":"macro"},{"doc":"Calls import/2 with the given arguments, but only if the module is available. This lets you put imports in .iex.exs files (including ~/.iex.exs ) without getting compile errors if you open a console where the module is not available. Example # In ~/.iex.exs import_if_available ( Ecto.Query )","ref":"IEx.Helpers.html#import_if_available/2","source_doc":"Calls `import/2` with the given arguments, but only if the module is available.\n\nThis lets you put imports in `.iex.exs` files (including `~/.iex.exs`) without\ngetting compile errors if you open a console where the module is not available.\n\n## Example\n\n    # In ~/.iex.exs\n    import_if_available(Ecto.Query)\n\n","title":"IEx.Helpers.import_if_available/2","type":"macro"},{"doc":"Loads the given module's BEAM code (and ensures any previous old version was properly purged before). This function is useful when you know the bytecode for module has been updated in the file system and you want to tell the VM to load it.","ref":"IEx.Helpers.html#l/1","source_doc":"Loads the given module's BEAM code (and ensures any previous\nold version was properly purged before).\n\nThis function is useful when you know the bytecode for module\nhas been updated in the file system and you want to tell the VM\nto load it.\n","title":"IEx.Helpers.l/1","type":"function"},{"doc":"Prints a list of the given directory's contents. If path points to a file, prints its full path.","ref":"IEx.Helpers.html#ls/1","source_doc":"Prints a list of the given directory's contents.\n\nIf `path` points to a file, prints its full path.\n","title":"IEx.Helpers.ls/1","type":"function"},{"doc":"A shortcut for next/0 .","ref":"IEx.Helpers.html#n/0","source_doc":"A shortcut for `next/0`.\n","title":"IEx.Helpers.n/0","type":"function"},{"doc":"Goes to the next line of the current breakpoint. This is usually called by sessions started with IEx.break!/4 . If instead of the next line you want to move to the next breakpoint, call continue/0 instead. While the process executes, the user will no longer have control of the shell. If you would rather start a new shell, use respawn/0 instead.","ref":"IEx.Helpers.html#next/0","source_doc":"Goes to the next line of the current breakpoint.\n\nThis is usually called by sessions started with `IEx.break!/4`.\nIf instead of the next line you want to move to the next breakpoint,\ncall `continue/0` instead.\n\nWhile the process executes, the user will no longer have\ncontrol of the shell. If you would rather start a new shell,\nuse `respawn/0` instead.\n","title":"IEx.Helpers.next/0","type":"function"},{"doc":"Deploys a given module's BEAM code to a list of nodes. This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes. The node list defaults to a list of all connected nodes. Returns {:error, :nofile} if the object code (i.e. &quot;.beam&quot; file) for the module could not be found locally. Examples iex&gt; nl ( HelloWorld ) { :ok , [ { :node1@easthost , :loaded , HelloWorld } , { :node1@westhost , :loaded , HelloWorld } ] } iex&gt; nl ( NoSuchModuleExists ) { :error , :nofile }","ref":"IEx.Helpers.html#nl/2","source_doc":"Deploys a given module's BEAM code to a list of nodes.\n\nThis function is useful for development and debugging when you have code that\nhas been compiled or updated locally that you want to run on other nodes.\n\nThe node list defaults to a list of all connected nodes.\n\nReturns `{:error, :nofile}` if the object code (i.e. \".beam\" file) for the module\ncould not be found locally.\n\n## Examples\n\n    iex> nl(HelloWorld)\n    {:ok,\n     [\n       {:node1@easthost, :loaded, HelloWorld},\n       {:node1@westhost, :loaded, HelloWorld}\n     ]}\n\n    iex> nl(NoSuchModuleExists)\n    {:error, :nofile}\n\n","title":"IEx.Helpers.nl/2","type":"function"},{"doc":"Opens the current prying location. This command only works inside a pry session started manually via IEx.pry/0 or a breakpoint set via IEx.break!/4 . Calling this function during a regular IEx session will print an error. Keep in mind the open/0 location may not exist when prying precompiled source code, such as Elixir itself. For more information and to open any module or function, see open/1 .","ref":"IEx.Helpers.html#open/0","source_doc":"Opens the current prying location.\n\nThis command only works inside a pry session started manually\nvia `IEx.pry/0` or a breakpoint set via `IEx.break!/4`. Calling\nthis function during a regular `IEx` session will print an error.\n\nKeep in mind the `open/0` location may not exist when prying\nprecompiled source code, such as Elixir itself.\n\nFor more information and to open any module or function, see\n`open/1`.\n","title":"IEx.Helpers.open/0","type":"function"},{"doc":"Opens the given module , module.function/arity , or {file, line} . This function uses the ELIXIR_EDITOR environment variable and falls back to EDITOR if the former is not available. By default, it attempts to open the file and line using the file:line notation. For example, for Sublime Text you can set it as: ELIXIR_EDITOR = &quot;subl&quot; Which will then try to open it as: subl path / to / file :line For Visual Studio Code, once enabled on the command line, you can set it to: ELIXIR_EDITOR = &quot;code --goto&quot; It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window. For more complex use cases, you can use the __FILE__ and __LINE__ notations to explicitly interpolate the file and line into the command: ELIXIR_EDITOR = &quot;my_editor +__LINE__ __FILE__&quot; Since this function prints the result returned by the editor, ELIXIR_EDITOR can be set &quot;echo&quot; if you prefer to display the location rather than opening it. Keep in mind the location may not exist when opening precompiled source code. Examples iex&gt; open ( MyApp ) iex&gt; open ( MyApp . fun / 2 ) iex&gt; open ( { &quot;path/to/file&quot; , 1 } )","ref":"IEx.Helpers.html#open/1","source_doc":"Opens the given `module`, `module.function/arity`, or `{file, line}`.\n\nThis function uses the `ELIXIR_EDITOR` environment variable\nand falls back to `EDITOR` if the former is not available.\n\nBy default, it attempts to open the file and line using the\n`file:line` notation. For example, for Sublime Text you can\nset it as:\n\n    ELIXIR_EDITOR=\"subl\"\n\nWhich will then try to open it as:\n\n    subl path/to/file:line\n\nFor Visual Studio Code, once enabled on the command line,\nyou can set it to:\n\n    ELIXIR_EDITOR=\"code --goto\"\n\nIt is important that you choose an editor command that does\nnot block nor that attempts to run an editor directly in the\nterminal. Command-line based editors likely need extra\nconfiguration so they open up the given file and line in a\nseparate window.\n\nFor more complex use cases, you can use the `__FILE__` and\n`__LINE__` notations to explicitly interpolate the file and\nline into the command:\n\n    ELIXIR_EDITOR=\"my_editor +__LINE__ __FILE__\"\n\nSince this function prints the result returned by the editor,\n`ELIXIR_EDITOR` can be set \"echo\" if you prefer to display the\nlocation rather than opening it.\n\nKeep in mind the location may not exist when opening precompiled\nsource code.\n\n## Examples\n\n    iex> open(MyApp)\n    iex> open(MyApp.fun/2)\n    iex> open({\"path/to/file\", 1})\n\n","title":"IEx.Helpers.open/1","type":"macro"},{"doc":"Creates a PID from string or atom . Examples iex&gt; pid ( &quot;0.21.32&quot; ) # PID &lt; 0 . 21 . 32 &gt; iex&gt; pid ( &quot;#PID&lt;0.21.32&gt;&quot; ) # PID &lt; 0 . 21 . 32 &gt; iex&gt; pid ( :init ) # PID &lt; 0 . 0 . 0 &gt;","ref":"IEx.Helpers.html#pid/1","source_doc":"Creates a PID from `string` or `atom`.\n\n## Examples\n\n    iex> pid(\"0.21.32\")\n    #PID<0.21.32>\n\n    iex> pid(\"#PID<0.21.32>\")\n    #PID<0.21.32>\n\n    iex> pid(:init)\n    #PID<0.0.0>\n\n","title":"IEx.Helpers.pid/1","type":"function"},{"doc":"Creates a PID with 3 non-negative integers passed as arguments to the function. Examples iex&gt; pid ( 0 , 21 , 32 ) # PID &lt; 0 . 21 . 32 &gt; iex&gt; pid ( 0 , 64 , 2048 ) # PID &lt; 0 . 64 . 2048 &gt;","ref":"IEx.Helpers.html#pid/3","source_doc":"Creates a PID with 3 non-negative integers passed as arguments\nto the function.\n\n## Examples\n\n    iex> pid(0, 21, 32)\n    #PID<0.21.32>\n    iex> pid(0, 64, 2048)\n    #PID<0.64.2048>\n\n","title":"IEx.Helpers.pid/3","type":"function"},{"doc":"Creates a Port from string . Examples iex&gt; port ( &quot;0.4&quot; ) # Port &lt; 0.4 &gt;","ref":"IEx.Helpers.html#port/1","source_doc":"Creates a Port from `string`.\n\n## Examples\n\n    iex> port(\"0.4\")\n    #Port<0.4>\n\n","title":"IEx.Helpers.port/1","type":"function"},{"doc":"Creates a Port from two non-negative integers. Examples iex&gt; port ( 0 , 8080 ) # Port &lt; 0.8080 &gt; iex&gt; port ( 0 , 443 ) # Port &lt; 0.443 &gt;","ref":"IEx.Helpers.html#port/2","source_doc":"Creates a Port from two non-negative integers.\n\n## Examples\n\n    iex> port(0, 8080)\n    #Port<0.8080>\n    iex> port(0, 443)\n    #Port<0.443>\n\n","title":"IEx.Helpers.port/2","type":"function"},{"doc":"Prints the current working directory.","ref":"IEx.Helpers.html#pwd/0","source_doc":"Prints the current working directory.\n","title":"IEx.Helpers.pwd/0","type":"function"},{"doc":"Recompiles and reloads the given module or modules . Please note that all the modules defined in the same file as modules are recompiled and reloaded. If you want to reload multiple modules, it is best to reload them at the same time, such as in r [Foo, Bar] . This is important to avoid false warnings, since the module is only reloaded in memory and its latest information is not persisted to disk. See the &quot;In-memory reloading&quot; section below. This function is meant to be used for development and debugging purposes. Do not depend on it in production code. In-memory reloading When we reload the module in IEx, we recompile the module source code, updating its contents in memory. The original .beam file in disk, probably the one where the first definition of the module came from, does not change at all. Since docs, typespecs, and exports information are loaded from the .beam file, they are not reloaded when you invoke this function.","ref":"IEx.Helpers.html#r/1","source_doc":"Recompiles and reloads the given `module` or `modules`.\n\nPlease note that all the modules defined in the same file as\n`modules` are recompiled and reloaded. If you want to reload\nmultiple modules, it is best to reload them at the same time,\nsuch as in `r [Foo, Bar]`. This is important to avoid false\nwarnings, since the module is only reloaded in memory and its\nlatest information is not persisted to disk. See the \"In-memory\nreloading\" section below.\n\nThis function is meant to be used for development and\ndebugging purposes. Do not depend on it in production code.\n\n## In-memory reloading\n\nWhen we reload the module in IEx, we recompile the module source\ncode, updating its contents in memory. The original `.beam` file\nin disk, probably the one where the first definition of the module\ncame from, does not change at all.\n\nSince docs, typespecs, and exports information are loaded from the\n.beam file, they are not reloaded when you invoke this function.\n","title":"IEx.Helpers.r/1","type":"function"},{"doc":"Recompiles the current Mix project. This helper only works when IEx is started with a Mix project, for example, iex -S mix . Note this function simply recompiles Elixir modules, without reloading configuration, recompiling dependencies, or restarting applications. Therefore, any long running process may crash on recompilation, as changed modules will be temporarily removed and recompiled, without going through the proper code change callback. If you want to reload a single module, consider using r(ModuleName) instead. This function is meant to be used for development and debugging purposes. Do not depend on it in production code. Options :force - when true , forces the application to recompile","ref":"IEx.Helpers.html#recompile/1","source_doc":"Recompiles the current Mix project.\n\nThis helper only works when IEx is started with a Mix\nproject, for example, `iex -S mix`. Note this function\nsimply recompiles Elixir modules, without reloading\nconfiguration, recompiling dependencies, or restarting\napplications.\n\nTherefore, any long running process may crash on recompilation,\nas changed modules will be temporarily removed and recompiled,\nwithout going through the proper code change callback.\n\nIf you want to reload a single module, consider using\n`r(ModuleName)` instead.\n\nThis function is meant to be used for development and\ndebugging purposes. Do not depend on it in production code.\n\n## Options\n\n  * `:force` - when `true`, forces the application to recompile\n\n","title":"IEx.Helpers.recompile/1","type":"function"},{"doc":"Creates a Reference from string . Examples iex&gt; ref ( &quot;0.1.2.3&quot; ) # Reference &lt; 0.1 . 2.3 &gt;","ref":"IEx.Helpers.html#ref/1","source_doc":"Creates a Reference from `string`.\n\n## Examples\n\n    iex> ref(\"0.1.2.3\")\n    #Reference<0.1.2.3>\n\n","title":"IEx.Helpers.ref/1","type":"function"},{"doc":"Creates a Reference from its 4 non-negative integers components. Examples iex&gt; ref ( 0 , 1 , 2 , 3 ) # Reference &lt; 0.1 . 2.3 &gt;","ref":"IEx.Helpers.html#ref/4","source_doc":"Creates a Reference from its 4 non-negative integers components.\n\n## Examples\n\n    iex> ref(0, 1, 2, 3)\n    #Reference<0.1.2.3>\n\n","title":"IEx.Helpers.ref/4","type":"function"},{"doc":"Removes all breakpoints and instrumentation from all modules.","ref":"IEx.Helpers.html#remove_breaks/0","source_doc":"Removes all breakpoints and instrumentation from all modules.\n","title":"IEx.Helpers.remove_breaks/0","type":"function"},{"doc":"Removes all breakpoints and instrumentation from module .","ref":"IEx.Helpers.html#remove_breaks/1","source_doc":"Removes all breakpoints and instrumentation from `module`.\n","title":"IEx.Helpers.remove_breaks/1","type":"function"},{"doc":"Sets the number of pending stops in the breakpoint with the given id to zero. Returns :ok if there is such breakpoint ID. :not_found otherwise. Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use remove_breaks/1 instead.","ref":"IEx.Helpers.html#reset_break/1","source_doc":"Sets the number of pending stops in the breakpoint\nwith the given `id` to zero.\n\nReturns `:ok` if there is such breakpoint ID. `:not_found`\notherwise.\n\nNote the module remains \"instrumented\" on reset. If you would\nlike to effectively remove all breakpoints and instrumentation\ncode from a module, use `remove_breaks/1` instead.\n","title":"IEx.Helpers.reset_break/1","type":"function"},{"doc":"Sets the number of pending stops in the given module, function and arity to zero. If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns :not_found . Otherwise it returns :ok . Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use remove_breaks/1 instead.","ref":"IEx.Helpers.html#reset_break/3","source_doc":"Sets the number of pending stops in the given module,\nfunction and arity to zero.\n\nIf the module is not instrumented or if the given function\ndoes not have a breakpoint, it is a no-op and it returns\n`:not_found`. Otherwise it returns `:ok`.\n\nNote the module remains \"instrumented\" on reset. If you would\nlike to effectively remove all breakpoints and instrumentation\ncode from a module, use `remove_breaks/1` instead.\n","title":"IEx.Helpers.reset_break/3","type":"function"},{"doc":"Respawns the current shell by starting a new shell process.","ref":"IEx.Helpers.html#respawn/0","source_doc":"Respawns the current shell by starting a new shell process.\n","title":"IEx.Helpers.respawn/0","type":"function"},{"doc":"Prints VM/runtime information such as versions, memory usage and statistics. Additional topics are available via runtime_info/1 . For more metrics, info, and debugging facilities, see the Recon project.","ref":"IEx.Helpers.html#runtime_info/0","source_doc":"Prints VM/runtime information such as versions, memory usage and statistics.\n\nAdditional topics are available via `runtime_info/1`.\n\nFor more metrics, info, and debugging facilities, see the\n[Recon](https://github.com/ferd/recon) project.\n","title":"IEx.Helpers.runtime_info/0","type":"function"},{"doc":"Just like runtime_info/0 , except accepts topic or a list of topics. For example, topic :applications will list the applications loaded.","ref":"IEx.Helpers.html#runtime_info/1","source_doc":"Just like `runtime_info/0`, except accepts topic or a list of topics.\n\nFor example, topic `:applications` will list the applications loaded.\n","title":"IEx.Helpers.runtime_info/1","type":"function"},{"doc":"Prints the types for the given module or for the given function/arity pair. Examples iex&gt; t ( Enum ) @type t ( ) :: Enumerable . t ( ) @type acc ( ) :: any ( ) @type element ( ) :: any ( ) @type index ( ) :: integer ( ) @type default ( ) :: any ( ) iex&gt; t ( Enum . t / 0 ) @type t ( ) :: Enumerable . t ( ) iex&gt; t ( Enum . t ) @type t ( ) :: Enumerable . t ( )","ref":"IEx.Helpers.html#t/1","source_doc":"Prints the types for the given module or for the given function/arity pair.\n\n## Examples\n\n    iex> t(Enum)\n    @type t() :: Enumerable.t()\n    @type acc() :: any()\n    @type element() :: any()\n    @type index() :: integer()\n    @type default() :: any()\n\n    iex> t(Enum.t/0)\n    @type t() :: Enumerable.t()\n\n    iex> t(Enum.t)\n    @type t() :: Enumerable.t()\n\n","title":"IEx.Helpers.t/1","type":"macro"},{"doc":"Calls use/2 with the given arguments, but only if the module is available. This lets you use the module in .iex.exs files (including ~/.iex.exs ) without getting compile errors if you open a console where the module is not available. Example # In ~/.iex.exs use_if_available ( Phoenix.HTML )","ref":"IEx.Helpers.html#use_if_available/2","source_doc":"Calls `use/2` with the given arguments, but only if the module is available.\n\nThis lets you use the module in `.iex.exs` files (including `~/.iex.exs`) without\ngetting compile errors if you open a console where the module is not available.\n\n## Example\n\n    # In ~/.iex.exs\n    use_if_available(Phoenix.HTML)\n\n","title":"IEx.Helpers.use_if_available/2","type":"macro"},{"doc":"Returns the value of the n th expression in the history. n can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, v(-2) returns the value of the expression evaluated before the last evaluated expression. In particular, v(-1) returns the result of the last evaluated expression and v() does the same. Examples iex(1)&gt; &quot;hello&quot; &lt;&gt; &quot; world&quot; &quot;hello world&quot; iex(2)&gt; 40 + 2 42 iex(3)&gt; v ( - 2 ) &quot;hello world&quot; iex(4)&gt; v ( 2 ) 42 iex(5)&gt; v ( ) 42","ref":"IEx.Helpers.html#v/1","source_doc":"Returns the value of the `n`th expression in the history.\n\n`n` can be a negative value: if it is, the corresponding expression value\nrelative to the current one is returned. For example, `v(-2)` returns the\nvalue of the expression evaluated before the last evaluated expression. In\nparticular, `v(-1)` returns the result of the last evaluated expression and\n`v()` does the same.\n\n## Examples\n\n    iex(1)> \"hello\" <> \" world\"\n    \"hello world\"\n    iex(2)> 40 + 2\n    42\n    iex(3)> v(-2)\n    \"hello world\"\n    iex(4)> v(2)\n    42\n    iex(5)> v()\n    42\n\n","title":"IEx.Helpers.v/1","type":"function"},{"doc":"Prints the current location and stacktrace in a pry session. It expects a radius which chooses how many lines before and after the current line we should print. By default the radius is of two lines: Location : lib / iex / lib / iex / helpers . ex : 79 77 : 78 : def recompile do 79 : require IEx ; IEx . pry ( ) 80 : if mix_started? ( ) do 81 : config = Mix.Project . config ( IEx.Helpers ) lib / iex / lib / iex / helpers . ex : 78 : IEx.Helpers . recompile / 0 This command only works inside a pry session started manually via IEx.pry/0 or a breakpoint set via IEx.break!/4 . Calling this function during a regular IEx session will print an error. Keep in mind the whereami/1 location may not exist when prying precompiled source code, such as Elixir itself.","ref":"IEx.Helpers.html#whereami/1","source_doc":"Prints the current location and stacktrace in a pry session.\n\nIt expects a `radius` which chooses how many lines before and after\nthe current line we should print. By default the `radius` is of two\nlines:\n\n    Location: lib/iex/lib/iex/helpers.ex:79\n\n    77:\n    78:   def recompile do\n    79:     require IEx; IEx.pry()\n    80:     if mix_started?() do\n    81:       config = Mix.Project.config\n\n    (IEx.Helpers) lib/iex/lib/iex/helpers.ex:78: IEx.Helpers.recompile/0\n\nThis command only works inside a pry session started manually\nvia `IEx.pry/0` or a breakpoint set via `IEx.break!/4`. Calling\nthis function during a regular `IEx` session will print an error.\n\nKeep in mind the `whereami/1` location may not exist when prying\nprecompiled source code, such as Elixir itself.\n","title":"IEx.Helpers.whereami/1","type":"function"},{"doc":"A protocol to print information in IEx about the given datastructure. IEx.Helpers.i/1 uses this protocol to display a term-specific list of of information. By default, an Any implementation will be used which returns the &quot;Data type&quot; , &quot;Description&quot; and &quot;Reference modules&quot; sections.","ref":"IEx.Info.html","source_doc":"A protocol to print information in IEx about the given datastructure.\n\n`IEx.Helpers.i/1` uses this protocol to display a term-specific list\nof of information.\n\nBy default, an `Any` implementation will be used which returns\nthe `\"Data type\"`, `\"Description\"` and `\"Reference modules\"` sections.\n","title":"IEx.Info","type":"protocol"},{"doc":"Returns information for the given term. Information should be returned as a list of info_name - info tuples, where info_name is a string-like value, such as an atom or a string itself, and info is a string. info_name should be short. info can be arbitrarily long and contain newlines. IEx.Helpers.i/1 will generate (and always display) the 'Implemented protocols' and 'Term' sections in the result. All other sections of information are added (and can be overridden) by customized implementations of this function. It is recommended to at least include the following sections for a custom implementation: &quot;Data type&quot; : Name of the data type. Usually the name of the module defining the data type. &quot;Description&quot; : One or a few sentences describing what the data type represents. &quot;Reference modules : One or a few comma-separated module names that focus on working with this datatype. Other recommended sections are: &quot;Raw representation : showing another way of writing the passed term . This is mostly relevant for data-structures whose String.Chars -implementations make use of sigils or other syntactic sugar.","ref":"IEx.Info.html#info/1","source_doc":"Returns information for the given term.\n\nInformation should be returned as a list of `info_name`-`info` tuples,\nwhere `info_name` is a string-like value, such as an atom or a string\nitself, and `info` is a string. `info_name` should be short. `info` can\nbe arbitrarily long and contain newlines.\n\n`IEx.Helpers.i/1` will generate (and always display)\nthe 'Implemented protocols' and 'Term' sections in the result.\n\nAll other sections of information are added (and can be overridden)\nby customized implementations of this function.\n\nIt is recommended to at least include the following sections for a\ncustom implementation:\n\n  * `\"Data type\"`: Name of the data type. Usually the name of the module\n     defining the data type.\n  * `\"Description\"`: One or a few sentences describing what the data type represents.\n  * `\"Reference modules`: One or a few comma-separated module names that focus\n    on working with this datatype.\n\nOther recommended sections are:\n\n  * `\"Raw representation`: showing another way of writing the passed `term`.\n    This is mostly relevant for data-structures whose `String.Chars`-implementations\n    make use of sigils or other syntactic sugar.\n","title":"IEx.Info.info/1","type":"function"},{"doc":"All the types that implement this protocol.","ref":"IEx.Info.html#t:t/0","source_doc":"All the types that implement this protocol.\n","title":"IEx.Info.t/0","type":"type"},{"doc":"The low-level API for prying sessions and setting up breakpoints.","ref":"IEx.Pry.html","source_doc":"The low-level API for prying sessions and setting up breakpoints.\n","title":"IEx.Pry","type":"module"},{"doc":"Sets up a breakpoint on the given module/function/arity.","ref":"IEx.Pry.html#break/4","source_doc":"Sets up a breakpoint on the given module/function/arity.\n","title":"IEx.Pry.break/4","type":"function"},{"doc":"Sets up a breakpoint on the given module/function/args with the given guard . It requires an env to be given to make the expansion of the guards.","ref":"IEx.Pry.html#break/6","source_doc":"Sets up a breakpoint on the given module/function/args with the given `guard`.\n\nIt requires an `env` to be given to make the expansion of the guards.\n","title":"IEx.Pry.break/6","type":"function"},{"doc":"Raising variant of break/4 .","ref":"IEx.Pry.html#break!/4","source_doc":"Raising variant of `break/4`.\n","title":"IEx.Pry.break!/4","type":"function"},{"doc":"Raising variant of break/6 .","ref":"IEx.Pry.html#break!/6","source_doc":"Raising variant of `break/6`.\n","title":"IEx.Pry.break!/6","type":"function"},{"doc":"Returns all breakpoints.","ref":"IEx.Pry.html#breaks/0","source_doc":"Returns all breakpoints.\n","title":"IEx.Pry.breaks/0","type":"function"},{"doc":"Callback for IEx.pry/0 . You can invoke this function directly when you are not able to invoke IEx.pry/0 as a macro. This function expects the binding (from binding/0 ) and the environment (from __ENV__/0 ).","ref":"IEx.Pry.html#pry/2","source_doc":"Callback for `IEx.pry/0`.\n\nYou can invoke this function directly when you are not able to invoke\n`IEx.pry/0` as a macro. This function expects the binding (from\n`binding/0`) and the environment (from `__ENV__/0`).\n","title":"IEx.Pry.pry/2","type":"function"},{"doc":"Removes all breakpoints on all modules. This effectively loads the non-instrumented version of currently instrumented modules into memory.","ref":"IEx.Pry.html#remove_breaks/0","source_doc":"Removes all breakpoints on all modules.\n\nThis effectively loads the non-instrumented version of\ncurrently instrumented modules into memory.\n","title":"IEx.Pry.remove_breaks/0","type":"function"},{"doc":"Removes breakpoints in the given module. This effectively loads the non-instrumented version of the module into memory.","ref":"IEx.Pry.html#remove_breaks/1","source_doc":"Removes breakpoints in the given module.\n\nThis effectively loads the non-instrumented version of\nthe module into memory.\n","title":"IEx.Pry.remove_breaks/1","type":"function"},{"doc":"Resets the breaks on a given breakpoint ID.","ref":"IEx.Pry.html#reset_break/1","source_doc":"Resets the breaks on a given breakpoint ID.\n","title":"IEx.Pry.reset_break/1","type":"function"},{"doc":"Resets the breaks for the given module , function and arity . If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns :not_found . Otherwise it returns :ok .","ref":"IEx.Pry.html#reset_break/3","source_doc":"Resets the breaks for the given `module`, `function` and `arity`.\n\nIf the `module` is not instrumented or if the given `function`\ndoes not have a breakpoint, it is a no-op and it returns\n`:not_found`. Otherwise it returns `:ok`.\n","title":"IEx.Pry.reset_break/3","type":"function"},{"doc":"Formats the location for whereami/3 prying. It receives the file , line and the snippet radius and returns {:ok, lines} , where lines is a list of chardata containing each formatted line, or :error . The actual line is especially formatted in bold.","ref":"IEx.Pry.html#whereami/3","source_doc":"Formats the location for `whereami/3` prying.\n\nIt receives the `file`, `line` and the snippet `radius` and\nreturns `{:ok, lines}`, where lines is a list of chardata\ncontaining each formatted line, or `:error`.\n\nThe actual line is especially formatted in bold.\n","title":"IEx.Pry.whereami/3","type":"function"},{"doc":"","ref":"IEx.Pry.html#t:break/0","source_doc":false,"title":"IEx.Pry.break/0","type":"type"},{"doc":"","ref":"IEx.Pry.html#t:break_error/0","source_doc":false,"title":"IEx.Pry.break_error/0","type":"type"},{"doc":"","ref":"IEx.Pry.html#t:id/0","source_doc":false,"title":"IEx.Pry.id/0","type":"type"},{"doc":"The IEx.Server. The server responsibilities include: reading input from the group leader and writing to the group leader sending messages to the evaluator taking over the evaluator process when using IEx.pry/0 or setting up breakpoints","ref":"IEx.Server.html","source_doc":"The IEx.Server.\n\nThe server responsibilities include:\n\n  * reading input from the group leader and writing to the group leader\n  * sending messages to the evaluator\n  * taking over the evaluator process when using `IEx.pry/0` or setting up breakpoints\n\n","title":"IEx.Server","type":"module"},{"doc":"Starts a new IEx server session. The accepted options are: :prefix - the IEx prefix :env - the Macro.Env used for the evaluator :binding - an initial set of variables for the evaluator :on_eof - if it should :stop_evaluator (default) or :halt the system","ref":"IEx.Server.html#run/1","source_doc":"Starts a new IEx server session.\n\nThe accepted options are:\n\n  * `:prefix` - the IEx prefix\n  * `:env` - the `Macro.Env` used for the evaluator\n  * `:binding` - an initial set of variables for the evaluator\n  * `:on_eof` - if it should `:stop_evaluator` (default) or `:halt` the system\n\n","title":"IEx.Server.run/1","type":"function"}]