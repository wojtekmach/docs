searchNodes=[{"doc":"Kernel is Elixir's default environment. It mainly consists of: basic language primitives, such as arithmetic operators, spawning of processes, data type handling, and others macros for control-flow and defining new functionality (modules, functions, and the like) guard checks for augmenting pattern matching You can invoke Kernel functions and macros anywhere in Elixir code without the use of the Kernel. prefix since they have all been automatically imported. For example, in IEx, you can call: iex&gt; is_number ( 13 ) true If you don't want to import a function or macro from Kernel , use the :except option and then list the function/macro by arity: import Kernel , except : [ if : 2 , unless : 2 ] See Kernel.SpecialForms.import/2 for more information on importing. Elixir also has special forms that are always imported and cannot be skipped. These are described in Kernel.SpecialForms . The standard library Kernel provides the basic capabilities the Elixir standard library is built on top of. It is recommended to explore the standard library for advanced functionality. Here are the main groups of modules in the standard library (this list is not a complete reference, see the documentation sidebar for all entries). Built-in types The following modules handle Elixir built-in data types: Atom - literal constants with a name ( true , false , and nil are atoms) Float - numbers with floating point precision Function - a reference to code chunk, created with the fn/1 special form Integer - whole numbers (not fractions) List - collections of a variable number of elements (linked lists) Map - collections of key-value pairs Process - light-weight threads of execution Port - mechanisms to interact with the external world Tuple - collections of a fixed number of elements There are two data types without an accompanying module: Bitstring - a sequence of bits, created with Kernel.SpecialForms.&lt;&lt;&gt;&gt;/1 . When the number of bits is divisible by 8, they are called binaries and can be manipulated with Erlang's :binary module Reference - a unique value in the runtime system, created with make_ref/0 Data types Elixir also provides other data types that are built on top of the types listed above. Some of them are: Date - year-month-day structs in a given calendar DateTime - date and time with time zone in a given calendar Exception - data raised from errors and unexpected scenarios MapSet - unordered collections of unique elements NaiveDateTime - date and time without time zone in a given calendar Keyword - lists of two-element tuples, often representing optional values Range - inclusive ranges between two integers Regex - regular expressions String - UTF-8 encoded binaries representing characters Time - hour:minute:second structs in a given calendar URI - representation of URIs that identify resources Version - representation of versions and requirements System modules Modules that interface with the underlying system, such as: IO - handles input and output File - interacts with the underlying file system Path - manipulates file system paths System - reads and writes system information Protocols Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See Protocol for more information on protocols. Elixir provides the following protocols in the standard library: Collectable - collects data into a data type Enumerable - handles collections in Elixir. The Enum module provides eager functions for working with collections, the Stream module provides lazy functions Inspect - converts data types into their programming language representation List.Chars - converts data types to their outside world representation as charlists (non-programming based) String.Chars - converts data types to their outside world representation as strings (non-programming based) Process-based and application-centric functionality The following modules build on top of processes to provide concurrency, fault-tolerance, and more. Agent - a process that encapsulates mutable state Application - functions for starting, stopping and configuring applications GenServer - a generic client-server API Registry - a key-value process-based storage Supervisor - a process that is responsible for starting, supervising and shutting down other processes Task - a process that performs computations Task.Supervisor - a supervisor for managing tasks exclusively Supporting documents Elixir documentation also includes supporting documents under the &quot;Pages&quot; section. Those are: Compatibility and deprecations - lists compatibility between every Elixir version and Erlang/OTP, release schema; lists all deprecated functions, when they were deprecated and alternatives Library guidelines - general guidelines, anti-patterns, and rules for those writing libraries Naming conventions - naming conventions for Elixir code Operators - lists all Elixir operators and their precedences Patterns and guards - an introduction to patterns, guards, and extensions Syntax reference - the language syntax reference Typespecs - types and function specifications, including list of types Unicode syntax - outlines Elixir support for Unicode Writing documentation - guidelines for writing documentation in Elixir Guards This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the when operator. For example: def drive ( % User { age : age } ) when age &gt;= 16 do ... end The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with and and or . The whole guard is true if all guard expressions will evaluate to true . A more complete introduction to guards is available in the Patterns and guards page. Truthy and falsy values Besides the booleans true and false , Elixir has the concept of a &quot;truthy&quot; or &quot;falsy&quot; value. a value is truthy when it is neither false nor nil a value is falsy when it is either false or nil Elixir has functions, like and/2 , that only work with booleans, but also functions that work with these truthy/falsy values, like &amp;&amp;/2 and !/1 . Structural comparison The function in this module perform structural comparison. This allows different data types to be compared using comparison operators: iex&gt; 1 &lt; :an_atom true This is possible so Elixir developers can create collections, such as dictionaries and ordered sets, that store a mixture of data types in them. To understand why this matters, let's discuss the two types of comparisons we find in software: structural and semantic . Structural means we are comparing the underlying data structures and we often want those operations to be as fast as possible, because it is used to power several algorithms and data structures in the language. A semantic comparison worries about what each data type represents. For example, semantically speaking, it doesn't make sense to compare Time with Date . One example that shows the differences between structural and semantic comparisons are strings: &quot;alien&quot; sorts less than &quot;office&quot; ( &quot;alien&quot; &lt; &quot;office&quot; ) but &quot;álien&quot; is greater than &quot;office&quot;. This happens because &lt; compares the underlying bytes that form the string. If you were doing alphabetical listing, you may want &quot;álien&quot; to also appear before &quot;office&quot;. This means comparisons in Elixir are structural , as it has the goal of comparing data types as efficiently as possible to create flexible and perform data structures. This distinction is specially important for functions that provide ordering, such as &gt;/2 , &lt;/2 , &gt;=/2 , &lt;=/2 , min/2 , and max/2 . For example: ~D[2017-03-31] &gt; ~D[2017-04-01] will return true because structural comparison compares the :day field before :month or :year . In order to perform semantic comparisons, the relevant data-types provide a compare/2 function, such as Date.compare/2 : iex&gt; Date . compare ( ~D[2017-03-31] , ~D[2017-04-01] ) :lt Alternatively, you can use the functions in the Enum module to sort or compute a maximum/minimum: iex&gt; Enum . sort ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) [ ~D[2017-03-31] , ~D[2017-04-01] ] iex&gt; Enum . max ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-04-01] The second argument is precisely the module to be used for semantic comparison. Keeping this distinction is important, because if semantic comparison was used by default for implementing data structures and algorithms, they could become orders of magnitude slower! Finally, note there is an overall structural sorting order, called &quot;Term Ordering&quot;, defined below. This order is provided for reference purposes, it is not required by Elixir developers to know it by heart. Term ordering number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring When comparing two numbers of different types (a number being either an integer or a float), a conversion to the type with greater precision will always occur, unless the comparison operator used is either ===/2 or !== . A float will be considered more precise than an integer, unless the float is greater/less than +/-9007199254740992.0 respectively, at which point all the significant figures of the float are to the left of the decimal point. This behavior exists so that the comparison of large numbers remains transitive. The collection types are compared using the following rules: Tuples are compared by size, then element by element. Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats. Lists are compared element by element. Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit. Atoms are compared using their string value, codepoint by codepoint. Examples We can check the truthiness of a value by using the !/1 function twice. Truthy values: iex&gt; ! ! true true iex&gt; ! ! 5 true iex&gt; ! ! [ 1 , 2 ] true iex&gt; ! ! &quot;foo&quot; true Falsy values (of which there are exactly two): iex&gt; ! ! false false iex&gt; ! ! nil false Inlining Some of the functions described in this module are inlined by the Elixir compiler into their Erlang counterparts in the :erlang module. Those functions are called BIFs (built-in internal functions) in Erlang-land and they exhibit interesting properties, as some of them are allowed in guards and others are used for compiler optimizations. Most of the inlined functions can be seen in effect when capturing the function: iex&gt; &amp; Kernel . is_atom / 1 &amp; :erlang . is_atom / 1 Those functions will be explicitly marked in their docs as &quot;inlined by the compiler&quot;.","ref":"Kernel.html","source_doc":"`Kernel` is Elixir's default environment.\n\nIt mainly consists of:\n\n  * basic language primitives, such as arithmetic operators, spawning of processes,\n    data type handling, and others\n  * macros for control-flow and defining new functionality (modules, functions, and the like)\n  * guard checks for augmenting pattern matching\n\nYou can invoke `Kernel` functions and macros anywhere in Elixir code\nwithout the use of the `Kernel.` prefix since they have all been\nautomatically imported. For example, in IEx, you can call:\n\n    iex> is_number(13)\n    true\n\nIf you don't want to import a function or macro from `Kernel`, use the `:except`\noption and then list the function/macro by arity:\n\n    import Kernel, except: [if: 2, unless: 2]\n\nSee `Kernel.SpecialForms.import/2` for more information on importing.\n\nElixir also has special forms that are always imported and\ncannot be skipped. These are described in `Kernel.SpecialForms`.\n\n## The standard library\n\n`Kernel` provides the basic capabilities the Elixir standard library\nis built on top of. It is recommended to explore the standard library\nfor advanced functionality. Here are the main groups of modules in the\nstandard library (this list is not a complete reference, see the\ndocumentation sidebar for all entries).\n\n### Built-in types\n\nThe following modules handle Elixir built-in data types:\n\n  * `Atom` - literal constants with a name (`true`, `false`, and `nil` are atoms)\n  * `Float` - numbers with floating point precision\n  * `Function` - a reference to code chunk, created with the `fn/1` special form\n  * `Integer` - whole numbers (not fractions)\n  * `List` - collections of a variable number of elements (linked lists)\n  * `Map` - collections of key-value pairs\n  * `Process` - light-weight threads of execution\n  * `Port` - mechanisms to interact with the external world\n  * `Tuple` - collections of a fixed number of elements\n\nThere are two data types without an accompanying module:\n\n  * Bitstring - a sequence of bits, created with `Kernel.SpecialForms.<<>>/1`.\n    When the number of bits is divisible by 8, they are called binaries and can\n    be manipulated with Erlang's `:binary` module\n  * Reference - a unique value in the runtime system, created with `make_ref/0`\n\n### Data types\n\nElixir also provides other data types that are built on top of the types\nlisted above. Some of them are:\n\n  * `Date` - `year-month-day` structs in a given calendar\n  * `DateTime` - date and time with time zone in a given calendar\n  * `Exception` - data raised from errors and unexpected scenarios\n  * `MapSet` - unordered collections of unique elements\n  * `NaiveDateTime` - date and time without time zone in a given calendar\n  * `Keyword` - lists of two-element tuples, often representing optional values\n  * `Range` - inclusive ranges between two integers\n  * `Regex` - regular expressions\n  * `String` - UTF-8 encoded binaries representing characters\n  * `Time` - `hour:minute:second` structs in a given calendar\n  * `URI` - representation of URIs that identify resources\n  * `Version` - representation of versions and requirements\n\n### System modules\n\nModules that interface with the underlying system, such as:\n\n  * `IO` - handles input and output\n  * `File` - interacts with the underlying file system\n  * `Path` - manipulates file system paths\n  * `System` - reads and writes system information\n\n### Protocols\n\nProtocols add polymorphic dispatch to Elixir. They are contracts\nimplementable by data types. See `Protocol` for more information on\nprotocols. Elixir provides the following protocols in the standard library:\n\n  * `Collectable` - collects data into a data type\n  * `Enumerable` - handles collections in Elixir. The `Enum` module\n    provides eager functions for working with collections, the `Stream`\n    module provides lazy functions\n  * `Inspect` - converts data types into their programming language\n    representation\n  * `List.Chars` - converts data types to their outside world\n    representation as charlists (non-programming based)\n  * `String.Chars` - converts data types to their outside world\n    representation as strings (non-programming based)\n\n### Process-based and application-centric functionality\n\nThe following modules build on top of processes to provide concurrency,\nfault-tolerance, and more.\n\n  * `Agent` - a process that encapsulates mutable state\n  * `Application` - functions for starting, stopping and configuring\n    applications\n  * `GenServer` - a generic client-server API\n  * `Registry` - a key-value process-based storage\n  * `Supervisor` - a process that is responsible for starting,\n    supervising and shutting down other processes\n  * `Task` - a process that performs computations\n  * `Task.Supervisor` - a supervisor for managing tasks exclusively\n\n### Supporting documents\n\nElixir documentation also includes supporting documents under the\n\"Pages\" section. Those are:\n\n  * [Compatibility and deprecations](compatibility-and-deprecations.md) - lists\n    compatibility between every Elixir version and Erlang/OTP, release schema;\n    lists all deprecated functions, when they were deprecated and alternatives\n  * [Library guidelines](library-guidelines.md) - general guidelines, anti-patterns,\n    and rules for those writing libraries\n  * [Naming conventions](naming-conventions.md) - naming conventions for Elixir code\n  * [Operators](operators.md) - lists all Elixir operators and their precedences\n  * [Patterns and guards](patterns-and-guards.md) - an introduction to patterns,\n    guards, and extensions\n  * [Syntax reference](syntax-reference.md) - the language syntax reference\n  * [Typespecs](typespecs.md)- types and function specifications, including list of types\n  * [Unicode syntax](unicode-syntax.md) - outlines Elixir support for Unicode\n  * [Writing documentation](writing-documentation.md) - guidelines for writing\n    documentation in Elixir\n\n## Guards\n\nThis module includes the built-in guards used by Elixir developers.\nThey are a predefined set of functions and macros that augment pattern\nmatching, typically invoked after the `when` operator. For example:\n\n    def drive(%User{age: age}) when age >= 16 do\n      ...\n    end\n\nThe clause above will only be invoked if the user's age is more than\nor equal to 16. Guards also support joining multiple conditions with\n`and` and `or`. The whole guard is true if all guard expressions will\nevaluate to `true`. A more complete introduction to guards is available\nin the [Patterns and guards](patterns-and-guards.md) page.\n\n## Truthy and falsy values\n\nBesides the booleans `true` and `false`, Elixir has the\nconcept of a \"truthy\" or \"falsy\" value.\n\n  *  a value is truthy when it is neither `false` nor `nil`\n  *  a value is falsy when it is either `false` or `nil`\n\nElixir has functions, like `and/2`, that *only* work with\nbooleans, but also functions that work with these\ntruthy/falsy values, like `&&/2` and `!/1`.\n\n## Structural comparison\n\nThe function in this module perform structural comparison. This allows\ndifferent data types to be compared using comparison operators:\n\n```elixir\niex> 1 < :an_atom\ntrue\n```\n\nThis is possible so Elixir developers can create collections, such as\ndictionaries and ordered sets, that store a mixture of data types in them.\nTo understand why this matters, let's discuss the two types of comparisons\nwe find in software: _structural_ and _semantic_.\n\nStructural means we are comparing the underlying data structures and we often\nwant those operations to be as fast as possible, because it is used to power\nseveral algorithms and data structures in the language. A semantic comparison\nworries about what each data type represents. For example, semantically\nspeaking, it doesn't make sense to compare `Time` with `Date`.\n\nOne example that shows the differences between structural and semantic\ncomparisons are strings: \"alien\" sorts less than \"office\" (`\"alien\" < \"office\"`)\nbut \"álien\" is greater than \"office\". This happens because `<` compares the\nunderlying bytes that form the string. If you were doing alphabetical listing,\nyou may want \"álien\" to also appear before \"office\".\n\nThis means **comparisons in Elixir are structural**, as it has the goal\nof comparing data types as efficiently as possible to create flexible\nand perform data structures. This distinction is specially important\nfor functions that provide ordering, such as `>/2`, `</2`, `>=/2`,\n`<=/2`, `min/2`, and `max/2`. For example:\n\n    ~D[2017-03-31] > ~D[2017-04-01]\n\nwill return `true` because structural comparison compares the `:day`\nfield before `:month` or `:year`. In order to perform semantic comparisons,\nthe relevant data-types provide a `compare/2` function, such as\n`Date.compare/2`:\n\n    iex> Date.compare(~D[2017-03-31], ~D[2017-04-01])\n    :lt\n\nAlternatively, you can use the functions in the `Enum` module to\nsort or compute a maximum/minimum:\n\n    iex> Enum.sort([~D[2017-03-31], ~D[2017-04-01]], Date)\n    [~D[2017-03-31], ~D[2017-04-01]]\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]\n\nThe second argument is precisely the module to be used for semantic\ncomparison. Keeping this distinction is important, because if semantic\ncomparison was used by default for implementing data structures and\nalgorithms, they could become orders of magnitude slower!\n\nFinally, note there is an overall structural sorting order, called\n\"Term Ordering\", defined below. This order is provided for reference\npurposes, it is not required by Elixir developers to know it by heart.\n\n### Term ordering\n\n```\nnumber < atom < reference < function < port < pid < tuple < map < list < bitstring\n```\n\nWhen comparing two numbers of different types (a number being either\nan integer or a float), a conversion to the type with greater precision\nwill always occur, unless the comparison operator used is either `===/2`\nor `!==`. A float will be considered more precise than an integer, unless\nthe float is greater/less than +/-9007199254740992.0 respectively,\nat which point all the significant figures of the float are to the left\nof the decimal point. This behavior exists so that the comparison of large\nnumbers remains transitive.\n\nThe collection types are compared using the following rules:\n\n* Tuples are compared by size, then element by element.\n* Maps are compared by size, then by keys in ascending term order,\n  then by values in key order. In the specific case of maps' key\n  ordering, integers are always considered to be less than floats.\n* Lists are compared element by element.\n* Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit.\n* Atoms are compared using their string value, codepoint by codepoint.\n\n### Examples\n\nWe can check the truthiness of a value by using the `!/1`\nfunction twice.\n\nTruthy values:\n\n    iex> !!true\n    true\n    iex> !!5\n    true\n    iex> !![1,2]\n    true\n    iex> !!\"foo\"\n    true\n\nFalsy values (of which there are exactly two):\n\n    iex> !!false\n    false\n    iex> !!nil\n    false\n\n## Inlining\n\nSome of the functions described in this module are inlined by\nthe Elixir compiler into their Erlang counterparts in the\n[`:erlang`](`:erlang`) module.\nThose functions are called BIFs (built-in internal functions)\nin Erlang-land and they exhibit interesting properties, as some\nof them are allowed in guards and others are used for compiler\noptimizations.\n\nMost of the inlined functions can be seen in effect when\ncapturing the function:\n\n    iex> &Kernel.is_atom/1\n    &:erlang.is_atom/1\n\nThose functions will be explicitly marked in their docs as\n\"inlined by the compiler\".\n","title":"Kernel","type":"module"},{"doc":"Boolean &quot;and&quot; operator. Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to a truthy value (neither false nor nil ). Returns the first expression otherwise. Not allowed in guard clauses. Examples iex&gt; Enum . empty? ( [ ] ) &amp;&amp; Enum . empty? ( [ ] ) true iex&gt; List . first ( [ ] ) &amp;&amp; true nil iex&gt; Enum . empty? ( [ ] ) &amp;&amp; List . first ( [ 1 ] ) 1 iex&gt; false &amp;&amp; throw ( :bad ) false Note that, unlike and/2 , this operator accepts any expression as the first argument, not only booleans.","ref":"Kernel.html#&&/2","source_doc":"Boolean \"and\" operator.\n\nProvides a short-circuit operator that evaluates and returns\nthe second expression only if the first one evaluates to a truthy value\n(neither `false` nor `nil`). Returns the first expression\notherwise.\n\nNot allowed in guard clauses.\n\n## Examples\n\n    iex> Enum.empty?([]) && Enum.empty?([])\n    true\n\n    iex> List.first([]) && true\n    nil\n\n    iex> Enum.empty?([]) && List.first([1])\n    1\n\n    iex> false && throw(:bad)\n    false\n\nNote that, unlike `and/2`, this operator accepts any expression\nas the first argument, not only booleans.\n","title":"Kernel.&&/2","type":"macro"},{"doc":"Power operator. It takes two numbers for input. If both are integers and the right-hand side (the exponent ) is also greater than or equal to 0, then the result will also be an integer. Otherwise it returns a float. Examples iex&gt; 2 * * 2 4 iex&gt; 2 * * - 4 0.0625 iex&gt; 2.0 * * 2 4.0 iex&gt; 2 * * 2.0 4.0","ref":"Kernel.html#**/2","source_doc":"Power operator.\n\nIt takes two numbers for input. If both are integers and the right-hand\nside (the `exponent`) is also greater than or equal to 0, then the result\nwill also be an integer. Otherwise it returns a float.\n\n## Examples\n\n    iex> 2 ** 2\n    4\n    iex> 2 ** -4\n    0.0625\n\n    iex> 2.0 ** 2\n    4.0\n    iex> 2 ** 2.0\n    4.0\n\n","title":"Kernel.**/2","type":"function"},{"doc":"Arithmetic multiplication operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 * 2 2","ref":"Kernel.html#*/2","source_doc":"Arithmetic multiplication operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 * 2\n    2\n\n","title":"Kernel.*/2","type":"function"},{"doc":"List concatenation operator. Concatenates a proper list and a term, returning a list. The complexity of a ++ b is proportional to length(a) , so avoid repeatedly appending to lists of arbitrary length, for example, list ++ [element] . Instead, consider prepending via [element | rest] and then reversing. If the right operand is not a proper list, it returns an improper list. If the left operand is not a proper list, it raises ArgumentError . Inlined by the compiler. Examples iex&gt; [ 1 ] ++ [ 2 , 3 ] [ 1 , 2 , 3 ] iex&gt; ~c&quot;foo&quot; ++ ~c&quot;bar&quot; ~c&quot;foobar&quot; # a non-list on the right will return an improper list # with said element at the end iex&gt; [ 1 , 2 ] ++ 3 [ 1 , 2 | 3 ] iex&gt; [ 1 , 2 ] ++ { 3 , 4 } [ 1 , 2 | { 3 , 4 } ] # improper list on the right will return an improper list iex&gt; [ 1 ] ++ [ 2 | 3 ] [ 1 , 2 | 3 ] The ++/2 operator is right associative, meaning: iex&gt; [ 1 , 2 , 3 ] -- [ 1 ] ++ [ 2 ] [ 3 ] As it is equivalent to: iex&gt; [ 1 , 2 , 3 ] -- ( [ 1 ] ++ [ 2 ] ) [ 3 ]","ref":"Kernel.html#++/2","source_doc":"List concatenation operator. Concatenates a proper list and a term, returning a list.\n\nThe complexity of `a ++ b` is proportional to `length(a)`, so avoid repeatedly\nappending to lists of arbitrary length, for example, `list ++ [element]`.\nInstead, consider prepending via `[element | rest]` and then reversing.\n\nIf the `right` operand is not a proper list, it returns an improper list.\nIf the `left` operand is not a proper list, it raises `ArgumentError`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1] ++ [2, 3]\n    [1, 2, 3]\n\n    iex> ~c\"foo\" ++ ~c\"bar\"\n    ~c\"foobar\"\n\n    # a non-list on the right will return an improper list\n    # with said element at the end\n    iex> [1, 2] ++ 3\n    [1, 2 | 3]\n    iex> [1, 2] ++ {3, 4}\n    [1, 2 | {3, 4}]\n\n    # improper list on the right will return an improper list\n    iex> [1] ++ [2 | 3]\n    [1, 2 | 3]\n\nThe `++/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [1] ++ [2]\n    [3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([1] ++ [2])\n    [3]\n\n","title":"Kernel.++/2","type":"function"},{"doc":"Arithmetic positive unary operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; + 1 1","ref":"Kernel.html#+/1","source_doc":"Arithmetic positive unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> +1\n    1\n\n","title":"Kernel.+/1","type":"function"},{"doc":"Arithmetic addition operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 + 2 3","ref":"Kernel.html#+/2","source_doc":"Arithmetic addition operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 + 2\n    3\n\n","title":"Kernel.+/2","type":"function"},{"doc":"List subtraction operator. Removes the first occurrence of an element on the left list for each element on the right. This function is optimized so the complexity of a -- b is proportional to length(a) * log(length(b)) . See also the Erlang efficiency guide . Inlined by the compiler. Examples iex&gt; [ 1 , 2 , 3 ] -- [ 1 , 2 ] [ 3 ] iex&gt; [ 1 , 2 , 3 , 2 , 1 ] -- [ 1 , 2 , 2 ] [ 3 , 1 ] The --/2 operator is right associative, meaning: iex&gt; [ 1 , 2 , 3 ] -- [ 2 ] -- [ 3 ] [ 1 , 3 ] As it is equivalent to: iex&gt; [ 1 , 2 , 3 ] -- ( [ 2 ] -- [ 3 ] ) [ 1 , 3 ]","ref":"Kernel.html#--/2","source_doc":"List subtraction operator. Removes the first occurrence of an element\non the left list for each element on the right.\n\nThis function is optimized so the complexity of `a -- b` is proportional\nto `length(a) * log(length(b))`. See also the [Erlang efficiency\nguide](https://www.erlang.org/doc/efficiency_guide/retired_myths.html).\n\nInlined by the compiler.\n\n## Examples\n\n    iex> [1, 2, 3] -- [1, 2]\n    [3]\n\n    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n    [3, 1]\n\nThe `--/2` operator is right associative, meaning:\n\n    iex> [1, 2, 3] -- [2] -- [3]\n    [1, 3]\n\nAs it is equivalent to:\n\n    iex> [1, 2, 3] -- ([2] -- [3])\n    [1, 3]\n\n","title":"Kernel.--/2","type":"function"},{"doc":"Arithmetic negative unary operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; - 2 - 2","ref":"Kernel.html#-/1","source_doc":"Arithmetic negative unary operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> -2\n    -2\n\n","title":"Kernel.-/1","type":"function"},{"doc":"Arithmetic subtraction operator. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 - 2 - 1","ref":"Kernel.html#-/2","source_doc":"Arithmetic subtraction operator.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 - 2\n    -1\n\n","title":"Kernel.-/2","type":"function"},{"doc":"Creates the full-slice range 0..-1//1 . This macro returns a range with the following properties: When enumerated, it is empty When used as a slice , it returns the sliced element as is See ..///3 and the Range module for more information. Examples iex&gt; Enum . to_list ( .. ) [ ] iex&gt; String . slice ( &quot;Hello world!&quot; , .. ) &quot;Hello world!&quot;","ref":"Kernel.html#../0","source_doc":"Creates the full-slice range `0..-1//1`.\n\nThis macro returns a range with the following properties:\n\n  * When enumerated, it is empty\n\n  * When used as a `slice`, it returns the sliced element as is\n\nSee `..///3` and the `Range` module for more information.\n\n## Examples\n\n    iex> Enum.to_list(..)\n    []\n\n    iex> String.slice(\"Hello world!\", ..)\n    \"Hello world!\"\n\n","title":"Kernel.../0","type":"macro"},{"doc":"Creates a range from first to last . If first is less than last, the range will be increasing from first to last. If first is equal to last, the range will contain one element, which is the number itself. If first is more than last, the range will be decreasing from first to last, albeit this behaviour is deprecated. Instead prefer to explicitly list the step with first..last//-1 . See the Range module for more information. Examples iex&gt; 0 in 1 .. 3 false iex&gt; 2 in 1 .. 3 true iex&gt; Enum . to_list ( 1 .. 3 ) [ 1 , 2 , 3 ]","ref":"Kernel.html#../2","source_doc":"Creates a range from `first` to `last`.\n\nIf first is less than last, the range will be increasing from\nfirst to last. If first is equal to last, the range will contain\none element, which is the number itself.\n\nIf first is more than last, the range will be decreasing from first\nto last, albeit this behaviour is deprecated. Instead prefer to\nexplicitly list the step with `first..last//-1`.\n\nSee the `Range` module for more information.\n\n## Examples\n\n    iex> 0 in 1..3\n    false\n    iex> 2 in 1..3\n    true\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n\n","title":"Kernel.../2","type":"macro"},{"doc":"Creates a range from first to last with step . See the Range module for more information. Examples iex&gt; 0 in 1 .. 3 // 1 false iex&gt; 2 in 1 .. 3 // 1 true iex&gt; 2 in 1 .. 3 // 2 false iex&gt; Enum . to_list ( 1 .. 3 // 1 ) [ 1 , 2 , 3 ] iex&gt; Enum . to_list ( 1 .. 3 // 2 ) [ 1 , 3 ] iex&gt; Enum . to_list ( 3 .. 1 // - 1 ) [ 3 , 2 , 1 ] iex&gt; Enum . to_list ( 1 .. 0 // 1 ) [ ]","ref":"Kernel.html#..///3","source_doc":"Creates a range from `first` to `last` with `step`.\n\nSee the `Range` module for more information.\n\n## Examples\n\n    iex> 0 in 1..3//1\n    false\n    iex> 2 in 1..3//1\n    true\n    iex> 2 in 1..3//2\n    false\n\n    iex> Enum.to_list(1..3//1)\n    [1, 2, 3]\n    iex> Enum.to_list(1..3//2)\n    [1, 3]\n    iex> Enum.to_list(3..1//-1)\n    [3, 2, 1]\n    iex> Enum.to_list(1..0//1)\n    []\n\n","title":"Kernel...///3","type":"macro"},{"doc":"Arithmetic division operator. The result is always a float. Use div/2 and rem/2 if you want an integer division or the remainder. Raises ArithmeticError if right is 0 or 0.0. Allowed in guard tests. Inlined by the compiler. Examples 1 / 2 #=&gt; 0.5 - 3.0 / 2.0 #=&gt; -1.5 5 / 1 #=&gt; 5.0 7 / 0 ** (ArithmeticError) bad argument in arithmetic expression","ref":"Kernel.html#//2","source_doc":"Arithmetic division operator.\n\nThe result is always a float. Use `div/2` and `rem/2` if you want\nan integer division or the remainder.\n\nRaises `ArithmeticError` if `right` is 0 or 0.0.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    1 / 2\n    #=> 0.5\n\n    -3.0 / 2.0\n    #=> -1.5\n\n    5 / 1\n    #=> 5.0\n\n    7 / 0\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n","title":"Kernel.//2","type":"function"},{"doc":"Boolean &quot;not&quot; operator. Receives any value (not just booleans) and returns true if value is false or nil ; returns false otherwise. Not allowed in guard clauses. Examples iex&gt; ! Enum . empty? ( [ ] ) false iex&gt; ! List . first ( [ ] ) true","ref":"Kernel.html#!/1","source_doc":"Boolean \"not\" operator.\n\nReceives any value (not just booleans) and returns `true` if `value`\nis `false` or `nil`; returns `false` otherwise.\n\nNot allowed in guard clauses.\n\n## Examples\n\n    iex> !Enum.empty?([])\n    false\n\n    iex> !List.first([])\n    true\n\n","title":"Kernel.!/1","type":"macro"},{"doc":"Not equal to operator. Returns true if the two terms are not equal. This operator considers 1 and 1.0 to be equal. For match comparison, use !==/2 instead. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 != 2 true iex&gt; 1 != 1.0 false","ref":"Kernel.html#!=/2","source_doc":"Not equal to operator.\n\nReturns `true` if the two terms are not equal.\n\nThis operator considers 1 and 1.0 to be equal. For match\ncomparison, use `!==/2` instead.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 != 2\n    true\n\n    iex> 1 != 1.0\n    false\n\n","title":"Kernel.!=/2","type":"function"},{"doc":"Strictly not equal to operator. Returns true if the two terms are not exactly equal. See ===/2 for a definition of what is considered &quot;exactly equal&quot;. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 !== 2 true iex&gt; 1 !== 1.0 true","ref":"Kernel.html#!==/2","source_doc":"Strictly not equal to operator.\n\nReturns `true` if the two terms are not exactly equal.\nSee `===/2` for a definition of what is considered \"exactly equal\".\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 !== 2\n    true\n\n    iex> 1 !== 1.0\n    true\n\n","title":"Kernel.!==/2","type":"function"},{"doc":"Less-than operator. Returns true if left is less than right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &lt; 2 true","ref":"Kernel.html#%3C/2","source_doc":"Less-than operator.\n\nReturns `true` if `left` is less than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 < 2\n    true\n\n","title":"Kernel.</2","type":"function"},{"doc":"Less-than or equal to operator. Returns true if left is less than or equal to right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &lt;= 2 true","ref":"Kernel.html#%3C=/2","source_doc":"Less-than or equal to operator.\n\nReturns `true` if `left` is less than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <= 2\n    true\n\n","title":"Kernel.<=/2","type":"function"},{"doc":"Binary concatenation operator. Concatenates two binaries. Raises an ArgumentError if one of the sides aren't binaries. Examples iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot; &quot;foobar&quot; The &lt;&gt;/2 operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary: iex&gt; &quot;foo&quot; &lt;&gt; x = &quot;foobar&quot; iex&gt; x &quot;bar&quot; x &lt;&gt; &quot;bar&quot; = &quot;foobar&quot; would result in an ArgumentError exception.","ref":"Kernel.html#%3C%3E/2","source_doc":"Binary concatenation operator. Concatenates two binaries.\n\nRaises an `ArgumentError` if one of the sides aren't binaries.\n\n## Examples\n\n    iex> \"foo\" <> \"bar\"\n    \"foobar\"\n\nThe `<>/2` operator can also be used in pattern matching (and guard clauses) as\nlong as the left argument is a literal binary:\n\n    iex> \"foo\" <> x = \"foobar\"\n    iex> x\n    \"bar\"\n\n`x <> \"bar\" = \"foobar\"` would result in an `ArgumentError` exception.\n\n","title":"Kernel.<>/2","type":"macro"},{"doc":"Equal to operator. Returns true if the two terms are equal. This operator considers 1 and 1.0 to be equal. For stricter semantics, use ===/2 instead. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 == 2 false iex&gt; 1 == 1.0 true","ref":"Kernel.html#==/2","source_doc":"Equal to operator. Returns `true` if the two terms are equal.\n\nThis operator considers 1 and 1.0 to be equal. For stricter\nsemantics, use `===/2` instead.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 == 2\n    false\n\n    iex> 1 == 1.0\n    true\n\n","title":"Kernel.==/2","type":"function"},{"doc":"Strictly equal to operator. Returns true if the two terms are exactly equal. The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, 1 == 1.0 returns true , but since they are of different types, 1 === 1.0 returns false . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 === 2 false iex&gt; 1 === 1.0 false","ref":"Kernel.html#===/2","source_doc":"Strictly equal to operator.\n\nReturns `true` if the two terms are exactly equal.\n\nThe terms are only considered to be exactly equal if they\nhave the same value and are of the same type. For example,\n`1 == 1.0` returns `true`, but since they are of different\ntypes, `1 === 1.0` returns `false`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 === 2\n    false\n\n    iex> 1 === 1.0\n    false\n\n","title":"Kernel.===/2","type":"function"},{"doc":"Text-based match operator. Matches the term on the left against the regular expression or string on the right . If right is a regular expression, returns true if left matches right. If right is a string, returns true if left contains right . Examples iex&gt; &quot;abcd&quot; =~ ~r/c(d)/ true iex&gt; &quot;abcd&quot; =~ ~r/e/ false iex&gt; &quot;abcd&quot; =~ ~r// true iex&gt; &quot;abcd&quot; =~ &quot;bc&quot; true iex&gt; &quot;abcd&quot; =~ &quot;ad&quot; false iex&gt; &quot;abcd&quot; =~ &quot;abcd&quot; true iex&gt; &quot;abcd&quot; =~ &quot;&quot; true For more information about regular expressions, please check the Regex module.","ref":"Kernel.html#=~/2","source_doc":"Text-based match operator. Matches the term on the `left`\nagainst the regular expression or string on the `right`.\n\nIf `right` is a regular expression, returns `true` if `left` matches right.\n\nIf `right` is a string, returns `true` if `left` contains `right`.\n\n## Examples\n\n    iex> \"abcd\" =~ ~r/c(d)/\n    true\n\n    iex> \"abcd\" =~ ~r/e/\n    false\n\n    iex> \"abcd\" =~ ~r//\n    true\n\n    iex> \"abcd\" =~ \"bc\"\n    true\n\n    iex> \"abcd\" =~ \"ad\"\n    false\n\n    iex> \"abcd\" =~ \"abcd\"\n    true\n\n    iex> \"abcd\" =~ \"\"\n    true\n\nFor more information about regular expressions, please check the `Regex` module.\n","title":"Kernel.=~/2","type":"function"},{"doc":"Greater-than operator. Returns true if left is more than right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &gt; 2 false","ref":"Kernel.html#%3E/2","source_doc":"Greater-than operator.\n\nReturns `true` if `left` is more than `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 > 2\n    false\n\n","title":"Kernel.>/2","type":"function"},{"doc":"Greater-than or equal to operator. Returns true if left is more than or equal to right . This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &gt;= 2 false","ref":"Kernel.html#%3E=/2","source_doc":"Greater-than or equal to operator.\n\nReturns `true` if `left` is more than or equal to `right`.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >= 2\n    false\n\n","title":"Kernel.>=/2","type":"function"},{"doc":"Module attribute unary operator. Reads and writes attributes in the current module. The canonical example for attributes is annotating that a module implements an OTP behaviour, such as GenServer : defmodule MyServer do @behaviour GenServer # ... callbacks ... end By default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well: defmodule MyServer do @my_data 13 IO . inspect ( @my_data ) #=&gt; 13 end Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using Module.register_attribute/3 . Prefixing module attributes Libraries and frameworks should consider prefixing any module attributes that are private by underscore, such as @_my_data , so code completion tools do not show them on suggestions and prompts. Finally, note that attributes can also be read inside functions: defmodule MyServer do @my_data 11 def first_data , do : @my_data @my_data 13 def second_data , do : @my_data end MyServer . first_data ( ) #=&gt; 11 MyServer . second_data ( ) #=&gt; 13 It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the Module module for other functions to manipulate module attributes. Attention! Multiple references of the same attribute As mentioned above, every time you read a module attribute, a snapshot of its current value is taken. Therefore, if you are storing large values inside module attributes (for example, embedding external files in module attributes), you should avoid referencing the same attribute multiple times. For example, don't do this: @files %{ example1 : File . read! ( &quot;lib/example1.data&quot; ) , example2 : File . read! ( &quot;lib/example2.data&quot; ) } def example1 , do : @files [ :example1 ] def example2 , do : @files [ :example2 ] In the above, each reference to @files may end-up with a complete and individual copy of the whole @files module attribute. Instead, reference the module attribute once in a private function: @files %{ example1 : File . read! ( &quot;lib/example1.data&quot; ) , example2 : File . read! ( &quot;lib/example2.data&quot; ) } defp files ( ) , do : @files def example1 , do : files ( ) [ :example1 ] def example2 , do : files ( ) [ :example2 ] Attention! Compile-time dependencies Keep in mind references to other modules, even in module attributes, generate compile-time dependencies to said modules. For example, take this common pattern: @values [ :foo , :bar , :baz ] def handle_arg ( arg ) when arg in @values do ... end While the above is fine, imagine if instead you have actual module names in the module attribute, like this: @values [ Foo , Bar , Baz ] def handle_arg ( arg ) when arg in @values do ... end The code above will define a compile-time dependency on the modules Foo , Bar , and Baz , in a way that, if any of them change, the current module will have to recompile. In such cases, it may be preferred to avoid the module attribute altogether: def handle_arg ( arg ) when arg in [ Foo , Bar , Baz ] do ... end","ref":"Kernel.html#@/1","source_doc":"Module attribute unary operator.\n\nReads and writes attributes in the current module.\n\nThe canonical example for attributes is annotating that a module\nimplements an OTP behaviour, such as `GenServer`:\n\n    defmodule MyServer do\n      @behaviour GenServer\n      # ... callbacks ...\n    end\n\nBy default Elixir supports all the module attributes supported by Erlang, but\ncustom attributes can be used as well:\n\n    defmodule MyServer do\n      @my_data 13\n      IO.inspect(@my_data)\n      #=> 13\n    end\n\nUnlike Erlang, such attributes are not stored in the module by default since\nit is common in Elixir to use custom attributes to store temporary data that\nwill be available at compile-time. Custom attributes may be configured to\nbehave closer to Erlang by using `Module.register_attribute/3`.\n\n> #### Prefixing module attributes {: .tip}\n>\n> Libraries and frameworks should consider prefixing any\n> module attributes that are private by underscore, such as `@_my_data`,\n> so code completion tools do not show them on suggestions and prompts.\n\nFinally, note that attributes can also be read inside functions:\n\n    defmodule MyServer do\n      @my_data 11\n      def first_data, do: @my_data\n      @my_data 13\n      def second_data, do: @my_data\n    end\n\n    MyServer.first_data()\n    #=> 11\n\n    MyServer.second_data()\n    #=> 13\n\nIt is important to note that reading an attribute takes a snapshot of\nits current value. In other words, the value is read at compilation\ntime and not at runtime. Check the `Module` module for other functions\nto manipulate module attributes.\n\n## Attention! Multiple references of the same attribute\n\nAs mentioned above, every time you read a module attribute, a snapshot\nof its current value is taken. Therefore, if you are storing large\nvalues inside module attributes (for example, embedding external files\nin module attributes), you should avoid referencing the same attribute\nmultiple times. For example, don't do this:\n\n    @files %{\n      example1: File.read!(\"lib/example1.data\"),\n      example2: File.read!(\"lib/example2.data\")\n    }\n\n    def example1, do: @files[:example1]\n    def example2, do: @files[:example2]\n\nIn the above, each reference to `@files` may end-up with a complete\nand individual copy of the whole `@files` module attribute. Instead,\nreference the module attribute once in a private function:\n\n    @files %{\n      example1: File.read!(\"lib/example1.data\"),\n      example2: File.read!(\"lib/example2.data\")\n    }\n\n    defp files(), do: @files\n    def example1, do: files()[:example1]\n    def example2, do: files()[:example2]\n\n## Attention! Compile-time dependencies\n\nKeep in mind references to other modules, even in module attributes,\ngenerate compile-time dependencies to said modules.\n\nFor example, take this common pattern:\n\n    @values [:foo, :bar, :baz]\n\n    def handle_arg(arg) when arg in @values do\n      ...\n    end\n\nWhile the above is fine, imagine if instead you have actual\nmodule names in the module attribute, like this:\n\n    @values [Foo, Bar, Baz]\n\n    def handle_arg(arg) when arg in @values do\n      ...\n    end\n\nThe code above will define a compile-time dependency on the modules\n`Foo`, `Bar`, and `Baz`, in a way that, if any of them change, the\ncurrent module will have to recompile. In such cases, it may be\npreferred to avoid the module attribute altogether:\n\n    def handle_arg(arg) when arg in [Foo, Bar, Baz] do\n      ...\n    end\n\n","title":"Kernel.@/1","type":"macro"},{"doc":"Returns an integer or float which is the arithmetical absolute value of number . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; abs ( - 3.33 ) 3.33 iex&gt; abs ( - 3 ) 3","ref":"Kernel.html#abs/1","source_doc":"Returns an integer or float which is the arithmetical absolute value of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> abs(-3.33)\n    3.33\n\n    iex> abs(-3)\n    3\n\n","title":"Kernel.abs/1","type":"function"},{"doc":"When used inside quoting, marks that the given alias should not be hygienized. This means the alias will be expanded when the macro is expanded. Check Kernel.SpecialForms.quote/2 for more information.","ref":"Kernel.html#alias!/1","source_doc":"When used inside quoting, marks that the given alias should not\nbe hygienized. This means the alias will be expanded when\nthe macro is expanded.\n\nCheck `Kernel.SpecialForms.quote/2` for more information.\n","title":"Kernel.alias!/1","type":"macro"},{"doc":"Strictly boolean &quot;and&quot; operator. If left is false , returns false ; otherwise returns right . Requires only the left operand to be a boolean since it short-circuits. If the left operand is not a boolean, a BadBooleanError exception is raised. Allowed in guard tests. Examples iex&gt; true and false false iex&gt; true and &quot;yay!&quot; &quot;yay!&quot; iex&gt; &quot;yay!&quot; and true ** (BadBooleanError) expected a boolean on left-side of &quot;and&quot;, got: &quot;yay!&quot;","ref":"Kernel.html#and/2","source_doc":"Strictly boolean \"and\" operator.\n\nIf `left` is `false`, returns `false`; otherwise returns `right`.\n\nRequires only the `left` operand to be a boolean since it short-circuits. If\nthe `left` operand is not a boolean, a `BadBooleanError` exception is raised.\n\nAllowed in guard tests.\n\n## Examples\n\n    iex> true and false\n    false\n\n    iex> true and \"yay!\"\n    \"yay!\"\n\n    iex> \"yay!\" and true\n    ** (BadBooleanError) expected a boolean on left-side of \"and\", got: \"yay!\"\n\n","title":"Kernel.and/2","type":"macro"},{"doc":"Invokes the given anonymous function fun with the list of arguments args . If the number of arguments is known at compile time, prefer fun.(arg_1, arg_2, ..., arg_n) as it is clearer than apply(fun, [arg_1, arg_2, ..., arg_n]) . Inlined by the compiler. Examples iex&gt; apply ( fn x -&gt; x * 2 end , [ 2 ] ) 4","ref":"Kernel.html#apply/2","source_doc":"Invokes the given anonymous function `fun` with the list of\narguments `args`.\n\nIf the number of arguments is known at compile time, prefer\n`fun.(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(fun, [arg_1, arg_2, ..., arg_n])`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(fn x -> x * 2 end, [2])\n    4\n\n","title":"Kernel.apply/2","type":"function"},{"doc":"Invokes the given function from module with the list of arguments args . apply/3 is used to invoke functions where the module, function name or arguments are defined dynamically at runtime. For this reason, you can't invoke macros using apply/3 , only functions. If the number of arguments and the function name are known at compile time, prefer module.function(arg_1, arg_2, ..., arg_n) as it is clearer than apply(module, :function, [arg_1, arg_2, ..., arg_n]) . apply/3 cannot be used to call private functions. Inlined by the compiler. Examples iex&gt; apply ( Enum , :reverse , [ [ 1 , 2 , 3 ] ] ) [ 3 , 2 , 1 ]","ref":"Kernel.html#apply/3","source_doc":"Invokes the given function from `module` with the list of\narguments `args`.\n\n`apply/3` is used to invoke functions where the module, function\nname or arguments are defined dynamically at runtime. For this\nreason, you can't invoke macros using `apply/3`, only functions.\n\nIf the number of arguments and the function name are known at compile time,\nprefer `module.function(arg_1, arg_2, ..., arg_n)` as it is clearer than\n`apply(module, :function, [arg_1, arg_2, ..., arg_n])`.\n\n`apply/3` cannot be used to call private functions.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> apply(Enum, :reverse, [[1, 2, 3]])\n    [3, 2, 1]\n\n","title":"Kernel.apply/3","type":"function"},{"doc":"Extracts the part of the binary starting at start with length length . Binaries are zero-indexed. If start or length reference in any way outside the binary, an ArgumentError exception is raised. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; binary_part ( &quot;foo&quot; , 1 , 2 ) &quot;oo&quot; A negative length can be used to extract bytes that come before the byte at start : iex&gt; binary_part ( &quot;Hello&quot; , 5 , - 3 ) &quot;llo&quot; An ArgumentError is raised when the length is outside of the binary: binary_part ( &quot;Hello&quot; , 0 , 10 ) ** (ArgumentError) argument error","ref":"Kernel.html#binary_part/3","source_doc":"Extracts the part of the binary starting at `start` with length `length`.\nBinaries are zero-indexed.\n\nIf `start` or `length` reference in any way outside the binary, an\n`ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> binary_part(\"foo\", 1, 2)\n    \"oo\"\n\nA negative `length` can be used to extract bytes that come *before* the byte\nat `start`:\n\n    iex> binary_part(\"Hello\", 5, -3)\n    \"llo\"\n\nAn `ArgumentError` is raised when the length is outside of the binary:\n\n    binary_part(\"Hello\", 0, 10)\n    ** (ArgumentError) argument error\n\n","title":"Kernel.binary_part/3","type":"function"},{"doc":"Returns a binary from the offset given by the start of the range to the offset given by the end of the range. If the start or end of the range are negative, they are converted into positive indices based on the binary size. For example, -1 means the last byte of the binary. This is similar to binary_part/3 except that it works with ranges and it is not allowed in guards. This function works with bytes. For a slicing operation that considers characters, see String.slice/2 . Examples iex&gt; binary_slice ( &quot;elixir&quot; , 0 .. 5 ) &quot;elixir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , 1 .. 3 ) &quot;lix&quot; iex&gt; binary_slice ( &quot;elixir&quot; , 1 .. 10 ) &quot;lixir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , - 4 .. - 1 ) &quot;ixir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , - 4 .. 6 ) &quot;ixir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , - 10 .. 10 ) &quot;elixir&quot; For ranges where start &gt; stop , you need to explicitly mark them as increasing: iex&gt; binary_slice ( &quot;elixir&quot; , 2 .. - 1 // 1 ) &quot;ixir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , 1 .. - 2 // 1 ) &quot;lixi&quot; You can use ../0 as a shortcut for 0..-1//1 , which returns the whole binary as is: iex&gt; binary_slice ( &quot;elixir&quot; , .. ) &quot;elixir&quot; The step can be any positive number. For example, to get every 2 characters of the binary: iex&gt; binary_slice ( &quot;elixir&quot; , 0 .. - 1 // 2 ) &quot;eii&quot; If the first position is after the string ends or after the last position of the range, it returns an empty string: iex&gt; binary_slice ( &quot;elixir&quot; , 10 .. 3 // 1 ) &quot;&quot; iex&gt; binary_slice ( &quot;elixir&quot; , - 10 .. - 7 ) &quot;&quot; iex&gt; binary_slice ( &quot;a&quot; , 1 .. 1500 ) &quot;&quot;","ref":"Kernel.html#binary_slice/2","source_doc":"Returns a binary from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start or end of the range are negative, they are converted\ninto positive indices based on the binary size. For example,\n`-1` means the last byte of the binary.\n\nThis is similar to `binary_part/3` except that it works with ranges\nand it is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/2`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0..5)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> binary_slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> binary_slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", -10..10)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> binary_slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> binary_slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole binary as is:\n\n    iex> binary_slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the binary:\n\n    iex> binary_slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> binary_slice(\"elixir\", 10..3//1)\n    \"\"\n    iex> binary_slice(\"elixir\", -10..-7)\n    \"\"\n    iex> binary_slice(\"a\", 1..1500)\n    \"\"\n\n","title":"Kernel.binary_slice/2","type":"function"},{"doc":"Returns a binary starting at the offset start and of the given size . This is similar to binary_part/3 except that if start + size is greater than the binary size, it automatically clips it to the binary size instead of raising. Opposite to binary_part/3 , this function is not allowed in guards. This function works with bytes. For a slicing operation that considers characters, see String.slice/3 . Examples iex&gt; binary_slice ( &quot;elixir&quot; , 0 , 6 ) &quot;elixir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , 0 , 5 ) &quot;elixi&quot; iex&gt; binary_slice ( &quot;elixir&quot; , 1 , 4 ) &quot;lixi&quot; iex&gt; binary_slice ( &quot;elixir&quot; , 0 , 10 ) &quot;elixir&quot; If start is negative, it is normalized against the binary size and clamped to 0: iex&gt; binary_slice ( &quot;elixir&quot; , - 3 , 10 ) &quot;xir&quot; iex&gt; binary_slice ( &quot;elixir&quot; , - 10 , 10 ) &quot;elixir&quot; If the size is zero, an empty binary is returned: iex&gt; binary_slice ( &quot;elixir&quot; , 1 , 0 ) &quot;&quot; If start is greater than or equal to the binary size, an empty binary is returned: iex&gt; binary_slice ( &quot;elixir&quot; , 10 , 10 ) &quot;&quot;","ref":"Kernel.html#binary_slice/3","source_doc":"Returns a binary starting at the offset `start` and of the given `size`.\n\nThis is similar to `binary_part/3` except that if `start + size`\nis greater than the binary size, it automatically clips it to\nthe binary size instead of raising. Opposite to `binary_part/3`,\nthis function is not allowed in guards.\n\nThis function works with bytes. For a slicing operation that\nconsiders characters, see `String.slice/3`.\n\n## Examples\n\n    iex> binary_slice(\"elixir\", 0, 6)\n    \"elixir\"\n    iex> binary_slice(\"elixir\", 0, 5)\n    \"elixi\"\n    iex> binary_slice(\"elixir\", 1, 4)\n    \"lixi\"\n    iex> binary_slice(\"elixir\", 0, 10)\n    \"elixir\"\n\nIf `start` is negative, it is normalized against the binary\nsize and clamped to 0:\n\n    iex> binary_slice(\"elixir\", -3, 10)\n    \"xir\"\n    iex> binary_slice(\"elixir\", -10, 10)\n    \"elixir\"\n\nIf the `size` is zero, an empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 1, 0)\n    \"\"\n\nIf `start` is greater than or equal to the binary size,\nan empty binary is returned:\n\n    iex> binary_slice(\"elixir\", 10, 10)\n    \"\"\n\n","title":"Kernel.binary_slice/3","type":"function"},{"doc":"Returns the binding for the given context as a keyword list. In the returned result, keys are variable names and values are the corresponding variable values. If the given context is nil (by default it is), the binding for the current context is returned. Examples iex&gt; x = 1 iex&gt; binding ( ) [ x : 1 ] iex&gt; x = 2 iex&gt; binding ( ) [ x : 2 ] iex&gt; binding ( :foo ) [ ] iex&gt; var! ( x , :foo ) = 1 1 iex&gt; binding ( :foo ) [ x : 1 ]","ref":"Kernel.html#binding/1","source_doc":"Returns the binding for the given context as a keyword list.\n\nIn the returned result, keys are variable names and values are the\ncorresponding variable values.\n\nIf the given `context` is `nil` (by default it is), the binding for the\ncurrent context is returned.\n\n## Examples\n\n    iex> x = 1\n    iex> binding()\n    [x: 1]\n    iex> x = 2\n    iex> binding()\n    [x: 2]\n\n    iex> binding(:foo)\n    []\n    iex> var!(x, :foo) = 1\n    1\n    iex> binding(:foo)\n    [x: 1]\n\n","title":"Kernel.binding/1","type":"macro"},{"doc":"Returns an integer which is the size in bits of bitstring . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bit_size ( &lt;&lt; 433 :: 16 , 3 :: 3 &gt;&gt; ) 19 iex&gt; bit_size ( &lt;&lt; 1 , 2 , 3 &gt;&gt; ) 24","ref":"Kernel.html#bit_size/1","source_doc":"Returns an integer which is the size in bits of `bitstring`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bit_size(<<433::16, 3::3>>)\n    19\n\n    iex> bit_size(<<1, 2, 3>>)\n    24\n\n","title":"Kernel.bit_size/1","type":"function"},{"doc":"Returns the number of bytes needed to contain bitstring . That is, if the number of bits in bitstring is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; byte_size ( &lt;&lt; 433 :: 16 , 3 :: 3 &gt;&gt; ) 3 iex&gt; byte_size ( &lt;&lt; 1 , 2 , 3 &gt;&gt; ) 3","ref":"Kernel.html#byte_size/1","source_doc":"Returns the number of bytes needed to contain `bitstring`.\n\nThat is, if the number of bits in `bitstring` is not divisible by 8, the\nresulting number of bytes will be rounded up (by excess). This operation\nhappens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> byte_size(<<433::16, 3::3>>)\n    3\n\n    iex> byte_size(<<1, 2, 3>>)\n    3\n\n","title":"Kernel.byte_size/1","type":"function"},{"doc":"Returns the smallest integer greater than or equal to number . If you want to perform ceil operation on other decimal places, use Float.ceil/2 instead. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; ceil ( 10 ) 10 iex&gt; ceil ( 10.1 ) 11 iex&gt; ceil ( - 10.1 ) - 10","ref":"Kernel.html#ceil/1","source_doc":"Returns the smallest integer greater than or equal to `number`.\n\nIf you want to perform ceil operation on other decimal places,\nuse `Float.ceil/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> ceil(10)\n    10\n\n    iex> ceil(10.1)\n    11\n\n    iex> ceil(-10.1)\n    -10\n\n","title":"Kernel.ceil/1","type":"function"},{"doc":"Debugs the given code . dbg/2 can be used to debug the given code through a configurable debug function. It returns the result of the given code. Examples Let's take this call to dbg/2 : dbg ( Atom . to_string ( :debugging ) ) #=&gt; &quot;debugging&quot; It returns the string &quot;debugging&quot; , which is the result of the Atom.to_string/1 call. Additionally, the call above prints: [ my_file . ex : 10 : MyMod . my_fun / 0 ] Atom . to_string ( :debugging ) #=&gt; &quot;debugging&quot; The default debugging function prints additional debugging info when dealing with pipelines. It prints the values at every &quot;step&quot; of the pipeline. &quot;Elixir is cool!&quot; |&gt; String . trim_trailing ( &quot;!&quot; ) |&gt; String . split ( ) |&gt; List . first ( ) |&gt; dbg ( ) #=&gt; &quot;Elixir&quot; The code above prints: [ my_file . ex : 10 : MyMod . my_fun / 0 ] &quot;Elixir is cool!&quot; #=&gt; &quot;Elixir is cool!&quot; |&gt; String . trim_trailing ( &quot;!&quot; ) #=&gt; &quot;Elixir is cool&quot; |&gt; String . split ( ) #=&gt; [&quot;Elixir&quot;, &quot;is&quot;, &quot;cool&quot;] |&gt; List . first ( ) #=&gt; &quot;Elixir&quot; With no arguments, dbg() debugs information about the current binding. See binding/1 . dbg inside IEx You can enable IEx to replace dbg with its IEx.pry/0 backend by calling: $ iex --dbg pry In such cases, dbg will start a pry session where you can interact with the imports, aliases, and variables of the current environment at the location of the dbg call. If you call dbg at the end of a pipeline (using |&gt; ) within IEx, you are able to go through each step of the pipeline one by one by entering &quot;next&quot; (or &quot;n&quot;). Note dbg only supports stepping for pipelines (in other words, it can only step through the code it sees). For general stepping, you can set breakpoints using IEx.break!/4 . For more information, see IEx documentation . Configuring the debug function One of the benefits of dbg/2 is that its debugging logic is configurable, allowing tools to extend dbg with enhanced behaviour. This is done, for example, by IEx which extends dbg with an interactive shell where you can directly inspect and access values. The debug function can be configured at compile time through the :dbg_callback key of the :elixir application. The debug function must be a {module, function, args} tuple. The function function in module will be invoked with three arguments prepended to args : The AST of code The AST of options The Macro.Env environment of where dbg/2 is invoked The debug function is invoked at compile time and it must also return an AST. The AST is expected to ultimately return the result of evaluating the debugged expression. Here's a simple example: defmodule MyMod do def debug_fun ( code , options , caller , device ) do quote do result = unquote ( code ) IO . inspect ( unquote ( device ) , result , label : unquote ( Macro . to_string ( code ) ) ) end end end To configure the debug function: # In config/config.exs config :elixir , :dbg_callback , { MyMod , :debug_fun , [ :stdio ] } Default debug function By default, the debug function we use is Macro.dbg/3 . It just prints information about the code to standard output and returns the value returned by evaluating code . options are used to control how terms are inspected. They are the same options accepted by inspect/2 .","ref":"Kernel.html#dbg/2","source_doc":"Debugs the given `code`.\n\n`dbg/2` can be used to debug the given `code` through a configurable debug function.\nIt returns the result of the given code.\n\n## Examples\n\nLet's take this call to `dbg/2`:\n\n    dbg(Atom.to_string(:debugging))\n    #=> \"debugging\"\n\nIt returns the string `\"debugging\"`, which is the result of the `Atom.to_string/1` call.\nAdditionally, the call above prints:\n\n    [my_file.ex:10: MyMod.my_fun/0]\n    Atom.to_string(:debugging) #=> \"debugging\"\n\nThe default debugging function prints additional debugging info when dealing with\npipelines. It prints the values at every \"step\" of the pipeline.\n\n    \"Elixir is cool!\"\n    |> String.trim_trailing(\"!\")\n    |> String.split()\n    |> List.first()\n    |> dbg()\n    #=> \"Elixir\"\n\nThe code above prints:\n\n    [my_file.ex:10: MyMod.my_fun/0]\n    \"Elixir is cool!\" #=> \"Elixir is cool!\"\n    |> String.trim_trailing(\"!\") #=> \"Elixir is cool\"\n    |> String.split() #=> [\"Elixir\", \"is\", \"cool\"]\n    |> List.first() #=> \"Elixir\"\n\nWith no arguments, `dbg()` debugs information about the current binding. See `binding/1`.\n\n## `dbg` inside IEx\n\nYou can enable IEx to replace `dbg` with its `IEx.pry/0` backend by calling:\n\n    $ iex --dbg pry\n\nIn such cases, `dbg` will start a `pry` session where you can interact with\nthe imports, aliases, and variables of the current environment at the location\nof the `dbg` call.\n\nIf you call `dbg` at the end of a pipeline (using `|>`) within IEx, you are able\nto go through each step of the pipeline one by one by entering \"next\" (or \"n\").\n\nNote `dbg` only supports stepping for pipelines (in other words, it can only\nstep through the code it sees). For general stepping, you can set breakpoints\nusing `IEx.break!/4`.\n\nFor more information, [see IEx documentation](https://hexdocs.pm/iex/IEx.html#module-dbg-and-breakpoints).\n\n## Configuring the debug function\n\nOne of the benefits of `dbg/2` is that its debugging logic is configurable,\nallowing tools to extend `dbg` with enhanced behaviour. This is done, for\nexample, by `IEx` which extends `dbg` with an interactive shell where you\ncan directly inspect and access values.\n\nThe debug function can be configured at compile time through the `:dbg_callback`\nkey of the `:elixir` application. The debug function must be a\n`{module, function, args}` tuple. The `function` function in `module` will be\ninvoked with three arguments *prepended* to `args`:\n\n  1. The AST of `code`\n  2. The AST of `options`\n  3. The `Macro.Env` environment of where `dbg/2` is invoked\n\nThe debug function is invoked at compile time and it must also return an AST.\nThe AST is expected to ultimately return the result of evaluating the debugged\nexpression.\n\nHere's a simple example:\n\n    defmodule MyMod do\n      def debug_fun(code, options, caller, device) do\n        quote do\n          result = unquote(code)\n          IO.inspect(unquote(device), result, label: unquote(Macro.to_string(code)))\n        end\n      end\n    end\n\nTo configure the debug function:\n\n    # In config/config.exs\n    config :elixir, :dbg_callback, {MyMod, :debug_fun, [:stdio]}\n\n### Default debug function\n\nBy default, the debug function we use is `Macro.dbg/3`. It just prints\ninformation about the code to standard output and returns the value\nreturned by evaluating `code`. `options` are used to control how terms\nare inspected. They are the same options accepted by `inspect/2`.\n","title":"Kernel.dbg/2","type":"macro"},{"doc":"Defines a public function with the given name and body. Examples defmodule Foo do def bar , do : :baz end Foo . bar ( ) #=&gt; :baz A function that expects arguments can be defined as follows: defmodule Foo do def sum ( a , b ) do a + b end end In the example above, a sum/2 function is defined; this function receives two arguments and returns their sum. Default arguments \\\\ is used to specify a default value for a parameter of a function. For example: defmodule MyMath do def multiply_by ( number , factor \\\\ 2 ) do number * factor end end MyMath . multiply_by ( 4 , 3 ) #=&gt; 12 MyMath . multiply_by ( 4 ) #=&gt; 8 The compiler translates this into multiple functions with different arities, here MyMath.multiply_by/1 and MyMath.multiply_by/2 , that represent cases when arguments for parameters with default values are passed or not passed. When defining a function with default arguments as well as multiple explicitly declared clauses, you must write a function head that declares the defaults. For example: defmodule MyString do def join ( string1 , string2 \\\\ nil , separator \\\\ &quot; &quot; ) def join ( string1 , nil , _separator ) do string1 end def join ( string1 , string2 , separator ) do string1 &lt;&gt; separator &lt;&gt; string2 end end Note that \\\\ can't be used with anonymous functions because they can only have a sole arity. Keyword lists with default arguments Functions containing many arguments can benefit from using Keyword lists to group and pass attributes as a single value. defmodule MyConfiguration do @default_opts [ storage : &quot;local&quot; ] def configure ( resource , opts \\\\ [ ] ) do opts = Keyword . merge ( @default_opts , opts ) storage = opts [ :storage ] # ... end end The difference between using Map and Keyword to store many arguments is Keyword 's keys: must be atoms can be given more than once ordered, as specified by the developer Function and variable names Function and variable names have the following syntax: A lowercase ASCII letter or an underscore , followed by any number of lowercase or uppercase ASCII letters , numbers , or underscores . Optionally they can end in either an exclamation mark or a question mark . For variables, any identifier starting with an underscore should indicate an unused variable. For example: def foo ( bar ) do [ ] end #=&gt; warning: variable bar is unused def foo ( _bar ) do [ ] end #=&gt; no warning def foo ( _bar ) do _bar end #=&gt; warning: the underscored variable &quot;_bar&quot; is used after being set rescue / catch / after / else Function bodies support rescue , catch , after , and else as Kernel.SpecialForms.try/1 does (known as &quot;implicit try&quot;). For example, the following two functions are equivalent: def convert ( number ) do try do String . to_integer ( number ) rescue e in ArgumentError -&gt; { :error , e . message } end end def convert ( number ) do String . to_integer ( number ) rescue e in ArgumentError -&gt; { :error , e . message } end","ref":"Kernel.html#def/2","source_doc":"Defines a public function with the given name and body.\n\n## Examples\n\n    defmodule Foo do\n      def bar, do: :baz\n    end\n\n    Foo.bar()\n    #=> :baz\n\nA function that expects arguments can be defined as follows:\n\n    defmodule Foo do\n      def sum(a, b) do\n        a + b\n      end\n    end\n\nIn the example above, a `sum/2` function is defined; this function receives\ntwo arguments and returns their sum.\n\n## Default arguments\n\n`\\\\` is used to specify a default value for a parameter of a function. For\nexample:\n\n    defmodule MyMath do\n      def multiply_by(number, factor \\\\ 2) do\n        number * factor\n      end\n    end\n\n    MyMath.multiply_by(4, 3)\n    #=> 12\n\n    MyMath.multiply_by(4)\n    #=> 8\n\nThe compiler translates this into multiple functions with different arities,\nhere `MyMath.multiply_by/1` and `MyMath.multiply_by/2`, that represent cases when\narguments for parameters with default values are passed or not passed.\n\nWhen defining a function with default arguments as well as multiple\nexplicitly declared clauses, you must write a function head that declares the\ndefaults. For example:\n\n    defmodule MyString do\n      def join(string1, string2 \\\\ nil, separator \\\\ \" \")\n\n      def join(string1, nil, _separator) do\n        string1\n      end\n\n      def join(string1, string2, separator) do\n        string1 <> separator <> string2\n      end\n    end\n\nNote that `\\\\` can't be used with anonymous functions because they\ncan only have a sole arity.\n\n### Keyword lists with default arguments\n\nFunctions containing many arguments can benefit from using `Keyword`\nlists to group and pass attributes as a single value.\n\n    defmodule MyConfiguration do\n      @default_opts [storage: \"local\"]\n\n      def configure(resource, opts \\\\ []) do\n        opts = Keyword.merge(@default_opts, opts)\n        storage = opts[:storage]\n        # ...\n      end\n    end\n\nThe difference between using `Map` and `Keyword` to store many\narguments is `Keyword`'s keys:\n\n  * must be atoms\n  * can be given more than once\n  * ordered, as specified by the developer\n\n## Function and variable names\n\nFunction and variable names have the following syntax:\nA _lowercase ASCII letter_ or an _underscore_, followed by any number of\n_lowercase or uppercase ASCII letters_, _numbers_, or _underscores_.\nOptionally they can end in either an _exclamation mark_ or a _question mark_.\n\nFor variables, any identifier starting with an underscore should indicate an\nunused variable. For example:\n\n    def foo(bar) do\n      []\n    end\n    #=> warning: variable bar is unused\n\n    def foo(_bar) do\n      []\n    end\n    #=> no warning\n\n    def foo(_bar) do\n      _bar\n    end\n    #=> warning: the underscored variable \"_bar\" is used after being set\n\n## `rescue`/`catch`/`after`/`else`\n\nFunction bodies support `rescue`, `catch`, `after`, and `else` as `Kernel.SpecialForms.try/1`\ndoes (known as \"implicit try\"). For example, the following two functions are equivalent:\n\n    def convert(number) do\n      try do\n        String.to_integer(number)\n      rescue\n        e in ArgumentError -> {:error, e.message}\n      end\n    end\n\n    def convert(number) do\n      String.to_integer(number)\n    rescue\n      e in ArgumentError -> {:error, e.message}\n    end\n\n","title":"Kernel.def/2","type":"macro"},{"doc":"Defines a function that delegates to another module. Functions defined with defdelegate/2 are public and can be invoked from outside the module they're defined in, as if they were defined using def/2 . Therefore, defdelegate/2 is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use alias/2 to shorten the module name or use import/2 to be able to invoke the function without the module name altogether. Delegation only works with functions; delegating macros is not supported. Check def/2 for rules on naming and default arguments. Options :to - the module to dispatch to. :as - the function to call on the target given in :to . This parameter is optional and defaults to the name being delegated ( funs ). Examples defmodule MyList do defdelegate reverse ( list ) , to : Enum defdelegate other_reverse ( list ) , to : Enum , as : :reverse end MyList . reverse ( [ 1 , 2 , 3 ] ) #=&gt; [3, 2, 1] MyList . other_reverse ( [ 1 , 2 , 3 ] ) #=&gt; [3, 2, 1]","ref":"Kernel.html#defdelegate/2","source_doc":"Defines a function that delegates to another module.\n\nFunctions defined with `defdelegate/2` are public and can be invoked from\noutside the module they're defined in, as if they were defined using `def/2`.\nTherefore, `defdelegate/2` is about extending the current module's public API.\nIf what you want is to invoke a function defined in another module without\nusing its full module name, then use `alias/2` to shorten the module name or use\n`import/2` to be able to invoke the function without the module name altogether.\n\nDelegation only works with functions; delegating macros is not supported.\n\nCheck `def/2` for rules on naming and default arguments.\n\n## Options\n\n  * `:to` - the module to dispatch to.\n\n  * `:as` - the function to call on the target given in `:to`.\n    This parameter is optional and defaults to the name being\n    delegated (`funs`).\n\n## Examples\n\n    defmodule MyList do\n      defdelegate reverse(list), to: Enum\n      defdelegate other_reverse(list), to: Enum, as: :reverse\n    end\n\n    MyList.reverse([1, 2, 3])\n    #=> [3, 2, 1]\n\n    MyList.other_reverse([1, 2, 3])\n    #=> [3, 2, 1]\n\n","title":"Kernel.defdelegate/2","type":"macro"},{"doc":"Defines an exception. Exceptions are structs backed by a module that implements the Exception behaviour. The Exception behaviour requires two functions to be implemented: exception/1 - receives the arguments given to raise/2 and returns the exception struct. The default implementation accepts either a set of keyword arguments that is merged into the struct or a string to be used as the exception's message. message/1 - receives the exception struct and must return its message. Most commonly exceptions have a message field which by default is accessed by this function. However, if an exception does not have a message field, this function must be explicitly implemented. Since exceptions are structs, the API supported by defstruct/1 is also available in defexception/1 . Raising exceptions The most common way to raise an exception is via raise/2 : defmodule MyAppError do defexception [ :message ] end value = [ :hello ] raise MyAppError , message : &quot;did not get what was expected, got: \#{ inspect ( value ) } &quot; In many cases it is more convenient to pass the expected value to raise/2 and generate the message in the Exception.exception/1 callback: defmodule MyAppError do defexception [ :message ] @impl true def exception ( value ) do msg = &quot;did not get what was expected, got: \#{ inspect ( value ) } &quot; % MyAppError { message : msg } end end raise MyAppError , value The example above shows the preferred strategy for customizing exception messages.","ref":"Kernel.html#defexception/1","source_doc":"Defines an exception.\n\nExceptions are structs backed by a module that implements\nthe `Exception` behaviour. The `Exception` behaviour requires\ntwo functions to be implemented:\n\n  * [`exception/1`](`c:Exception.exception/1`) - receives the arguments given to `raise/2`\n    and returns the exception struct. The default implementation\n    accepts either a set of keyword arguments that is merged into\n    the struct or a string to be used as the exception's message.\n\n  * [`message/1`](`c:Exception.message/1`) - receives the exception struct and must return its\n    message. Most commonly exceptions have a message field which\n    by default is accessed by this function. However, if an exception\n    does not have a message field, this function must be explicitly\n    implemented.\n\nSince exceptions are structs, the API supported by `defstruct/1`\nis also available in `defexception/1`.\n\n## Raising exceptions\n\nThe most common way to raise an exception is via `raise/2`:\n\n    defmodule MyAppError do\n      defexception [:message]\n    end\n\n    value = [:hello]\n\n    raise MyAppError,\n      message: \"did not get what was expected, got: \#{inspect(value)}\"\n\nIn many cases it is more convenient to pass the expected value to\n`raise/2` and generate the message in the `c:Exception.exception/1` callback:\n\n    defmodule MyAppError do\n      defexception [:message]\n\n      @impl true\n      def exception(value) do\n        msg = \"did not get what was expected, got: \#{inspect(value)}\"\n        %MyAppError{message: msg}\n      end\n    end\n\n    raise MyAppError, value\n\nThe example above shows the preferred strategy for customizing\nexception messages.\n","title":"Kernel.defexception/1","type":"macro"},{"doc":"Generates a macro suitable for use in guard expressions. It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards. Note the convention in Elixir is to prefix all guards that return a boolean with the is_ prefix, such as is_list/1 . If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as Keyword.keyword?/1 . Example defmodule Integer.Guards do defguard is_even ( value ) when is_integer ( value ) and rem ( value , 2 ) == 0 end defmodule Collatz do @moduledoc &quot;Tools for working with the Collatz sequence.&quot; import Integer.Guards @doc &quot;Determines the number of steps `n` takes to reach `1`.&quot; # If this function never converges, please let me know what `n` you used. def converge ( n ) when n &gt; 0 , do : step ( n , 0 ) defp step ( 1 , step_count ) do step_count end defp step ( n , step_count ) when is_even ( n ) do step ( div ( n , 2 ) , step_count + 1 ) end defp step ( n , step_count ) do step ( 3 * n + 1 , step_count + 1 ) end end","ref":"Kernel.html#defguard/1","source_doc":"Generates a macro suitable for use in guard expressions.\n\nIt raises at compile time if the definition uses expressions that aren't\nallowed in guards, and otherwise creates a macro that can be used both inside\nor outside guards.\n\nNote the convention in Elixir is to prefix all guards that return a boolean\nwith the `is_` prefix, such as `is_list/1`. If, however, the function/macro\nreturns a boolean and is not allowed in guards, it should have no prefix and\nend with a question mark, such as `Keyword.keyword?/1`.\n\n## Example\n\n    defmodule Integer.Guards do\n      defguard is_even(value) when is_integer(value) and rem(value, 2) == 0\n    end\n\n    defmodule Collatz do\n      @moduledoc \"Tools for working with the Collatz sequence.\"\n      import Integer.Guards\n\n      @doc \"Determines the number of steps `n` takes to reach `1`.\"\n      # If this function never converges, please let me know what `n` you used.\n      def converge(n) when n > 0, do: step(n, 0)\n\n      defp step(1, step_count) do\n        step_count\n      end\n\n      defp step(n, step_count) when is_even(n) do\n        step(div(n, 2), step_count + 1)\n      end\n\n      defp step(n, step_count) do\n        step(3 * n + 1, step_count + 1)\n      end\n    end\n\n","title":"Kernel.defguard/1","type":"macro"},{"doc":"Generates a private macro suitable for use in guard expressions. It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module. Similar to defmacrop/2 , defguardp/1 must be defined before its use in the current module.","ref":"Kernel.html#defguardp/1","source_doc":"Generates a private macro suitable for use in guard expressions.\n\nIt raises at compile time if the definition uses expressions that aren't\nallowed in guards, and otherwise creates a private macro that can be used\nboth inside or outside guards in the current module.\n\nSimilar to `defmacrop/2`, `defguardp/1` must be defined before its use\nin the current module.\n","title":"Kernel.defguardp/1","type":"macro"},{"doc":"Defines an implementation for the given protocol. See the Protocol module for more information.","ref":"Kernel.html#defimpl/3","source_doc":"Defines an implementation for the given protocol.\n\nSee the `Protocol` module for more information.\n","title":"Kernel.defimpl/3","type":"macro"},{"doc":"Defines a public macro with the given name and body. Macros must be defined before its usage. Check def/2 for rules on naming and default arguments. Examples defmodule MyLogic do defmacro unless ( expr , opts ) do quote do if ! unquote ( expr ) , unquote ( opts ) end end end require MyLogic MyLogic . unless false do IO . puts ( &quot;It works&quot; ) end","ref":"Kernel.html#defmacro/2","source_doc":"Defines a public macro with the given name and body.\n\nMacros must be defined before its usage.\n\nCheck `def/2` for rules on naming and default arguments.\n\n## Examples\n\n    defmodule MyLogic do\n      defmacro unless(expr, opts) do\n        quote do\n          if !unquote(expr), unquote(opts)\n        end\n      end\n    end\n\n    require MyLogic\n\n    MyLogic.unless false do\n      IO.puts(\"It works\")\n    end\n\n","title":"Kernel.defmacro/2","type":"macro"},{"doc":"Defines a private macro with the given name and body. Private macros are only accessible from the same module in which they are defined. Private macros must be defined before its usage. Check defmacro/2 for more information, and check def/2 for rules on naming and default arguments.","ref":"Kernel.html#defmacrop/2","source_doc":"Defines a private macro with the given name and body.\n\nPrivate macros are only accessible from the same module in which they are\ndefined.\n\nPrivate macros must be defined before its usage.\n\nCheck `defmacro/2` for more information, and check `def/2` for rules on\nnaming and default arguments.\n\n","title":"Kernel.defmacrop/2","type":"macro"},{"doc":"Defines a module given by name with the given contents. This macro defines a module with the given alias as its name and with the given contents. It returns a tuple with four elements: :module the module name the binary contents of the module the result of evaluating the contents block Examples defmodule Number do def one , do : 1 def two , do : 2 end #=&gt; {:module, Number, &lt;&lt;70, 79, 82, ...&gt;&gt;, {:two, 0}} Number . one ( ) #=&gt; 1 Number . two ( ) #=&gt; 2 Nesting Nesting a module inside another module affects the name of the nested module: defmodule Foo do defmodule Bar do end end In the example above, two modules - Foo and Foo.Bar - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module Foo.Bar to be accessed as Bar in the same lexical scope where it's defined (the Foo module). This only happens if the nested module is defined via an alias. If the Foo.Bar module is moved somewhere else, the references to Bar in the Foo module need to be updated to the fully-qualified name ( Foo.Bar ) or an alias has to be explicitly set in the Foo module with the help of Kernel.SpecialForms.alias/2 . defmodule Foo.Bar do # code end defmodule Foo do alias Foo.Bar # code here can refer to &quot;Foo.Bar&quot; as just &quot;Bar&quot; end Dynamic names Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write: defmodule String . to_atom ( &quot;Foo \#{ 1 } &quot; ) do # contents ... end Elixir will accept any module name as long as the expression passed as the first argument to defmodule/2 evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias. Reserved module names If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined. There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error: defmodule Any do # code end ** (CompileError) iex:1: module Any is reserved and cannot be defined Elixir reserves the following module names: Elixir , Any , BitString , PID , and Reference .","ref":"Kernel.html#defmodule/2","source_doc":"Defines a module given by name with the given contents.\n\nThis macro defines a module with the given `alias` as its name and with the\ngiven contents. It returns a tuple with four elements:\n\n  * `:module`\n  * the module name\n  * the binary contents of the module\n  * the result of evaluating the contents block\n\n## Examples\n\n    defmodule Number do\n      def one, do: 1\n      def two, do: 2\n    end\n    #=> {:module, Number, <<70, 79, 82, ...>>, {:two, 0}}\n\n    Number.one()\n    #=> 1\n\n    Number.two()\n    #=> 2\n\n## Nesting\n\nNesting a module inside another module affects the name of the nested module:\n\n    defmodule Foo do\n      defmodule Bar do\n      end\n    end\n\nIn the example above, two modules - `Foo` and `Foo.Bar` - are created.\nWhen nesting, Elixir automatically creates an alias to the inner module,\nallowing the second module `Foo.Bar` to be accessed as `Bar` in the same\nlexical scope where it's defined (the `Foo` module). This only happens\nif the nested module is defined via an alias.\n\nIf the `Foo.Bar` module is moved somewhere else, the references to `Bar` in\nthe `Foo` module need to be updated to the fully-qualified name (`Foo.Bar`) or\nan alias has to be explicitly set in the `Foo` module with the help of\n`Kernel.SpecialForms.alias/2`.\n\n    defmodule Foo.Bar do\n      # code\n    end\n\n    defmodule Foo do\n      alias Foo.Bar\n      # code here can refer to \"Foo.Bar\" as just \"Bar\"\n    end\n\n## Dynamic names\n\nElixir module names can be dynamically generated. This is very\nuseful when working with macros. For instance, one could write:\n\n    defmodule String.to_atom(\"Foo\#{1}\") do\n      # contents ...\n    end\n\nElixir will accept any module name as long as the expression passed as the\nfirst argument to `defmodule/2` evaluates to an atom.\nNote that, when a dynamic name is used, Elixir won't nest the name under\nthe current module nor automatically set up an alias.\n\n## Reserved module names\n\nIf you attempt to define a module that already exists, you will get a\nwarning saying that a module has been redefined.\n\nThere are some modules that Elixir does not currently implement but it\nmay be implement in the future. Those modules are reserved and defining\nthem will result in a compilation error:\n\n    defmodule Any do\n      # code\n    end\n    ** (CompileError) iex:1: module Any is reserved and cannot be defined\n\nElixir reserves the following module names: `Elixir`, `Any`, `BitString`,\n`PID`, and `Reference`.\n","title":"Kernel.defmodule/2","type":"macro"},{"doc":"Makes the given definitions in the current module overridable. If the user defines a new function or macro with the same name and arity, then the overridable ones are discarded. Otherwise, the original definitions are used. It is possible for the overridden definition to have a different visibility than the original: a public function can be overridden by a private function and vice-versa. Macros cannot be overridden as functions and vice-versa. Example defmodule DefaultMod do defmacro __using__ ( _opts ) do quote do def test ( x , y ) do x + y end defoverridable test : 2 end end end defmodule ChildMod do use DefaultMod def test ( x , y ) do x * y + super ( x , y ) end end As seen as in the example above, super can be used to call the default implementation. Disclaimer Use defoverridable with care. If you need to define multiple modules with the same behaviour, it may be best to move the default implementation to the caller, and check if a callback exists via Code.ensure_loaded?/1 and function_exported?/3 . For example, in the example above, imagine there is a module that calls the test/2 function. This module could be defined as such: defmodule CallsTest do def receives_module_and_calls_test ( module , x , y ) do if Code . ensure_loaded? ( module ) and function_exported? ( module , :test , 2 ) do module . test ( x , y ) else x + y end end end Example with behaviour You can also pass a behaviour to defoverridable and it will mark all of the callbacks in the behaviour as overridable: defmodule Behaviour do @callback test ( number ( ) , number ( ) ) :: number ( ) end defmodule DefaultMod do defmacro __using__ ( _opts ) do quote do @behaviour Behaviour def test ( x , y ) do x + y end defoverridable Behaviour end end end defmodule ChildMod do use DefaultMod def test ( x , y ) do x * y + super ( x , y ) end end","ref":"Kernel.html#defoverridable/1","source_doc":"Makes the given definitions in the current module overridable.\n\nIf the user defines a new function or macro with the same name\nand arity, then the overridable ones are discarded. Otherwise, the\noriginal definitions are used.\n\nIt is possible for the overridden definition to have a different visibility\nthan the original: a public function can be overridden by a private\nfunction and vice-versa.\n\nMacros cannot be overridden as functions and vice-versa.\n\n## Example\n\n    defmodule DefaultMod do\n      defmacro __using__(_opts) do\n        quote do\n          def test(x, y) do\n            x + y\n          end\n\n          defoverridable test: 2\n        end\n      end\n    end\n\n    defmodule ChildMod do\n      use DefaultMod\n\n      def test(x, y) do\n        x * y + super(x, y)\n      end\n    end\n\nAs seen as in the example above, `super` can be used to call the default\nimplementation.\n\n> #### Disclaimer {: .tip}\n>\n> Use `defoverridable` with care. If you need to define multiple modules\n> with the same behaviour, it may be best to move the default implementation\n> to the caller, and check if a callback exists via `Code.ensure_loaded?/1` and\n> `function_exported?/3`.\n>\n> For example, in the example above, imagine there is a module that calls the\n> `test/2` function. This module could be defined as such:\n>\n>     defmodule CallsTest do\n>       def receives_module_and_calls_test(module, x, y) do\n>         if Code.ensure_loaded?(module) and function_exported?(module, :test, 2) do\n>           module.test(x, y)\n>         else\n>           x + y\n>         end\n>       end\n>     end\n\n## Example with behaviour\n\nYou can also pass a behaviour to `defoverridable` and it will mark all of the\ncallbacks in the behaviour as overridable:\n\n\n    defmodule Behaviour do\n      @callback test(number(), number()) :: number()\n    end\n\n    defmodule DefaultMod do\n      defmacro __using__(_opts) do\n        quote do\n          @behaviour Behaviour\n\n          def test(x, y) do\n            x + y\n          end\n\n          defoverridable Behaviour\n        end\n      end\n    end\n\n    defmodule ChildMod do\n      use DefaultMod\n\n      def test(x, y) do\n        x * y + super(x, y)\n      end\n    end\n\n","title":"Kernel.defoverridable/1","type":"macro"},{"doc":"Defines a private function with the given name and body. Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an UndefinedFunctionError exception. Check def/2 for more information. Examples defmodule Foo do def bar do sum ( 1 , 2 ) end defp sum ( a , b ) , do : a + b end Foo . bar ( ) #=&gt; 3 Foo . sum ( 1 , 2 ) ** (UndefinedFunctionError) undefined function Foo.sum/2","ref":"Kernel.html#defp/2","source_doc":"Defines a private function with the given name and body.\n\nPrivate functions are only accessible from within the module in which they are\ndefined. Trying to access a private function from outside the module it's\ndefined in results in an `UndefinedFunctionError` exception.\n\nCheck `def/2` for more information.\n\n## Examples\n\n    defmodule Foo do\n      def bar do\n        sum(1, 2)\n      end\n\n      defp sum(a, b), do: a + b\n    end\n\n    Foo.bar()\n    #=> 3\n\n    Foo.sum(1, 2)\n    ** (UndefinedFunctionError) undefined function Foo.sum/2\n\n","title":"Kernel.defp/2","type":"macro"},{"doc":"Defines a protocol. See the Protocol module for more information.","ref":"Kernel.html#defprotocol/2","source_doc":"Defines a protocol.\n\nSee the `Protocol` module for more information.\n","title":"Kernel.defprotocol/2","type":"macro"},{"doc":"Defines a struct. A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions. For more information about structs, please check Kernel.SpecialForms.%/2 . It is only possible to define a struct per module, as the struct is tied to the module itself. Calling defstruct/1 also defines a __struct__/0 function that returns the struct itself. Examples defmodule User do defstruct name : nil , age : nil end Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, 10 + 11 is evaluated at compile-time and the age field is stored with value 21 : defmodule User do defstruct name : nil , age : 10 + 11 end The fields argument is usually a keyword list with field names as atom keys and default values as corresponding values. defstruct/1 also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to nil . defmodule Post do defstruct [ :title , :content , :author ] end Add documentation to a struct with the @doc attribute, like a function. defmodule Post do @doc &quot;A post. The content should be valid Markdown.&quot; defstruct [ :title , :content , :author ] end Deriving Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the User struct leads to an error: john = % User { name : &quot;John&quot; } MyProtocol . call ( john ) ** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...} defstruct/1 , however, allows protocol implementations to be derived . This can be done by defining a @derive attribute as a list before invoking defstruct/1 : defmodule User do @derive MyProtocol defstruct name : nil , age : nil end MyProtocol . call ( john ) # it works! A common example is to @derive the Inspect protocol to hide certain fields when the struct is printed: defmodule User do @derive { Inspect , only : :name } defstruct name : nil , age : nil end For each protocol in @derive , Elixir will assert the protocol has been implemented for Any . If the Any implementation defines a __deriving__/3 callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the Any implementation is automatically derived. For more information on the __deriving__/3 callback, see Protocol.derive/3 . Enforcing keys When building a struct, Elixir will automatically guarantee all keys belong to the struct: % User { name : &quot;john&quot; , unknown : :key } ** (KeyError) key :unknown not found in: %User{age: 21, name: nil} Elixir also allows developers to enforce that certain keys must always be given when building the struct: defmodule User do @enforce_keys [ :name ] defstruct name : nil , age : 10 + 11 end Now trying to build a struct without the name key will fail: % User { age : 21 } ** (ArgumentError) the following keys must also be given when building struct User: [:name] Keep in mind @enforce_keys is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation. Types It is recommended to define types for structs. By convention, such a type is called t . To define a struct inside a type, the struct literal syntax is used: defmodule User do defstruct name : &quot;John&quot; , age : 25 @type t :: % __MODULE__ { name : String . t ( ) , age : non_neg_integer } end It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct, it's better to use User.t() instead of %User{} . The types of the struct fields that are not included in %User{} default to term() (see term/0 ). Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the @opaque attribute. Structs whose internal structure is public should use @type .","ref":"Kernel.html#defstruct/1","source_doc":"Defines a struct.\n\nA struct is a tagged map that allows developers to provide\ndefault values for keys, tags to be used in polymorphic\ndispatches and compile time assertions. For more information\nabout structs, please check `Kernel.SpecialForms.%/2`.\n\nIt is only possible to define a struct per module, as the\nstruct is tied to the module itself. Calling `defstruct/1`\nalso defines a `__struct__/0` function that returns the\nstruct itself.\n\n## Examples\n\n    defmodule User do\n      defstruct name: nil, age: nil\n    end\n\nStruct fields are evaluated at compile-time, which allows\nthem to be dynamic. In the example below, `10 + 11` is\nevaluated at compile-time and the age field is stored\nwith value `21`:\n\n    defmodule User do\n      defstruct name: nil, age: 10 + 11\n    end\n\nThe `fields` argument is usually a keyword list with field names\nas atom keys and default values as corresponding values. `defstruct/1`\nalso supports a list of atoms as its argument: in that case, the atoms\nin the list will be used as the struct's field names and they will all\ndefault to `nil`.\n\n    defmodule Post do\n      defstruct [:title, :content, :author]\n    end\n\nAdd documentation to a struct with the `@doc` attribute, like a function.\n\n    defmodule Post do\n      @doc \"A post. The content should be valid Markdown.\"\n      defstruct [:title, :content, :author]\n    end\n\n## Deriving\n\nAlthough structs are maps, by default structs do not implement\nany of the protocols implemented for maps. For example, attempting\nto use a protocol with the `User` struct leads to an error:\n\n    john = %User{name: \"John\"}\n    MyProtocol.call(john)\n    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}\n\n`defstruct/1`, however, allows protocol implementations to be\n*derived*. This can be done by defining a `@derive` attribute as a\nlist before invoking `defstruct/1`:\n\n    defmodule User do\n      @derive MyProtocol\n      defstruct name: nil, age: nil\n    end\n\n    MyProtocol.call(john) # it works!\n\nA common example is to `@derive` the `Inspect` protocol to hide certain fields\nwhen the struct is printed:\n\n    defmodule User do\n      @derive {Inspect, only: :name}\n      defstruct name: nil, age: nil\n    end\n\nFor each protocol in `@derive`, Elixir will assert the protocol has\nbeen implemented for `Any`. If the `Any` implementation defines a\n`__deriving__/3` callback, the callback will be invoked and it should define\nthe implementation module. Otherwise an implementation that simply points to\nthe `Any` implementation is automatically derived. For more information on\nthe `__deriving__/3` callback, see `Protocol.derive/3`.\n\n## Enforcing keys\n\nWhen building a struct, Elixir will automatically guarantee all keys\nbelong to the struct:\n\n    %User{name: \"john\", unknown: :key}\n    ** (KeyError) key :unknown not found in: %User{age: 21, name: nil}\n\nElixir also allows developers to enforce that certain keys must always be\ngiven when building the struct:\n\n    defmodule User do\n      @enforce_keys [:name]\n      defstruct name: nil, age: 10 + 11\n    end\n\nNow trying to build a struct without the name key will fail:\n\n    %User{age: 21}\n    ** (ArgumentError) the following keys must also be given when building struct User: [:name]\n\nKeep in mind `@enforce_keys` is a simple compile-time guarantee\nto aid developers when building structs. It is not enforced on\nupdates and it does not provide any sort of value-validation.\n\n## Types\n\nIt is recommended to define types for structs. By convention, such a type\nis called `t`. To define a struct inside a type, the struct literal syntax\nis used:\n\n    defmodule User do\n      defstruct name: \"John\", age: 25\n      @type t :: %__MODULE__{name: String.t(), age: non_neg_integer}\n    end\n\nIt is recommended to only use the struct syntax when defining the struct's\ntype. When referring to another struct, it's better to use `User.t()` instead of\n`%User{}`.\n\nThe types of the struct fields that are not included in `%User{}` default to\n`term()` (see `t:term/0`).\n\nStructs whose internal structure is private to the local module (pattern\nmatching them or directly accessing their fields should not be allowed) should\nuse the `@opaque` attribute. Structs whose internal structure is public should\nuse `@type`.\n","title":"Kernel.defstruct/1","type":"macro"},{"doc":"Destructures two lists, assigning each term in the right one to the matching term in the left one. Unlike pattern matching via = , if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error. Examples iex&gt; destructure ( [ x , y , z ] , [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; { x , y , z } { 1 , 2 , 3 } In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to nil : iex&gt; destructure ( [ x , y , z ] , [ 1 ] ) iex&gt; { x , y , z } { 1 , nil , nil } The left-hand side supports any expression you would use on the left-hand side of a match: x = 1 destructure ( [ ^ x , y , z ] , [ 1 , 2 , 3 ] ) The example above will only work if x matches the first value in the right list. Otherwise, it will raise a MatchError (like the = operator would do).","ref":"Kernel.html#destructure/2","source_doc":"Destructures two lists, assigning each term in the\nright one to the matching term in the left one.\n\nUnlike pattern matching via `=`, if the sizes of the left\nand right lists don't match, destructuring simply stops\ninstead of raising an error.\n\n## Examples\n\n    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n    iex> {x, y, z}\n    {1, 2, 3}\n\nIn the example above, even though the right list has more entries than the\nleft one, destructuring works fine. If the right list is smaller, the\nremaining elements are simply set to `nil`:\n\n    iex> destructure([x, y, z], [1])\n    iex> {x, y, z}\n    {1, nil, nil}\n\nThe left-hand side supports any expression you would use\non the left-hand side of a match:\n\n    x = 1\n    destructure([^x, y, z], [1, 2, 3])\n\nThe example above will only work if `x` matches the first value in the right\nlist. Otherwise, it will raise a `MatchError` (like the `=` operator would\ndo).\n","title":"Kernel.destructure/2","type":"macro"},{"doc":"Performs an integer division. Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . div/2 performs truncated integer division. This means that the result is always rounded towards zero. If you want to perform floored integer division (rounding towards negative infinity), use Integer.floor_div/2 instead. Allowed in guard tests. Inlined by the compiler. Examples div ( 5 , 2 ) #=&gt; 2 div ( 6 , - 4 ) #=&gt; -1 div ( - 99 , 2 ) #=&gt; -49 div ( 100 , 0 ) ** (ArithmeticError) bad argument in arithmetic expression","ref":"Kernel.html#div/2","source_doc":"Performs an integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n`div/2` performs *truncated* integer division. This means that\nthe result is always rounded towards zero.\n\nIf you want to perform floored integer division (rounding towards negative infinity),\nuse `Integer.floor_div/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    div(5, 2)\n    #=> 2\n\n    div(6, -4)\n    #=> -1\n\n    div(-99, 2)\n    #=> -49\n\n    div(100, 0)\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n","title":"Kernel.div/2","type":"function"},{"doc":"Gets the element at the zero-based index in tuple . It raises ArgumentError when index is negative or it is out of range of the tuple elements. Allowed in guard tests. Inlined by the compiler. Examples tuple = { :foo , :bar , 3 } elem ( tuple , 1 ) #=&gt; :bar elem ( { } , 0 ) ** (ArgumentError) argument error elem ( { :foo , :bar } , 2 ) ** (ArgumentError) argument error","ref":"Kernel.html#elem/2","source_doc":"Gets the element at the zero-based `index` in `tuple`.\n\nIt raises `ArgumentError` when index is negative or it is out of range of the tuple elements.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tuple = {:foo, :bar, 3}\n    elem(tuple, 1)\n    #=> :bar\n\n    elem({}, 0)\n    ** (ArgumentError) argument error\n\n    elem({:foo, :bar}, 2)\n    ** (ArgumentError) argument error\n\n","title":"Kernel.elem/2","type":"function"},{"doc":"Stops the execution of the calling process with the given reason. Since evaluating this function causes the process to terminate, it has no return value. Inlined by the compiler. Examples When a process reaches its end, by default it exits with reason :normal . You can also call exit/1 explicitly if you want to terminate a process but not signal any failure: exit ( :normal ) In case something goes wrong, you can also use exit/1 with a different reason: exit ( :seems_bad ) If the exit reason is not :normal , all the processes linked to the process that exited will crash (unless they are trapping exits). OTP exits Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered &quot;normal&quot;: exit(:normal) exit(:shutdown) exit({:shutdown, term}) Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, and so forth. This behaviour is relied on in many different places. For example, ExUnit uses exit(:shutdown) when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too. CLI exits Building on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0. It is, however, possible to customize the operating system exit signal by invoking: exit ( { :shutdown , integer } ) This will cause the operating system process to exit with the status given by integer while signaling all linked Erlang processes to politely shut down. Any other exit reason will cause the operating system process to exit with status 1 and linked Erlang processes to crash.","ref":"Kernel.html#exit/1","source_doc":"Stops the execution of the calling process with the given reason.\n\nSince evaluating this function causes the process to terminate,\nit has no return value.\n\nInlined by the compiler.\n\n## Examples\n\nWhen a process reaches its end, by default it exits with\nreason `:normal`. You can also call `exit/1` explicitly if you\nwant to terminate a process but not signal any failure:\n\n    exit(:normal)\n\nIn case something goes wrong, you can also use `exit/1` with\na different reason:\n\n    exit(:seems_bad)\n\nIf the exit reason is not `:normal`, all the processes linked to the process\nthat exited will crash (unless they are trapping exits).\n\n## OTP exits\n\nExits are used by the OTP to determine if a process exited abnormally\nor not. The following exits are considered \"normal\":\n\n  * `exit(:normal)`\n  * `exit(:shutdown)`\n  * `exit({:shutdown, term})`\n\nExiting with any other reason is considered abnormal and treated\nas a crash. This means the default supervisor behaviour kicks in,\nerror reports are emitted, and so forth.\n\nThis behaviour is relied on in many different places. For example,\n`ExUnit` uses `exit(:shutdown)` when exiting the test process to\nsignal linked processes, supervision trees and so on to politely\nshut down too.\n\n## CLI exits\n\nBuilding on top of the exit signals mentioned above, if the\nprocess started by the command line exits with any of the three\nreasons above, its exit is considered normal and the Operating\nSystem process will exit with status 0.\n\nIt is, however, possible to customize the operating system exit\nsignal by invoking:\n\n    exit({:shutdown, integer})\n\nThis will cause the operating system process to exit with the status given by\n`integer` while signaling all linked Erlang processes to politely\nshut down.\n\nAny other exit reason will cause the operating system process to exit with\nstatus `1` and linked Erlang processes to crash.\n","title":"Kernel.exit/1","type":"function"},{"doc":"Returns the largest integer smaller than or equal to number . If you want to perform floor operation on other decimal places, use Float.floor/2 instead. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; floor ( 10 ) 10 iex&gt; floor ( 9.7 ) 9 iex&gt; floor ( - 9.7 ) - 10","ref":"Kernel.html#floor/1","source_doc":"Returns the largest integer smaller than or equal to `number`.\n\nIf you want to perform floor operation on other decimal places,\nuse `Float.floor/2` instead.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> floor(10)\n    10\n\n    iex> floor(9.7)\n    9\n\n    iex> floor(-9.7)\n    -10\n\n","title":"Kernel.floor/1","type":"function"},{"doc":"Returns true if module is loaded and contains a public function with the given arity , otherwise false . Note that this function does not load the module in case it is not loaded. Check Code.ensure_loaded/1 for more information. Inlined by the compiler. Examples iex&gt; function_exported? ( Enum , :map , 2 ) true iex&gt; function_exported? ( Enum , :map , 10 ) false iex&gt; function_exported? ( List , :to_string , 1 ) true","ref":"Kernel.html#function_exported?/3","source_doc":"Returns `true` if `module` is loaded and contains a\npublic `function` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> function_exported?(Enum, :map, 2)\n    true\n\n    iex> function_exported?(Enum, :map, 10)\n    false\n\n    iex> function_exported?(List, :to_string, 1)\n    true\n","title":"Kernel.function_exported?/3","type":"function"},{"doc":"Gets a value and updates a nested data structure via the given path . This is similar to get_and_update_in/3 , except the path is extracted via a macro rather than passing a list. For example: get_and_update_in ( opts [ :foo ] [ :bar ] , &amp; { &amp;1 , &amp;1 + 1 } ) Is equivalent to: get_and_update_in ( opts , [ :foo , :bar ] , &amp; { &amp;1 , &amp;1 + 1 } ) This also works with nested structs and the struct.path.to.value way to specify paths: get_and_update_in ( struct . foo . bar , &amp; { &amp;1 , &amp;1 + 1 } ) Note that in order for this macro to work, the complete path must always be visible by this macro. See the &quot;Paths&quot; section below. Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; get_and_update_in ( users [ &quot;john&quot; ] . age , &amp; { &amp;1 , &amp;1 + 1 } ) { 27 , %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } } Paths A path may start with a variable, local or remote call, and must be followed by one or more: foo[bar] - accesses the key bar in foo ; in case foo is nil, nil is returned foo.bar - accesses a map/struct field; in case the field is not present, an error is raised Here are some valid paths: users [ &quot;john&quot; ] [ :age ] users [ &quot;john&quot; ] . age User . all ( ) [ &quot;john&quot; ] . age all_users ( ) [ &quot;john&quot; ] . age Here are some invalid ones: # Does a remote call after the initial value users [ &quot;john&quot; ] . do_something ( arg1 , arg2 ) # Does not access any key or field users","ref":"Kernel.html#get_and_update_in/2","source_doc":"Gets a value and updates a nested data structure via the given `path`.\n\nThis is similar to `get_and_update_in/3`, except the path is extracted\nvia a macro rather than passing a list. For example:\n\n    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n\nIs equivalent to:\n\n    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n\nThis also works with nested structs and the `struct.path.to.value` way to specify\npaths:\n\n    get_and_update_in(struct.foo.bar, &{&1, &1 + 1})\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. See the \"Paths\" section below.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n\n## Paths\n\nA path may start with a variable, local or remote call, and must be\nfollowed by one or more:\n\n  * `foo[bar]` - accesses the key `bar` in `foo`; in case `foo` is nil,\n    `nil` is returned\n\n  * `foo.bar` - accesses a map/struct field; in case the field is not\n    present, an error is raised\n\nHere are some valid paths:\n\n    users[\"john\"][:age]\n    users[\"john\"].age\n    User.all()[\"john\"].age\n    all_users()[\"john\"].age\n\nHere are some invalid ones:\n\n    # Does a remote call after the initial value\n    users[\"john\"].do_something(arg1, arg2)\n\n    # Does not access any key or field\n    users\n\n","title":"Kernel.get_and_update_in/2","type":"macro"},{"doc":"Gets a value and updates a nested structure. data is a nested structure (that is, a map, keyword list, or struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present) and must return one of the following values: a two-element tuple {current_value, new_value} . In this case, current_value is the retrieved value which can possibly be operated on before being returned. new_value is the new value to be stored under key . :pop , which implies that the current value under key should be removed from the structure and returned. This function uses the Access module to traverse the structures according to the given keys , unless the key is a function, which is detailed in a later section. Examples This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; get_and_update_in ( users , [ &quot;john&quot; , :age ] , &amp; { &amp;1 , &amp;1 + 1 } ) { 27 , %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } } Note the current value given to the anonymous function may be nil . If any of the intermediate values are nil, it will raise: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; get_and_update_in ( users , [ &quot;jane&quot; , :age ] , &amp; { &amp;1 , &amp;1 + 1 } ) ** (ArgumentError) could not put/update key :age on a nil value Functions as keys If a key is a function, the function will be invoked passing three arguments: the operation ( :get_and_update ) the data to be accessed a function to be invoked next This means get_and_update_in/3 can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures. When one of the keys is a function, the function is invoked. In the example below, we use a function to get and increment all ages inside a list: iex&gt; users = [ %{ name : &quot;john&quot; , age : 27 } , %{ name : &quot;meg&quot; , age : 23 } ] iex&gt; all = fn :get_and_update , data , next -&gt; ...&gt; data |&gt; Enum . map ( next ) |&gt; Enum . unzip ( ) ...&gt; end iex&gt; get_and_update_in ( users , [ all , :age ] , &amp; { &amp;1 , &amp;1 + 1 } ) { [ 27 , 23 ] , [ %{ name : &quot;john&quot; , age : 28 } , %{ name : &quot;meg&quot; , age : 24 } ] } If the previous value before invoking the function is nil , the function will receive nil as a value and must handle it accordingly (be it by failing or providing a sane default). The Access module ships with many convenience accessor functions, like the all anonymous function defined above. See Access.all/0 , Access.key/2 , and others as examples.","ref":"Kernel.html#get_and_update_in/3","source_doc":"Gets a value and updates a nested structure.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return one of the following values:\n\n  * a two-element tuple `{current_value, new_value}`. In this case,\n    `current_value` is the retrieved value which can possibly be operated on before\n    being returned. `new_value` is the new value to be stored under `key`.\n\n  * `:pop`, which implies that the current value under `key`\n    should be removed from the structure and returned.\n\nThis function uses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a function,\nwhich is detailed in a later section.\n\n## Examples\n\nThis function is useful when there is a need to retrieve the current\nvalue (or something calculated in function of the current value) and\nupdate it at the same time. For example, it could be used to read the\ncurrent age of a user while increasing it by one in one pass:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_and_update_in(users, [\"jane\", :age], &{&1, &1 + 1})\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n## Functions as keys\n\nIf a key is a function, the function will be invoked passing three\narguments:\n\n  * the operation (`:get_and_update`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_and_update_in/3` can be extended to provide custom\nlookups. The downside is that functions cannot be stored as keys\nin the accessed data structures.\n\nWhen one of the keys is a function, the function is invoked.\nIn the example below, we use a function to get and increment all\nages inside a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get_and_update, data, next ->\n    ...>   data |> Enum.map(next) |> Enum.unzip()\n    ...> end\n    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n\nIf the previous value before invoking the function is `nil`,\nthe function *will* receive `nil` as a value and must handle it\naccordingly (be it by failing or providing a sane default).\n\nThe `Access` module ships with many convenience accessor functions,\nlike the `all` anonymous function defined above. See `Access.all/0`,\n`Access.key/2`, and others as examples.\n","title":"Kernel.get_and_update_in/3","type":"function"},{"doc":"Gets a value from a nested structure. Uses the Access module to traverse the structures according to the given keys , unless the key is a function, which is detailed in a later section. Note that if none of the given keys are functions, there is rarely a reason to use get_in over writing &quot;regular&quot; Elixir code using [] . Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; get_in ( users , [ &quot;john&quot; , :age ] ) 27 iex&gt; # Equivalent to: iex&gt; users [ &quot;john&quot; ] [ :age ] 27 get_in/2 can also use the accessors in the Access module to traverse more complex data structures. For example, here we use Access.all/0 to traverse a list: iex&gt; users = [ %{ name : &quot;john&quot; , age : 27 } , %{ name : &quot;meg&quot; , age : 23 } ] iex&gt; get_in ( users , [ Access . all ( ) , :age ] ) [ 27 , 23 ] In case any of the components returns nil , nil will be returned and get_in/2 won't traverse any further: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; get_in ( users , [ &quot;unknown&quot; , :age ] ) nil iex&gt; # Equivalent to: iex&gt; users [ &quot;unknown&quot; ] [ :age ] nil iex&gt; users = nil iex&gt; get_in ( users , [ Access . all ( ) , :age ] ) nil Alternatively, if you need to access complex data-structures, you can use pattern matching: case users do %{ &quot;john&quot; =&gt; %{ age : age } } -&gt; age _ -&gt; default_value end Functions as keys If a key given to get_in/2 is a function, the function will be invoked passing three arguments: the operation ( :get ) the data to be accessed a function to be invoked next This means get_in/2 can be extended to provide custom lookups. That's precisely how the Access.all/0 key in the previous section behaves. For example, we can manually implement such traversal as follows: iex&gt; users = [ %{ name : &quot;john&quot; , age : 27 } , %{ name : &quot;meg&quot; , age : 23 } ] iex&gt; all = fn :get , data , next -&gt; Enum . map ( data , next ) end iex&gt; get_in ( users , [ all , :age ] ) [ 27 , 23 ] The Access module ships with many convenience accessor functions. See Access.all/0 , Access.key/2 , and others as examples. Working with structs By default, structs do not implement the Access behaviour required by this function. Therefore, you can't do this: get_in ( some_struct , [ :some_key , :nested_key ] ) The good news is that structs have predefined shape. Therefore, you can write instead: some_struct . some_key . nested_key If, by any chance, some_key can return nil, you can always fallback to pattern matching to provide nested struct handling: case some_struct do %{ some_key : %{ nested_key : value } } -&gt; value %{ } -&gt; nil end","ref":"Kernel.html#get_in/2","source_doc":"Gets a value from a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction, which is detailed in a later section.\n\nNote that if none of the given keys are functions,\nthere is rarely a reason to use `get_in` over\nwriting \"regular\" Elixir code using `[]`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"john\", :age])\n    27\n    iex> # Equivalent to:\n    iex> users[\"john\"][:age]\n    27\n\n`get_in/2` can also use the accessors in the `Access` module\nto traverse more complex data structures. For example, here we\nuse `Access.all/0` to traverse a list:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> get_in(users, [Access.all(), :age])\n    [27, 23]\n\nIn case any of the components returns `nil`, `nil` will be returned\nand `get_in/2` won't traverse any further:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> get_in(users, [\"unknown\", :age])\n    nil\n    iex> # Equivalent to:\n    iex> users[\"unknown\"][:age]\n    nil\n\n    iex> users = nil\n    iex> get_in(users, [Access.all(), :age])\n    nil\n\nAlternatively, if you need to access complex data-structures, you can\nuse pattern matching:\n\n    case users do\n      %{\"john\" => %{age: age}} -> age\n      _ -> default_value\n    end\n\n## Functions as keys\n\nIf a key given to `get_in/2` is a function, the function will be invoked\npassing three arguments:\n\n  * the operation (`:get`)\n  * the data to be accessed\n  * a function to be invoked next\n\nThis means `get_in/2` can be extended to provide custom lookups.\nThat's precisely how the `Access.all/0` key in the previous section\nbehaves. For example, we can manually implement such traversal as\nfollows:\n\n    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n    iex> all = fn :get, data, next -> Enum.map(data, next) end\n    iex> get_in(users, [all, :age])\n    [27, 23]\n\nThe `Access` module ships with many convenience accessor functions.\nSee `Access.all/0`, `Access.key/2`, and others as examples.\n\n## Working with structs\n\nBy default, structs do not implement the `Access` behaviour required\nby this function. Therefore, you can't do this:\n\n    get_in(some_struct, [:some_key, :nested_key])\n\nThe good news is that structs have predefined shape. Therefore,\nyou can write instead:\n\n    some_struct.some_key.nested_key\n\nIf, by any chance, `some_key` can return nil, you can always\nfallback to pattern matching to provide nested struct handling:\n\n    case some_struct do\n      %{some_key: %{nested_key: value}} -> value\n      %{} -> nil\n    end\n\n","title":"Kernel.get_in/2","type":"function"},{"doc":"Returns the head of a list. Raises ArgumentError if the list is empty. The head of a list is its first element. It works with improper lists. Allowed in guard tests. Inlined by the compiler. Examples hd ( [ 1 , 2 , 3 , 4 ] ) #=&gt; 1 hd ( [ 1 | 2 ] ) #=&gt; 1 Giving it an empty list raises: hd ( [ ] ) ** (ArgumentError) argument error","ref":"Kernel.html#hd/1","source_doc":"Returns the head of a list. Raises `ArgumentError` if the list is empty.\n\nThe head of a list is its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    hd([1, 2, 3, 4])\n    #=> 1\n\n    hd([1 | 2])\n    #=> 1\n\nGiving it an empty list raises:\n\n    hd([])\n    ** (ArgumentError) argument error\n\n","title":"Kernel.hd/1","type":"function"},{"doc":"Provides an if/2 macro. This macro expects the first argument to be a condition and the second argument to be a keyword list. One-liner examples if ( foo , do : bar ) In the example above, bar will be returned if foo evaluates to a truthy value (neither false nor nil ). Otherwise, nil will be returned. An else option can be given to specify the opposite: if ( foo , do : bar , else : baz ) Blocks examples It's also possible to pass a block to the if/2 macro. The first example above would be translated to: if foo do bar end Note that do - end become delimiters. The second example would translate to: if foo do bar else baz end In order to compare more than two clauses, the cond/1 macro has to be used.","ref":"Kernel.html#if/2","source_doc":"Provides an `if/2` macro.\n\nThis macro expects the first argument to be a condition and the second\nargument to be a keyword list.\n\n## One-liner examples\n\n    if(foo, do: bar)\n\nIn the example above, `bar` will be returned if `foo` evaluates to\na truthy value (neither `false` nor `nil`). Otherwise, `nil` will be\nreturned.\n\nAn `else` option can be given to specify the opposite:\n\n    if(foo, do: bar, else: baz)\n\n## Blocks examples\n\nIt's also possible to pass a block to the `if/2` macro. The first\nexample above would be translated to:\n\n    if foo do\n      bar\n    end\n\nNote that `do`-`end` become delimiters. The second example would\ntranslate to:\n\n    if foo do\n      bar\n    else\n      baz\n    end\n\nIn order to compare more than two clauses, the `cond/1` macro has to be used.\n","title":"Kernel.if/2","type":"macro"},{"doc":"Membership operator. Checks if the element on the left-hand side is a member of the collection on the right-hand side. Examples iex&gt; x = 1 iex&gt; x in [ 1 , 2 , 3 ] true This operator (which is a macro) simply translates to a call to Enum.member?/2 . The example above would translate to: Enum . member? ( [ 1 , 2 , 3 ] , x ) Elixir also supports left not in right , which evaluates to not(left in right) : iex&gt; x = 1 iex&gt; x not in [ 1 , 2 , 3 ] false Guards The in/2 operator (as well as not in ) can be used in guard clauses as long as the right-hand side is a range or a list. If the right-hand side is a list, Elixir will expand the operator to a valid guard expression which needs to check each value. For example: when x in [ 1 , 2 , 3 ] translates to: when x === 1 or x === 2 or x === 3 However, this construct will be inefficient for large lists. In such cases, it is best to stop using guards and use a more appropriate data structure, such as MapSet . If the right-hand side is a range, a more efficient comparison check will be done. For example: when x in 1 .. 1000 translates roughly to: when x &gt;= 1 and x &lt;= 1000 AST considerations left not in right is parsed by the compiler into the AST: { :not , _ , [ { :in , _ , [ left , right ] } ] } This is the same AST as not(left in right) . Additionally, Macro.to_string/2 and Code.format_string!/2 will translate all occurrences of this AST to left not in right .","ref":"Kernel.html#in/2","source_doc":"Membership operator.\n\nChecks if the element on the left-hand side is a member of the\ncollection on the right-hand side.\n\n## Examples\n\n    iex> x = 1\n    iex> x in [1, 2, 3]\n    true\n\nThis operator (which is a macro) simply translates to a call to\n`Enum.member?/2`. The example above would translate to:\n\n    Enum.member?([1, 2, 3], x)\n\nElixir also supports `left not in right`, which evaluates to\n`not(left in right)`:\n\n    iex> x = 1\n    iex> x not in [1, 2, 3]\n    false\n\n## Guards\n\nThe `in/2` operator (as well as `not in`) can be used in guard clauses as\nlong as the right-hand side is a range or a list.\n\nIf the right-hand side is a list, Elixir will expand the operator to a valid\nguard expression which needs to check each value. For example:\n\n    when x in [1, 2, 3]\n\ntranslates to:\n\n    when x === 1 or x === 2 or x === 3\n\nHowever, this construct will be inefficient for large lists. In such cases, it\nis best to stop using guards and use a more appropriate data structure, such\nas `MapSet`.\n\nIf the right-hand side is a range, a more efficient comparison check will be\ndone. For example:\n\n    when x in 1..1000\n\ntranslates roughly to:\n\n    when x >= 1 and x <= 1000\n\n### AST considerations\n\n`left not in right` is parsed by the compiler into the AST:\n\n    {:not, _, [{:in, _, [left, right]}]}\n\nThis is the same AST as `not(left in right)`.\n\nAdditionally, `Macro.to_string/2` and `Code.format_string!/2`\nwill translate all occurrences of this AST to `left not in right`.\n","title":"Kernel.in/2","type":"macro"},{"doc":"Inspects the given argument according to the Inspect protocol. The second argument is a keyword list with options to control inspection. Options inspect/2 accepts a list of options that are internally translated to an Inspect.Opts struct. Check the docs for Inspect.Opts to see the supported options. Examples iex&gt; inspect ( :foo ) &quot;:foo&quot; iex&gt; inspect ( [ 1 , 2 , 3 , 4 , 5 ] , limit : 3 ) &quot;[1, 2, 3, ...]&quot; iex&gt; inspect ( [ 1 , 2 , 3 ] , pretty : true , width : 0 ) &quot;[1, \\n 2, \\n 3]&quot; iex&gt; inspect ( &quot;olá&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; ) &quot;&lt;&lt;111, 108, 195, 161, 0&gt;&gt;&quot; iex&gt; inspect ( &quot;olá&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; , binaries : :as_strings ) &quot; \\&quot; olá \\\\ 0 \\&quot; &quot; iex&gt; inspect ( &quot;olá&quot; , binaries : :as_binaries ) &quot;&lt;&lt;111, 108, 195, 161&gt;&gt;&quot; iex&gt; inspect ( ~c&quot;bar&quot; ) &quot;~c \\&quot; bar \\&quot; &quot; iex&gt; inspect ( [ 0 | ~c&quot;bar&quot; ] ) &quot;[0, 98, 97, 114]&quot; iex&gt; inspect ( 100 , base : :octal ) &quot;0o144&quot; iex&gt; inspect ( 100 , base : :hex ) &quot;0x64&quot; Note that the Inspect protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with # . For example, inspecting a function will return: inspect ( fn a , b -&gt; a + b end ) #=&gt; #Function&lt;...&gt; The Inspect protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the Inspect protocol for more information.","ref":"Kernel.html#inspect/2","source_doc":"Inspects the given argument according to the `Inspect` protocol.\nThe second argument is a keyword list with options to control\ninspection.\n\n## Options\n\n`inspect/2` accepts a list of options that are internally\ntranslated to an `Inspect.Opts` struct. Check the docs for\n`Inspect.Opts` to see the supported options.\n\n## Examples\n\n    iex> inspect(:foo)\n    \":foo\"\n\n    iex> inspect([1, 2, 3, 4, 5], limit: 3)\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect([1, 2, 3], pretty: true, width: 0)\n    \"[1,\\n 2,\\n 3]\"\n\n    iex> inspect(\"olá\" <> <<0>>)\n    \"<<111, 108, 195, 161, 0>>\"\n\n    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n    \"\\\"olá\\\\0\\\"\"\n\n    iex> inspect(\"olá\", binaries: :as_binaries)\n    \"<<111, 108, 195, 161>>\"\n\n    iex> inspect(~c\"bar\")\n    \"~c\\\"bar\\\"\"\n\n    iex> inspect([0 | ~c\"bar\"])\n    \"[0, 98, 97, 114]\"\n\n    iex> inspect(100, base: :octal)\n    \"0o144\"\n\n    iex> inspect(100, base: :hex)\n    \"0x64\"\n\nNote that the `Inspect` protocol does not necessarily return a valid\nrepresentation of an Elixir term. In such cases, the inspected result\nmust start with `#`. For example, inspecting a function will return:\n\n    inspect(fn a, b -> a + b end)\n    #=> #Function<...>\n\nThe `Inspect` protocol can be derived to hide certain fields\nfrom structs, so they don't show up in logs, inspects and similar.\nSee the \"Deriving\" section of the documentation of the `Inspect`\nprotocol for more information.\n","title":"Kernel.inspect/2","type":"function"},{"doc":"Returns true if term is an atom; otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_atom ( false ) true iex&gt; is_atom ( :name ) true iex&gt; is_atom ( AnAtom ) true iex&gt; is_atom ( &quot;true&quot; ) false","ref":"Kernel.html#is_atom/1","source_doc":"Returns `true` if `term` is an atom; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_atom(false)\n    true\n\n    iex> is_atom(:name)\n    true\n\n    iex> is_atom(AnAtom)\n    true\n\n    iex> is_atom(\"true\")\n    false\n\n","title":"Kernel.is_atom/1","type":"function"},{"doc":"Returns true if term is a binary; otherwise returns false . A binary always contains a complete number of bytes. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_binary ( &quot;foo&quot; ) true iex&gt; is_binary ( &lt;&lt; 1 :: 3 &gt;&gt; ) false","ref":"Kernel.html#is_binary/1","source_doc":"Returns `true` if `term` is a binary; otherwise returns `false`.\n\nA binary always contains a complete number of bytes.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_binary(\"foo\")\n    true\n    iex> is_binary(<<1::3>>)\n    false\n\n","title":"Kernel.is_binary/1","type":"function"},{"doc":"Returns true if term is a bitstring (including a binary); otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_bitstring ( &quot;foo&quot; ) true iex&gt; is_bitstring ( &lt;&lt; 1 :: 3 &gt;&gt; ) true","ref":"Kernel.html#is_bitstring/1","source_doc":"Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_bitstring(\"foo\")\n    true\n    iex> is_bitstring(<<1::3>>)\n    true\n\n","title":"Kernel.is_bitstring/1","type":"function"},{"doc":"Returns true if term is either the atom true or the atom false (i.e., a boolean); otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_boolean ( false ) true iex&gt; is_boolean ( true ) true iex&gt; is_boolean ( :test ) false","ref":"Kernel.html#is_boolean/1","source_doc":"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e.,\na boolean); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_boolean(false)\n    true\n\n    iex> is_boolean(true)\n    true\n\n    iex> is_boolean(:test)\n    false\n\n","title":"Kernel.is_boolean/1","type":"function"},{"doc":"Returns true if term is an exception; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_exception ( % RuntimeError { } ) true iex&gt; is_exception ( %{ } ) false","ref":"Kernel.html#is_exception/1","source_doc":"Returns true if `term` is an exception; otherwise returns `false`.\n\nAllowed in guard tests.\n\n## Examples\n\n    iex> is_exception(%RuntimeError{})\n    true\n\n    iex> is_exception(%{})\n    false\n\n","title":"Kernel.is_exception/1","type":"macro"},{"doc":"Returns true if term is an exception of name ; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_exception ( % RuntimeError { } , RuntimeError ) true iex&gt; is_exception ( % RuntimeError { } , Macro.Env ) false","ref":"Kernel.html#is_exception/2","source_doc":"Returns true if `term` is an exception of `name`; otherwise returns `false`.\n\nAllowed in guard tests.\n\n## Examples\n\n    iex> is_exception(%RuntimeError{}, RuntimeError)\n    true\n\n    iex> is_exception(%RuntimeError{}, Macro.Env)\n    false\n\n","title":"Kernel.is_exception/2","type":"macro"},{"doc":"Returns true if term is a floating-point number; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_float/1","source_doc":"Returns `true` if `term` is a floating-point number; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_float/1","type":"function"},{"doc":"Returns true if term is a function; otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_function ( fn x -&gt; x + x end ) true iex&gt; is_function ( &quot;not a function&quot; ) false","ref":"Kernel.html#is_function/1","source_doc":"Returns `true` if `term` is a function; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x + x end)\n    true\n\n    iex> is_function(\"not a function\")\n    false\n\n","title":"Kernel.is_function/1","type":"function"},{"doc":"Returns true if term is a function that can be applied with arity number of arguments; otherwise returns false . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_function ( fn x -&gt; x * 2 end , 1 ) true iex&gt; is_function ( fn x -&gt; x * 2 end , 2 ) false","ref":"Kernel.html#is_function/2","source_doc":"Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_function(fn x -> x * 2 end, 1)\n    true\n    iex> is_function(fn x -> x * 2 end, 2)\n    false\n\n","title":"Kernel.is_function/2","type":"function"},{"doc":"Returns true if term is an integer; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_integer/1","source_doc":"Returns `true` if `term` is an integer; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_integer/1","type":"function"},{"doc":"Returns true if term is a list with zero or more elements; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_list/1","source_doc":"Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_list/1","type":"function"},{"doc":"Returns true if term is a map; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_map/1","source_doc":"Returns `true` if `term` is a map; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_map/1","type":"function"},{"doc":"Returns true if key is a key in map ; otherwise returns false . It raises BadMapError if the first element is not a map. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; is_map_key ( %{ a : &quot;foo&quot; , b : &quot;bar&quot; } , :a ) true iex&gt; is_map_key ( %{ a : &quot;foo&quot; , b : &quot;bar&quot; } , :c ) false","ref":"Kernel.html#is_map_key/2","source_doc":"Returns `true` if `key` is a key in `map`; otherwise returns `false`.\n\nIt raises `BadMapError` if the first element is not a map.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> is_map_key(%{a: \"foo\", b: \"bar\"}, :a)\n    true\n\n    iex> is_map_key(%{a: \"foo\", b: \"bar\"}, :c)\n    false\n","title":"Kernel.is_map_key/2","type":"function"},{"doc":"Returns true if term is nil , false otherwise. Allowed in guard clauses. Examples iex&gt; is_nil ( 1 ) false iex&gt; is_nil ( nil ) true","ref":"Kernel.html#is_nil/1","source_doc":"Returns `true` if `term` is `nil`, `false` otherwise.\n\nAllowed in guard clauses.\n\n## Examples\n\n    iex> is_nil(1)\n    false\n\n    iex> is_nil(nil)\n    true\n\n","title":"Kernel.is_nil/1","type":"macro"},{"doc":"Returns true if term is either an integer or a floating-point number; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_number/1","source_doc":"Returns `true` if `term` is either an integer or a floating-point number;\notherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_number/1","type":"function"},{"doc":"Returns true if term is a PID (process identifier); otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_pid/1","source_doc":"Returns `true` if `term` is a PID (process identifier); otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_pid/1","type":"function"},{"doc":"Returns true if term is a port identifier; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_port/1","source_doc":"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_port/1","type":"function"},{"doc":"Returns true if term is a reference; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_reference/1","source_doc":"Returns `true` if `term` is a reference; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_reference/1","type":"function"},{"doc":"Returns true if term is a struct; otherwise returns false . Allowed in guard tests. Examples iex&gt; is_struct ( URI . parse ( &quot;/&quot; ) ) true iex&gt; is_struct ( %{ } ) false","ref":"Kernel.html#is_struct/1","source_doc":"Returns true if `term` is a struct; otherwise returns `false`.\n\nAllowed in guard tests.\n\n## Examples\n\n    iex> is_struct(URI.parse(\"/\"))\n    true\n\n    iex> is_struct(%{})\n    false\n\n","title":"Kernel.is_struct/1","type":"macro"},{"doc":"Returns true if term is a struct of name ; otherwise returns false . is_struct/2 does not check that name exists and is a valid struct. If you want such validations, you must pattern match on the struct instead, such as match?(%URI{}, arg) . Allowed in guard tests. Examples iex&gt; is_struct ( URI . parse ( &quot;/&quot; ) , URI ) true iex&gt; is_struct ( URI . parse ( &quot;/&quot; ) , Macro.Env ) false","ref":"Kernel.html#is_struct/2","source_doc":"Returns true if `term` is a struct of `name`; otherwise returns `false`.\n\n`is_struct/2` does not check that `name` exists and is a valid struct.\nIf you want such validations, you must pattern match on the struct\ninstead, such as `match?(%URI{}, arg)`.\n\nAllowed in guard tests.\n\n## Examples\n\n    iex> is_struct(URI.parse(\"/\"), URI)\n    true\n\n    iex> is_struct(URI.parse(\"/\"), Macro.Env)\n    false\n\n","title":"Kernel.is_struct/2","type":"macro"},{"doc":"Returns true if term is a tuple; otherwise returns false . Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#is_tuple/1","source_doc":"Returns `true` if `term` is a tuple; otherwise returns `false`.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.is_tuple/1","type":"function"},{"doc":"Returns the length of list . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; length ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ) 9","ref":"Kernel.html#length/1","source_doc":"Returns the length of `list`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    9\n\n","title":"Kernel.length/1","type":"function"},{"doc":"Returns true if module is loaded and contains a public macro with the given arity , otherwise false . Note that this function does not load the module in case it is not loaded. Check Code.ensure_loaded/1 for more information. If module is an Erlang module (as opposed to an Elixir module), this function always returns false . Examples iex&gt; macro_exported? ( Kernel , :use , 2 ) true iex&gt; macro_exported? ( :erlang , :abs , 1 ) false","ref":"Kernel.html#macro_exported?/3","source_doc":"Returns `true` if `module` is loaded and contains a\npublic `macro` with the given `arity`, otherwise `false`.\n\nNote that this function does not load the module in case\nit is not loaded. Check `Code.ensure_loaded/1` for more\ninformation.\n\nIf `module` is an Erlang module (as opposed to an Elixir module), this\nfunction always returns `false`.\n\n## Examples\n\n    iex> macro_exported?(Kernel, :use, 2)\n    true\n\n    iex> macro_exported?(:erlang, :abs, 1)\n    false\n\n","title":"Kernel.macro_exported?/3","type":"function"},{"doc":"Returns an almost unique reference. The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes. Inlined by the compiler. Examples make_ref ( ) #=&gt; #Reference&lt;0.0.0.135&gt;","ref":"Kernel.html#make_ref/0","source_doc":"Returns an almost unique reference.\n\nThe returned reference will re-occur after approximately 2^82 calls;\ntherefore it is unique enough for practical purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    make_ref()\n    #=> #Reference<0.0.0.135>\n\n","title":"Kernel.make_ref/0","type":"function"},{"doc":"Returns the size of a map. The size of a map is the number of key-value pairs that the map contains. This operation happens in constant time. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; map_size ( %{ a : &quot;foo&quot; , b : &quot;bar&quot; } ) 2","ref":"Kernel.html#map_size/1","source_doc":"Returns the size of a map.\n\nThe size of a map is the number of key-value pairs that the map contains.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> map_size(%{a: \"foo\", b: \"bar\"})\n    2\n\n","title":"Kernel.map_size/1","type":"function"},{"doc":"A convenience macro that checks if the right side (an expression) matches the left side (a pattern). Examples iex&gt; match? ( 1 , 1 ) true iex&gt; match? ( { 1 , _ } , { 1 , 2 } ) true iex&gt; map = %{ a : 1 , b : 2 } iex&gt; match? ( %{ a : _ } , map ) true iex&gt; a = 1 iex&gt; match? ( ^ a , 1 ) true match?/2 is very useful when filtering or finding a value in an enumerable: iex&gt; list = [ a : 1 , b : 2 , a : 3 ] iex&gt; Enum . filter ( list , &amp; match? ( { :a , _ } , &amp;1 ) ) [ a : 1 , a : 3 ] Guard clauses can also be given to the match: iex&gt; list = [ a : 1 , b : 2 , a : 3 ] iex&gt; Enum . filter ( list , &amp; match? ( { :a , x } when x &lt; 2 , &amp;1 ) ) [ a : 1 ] Variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the = operator): iex&gt; match? ( _x , 1 ) true iex&gt; binding ( ) [ ] Values vs patterns Remember the pin operator matches values , not patterns . Passing a variable as the pattern will always return true and will result in a warning that the variable is unused: # don&#39;t do this pattern = %{ a : :a } match? ( pattern , %{ b : :b } ) Similarly, moving an expression out the pattern may no longer preserve its semantics. For example: match? ( [ _ | _ ] , [ 1 , 2 , 3 ] ) #=&gt; true pattern = [ _ | _ ] match? ( pattern , [ 1 , 2 , 3 ] ) ** (CompileError) invalid use of _. _ can only be used inside patterns to ignore values and cannot be used in expressions. Make sure you are inside a pattern or change it accordingly Another example is that a map as a pattern performs a subset match, but not once assigned to a variable: match? ( %{ x : 1 } , %{ x : 1 , y : 2 } ) #=&gt; true attrs = %{ x : 1 } match? ( ^ attrs , %{ x : 1 , y : 2 } ) #=&gt; false The pin operator will check if the values are equal, using ===/2 , while patterns have their own rules when matching maps, lists, and so forth. Such behaviour is not specific to match?/2 . The following code also throws an exception: attrs = %{ x : 1 } ^ attrs = %{ x : 1 , y : 2 } #=&gt; (MatchError) no match of right hand side value: %{x: 1, y: 2}","ref":"Kernel.html#match?/2","source_doc":"A convenience macro that checks if the right side (an expression) matches the\nleft side (a pattern).\n\n## Examples\n\n    iex> match?(1, 1)\n    true\n\n    iex> match?({1, _}, {1, 2})\n    true\n\n    iex> map = %{a: 1, b: 2}\n    iex> match?(%{a: _}, map)\n    true\n\n    iex> a = 1\n    iex> match?(^a, 1)\n    true\n\n`match?/2` is very useful when filtering or finding a value in an enumerable:\n\n    iex> list = [a: 1, b: 2, a: 3]\n    iex> Enum.filter(list, &match?({:a, _}, &1))\n    [a: 1, a: 3]\n\nGuard clauses can also be given to the match:\n\n    iex> list = [a: 1, b: 2, a: 3]\n    iex> Enum.filter(list, &match?({:a, x} when x < 2, &1))\n    [a: 1]\n\nVariables assigned in the match will not be available outside of the\nfunction call (unlike regular pattern matching with the `=` operator):\n\n    iex> match?(_x, 1)\n    true\n    iex> binding()\n    []\n\n## Values vs patterns\n\nRemember the pin operator matches _values_, not _patterns_.\nPassing a variable as the pattern will always return `true` and will\nresult in a warning that the variable is unused:\n\n    # don't do this\n    pattern = %{a: :a}\n    match?(pattern, %{b: :b})\n\nSimilarly, moving an expression out the pattern may no longer preserve\nits semantics. For example:\n\n    match?([_ | _], [1, 2, 3])\n    #=> true\n\n    pattern = [_ | _]\n    match?(pattern, [1, 2, 3])\n    ** (CompileError) invalid use of _. _ can only be used inside patterns to ignore values and cannot be used in expressions. Make sure you are inside a pattern or change it accordingly\n\nAnother example is that a map as a pattern performs a subset match, but not\nonce assigned to a variable:\n\n    match?(%{x: 1}, %{x: 1, y: 2})\n    #=> true\n\n    attrs = %{x: 1}\n    match?(^attrs, %{x: 1, y: 2})\n    #=> false\n\nThe pin operator will check if the values are equal, using `===/2`, while\npatterns have their own rules when matching maps, lists, and so forth.\nSuch behaviour is not specific to `match?/2`. The following code also\nthrows an exception:\n\n    attrs = %{x: 1}\n    ^attrs = %{x: 1, y: 2}\n    #=> (MatchError) no match of right hand side value: %{x: 1, y: 2}\n\n","title":"Kernel.match?/2","type":"macro"},{"doc":"Returns the biggest of the two given terms according to their structural comparison. If the terms compare equal, the first one is returned. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Inlined by the compiler. Examples iex&gt; max ( 1 , 2 ) 2 iex&gt; max ( :a , :b ) :b","ref":"Kernel.html#max/2","source_doc":"Returns the biggest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> max(1, 2)\n    2\n    iex> max(:a, :b)\n    :b\n\n","title":"Kernel.max/2","type":"function"},{"doc":"Returns the smallest of the two given terms according to their structural comparison. If the terms compare equal, the first one is returned. This performs a structural comparison where all Elixir terms can be compared with each other. See the &quot;Structural comparison&quot; section section for more information. Inlined by the compiler. Examples iex&gt; min ( 1 , 2 ) 1 iex&gt; min ( &quot;foo&quot; , &quot;bar&quot; ) &quot;bar&quot;","ref":"Kernel.html#min/2","source_doc":"Returns the smallest of the two given terms according to\ntheir structural comparison.\n\nIf the terms compare equal, the first one is returned.\n\nThis performs a structural comparison where all Elixir\nterms can be compared with each other. See the [\"Structural\ncomparison\" section](#module-structural-comparison) section\nfor more information.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> min(1, 2)\n    1\n    iex> min(\"foo\", \"bar\")\n    \"bar\"\n\n","title":"Kernel.min/2","type":"function"},{"doc":"Returns an atom representing the name of the local node. If the node is not alive, :nonode@nohost is returned instead. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#node/0","source_doc":"Returns an atom representing the name of the local node.\nIf the node is not alive, `:nonode@nohost` is returned instead.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.node/0","type":"function"},{"doc":"Returns the node where the given argument is located. The argument can be a PID, a reference, or a port. If the local node is not alive, :nonode@nohost is returned. Allowed in guard tests. Inlined by the compiler.","ref":"Kernel.html#node/1","source_doc":"Returns the node where the given argument is located.\nThe argument can be a PID, a reference, or a port.\nIf the local node is not alive, `:nonode@nohost` is returned.\n\nAllowed in guard tests. Inlined by the compiler.\n","title":"Kernel.node/1","type":"function"},{"doc":"Strictly boolean &quot;not&quot; operator. value must be a boolean; if it's not, an ArgumentError exception is raised. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; not false true","ref":"Kernel.html#not/1","source_doc":"Strictly boolean \"not\" operator.\n\n`value` must be a boolean; if it's not, an `ArgumentError` exception is raised.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> not false\n    true\n\n","title":"Kernel.not/1","type":"function"},{"doc":"Strictly boolean &quot;or&quot; operator. If left is true , returns true ; otherwise returns right . Requires only the left operand to be a boolean since it short-circuits. If the left operand is not a boolean, a BadBooleanError exception is raised. Allowed in guard tests. Examples iex&gt; true or false true iex&gt; false or 42 42 iex&gt; 42 or false ** (BadBooleanError) expected a boolean on left-side of &quot;or&quot;, got: 42","ref":"Kernel.html#or/2","source_doc":"Strictly boolean \"or\" operator.\n\nIf `left` is `true`, returns `true`; otherwise returns `right`.\n\nRequires only the `left` operand to be a boolean since it short-circuits.\nIf the `left` operand is not a boolean, a `BadBooleanError` exception is\nraised.\n\nAllowed in guard tests.\n\n## Examples\n\n    iex> true or false\n    true\n\n    iex> false or 42\n    42\n\n    iex> 42 or false\n    ** (BadBooleanError) expected a boolean on left-side of \"or\", got: 42\n\n","title":"Kernel.or/2","type":"macro"},{"doc":"Pops a key from the nested structure via the given path . This is similar to pop_in/2 , except the path is extracted via a macro rather than passing a list. For example: pop_in ( opts [ :foo ] [ :bar ] ) Is equivalent to: pop_in ( opts , [ :foo , :bar ] ) Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs. Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; pop_in ( users [ &quot;john&quot; ] [ :age ] ) { 27 , %{ &quot;john&quot; =&gt; %{ } , &quot;meg&quot; =&gt; %{ age : 23 } } } iex&gt; users = %{ john : %{ age : 27 } , meg : %{ age : 23 } } iex&gt; pop_in ( users . john [ :age ] ) { 27 , %{ john : %{ } , meg : %{ age : 23 } } } In case any entry returns nil , its key will be removed and the deletion will be considered a success.","ref":"Kernel.html#pop_in/1","source_doc":"Pops a key from the nested structure via the given `path`.\n\nThis is similar to `pop_in/2`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    pop_in(opts[:foo][:bar])\n\nIs equivalent to:\n\n    pop_in(opts, [:foo, :bar])\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users[\"john\"][:age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\n    iex> users = %{john: %{age: 27}, meg: %{age: 23}}\n    iex> pop_in(users.john[:age])\n    {27, %{john: %{}, meg: %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.\n","title":"Kernel.pop_in/1","type":"macro"},{"doc":"Pops a key from the given nested structure. Uses the Access protocol to traverse the structures according to the given keys , unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3 . Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; pop_in ( users , [ &quot;john&quot; , :age ] ) { 27 , %{ &quot;john&quot; =&gt; %{ } , &quot;meg&quot; =&gt; %{ age : 23 } } } In case any entry returns nil , its key will be removed and the deletion will be considered a success. iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; pop_in ( users , [ &quot;jane&quot; , :age ] ) { nil , %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } }","ref":"Kernel.html#pop_in/2","source_doc":"Pops a key from the given nested structure.\n\nUses the `Access` protocol to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"john\", :age])\n    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n\nIn case any entry returns `nil`, its key will be removed\nand the deletion will be considered a success.\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> pop_in(users, [\"jane\", :age])\n    {nil, %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}}\n\n","title":"Kernel.pop_in/2","type":"function"},{"doc":"Puts value at the given zero-based index in tuple . Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar , 3 } iex&gt; put_elem ( tuple , 0 , :baz ) { :baz , :bar , 3 }","ref":"Kernel.html#put_elem/3","source_doc":"Puts `value` at the given zero-based `index` in `tuple`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, 3}\n    iex> put_elem(tuple, 0, :baz)\n    {:baz, :bar, 3}\n\n","title":"Kernel.put_elem/3","type":"function"},{"doc":"Puts a value in a nested structure via the given path . This is similar to put_in/3 , except the path is extracted via a macro rather than passing a list. For example: put_in ( opts [ :foo ] [ :bar ] , :baz ) Is equivalent to: put_in ( opts , [ :foo , :bar ] , :baz ) This also works with nested structs and the struct.path.to.value way to specify paths: put_in ( struct . foo . bar , :baz ) Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs. Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] [ :age ] , 28 ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] . age , 28 ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } }","ref":"Kernel.html#put_in/2","source_doc":"Puts a value in a nested structure via the given `path`.\n\nThis is similar to `put_in/3`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    put_in(opts[:foo][:bar], :baz)\n\nIs equivalent to:\n\n    put_in(opts, [:foo, :bar], :baz)\n\nThis also works with nested structs and the `struct.path.to.value` way to specify\npaths:\n\n    put_in(struct.foo.bar, :baz)\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"][:age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"].age, 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n","title":"Kernel.put_in/2","type":"macro"},{"doc":"Puts a value in a nested structure. Uses the Access module to traverse the structures according to the given keys , unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3 . Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; put_in ( users , [ &quot;john&quot; , :age ] , 28 ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } If any of the intermediate values are nil, it will raise: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; put_in ( users , [ &quot;jane&quot; , :age ] , &quot;oops&quot; ) ** (ArgumentError) could not put/update key :age on a nil value","ref":"Kernel.html#put_in/3","source_doc":"Puts a value in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"john\", :age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users, [\"jane\", :age], \"oops\")\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n","title":"Kernel.put_in/3","type":"function"},{"doc":"Raises an exception. If message is a string, it raises a RuntimeError exception with it. If message is an atom, it just calls raise/2 with the atom as the first argument and [] as the second one. If message is an exception struct, it is raised as is. If message is anything else, raise will fail with an ArgumentError exception. Examples iex&gt; raise &quot;oops&quot; ** (RuntimeError) oops try do 1 + :foo rescue x in [ ArithmeticError ] -&gt; IO . puts ( &quot;that was expected&quot; ) raise x end","ref":"Kernel.html#raise/1","source_doc":"Raises an exception.\n\nIf `message` is a string, it raises a `RuntimeError` exception with it.\n\nIf `message` is an atom, it just calls `raise/2` with the atom as the first\nargument and `[]` as the second one.\n\nIf `message` is an exception struct, it is raised as is.\n\nIf `message` is anything else, `raise` will fail with an `ArgumentError`\nexception.\n\n## Examples\n\n    iex> raise \"oops\"\n    ** (RuntimeError) oops\n\n    try do\n      1 + :foo\n    rescue\n      x in [ArithmeticError] ->\n        IO.puts(\"that was expected\")\n        raise x\n    end\n\n","title":"Kernel.raise/1","type":"macro"},{"doc":"Raises an exception. Calls the exception/1 function on the given argument (which has to be a module name like ArgumentError or RuntimeError ) passing attributes in order to retrieve the exception struct. Any module that contains a call to the defexception/1 macro automatically implements the Exception.exception/1 callback expected by raise/2 . For more information, see defexception/1 . Examples iex&gt; raise ( ArgumentError , &quot;Sample&quot; ) ** (ArgumentError) Sample","ref":"Kernel.html#raise/2","source_doc":"Raises an exception.\n\nCalls the `exception/1` function on the given argument (which has to be a\nmodule name like `ArgumentError` or `RuntimeError`) passing `attributes`\nin order to retrieve the exception struct.\n\nAny module that contains a call to the `defexception/1` macro automatically\nimplements the `c:Exception.exception/1` callback expected by `raise/2`.\nFor more information, see `defexception/1`.\n\n## Examples\n\n    iex> raise(ArgumentError, \"Sample\")\n    ** (ArgumentError) Sample\n\n","title":"Kernel.raise/2","type":"macro"},{"doc":"Computes the remainder of an integer division. rem/2 uses truncated division, which means that the result will always have the sign of the dividend . Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; rem ( 5 , 2 ) 1 iex&gt; rem ( 6 , - 4 ) 2","ref":"Kernel.html#rem/2","source_doc":"Computes the remainder of an integer division.\n\n`rem/2` uses truncated division, which means that\nthe result will always have the sign of the `dividend`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> rem(5, 2)\n    1\n    iex> rem(6, -4)\n    2\n\n","title":"Kernel.rem/2","type":"function"},{"doc":"Raises an exception preserving a previous stacktrace. Works like raise/1 but does not generate a new stacktrace. Note that __STACKTRACE__ can be used inside catch/rescue to retrieve the current stacktrace. Examples try do raise &quot;oops&quot; rescue exception -&gt; reraise exception , __STACKTRACE__ end","ref":"Kernel.html#reraise/2","source_doc":"Raises an exception preserving a previous stacktrace.\n\nWorks like `raise/1` but does not generate a new stacktrace.\n\nNote that `__STACKTRACE__` can be used inside catch/rescue\nto retrieve the current stacktrace.\n\n## Examples\n\n    try do\n      raise \"oops\"\n    rescue\n      exception ->\n        reraise exception, __STACKTRACE__\n    end\n\n","title":"Kernel.reraise/2","type":"macro"},{"doc":"Raises an exception preserving a previous stacktrace. reraise/3 works like reraise/2 , except it passes arguments to the exception/1 function as explained in raise/2 . Examples try do raise &quot;oops&quot; rescue exception -&gt; reraise WrapperError , [ exception : exception ] , __STACKTRACE__ end","ref":"Kernel.html#reraise/3","source_doc":"Raises an exception preserving a previous stacktrace.\n\n`reraise/3` works like `reraise/2`, except it passes arguments to the\n`exception/1` function as explained in `raise/2`.\n\n## Examples\n\n    try do\n      raise \"oops\"\n    rescue\n      exception ->\n        reraise WrapperError, [exception: exception], __STACKTRACE__\n    end\n\n","title":"Kernel.reraise/3","type":"macro"},{"doc":"Rounds a number to the nearest integer. If the number is equidistant to the two nearest integers, rounds away from zero. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; round ( 5.6 ) 6 iex&gt; round ( 5.2 ) 5 iex&gt; round ( - 9.9 ) - 10 iex&gt; round ( - 9 ) - 9 iex&gt; round ( 2.5 ) 3 iex&gt; round ( - 2.5 ) - 3","ref":"Kernel.html#round/1","source_doc":"Rounds a number to the nearest integer.\n\nIf the number is equidistant to the two nearest integers, rounds away from zero.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> round(5.6)\n    6\n\n    iex> round(5.2)\n    5\n\n    iex> round(-9.9)\n    -10\n\n    iex> round(-9)\n    -9\n\n    iex> round(2.5)\n    3\n\n    iex> round(-2.5)\n    -3\n\n","title":"Kernel.round/1","type":"function"},{"doc":"Returns the PID (process identifier) of the calling process. Allowed in guard clauses. Inlined by the compiler.","ref":"Kernel.html#self/0","source_doc":"Returns the PID (process identifier) of the calling process.\n\nAllowed in guard clauses. Inlined by the compiler.\n","title":"Kernel.self/0","type":"function"},{"doc":"Sends a message to the given dest and returns the message. dest may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node. Inlined by the compiler. Examples iex&gt; send ( self ( ) , :hello ) :hello","ref":"Kernel.html#send/2","source_doc":"Sends a message to the given `dest` and returns the message.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> send(self(), :hello)\n    :hello\n\n","title":"Kernel.send/2","type":"function"},{"doc":"Handles the sigil ~C for charlists. It returns a charlist without interpolations and without escape characters, except for the escaping of the closing sigil character itself. A charlist is a list of integers where all the integers are valid code points. The three expressions below are equivalent: ~C&quot;foo\\n&quot; [ ?f , ?o , ?o , ?\\\\ , ?n ] [ 102 , 111 , 111 , 92 , 110 ] In practice, charlists are mostly used in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments. Examples iex&gt; ~C(foo) ~c&quot;foo&quot; iex&gt; ~C(f\#{o}o) ~c&quot;f \\# {o}o&quot; iex&gt; ~C(foo\\n) ~c&quot;foo \\\\ n&quot;","ref":"Kernel.html#sigil_C/2","source_doc":"Handles the sigil `~C` for charlists.\n\nIt returns a charlist without interpolations and without escape\ncharacters, except for the escaping of the closing sigil character\nitself.\n\nA charlist is a list of integers where all the integers are valid code points.\nThe three expressions below are equivalent:\n\n    ~C\"foo\\n\"\n    [?f, ?o, ?o, ?\\\\, ?n]\n    [102, 111, 111, 92, 110]\n\nIn practice, charlists are mostly used in specific scenarios such as\ninterfacing with older Erlang libraries that do not accept binaries as arguments.\n\n## Examples\n\n    iex> ~C(foo)\n    ~c\"foo\"\n\n    iex> ~C(f\#{o}o)\n    ~c\"f\\\#{o}o\"\n\n    iex> ~C(foo\\n)\n    ~c\"foo\\\\n\"\n\n","title":"Kernel.sigil_C/2","type":"macro"},{"doc":"Handles the sigil ~c for charlists. It returns a charlist, unescaping characters and replacing interpolations. A charlist is a list of integers where all the integers are valid code points. The three expressions below are equivalent: ~c&quot;foo&quot; [ ?f , ?o , ?o ] [ 102 , 111 , 111 ] In practice, charlists are mostly used in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments. Examples iex&gt; ~c(foo) ~c&quot;foo&quot; iex&gt; ~c(f \#{ :o } o) ~c&quot;foo&quot; iex&gt; ~c(f \\# {:o}o) ~c&quot;f \\# {:o}o&quot; The list is only printed as a ~c sigil if all code points are within the ASCII range: iex&gt; ~c&quot;hełło&quot; [ 104 , 101 , 322 , 322 , 111 ] iex&gt; [ 104 , 101 , 108 , 108 , 111 ] ~c&quot;hello&quot; See Inspect.Opts for more information.","ref":"Kernel.html#sigil_c/2","source_doc":"Handles the sigil `~c` for charlists.\n\nIt returns a charlist, unescaping characters and replacing interpolations.\n\nA charlist is a list of integers where all the integers are valid code points.\nThe three expressions below are equivalent:\n\n    ~c\"foo\"\n    [?f, ?o, ?o]\n    [102, 111, 111]\n\nIn practice, charlists are mostly used in specific scenarios such as\ninterfacing with older Erlang libraries that do not accept binaries as arguments.\n\n## Examples\n\n    iex> ~c(foo)\n    ~c\"foo\"\n\n    iex> ~c(f\#{:o}o)\n    ~c\"foo\"\n\n    iex> ~c(f\\\#{:o}o)\n    ~c\"f\\\#{:o}o\"\n\nThe list is only printed as a `~c` sigil if all code points are within the\nASCII range:\n\n    iex> ~c\"hełło\"\n    [104, 101, 322, 322, 111]\n\n    iex> [104, 101, 108, 108, 111]\n    ~c\"hello\"\n\nSee `Inspect.Opts` for more information.\n","title":"Kernel.sigil_c/2","type":"macro"},{"doc":"Handles the sigil ~D for dates. By default, this sigil uses the built-in Calendar.ISO , which requires dates to be written in the ISO8601 format: ~D[yyyy-mm-dd] such as: ~D[2015-01-13] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~D[SOME-REPRESENTATION My.Alternative.Calendar] The lower case ~d variant does not exist as interpolation and escape characters are not useful for date sigils. More information on dates can be found in the Date module. Examples iex&gt; ~D[2015-01-13] ~D[2015-01-13]","ref":"Kernel.html#sigil_D/2","source_doc":"Handles the sigil `~D` for dates.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires dates to be written in the ISO8601 format:\n\n    ~D[yyyy-mm-dd]\n\nsuch as:\n\n    ~D[2015-01-13]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~D[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe lower case `~d` variant does not exist as interpolation\nand escape characters are not useful for date sigils.\n\nMore information on dates can be found in the `Date` module.\n\n## Examples\n\n    iex> ~D[2015-01-13]\n    ~D[2015-01-13]\n\n","title":"Kernel.sigil_D/2","type":"macro"},{"doc":"Handles the sigil ~N for naive date times. By default, this sigil uses the built-in Calendar.ISO , which requires naive date times to be written in the ISO8601 format: ~N[yyyy-mm-dd hh:mm:ss] ~N[yyyy-mm-dd hh:mm:ss.ssssss] ~N[yyyy-mm-ddThh:mm:ss.ssssss] such as: ~N[2015-01-13 13:00:07] ~N[2015-01-13T13:00:07.123] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~N[SOME-REPRESENTATION My.Alternative.Calendar] The lower case ~n variant does not exist as interpolation and escape characters are not useful for date time sigils. More information on naive date times can be found in the NaiveDateTime module. Examples iex&gt; ~N[2015-01-13 13:00:07] ~N[2015-01-13 13:00:07] iex&gt; ~N[2015-01-13T13:00:07.001] ~N[2015-01-13 13:00:07.001]","ref":"Kernel.html#sigil_N/2","source_doc":"Handles the sigil `~N` for naive date times.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires naive date times to be written in the ISO8601 format:\n\n    ~N[yyyy-mm-dd hh:mm:ss]\n    ~N[yyyy-mm-dd hh:mm:ss.ssssss]\n    ~N[yyyy-mm-ddThh:mm:ss.ssssss]\n\nsuch as:\n\n    ~N[2015-01-13 13:00:07]\n    ~N[2015-01-13T13:00:07.123]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~N[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe lower case `~n` variant does not exist as interpolation\nand escape characters are not useful for date time sigils.\n\nMore information on naive date times can be found in the\n`NaiveDateTime` module.\n\n## Examples\n\n    iex> ~N[2015-01-13 13:00:07]\n    ~N[2015-01-13 13:00:07]\n    iex> ~N[2015-01-13T13:00:07.001]\n    ~N[2015-01-13 13:00:07.001]\n\n","title":"Kernel.sigil_N/2","type":"macro"},{"doc":"Handles the sigil ~R for regular expressions. It returns a regular expression pattern without interpolations and without escape characters. Note it still supports escape of Regex tokens (such as escaping + or ? ) and it also requires you to escape the closing sigil character itself if it appears on the Regex. More information on regexes can be found in the Regex module. Examples iex&gt; Regex . match? ( ~R(f\#{1,3}o) , &quot;f#o&quot; ) true","ref":"Kernel.html#sigil_R/2","source_doc":"Handles the sigil `~R` for regular expressions.\n\nIt returns a regular expression pattern without interpolations and\nwithout escape characters. Note it still supports escape of Regex\ntokens (such as escaping `+` or `?`) and it also requires you to\nescape the closing sigil character itself if it appears on the Regex.\n\nMore information on regexes can be found in the `Regex` module.\n\n## Examples\n\n    iex> Regex.match?(~R(f\#{1,3}o), \"f#o\")\n    true\n\n","title":"Kernel.sigil_R/2","type":"macro"},{"doc":"Handles the sigil ~r for regular expressions. It returns a regular expression pattern, unescaping characters and replacing interpolations. More information on regular expressions can be found in the Regex module. Examples iex&gt; Regex . match? ( ~r/foo/ , &quot;foo&quot; ) true iex&gt; Regex . match? ( ~r/a \#{ :b } c/ , &quot;abc&quot; ) true While the ~r sigil allows parens and brackets to be used as delimiters, it is preferred to use &quot; or / to avoid escaping conflicts with reserved regex characters.","ref":"Kernel.html#sigil_r/2","source_doc":"Handles the sigil `~r` for regular expressions.\n\nIt returns a regular expression pattern, unescaping characters and replacing\ninterpolations.\n\nMore information on regular expressions can be found in the `Regex` module.\n\n## Examples\n\n    iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/a\#{:b}c/, \"abc\")\n    true\n\nWhile the `~r` sigil allows parens and brackets to be used as delimiters,\nit is preferred to use `\"` or `/` to avoid escaping conflicts with reserved\nregex characters.\n","title":"Kernel.sigil_r/2","type":"macro"},{"doc":"Handles the sigil ~S for strings. It returns a string without interpolations and without escape characters, except for the escaping of the closing sigil character itself. Examples iex&gt; ~S(foo) &quot;foo&quot; iex&gt; ~S(f\#{o}o) &quot;f \\# {o}o&quot; iex&gt; ~S(\\o/) &quot; \\\\ o/&quot; However, if you want to re-use the sigil character itself on the string, you need to escape it: iex&gt; ~S((\\)) &quot;()&quot;","ref":"Kernel.html#sigil_S/2","source_doc":"Handles the sigil `~S` for strings.\n\nIt returns a string without interpolations and without escape\ncharacters, except for the escaping of the closing sigil character\nitself.\n\n## Examples\n\n    iex> ~S(foo)\n    \"foo\"\n    iex> ~S(f\#{o}o)\n    \"f\\\#{o}o\"\n    iex> ~S(\\o/)\n    \"\\\\o/\"\n\nHowever, if you want to re-use the sigil character itself on\nthe string, you need to escape it:\n\n    iex> ~S((\\))\n    \"()\"\n\n","title":"Kernel.sigil_S/2","type":"macro"},{"doc":"Handles the sigil ~s for strings. It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations. Examples iex&gt; ~s(foo) &quot;foo&quot; iex&gt; ~s(f \#{ :o } o) &quot;foo&quot; iex&gt; ~s(f \\# {:o}o) &quot;f \\# {:o}o&quot;","ref":"Kernel.html#sigil_s/2","source_doc":"Handles the sigil `~s` for strings.\n\nIt returns a string as if it was a double quoted string, unescaping characters\nand replacing interpolations.\n\n## Examples\n\n    iex> ~s(foo)\n    \"foo\"\n\n    iex> ~s(f\#{:o}o)\n    \"foo\"\n\n    iex> ~s(f\\\#{:o}o)\n    \"f\\\#{:o}o\"\n\n","title":"Kernel.sigil_s/2","type":"macro"},{"doc":"Handles the sigil ~T for times. By default, this sigil uses the built-in Calendar.ISO , which requires times to be written in the ISO8601 format: ~T[hh:mm:ss] ~T[hh:mm:ss.ssssss] such as: ~T[13:00:07] ~T[13:00:07.123] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~T[SOME-REPRESENTATION My.Alternative.Calendar] The lower case ~t variant does not exist as interpolation and escape characters are not useful for time sigils. More information on times can be found in the Time module. Examples iex&gt; ~T[13:00:07] ~T[13:00:07] iex&gt; ~T[13:00:07.001] ~T[13:00:07.001]","ref":"Kernel.html#sigil_T/2","source_doc":"Handles the sigil `~T` for times.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires times to be written in the ISO8601 format:\n\n    ~T[hh:mm:ss]\n    ~T[hh:mm:ss.ssssss]\n\nsuch as:\n\n    ~T[13:00:07]\n    ~T[13:00:07.123]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~T[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe lower case `~t` variant does not exist as interpolation\nand escape characters are not useful for time sigils.\n\nMore information on times can be found in the `Time` module.\n\n## Examples\n\n    iex> ~T[13:00:07]\n    ~T[13:00:07]\n    iex> ~T[13:00:07.001]\n    ~T[13:00:07.001]\n\n","title":"Kernel.sigil_T/2","type":"macro"},{"doc":"Handles the sigil ~U to create a UTC DateTime . By default, this sigil uses the built-in Calendar.ISO , which requires UTC date times to be written in the ISO8601 format: ~U[yyyy-mm-dd hh:mm:ssZ] ~U[yyyy-mm-dd hh:mm:ss.ssssssZ] ~U[yyyy-mm-ddThh:mm:ss.ssssss+00:00] such as: ~U[2015-01-13 13:00:07Z] ~U[2015-01-13T13:00:07.123+00:00] If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name: ~U[SOME-REPRESENTATION My.Alternative.Calendar] The given datetime_string must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised. The lower case ~u variant does not exist as interpolation and escape characters are not useful for date time sigils. More information on date times can be found in the DateTime module. Examples iex&gt; ~U[2015-01-13 13:00:07Z] ~U[2015-01-13 13:00:07Z] iex&gt; ~U[2015-01-13T13:00:07.001+00:00] ~U[2015-01-13 13:00:07.001Z]","ref":"Kernel.html#sigil_U/2","source_doc":"Handles the sigil `~U` to create a UTC `DateTime`.\n\nBy default, this sigil uses the built-in `Calendar.ISO`, which\nrequires UTC date times to be written in the ISO8601 format:\n\n    ~U[yyyy-mm-dd hh:mm:ssZ]\n    ~U[yyyy-mm-dd hh:mm:ss.ssssssZ]\n    ~U[yyyy-mm-ddThh:mm:ss.ssssss+00:00]\n\nsuch as:\n\n    ~U[2015-01-13 13:00:07Z]\n    ~U[2015-01-13T13:00:07.123+00:00]\n\nIf you are using alternative calendars, any representation can\nbe used as long as you follow the representation by a single space\nand the calendar name:\n\n    ~U[SOME-REPRESENTATION My.Alternative.Calendar]\n\nThe given `datetime_string` must include \"Z\" or \"00:00\" offset\nwhich marks it as UTC, otherwise an error is raised.\n\nThe lower case `~u` variant does not exist as interpolation\nand escape characters are not useful for date time sigils.\n\nMore information on date times can be found in the `DateTime` module.\n\n## Examples\n\n    iex> ~U[2015-01-13 13:00:07Z]\n    ~U[2015-01-13 13:00:07Z]\n    iex> ~U[2015-01-13T13:00:07.001+00:00]\n    ~U[2015-01-13 13:00:07.001Z]\n\n","title":"Kernel.sigil_U/2","type":"macro"},{"doc":"Handles the sigil ~W for list of words. It returns a list of &quot;words&quot; split by whitespace without interpolations and without escape characters, except for the escaping of the closing sigil character itself. Modifiers s : words in the list are strings (default) a : words in the list are atoms c : words in the list are charlists Examples iex&gt; ~W(foo \#{bar} baz) [ &quot;foo&quot; , &quot; \\# {bar}&quot; , &quot;baz&quot; ]","ref":"Kernel.html#sigil_W/2","source_doc":"Handles the sigil `~W` for list of words.\n\nIt returns a list of \"words\" split by whitespace without interpolations\nand without escape characters, except for the escaping of the closing\nsigil character itself.\n\n## Modifiers\n\n  * `s`: words in the list are strings (default)\n  * `a`: words in the list are atoms\n  * `c`: words in the list are charlists\n\n## Examples\n\n    iex> ~W(foo \#{bar} baz)\n    [\"foo\", \"\\\#{bar}\", \"baz\"]\n\n","title":"Kernel.sigil_W/2","type":"macro"},{"doc":"Handles the sigil ~w for list of words. It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word. Modifiers s : words in the list are strings (default) a : words in the list are atoms c : words in the list are charlists Examples iex&gt; ~w(foo \#{ :bar } baz) [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] iex&gt; ~w(foo \#{ &quot; bar baz &quot; } ) [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] iex&gt; ~w(--source test/enum_test.exs) [ &quot;--source&quot; , &quot;test/enum_test.exs&quot; ] iex&gt; ~w(foo bar baz)a [ :foo , :bar , :baz ] iex&gt; ~w(foo bar baz)c [ ~c&quot;foo&quot; , ~c&quot;bar&quot; , ~c&quot;baz&quot; ]","ref":"Kernel.html#sigil_w/2","source_doc":"Handles the sigil `~w` for list of words.\n\nIt returns a list of \"words\" split by whitespace. Character unescaping and\ninterpolation happens for each word.\n\n## Modifiers\n\n  * `s`: words in the list are strings (default)\n  * `a`: words in the list are atoms\n  * `c`: words in the list are charlists\n\n## Examples\n\n    iex> ~w(foo \#{:bar} baz)\n    [\"foo\", \"bar\", \"baz\"]\n\n    iex> ~w(foo \#{\" bar baz \"})\n    [\"foo\", \"bar\", \"baz\"]\n\n    iex> ~w(--source test/enum_test.exs)\n    [\"--source\", \"test/enum_test.exs\"]\n\n    iex> ~w(foo bar baz)a\n    [:foo, :bar, :baz]\n\n    iex> ~w(foo bar baz)c\n    [~c\"foo\", ~c\"bar\", ~c\"baz\"]\n\n","title":"Kernel.sigil_w/2","type":"macro"},{"doc":"Spawns the given function and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. The anonymous function receives 0 arguments, and may return any value. Inlined by the compiler. Examples current = self ( ) child = spawn ( fn -&gt; send ( current , { self ( ) , 1 + 2 } ) end ) receive do { ^ child , 3 } -&gt; IO . puts ( &quot;Received 3 back&quot; ) end","ref":"Kernel.html#spawn/1","source_doc":"Spawns the given function and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end\n\n","title":"Kernel.spawn/1","type":"function"},{"doc":"Spawns the given function fun from the given module passing it the given args and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. Inlined by the compiler. Examples spawn ( SomeModule , :function , [ 1 , 2 , 3 ] )","ref":"Kernel.html#spawn/3","source_doc":"Spawns the given function `fun` from the given `module` passing it the given\n`args` and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn(SomeModule, :function, [1, 2, 3])\n\n","title":"Kernel.spawn/3","type":"function"},{"doc":"Spawns the given function, links it to the current process, and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. For more information on linking, check Process.link/1 . The anonymous function receives 0 arguments, and may return any value. Inlined by the compiler. Examples current = self ( ) child = spawn_link ( fn -&gt; send ( current , { self ( ) , 1 + 2 } ) end ) receive do { ^ child , 3 } -&gt; IO . puts ( &quot;Received 3 back&quot; ) end","ref":"Kernel.html#spawn_link/1","source_doc":"Spawns the given function, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    child = spawn_link(fn -> send(current, {self(), 1 + 2}) end)\n\n    receive do\n      {^child, 3} -> IO.puts(\"Received 3 back\")\n    end\n\n","title":"Kernel.spawn_link/1","type":"function"},{"doc":"Spawns the given function fun from the given module passing it the given args , links it to the current process, and returns its PID. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. For more information on linking, check Process.link/1 . Inlined by the compiler. Examples spawn_link ( SomeModule , :function , [ 1 , 2 , 3 ] )","ref":"Kernel.html#spawn_link/3","source_doc":"Spawns the given function `fun` from the given `module` passing it the given\n`args`, links it to the current process, and returns its PID.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions. For more\ninformation on linking, check `Process.link/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_link(SomeModule, :function, [1, 2, 3])\n\n","title":"Kernel.spawn_link/3","type":"function"},{"doc":"Spawns the given function, monitors it and returns its PID and monitoring reference. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. The anonymous function receives 0 arguments, and may return any value. Inlined by the compiler. Examples current = self ( ) spawn_monitor ( fn -&gt; send ( current , { self ( ) , 1 + 2 } ) end )","ref":"Kernel.html#spawn_monitor/1","source_doc":"Spawns the given function, monitors it and returns its PID\nand monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nThe anonymous function receives 0 arguments, and may return any value.\n\nInlined by the compiler.\n\n## Examples\n\n    current = self()\n    spawn_monitor(fn -> send(current, {self(), 1 + 2}) end)\n\n","title":"Kernel.spawn_monitor/1","type":"function"},{"doc":"Spawns the given module and function passing the given args, monitors it and returns its PID and monitoring reference. Typically developers do not use the spawn functions, instead they use abstractions such as Task , GenServer and Agent , built on top of spawn , that spawns processes with more conveniences in terms of introspection and debugging. Check the Process module for more process-related functions. Inlined by the compiler. Examples spawn_monitor ( SomeModule , :function , [ 1 , 2 , 3 ] )","ref":"Kernel.html#spawn_monitor/3","source_doc":"Spawns the given module and function passing the given args,\nmonitors it and returns its PID and monitoring reference.\n\nTypically developers do not use the `spawn` functions, instead they use\nabstractions such as `Task`, `GenServer` and `Agent`, built on top of\n`spawn`, that spawns processes with more conveniences in terms of\nintrospection and debugging.\n\nCheck the `Process` module for more process-related functions.\n\nInlined by the compiler.\n\n## Examples\n\n    spawn_monitor(SomeModule, :function, [1, 2, 3])\n\n","title":"Kernel.spawn_monitor/3","type":"function"},{"doc":"Creates and updates a struct. The struct argument may be an atom (which defines defstruct ) or a struct itself. The second argument is any Enumerable that emits two-element tuples (key-value pairs) during enumeration. Keys in the Enumerable that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct. If keys in the Enumerable are duplicated, the last entry will be taken (same behaviour as Map.new/1 ). This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate :__struct__ field into the map may not be enough and struct/2 should be used instead. Examples defmodule User do defstruct name : &quot;john&quot; end struct ( User ) #=&gt; %User{name: &quot;john&quot;} opts = [ name : &quot;meg&quot; ] user = struct ( User , opts ) #=&gt; %User{name: &quot;meg&quot;} struct ( user , unknown : &quot;value&quot; ) #=&gt; %User{name: &quot;meg&quot;} struct ( User , %{ name : &quot;meg&quot; } ) #=&gt; %User{name: &quot;meg&quot;} # String keys are ignored struct ( User , %{ &quot;name&quot; =&gt; &quot;meg&quot; } ) #=&gt; %User{name: &quot;john&quot;}","ref":"Kernel.html#struct/2","source_doc":"Creates and updates a struct.\n\nThe `struct` argument may be an atom (which defines `defstruct`)\nor a `struct` itself. The second argument is any `Enumerable` that\nemits two-element tuples (key-value pairs) during enumeration.\n\nKeys in the `Enumerable` that don't exist in the struct are automatically\ndiscarded. Note that keys must be atoms, as only atoms are allowed when\ndefining a struct. If keys in the `Enumerable` are duplicated, the last\nentry will be taken (same behaviour as `Map.new/1`).\n\nThis function is useful for dynamically creating and updating structs, as\nwell as for converting maps to structs; in the latter case, just inserting\nthe appropriate `:__struct__` field into the map may not be enough and\n`struct/2` should be used instead.\n\n## Examples\n\n    defmodule User do\n      defstruct name: \"john\"\n    end\n\n    struct(User)\n    #=> %User{name: \"john\"}\n\n    opts = [name: \"meg\"]\n    user = struct(User, opts)\n    #=> %User{name: \"meg\"}\n\n    struct(user, unknown: \"value\")\n    #=> %User{name: \"meg\"}\n\n    struct(User, %{name: \"meg\"})\n    #=> %User{name: \"meg\"}\n\n    # String keys are ignored\n    struct(User, %{\"name\" => \"meg\"})\n    #=> %User{name: \"john\"}\n\n","title":"Kernel.struct/2","type":"function"},{"doc":"Similar to struct/2 but checks for key validity. The function struct!/2 emulates the compile time behaviour of structs. This means that: when building a struct, as in struct!(SomeStruct, key: :value) , it is equivalent to %SomeStruct{key: :value} and therefore this function will check if every given key-value belongs to the struct. If the struct is enforcing any key via @enforce_keys , those will be enforced as well; when updating a struct, as in struct!(%SomeStruct{}, key: :value) , it is equivalent to %SomeStruct{struct | key: :value} and therefore this function will check if every given key-value belongs to the struct. However, updating structs does not enforce keys, as keys are enforced only when building;","ref":"Kernel.html#struct!/2","source_doc":"Similar to `struct/2` but checks for key validity.\n\nThe function `struct!/2` emulates the compile time behaviour\nof structs. This means that:\n\n  * when building a struct, as in `struct!(SomeStruct, key: :value)`,\n    it is equivalent to `%SomeStruct{key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    If the struct is enforcing any key via `@enforce_keys`, those will\n    be enforced as well;\n\n  * when updating a struct, as in `struct!(%SomeStruct{}, key: :value)`,\n    it is equivalent to `%SomeStruct{struct | key: :value}` and therefore this\n    function will check if every given key-value belongs to the struct.\n    However, updating structs does not enforce keys, as keys are enforced\n    only when building;\n\n","title":"Kernel.struct!/2","type":"function"},{"doc":"Pipes the first argument, value , into the second argument, a function fun , and returns value itself. Useful for running synchronous side effects in a pipeline, using the |&gt;/2 operator. Examples iex&gt; tap ( 1 , fn x -&gt; x + 1 end ) 1 Most commonly, this is used in pipelines, using the |&gt;/2 operator. For example, let's suppose you want to inspect part of a data structure. You could write: %{ a : 1 } |&gt; Map . update! ( :a , &amp; &amp;1 + 2 ) |&gt; tap ( &amp; IO . inspect ( &amp;1 . a ) ) |&gt; Map . update! ( :a , &amp; &amp;1 * 2 )","ref":"Kernel.html#tap/2","source_doc":"Pipes the first argument, `value`, into the second argument, a function `fun`,\nand returns `value` itself.\n\nUseful for running synchronous side effects in a pipeline, using the `|>/2` operator.\n\n## Examples\n\n    iex> tap(1, fn x -> x + 1 end)\n    1\n\nMost commonly, this is used in pipelines, using the `|>/2` operator.\nFor example, let's suppose you want to inspect part of a data structure.\nYou could write:\n\n    %{a: 1}\n    |> Map.update!(:a, & &1 + 2)\n    |> tap(&IO.inspect(&1.a))\n    |> Map.update!(:a, & &1 * 2)\n\n","title":"Kernel.tap/2","type":"macro"},{"doc":"Pipes the first argument, value , into the second argument, a function fun , and returns the result of calling fun . In other words, it invokes the function fun with value as argument, and returns its result. This is most commonly used in pipelines, using the |&gt;/2 operator, allowing you to pipe a value to a function outside of its first argument. Examples iex&gt; 1 |&gt; then ( fn x -&gt; x * 2 end ) 2 iex&gt; 1 |&gt; then ( fn x -&gt; Enum . drop ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , x ) end ) [ &quot;b&quot; , &quot;c&quot; ]","ref":"Kernel.html#then/2","source_doc":"Pipes the first argument, `value`, into the second argument, a function `fun`,\nand returns the result of calling `fun`.\n\nIn other words, it invokes the function `fun` with `value` as argument,\nand returns its result.\n\nThis is most commonly used in pipelines, using the `|>/2` operator, allowing you\nto pipe a value to a function outside of its first argument.\n\n### Examples\n\n    iex> 1 |> then(fn x -> x * 2 end)\n    2\n\n    iex> 1 |> then(fn x -> Enum.drop([\"a\", \"b\", \"c\"], x) end)\n    [\"b\", \"c\"]\n","title":"Kernel.then/2","type":"macro"},{"doc":"A non-local return from a function. Using throw/1 is generally discouraged, as it allows a function to escape from its regular execution flow, which can make the code harder to read. Furthermore, all thrown values must be caught by try/catch . See try/1 for more information. Inlined by the compiler.","ref":"Kernel.html#throw/1","source_doc":"A non-local return from a function.\n\nUsing `throw/1` is generally discouraged, as it allows a function\nto escape from its regular execution flow, which can make the code\nharder to read. Furthermore, all thrown values must be caught by\n`try/catch`. See `try/1` for more information.\n\nInlined by the compiler.\n","title":"Kernel.throw/1","type":"function"},{"doc":"Returns the tail of a list. Raises ArgumentError if the list is empty. The tail of a list is the list without its first element. It works with improper lists. Allowed in guard tests. Inlined by the compiler. Examples tl ( [ 1 , 2 , 3 , :go ] ) #=&gt; [2, 3, :go] tl ( [ :one ] ) #=&gt; [] tl ( [ :a , :b | :improper_end ] ) #=&gt; [:b | :improper_end] tl ( [ :a | %{ b : 1 } ] ) #=&gt; %{b: 1} Giving it an empty list raises: tl ( [ ] ) ** (ArgumentError) argument error","ref":"Kernel.html#tl/1","source_doc":"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n\nThe tail of a list is the list without its first element.\n\nIt works with improper lists.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    tl([1, 2, 3, :go])\n    #=> [2, 3, :go]\n\n    tl([:one])\n    #=> []\n\n    tl([:a, :b | :improper_end])\n    #=> [:b | :improper_end]\n\n    tl([:a | %{b: 1}])\n    #=> %{b: 1}\n\nGiving it an empty list raises:\n\n    tl([])\n    ** (ArgumentError) argument error\n\n","title":"Kernel.tl/1","type":"function"},{"doc":"Converts the given term to a charlist according to the List.Chars protocol. Examples iex&gt; to_charlist ( :foo ) ~c&quot;foo&quot;","ref":"Kernel.html#to_charlist/1","source_doc":"Converts the given term to a charlist according to the `List.Chars` protocol.\n\n## Examples\n\n    iex> to_charlist(:foo)\n    ~c\"foo\"\n\n","title":"Kernel.to_charlist/1","type":"macro"},{"doc":"Converts the argument to a string according to the String.Chars protocol. This is the function invoked when there is string interpolation. Examples iex&gt; to_string ( :foo ) &quot;foo&quot;","ref":"Kernel.html#to_string/1","source_doc":"Converts the argument to a string according to the\n`String.Chars` protocol.\n\nThis is the function invoked when there is string interpolation.\n\n## Examples\n\n    iex> to_string(:foo)\n    \"foo\"\n\n","title":"Kernel.to_string/1","type":"macro"},{"doc":"Returns the integer part of number . Allowed in guard tests. Inlined by the compiler. Examples iex&gt; trunc ( 5.4 ) 5 iex&gt; trunc ( - 5.99 ) - 5 iex&gt; trunc ( - 5 ) - 5","ref":"Kernel.html#trunc/1","source_doc":"Returns the integer part of `number`.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> trunc(5.4)\n    5\n\n    iex> trunc(-5.99)\n    -5\n\n    iex> trunc(-5)\n    -5\n\n","title":"Kernel.trunc/1","type":"function"},{"doc":"Returns the size of a tuple. This operation happens in constant time. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; tuple_size ( { :a , :b , :c } ) 3","ref":"Kernel.html#tuple_size/1","source_doc":"Returns the size of a tuple.\n\nThis operation happens in constant time.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> tuple_size({:a, :b, :c})\n    3\n\n","title":"Kernel.tuple_size/1","type":"function"},{"doc":"Provides an unless macro. This macro evaluates and returns the do block passed in as the second argument if condition evaluates to a falsy value ( false or nil ). Otherwise, it returns the value of the else block if present or nil if not. See also if/2 . Examples iex&gt; unless ( Enum . empty? ( [ ] ) , do : &quot;Hello&quot; ) nil iex&gt; unless ( Enum . empty? ( [ 1 , 2 , 3 ] ) , do : &quot;Hello&quot; ) &quot;Hello&quot; iex&gt; unless Enum . sum ( [ 2 , 2 ] ) == 5 do ...&gt; &quot;Math still works&quot; ...&gt; else ...&gt; &quot;Math is broken&quot; ...&gt; end &quot;Math still works&quot;","ref":"Kernel.html#unless/2","source_doc":"Provides an `unless` macro.\n\nThis macro evaluates and returns the `do` block passed in as the second\nargument if `condition` evaluates to a falsy value (`false` or `nil`).\nOtherwise, it returns the value of the `else` block if present or `nil` if not.\n\nSee also `if/2`.\n\n## Examples\n\n    iex> unless(Enum.empty?([]), do: \"Hello\")\n    nil\n\n    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n    \"Hello\"\n\n    iex> unless Enum.sum([2, 2]) == 5 do\n    ...>   \"Math still works\"\n    ...> else\n    ...>   \"Math is broken\"\n    ...> end\n    \"Math still works\"\n\n","title":"Kernel.unless/2","type":"macro"},{"doc":"Updates a nested structure via the given path . This is similar to update_in/3 , except the path is extracted via a macro rather than passing a list. For example: update_in ( opts [ :foo ] [ :bar ] , &amp; ( &amp;1 + 1 ) ) Is equivalent to: update_in ( opts , [ :foo , :bar ] , &amp; ( &amp;1 + 1 ) ) This also works with nested structs and the struct.path.to.value way to specify paths: update_in ( struct . foo . bar , &amp; ( &amp;1 + 1 ) ) Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check get_and_update_in/2 docs. Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; update_in ( users [ &quot;john&quot; ] [ :age ] , &amp; ( &amp;1 + 1 ) ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; update_in ( users [ &quot;john&quot; ] . age , &amp; ( &amp;1 + 1 ) ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } }","ref":"Kernel.html#update_in/2","source_doc":"Updates a nested structure via the given `path`.\n\nThis is similar to `update_in/3`, except the path is extracted via\na macro rather than passing a list. For example:\n\n    update_in(opts[:foo][:bar], &(&1 + 1))\n\nIs equivalent to:\n\n    update_in(opts, [:foo, :bar], &(&1 + 1))\n\nThis also works with nested structs and the `struct.path.to.value` way to specify\npaths:\n\n    update_in(struct.foo.bar, &(&1 + 1))\n\nNote that in order for this macro to work, the complete path must always\nbe visible by this macro. For more information about the supported path\nexpressions, please check `get_and_update_in/2` docs.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users[\"john\"].age, &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n","title":"Kernel.update_in/2","type":"macro"},{"doc":"Updates a key in a nested structure. Uses the Access module to traverse the structures according to the given keys , unless the key is a function. If the key is a function, it will be invoked as specified in get_and_update_in/3 . data is a nested structure (that is, a map, keyword list, or struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present) and the result replaces the value in the structure. Examples iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; update_in ( users , [ &quot;john&quot; , :age ] , &amp; ( &amp;1 + 1 ) ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } Note the current value given to the anonymous function may be nil . If any of the intermediate values are nil, it will raise: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; update_in ( users , [ &quot;jane&quot; , :age ] , &amp; &amp;1 + 1 ) ** (ArgumentError) could not put/update key :age on a nil value","ref":"Kernel.html#update_in/3","source_doc":"Updates a key in a nested structure.\n\nUses the `Access` module to traverse the structures\naccording to the given `keys`, unless the `key` is a\nfunction. If the key is a function, it will be invoked\nas specified in `get_and_update_in/3`.\n\n`data` is a nested structure (that is, a map, keyword\nlist, or struct that implements the `Access` behaviour).\nThe `fun` argument receives the value of `key` (or `nil`\nif `key` is not present) and the result replaces the value\nin the structure.\n\n## Examples\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nNote the current value given to the anonymous function may be `nil`.\nIf any of the intermediate values are nil, it will raise:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> update_in(users, [\"jane\", :age], & &1 + 1)\n    ** (ArgumentError) could not put/update key :age on a nil value\n\n","title":"Kernel.update_in/3","type":"function"},{"doc":"Uses the given module in the current context. When calling: use MyModule , some : :options Elixir will invoke MyModule.__using__/1 passing the second argument of use as its argument. Since __using__/1 is typically a macro, all the usual macro rules apply, and its return value should be quoted code that is then inserted where use/2 is called. Code injection use MyModule works as a code-injection point in the caller. Given the caller of use MyModule has little control over how the code is injected, use/2 should be used with care. If you can, avoid use in favor of import/2 or alias/2 whenever possible. Examples For example, to write test cases using the ExUnit framework provided with Elixir, a developer should use the ExUnit.Case module: defmodule AssertionTest do use ExUnit.Case , async : true test &quot;always pass&quot; do assert true end end In this example, Elixir will call the __using__/1 macro in the ExUnit.Case module with the keyword list [async: true] as its argument. In other words, use/2 translates to: defmodule AssertionTest do require ExUnit.Case ExUnit.Case . __using__ ( async : true ) test &quot;always pass&quot; do assert true end end where ExUnit.Case defines the __using__/1 macro: defmodule ExUnit.Case do defmacro __using__ ( opts ) do # do something with opts quote do # return some code to inject in the caller end end end Best practices __using__/1 is typically used when there is a need to set some state (via module attributes) or callbacks (like @before_compile , see the documentation for Module for more information) into the caller. __using__/1 may also be used to alias, require, or import functionality from different modules: defmodule MyModule do defmacro __using__ ( _opts ) do quote do import MyModule.Foo import MyModule.Bar import MyModule.Baz alias MyModule.Repo end end end However, do not provide __using__/1 if all it does is to import, alias or require the module itself. For example, avoid this: defmodule MyModule do defmacro __using__ ( _opts ) do quote do import MyModule end end end In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind use/2 . Finally, developers should also avoid defining functions inside the __using__/1 callback, unless those functions are the default implementation of a previously defined @callback or are functions meant to be overridden (see defoverridable/1 ). Even in these cases, defining functions should be seen as a &quot;last resort&quot;.","ref":"Kernel.html#use/2","source_doc":"Uses the given module in the current context.\n\nWhen calling:\n\n    use MyModule, some: :options\n\nElixir will invoke `MyModule.__using__/1` passing the second argument of\n`use` as its argument. Since `__using__/1` is typically a macro, all\nthe usual macro rules apply, and its return value should be quoted code\nthat is then inserted where `use/2` is called.\n\n> #### Code injection {: .warning}\n>\n> `use MyModule` works as a **code-injection point** in the caller.\n> Given the caller of `use MyModule` has little control over how the\n> code is injected, `use/2` should be used with care. If you can,\n> avoid use in favor of `import/2` or `alias/2` whenever possible.\n\n## Examples\n\nFor example, to write test cases using the `ExUnit` framework provided\nwith Elixir, a developer should `use` the `ExUnit.Case` module:\n\n    defmodule AssertionTest do\n      use ExUnit.Case, async: true\n\n      test \"always pass\" do\n        assert true\n      end\n    end\n\nIn this example, Elixir will call the `__using__/1` macro in the\n`ExUnit.Case` module with the keyword list `[async: true]` as its\nargument.\n\nIn other words, `use/2` translates to:\n\n    defmodule AssertionTest do\n      require ExUnit.Case\n      ExUnit.Case.__using__(async: true)\n\n      test \"always pass\" do\n        assert true\n      end\n    end\n\nwhere `ExUnit.Case` defines the `__using__/1` macro:\n\n    defmodule ExUnit.Case do\n      defmacro __using__(opts) do\n        # do something with opts\n        quote do\n          # return some code to inject in the caller\n        end\n      end\n    end\n\n## Best practices\n\n`__using__/1` is typically used when there is a need to set some state\n(via module attributes) or callbacks (like `@before_compile`, see the\ndocumentation for `Module` for more information) into the caller.\n\n`__using__/1` may also be used to alias, require, or import functionality\nfrom different modules:\n\n    defmodule MyModule do\n      defmacro __using__(_opts) do\n        quote do\n          import MyModule.Foo\n          import MyModule.Bar\n          import MyModule.Baz\n\n          alias MyModule.Repo\n        end\n      end\n    end\n\nHowever, do not provide `__using__/1` if all it does is to import,\nalias or require the module itself. For example, avoid this:\n\n    defmodule MyModule do\n      defmacro __using__(_opts) do\n        quote do\n          import MyModule\n        end\n      end\n    end\n\nIn such cases, developers should instead import or alias the module\ndirectly, so that they can customize those as they wish,\nwithout the indirection behind `use/2`.\n\nFinally, developers should also avoid defining functions inside\nthe `__using__/1` callback, unless those functions are the default\nimplementation of a previously defined `@callback` or are functions\nmeant to be overridden (see `defoverridable/1`). Even in these cases,\ndefining functions should be seen as a \"last resort\".\n","title":"Kernel.use/2","type":"macro"},{"doc":"Marks that the given variable should not be hygienized. This macro expects a variable and it is typically invoked inside Kernel.SpecialForms.quote/2 to mark that a variable should not be hygienized. See Kernel.SpecialForms.quote/2 for more information. Examples iex&gt; Kernel . var! ( example ) = 1 1 iex&gt; Kernel . var! ( example ) 1","ref":"Kernel.html#var!/2","source_doc":"Marks that the given variable should not be hygienized.\n\nThis macro expects a variable and it is typically invoked\ninside `Kernel.SpecialForms.quote/2` to mark that a variable\nshould not be hygienized. See `Kernel.SpecialForms.quote/2`\nfor more information.\n\n## Examples\n\n    iex> Kernel.var!(example) = 1\n    1\n    iex> Kernel.var!(example)\n    1\n\n","title":"Kernel.var!/2","type":"macro"},{"doc":"Pipe operator. This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side. Examples iex&gt; [ 1 , [ 2 ] , 3 ] |&gt; List . flatten ( ) [ 1 , 2 , 3 ] The example above is the same as calling List.flatten([1, [2], 3]) . The |&gt;/2 operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline: iex&gt; [ 1 , [ 2 ] , 3 ] |&gt; List . flatten ( ) |&gt; Enum . map ( fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] In the example above, the list [1, [2], 3] is passed as the first argument to the List.flatten/1 function, then the flattened list is passed as the first argument to the Enum.map/2 function which doubles each element of the list. In other words, the expression above simply translates to: Enum . map ( List . flatten ( [ 1 , [ 2 ] , 3 ] ) , fn x -&gt; x * 2 end ) Pitfalls There are two common pitfalls when using the pipe operator. The first one is related to operator precedence. For example, the following expression: String . graphemes &quot;Hello&quot; |&gt; Enum . reverse Translates to: String . graphemes ( &quot;Hello&quot; |&gt; Enum . reverse ( ) ) which results in an error as the Enumerable protocol is not defined for binaries. Adding explicit parentheses resolves the ambiguity: String . graphemes ( &quot;Hello&quot; ) |&gt; Enum . reverse ( ) Or, even better: &quot;Hello&quot; |&gt; String . graphemes ( ) |&gt; Enum . reverse ( ) The second limitation is that Elixir always pipes to a function call. Therefore, to pipe into an anonymous function, you need to invoke it: some_fun = &amp; Regex . replace ( ~r/l/ , &amp;1 , &quot;L&quot; ) &quot;Hello&quot; |&gt; some_fun . ( ) Alternatively, you can use then/2 for the same effect: some_fun = &amp; Regex . replace ( ~r/l/ , &amp;1 , &quot;L&quot; ) &quot;Hello&quot; |&gt; then ( some_fun ) then/2 is most commonly used when you want to pipe to a function but the value is expected outside of the first argument, such as above. By replacing some_fun by its value, we get: &quot;Hello&quot; |&gt; then ( &amp; Regex . replace ( ~r/l/ , &amp;1 , &quot;L&quot; ) )","ref":"Kernel.html#%7C%3E/2","source_doc":"Pipe operator.\n\nThis operator introduces the expression on the left-hand side as\nthe first argument to the function call on the right-hand side.\n\n## Examples\n\n    iex> [1, [2], 3] |> List.flatten()\n    [1, 2, 3]\n\nThe example above is the same as calling `List.flatten([1, [2], 3])`.\n\nThe `|>/2` operator is mostly useful when there is a desire to execute a series\nof operations resembling a pipeline:\n\n    iex> [1, [2], 3] |> List.flatten() |> Enum.map(fn x -> x * 2 end)\n    [2, 4, 6]\n\nIn the example above, the list `[1, [2], 3]` is passed as the first argument\nto the `List.flatten/1` function, then the flattened list is passed as the\nfirst argument to the `Enum.map/2` function which doubles each element of the\nlist.\n\nIn other words, the expression above simply translates to:\n\n    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n\n## Pitfalls\n\nThere are two common pitfalls when using the pipe operator.\n\nThe first one is related to operator precedence. For example,\nthe following expression:\n\n    String.graphemes \"Hello\" |> Enum.reverse\n\nTranslates to:\n\n    String.graphemes(\"Hello\" |> Enum.reverse())\n\nwhich results in an error as the `Enumerable` protocol is not defined\nfor binaries. Adding explicit parentheses resolves the ambiguity:\n\n    String.graphemes(\"Hello\") |> Enum.reverse()\n\nOr, even better:\n\n    \"Hello\" |> String.graphemes() |> Enum.reverse()\n\nThe second limitation is that Elixir always pipes to a function\ncall. Therefore, to pipe into an anonymous function, you need to\ninvoke it:\n\n    some_fun = &Regex.replace(~r/l/, &1, \"L\")\n    \"Hello\" |> some_fun.()\n\nAlternatively, you can use `then/2` for the same effect:\n\n    some_fun = &Regex.replace(~r/l/, &1, \"L\")\n    \"Hello\" |> then(some_fun)\n\n`then/2` is most commonly used when you want to pipe to a function\nbut the value is expected outside of the first argument, such as\nabove. By replacing `some_fun` by its value, we get:\n\n    \"Hello\" |> then(&Regex.replace(~r/l/, &1, \"L\"))\n\n","title":"Kernel.|>/2","type":"macro"},{"doc":"Boolean &quot;or&quot; operator. Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either nil or false ). Returns the first expression otherwise. Not allowed in guard clauses. Examples iex&gt; Enum . empty? ( [ 1 ] ) || Enum . empty? ( [ 1 ] ) false iex&gt; List . first ( [ ] ) || true true iex&gt; Enum . empty? ( [ 1 ] ) || 1 1 iex&gt; Enum . empty? ( [ ] ) || throw ( :bad ) true Note that, unlike or/2 , this operator accepts any expression as the first argument, not only booleans.","ref":"Kernel.html#%7C%7C/2","source_doc":"Boolean \"or\" operator.\n\nProvides a short-circuit operator that evaluates and returns the second\nexpression only if the first one does not evaluate to a truthy value (that is,\nit is either `nil` or `false`). Returns the first expression otherwise.\n\nNot allowed in guard clauses.\n\n## Examples\n\n    iex> Enum.empty?([1]) || Enum.empty?([1])\n    false\n\n    iex> List.first([]) || true\n    true\n\n    iex> Enum.empty?([1]) || 1\n    1\n\n    iex> Enum.empty?([]) || throw(:bad)\n    true\n\nNote that, unlike `or/2`, this operator accepts any expression\nas the first argument, not only booleans.\n","title":"Kernel.||/2","type":"macro"},{"doc":"Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer. The Kernel.SpecialForms module consists solely of macros that can be invoked anywhere in Elixir code without the use of the Kernel.SpecialForms. prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the Kernel module. These building blocks are defined in this module. Some of these special forms are lexical (such as alias/2 and case/2 ). The macros {}/1 and &lt;&lt;&gt;&gt;/1 are also special forms used to define tuple and binary data structures respectively. This module also documents macros that return information about Elixir's compilation environment, such as ( __ENV__/0 , __MODULE__/0 , __DIR__/0 , __STACKTRACE__/0 , and __CALLER__/0 ). Additionally, it documents two special forms, __block__/1 and __aliases__/1 , which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.","ref":"Kernel.SpecialForms.html","source_doc":"Special forms are the basic building blocks of Elixir, and therefore\ncannot be overridden by the developer.\n\nThe `Kernel.SpecialForms` module consists solely of macros that can be\ninvoked anywhere in Elixir code without the use of the\n`Kernel.SpecialForms.` prefix. This is possible because they all have\nbeen automatically imported, in the same fashion as the functions and\nmacros from the `Kernel` module.\n\nThese building blocks are defined in this module. Some of these special forms are lexical (such as\n`alias/2` and `case/2`). The macros `{}/1` and `<<>>/1` are also special\nforms used to define tuple and binary data structures respectively.\n\nThis module also documents macros that return information about Elixir's\ncompilation environment, such as (`__ENV__/0`, `__MODULE__/0`, `__DIR__/0`,\n`__STACKTRACE__/0`, and `__CALLER__/0`).\n\nAdditionally, it documents two special forms, `__block__/1` and\n`__aliases__/1`, which are not intended to be called directly by the\ndeveloper but they appear in quoted contents since they are essential\nin Elixir's constructs.\n","title":"Kernel.SpecialForms","type":"module"},{"doc":"Matches on or builds a struct. A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions. Structs are usually defined with the Kernel.defstruct/1 macro: defmodule User do defstruct name : &quot;john&quot; , age : 27 end Now a struct can be created as follows: % User { } Underneath a struct is just a map with a :__struct__ key pointing to the User module: % User { } == %{ __struct__ : User , name : &quot;john&quot; , age : 27 } The struct fields can be given when building the struct: % User { age : 31 } #=&gt; %{__struct__: User, name: &quot;john&quot;, age: 31} Or also on pattern matching to extract values out: % User { age : age } = user An update operation specific for structs is also available: % User { user | age : 28 } The advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key :full_name in the User struct: % User { full_name : &quot;john doe&quot; } The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with BadStructError otherwise. Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check Kernel.defprotocol/2 for more information on how structs can be used with protocols for polymorphic dispatch. Also see Kernel.struct/2 and Kernel.struct!/2 for examples on how to create and update structs dynamically. Pattern matching on struct names Besides allowing pattern matching on struct fields, such as: % User { age : age } = user Structs also allow pattern matching on the struct name: % struct_name { } = user struct_name #=&gt; User You can also assign the struct name to _ when you want to check if something is a struct but you are not interested in its name: % _ { } = user","ref":"Kernel.SpecialForms.html#%25/2","source_doc":"Matches on or builds a struct.\n\nA struct is a tagged map that allows developers to provide\ndefault values for keys, tags to be used in polymorphic\ndispatches and compile time assertions.\n\nStructs are usually defined with the `Kernel.defstruct/1` macro:\n\n    defmodule User do\n      defstruct name: \"john\", age: 27\n    end\n\nNow a struct can be created as follows:\n\n    %User{}\n\nUnderneath a struct is just a map with a `:__struct__` key\npointing to the `User` module:\n\n    %User{} == %{__struct__: User, name: \"john\", age: 27}\n\nThe struct fields can be given when building the struct:\n\n    %User{age: 31}\n    #=> %{__struct__: User, name: \"john\", age: 31}\n\nOr also on pattern matching to extract values out:\n\n    %User{age: age} = user\n\nAn update operation specific for structs is also available:\n\n    %User{user | age: 28}\n\nThe advantage of structs is that they validate that the given\nkeys are part of the defined struct. The example below will fail\nbecause there is no key `:full_name` in the `User` struct:\n\n    %User{full_name: \"john doe\"}\n\nThe syntax above will guarantee the given keys are valid at\ncompilation time and it will guarantee at runtime the given\nargument is a struct, failing with `BadStructError` otherwise.\n\nAlthough structs are maps, by default structs do not implement\nany of the protocols implemented for maps. Check\n`Kernel.defprotocol/2` for more information on how structs\ncan be used with protocols for polymorphic dispatch. Also\nsee `Kernel.struct/2` and `Kernel.struct!/2` for examples on\nhow to create and update structs dynamically.\n\n## Pattern matching on struct names\n\nBesides allowing pattern matching on struct fields, such as:\n\n    %User{age: age} = user\n\nStructs also allow pattern matching on the struct name:\n\n    %struct_name{} = user\n    struct_name #=> User\n\nYou can also assign the struct name to `_` when you want to\ncheck if something is a struct but you are not interested in\nits name:\n\n    %_{} = user\n\n","title":"Kernel.SpecialForms.%/2","type":"macro"},{"doc":"Creates a map. See the Map module for more information about maps, their syntax, and ways to access and manipulate them. AST representation Regardless of whether =&gt; or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity: iex&gt; quote do ...&gt; %{ &quot;a&quot; =&gt; :b , c : :d } ...&gt; end { :%{} , [ ] , [ { &quot;a&quot; , :b } , { :c , :d } ] }","ref":"Kernel.SpecialForms.html#%25%7B%7D/1","source_doc":"Creates a map.\n\nSee the `Map` module for more information about maps, their syntax, and ways to\naccess and manipulate them.\n\n## AST representation\n\nRegardless of whether `=>` or the keyword syntax is used, key-value pairs in\nmaps are always represented internally as a list of two-element tuples for\nsimplicity:\n\n    iex> quote do\n    ...>   %{\"a\" => :b, c: :d}\n    ...> end\n    {:%{}, [], [{\"a\", :b}, {:c, :d}]}\n\n","title":"Kernel.SpecialForms.%{}/1","type":"macro"},{"doc":"Capture operator. Captures or creates an anonymous function. Capture The capture operator is most commonly used to capture a function with given name and arity from a module: iex&gt; fun = &amp; Kernel . is_atom / 1 iex&gt; fun . ( :atom ) true iex&gt; fun . ( &quot;string&quot; ) false In the example above, we captured Kernel.is_atom/1 as an anonymous function and then invoked it. The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name: &amp; local_function / 1 See also Function.capture/3 . Anonymous functions The capture operator can also be used to partially apply functions, where &amp;1 , &amp;2 and so on can be used as value placeholders. For example: iex&gt; double = &amp; ( &amp;1 * 2 ) iex&gt; double . ( 2 ) 4 In other words, &amp;(&amp;1 * 2) is equivalent to fn x -&gt; x * 2 end . We can partially apply a remote function with placeholder: iex&gt; take_five = &amp; Enum . take ( &amp;1 , 5 ) iex&gt; take_five . ( 1 .. 10 ) [ 1 , 2 , 3 , 4 , 5 ] Another example while using an imported or local function: iex&gt; first_elem = &amp; elem ( &amp;1 , 0 ) iex&gt; first_elem . ( { 0 , 1 } ) 0 The &amp; operator can be used with more complex expressions: iex&gt; fun = &amp; ( &amp;1 + &amp;2 + &amp;3 ) iex&gt; fun . ( 1 , 2 , 3 ) 6 As well as with lists and tuples: iex&gt; fun = &amp; { &amp;1 , &amp;2 } iex&gt; fun . ( 1 , 2 ) { 1 , 2 } iex&gt; fun = &amp; [ &amp;1 | &amp;2 ] iex&gt; fun . ( 1 , [ 2 , 3 ] ) [ 1 , 2 , 3 ] The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &amp;1 , and that block expressions are not supported: # No placeholder, fails to compile. &amp; ( :foo ) # Block expression, fails to compile. &amp; ( &amp;1 ; &amp;2 )","ref":"Kernel.SpecialForms.html#&/1","source_doc":"Capture operator. Captures or creates an anonymous function.\n\n## Capture\n\nThe capture operator is most commonly used to capture a\nfunction with given name and arity from a module:\n\n    iex> fun = &Kernel.is_atom/1\n    iex> fun.(:atom)\n    true\n    iex> fun.(\"string\")\n    false\n\nIn the example above, we captured `Kernel.is_atom/1` as an\nanonymous function and then invoked it.\n\nThe capture operator can also be used to capture local functions,\nincluding private ones, and imported functions by omitting the\nmodule name:\n\n    &local_function/1\n\nSee also `Function.capture/3`.\n\n## Anonymous functions\n\nThe capture operator can also be used to partially apply\nfunctions, where `&1`, `&2` and so on can be used as value\nplaceholders. For example:\n\n    iex> double = &(&1 * 2)\n    iex> double.(2)\n    4\n\nIn other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n\nWe can partially apply a remote function with placeholder:\n\n    iex> take_five = &Enum.take(&1, 5)\n    iex> take_five.(1..10)\n    [1, 2, 3, 4, 5]\n\nAnother example while using an imported or local function:\n\n    iex> first_elem = &elem(&1, 0)\n    iex> first_elem.({0, 1})\n    0\n\nThe `&` operator can be used with more complex expressions:\n\n    iex> fun = &(&1 + &2 + &3)\n    iex> fun.(1, 2, 3)\n    6\n\nAs well as with lists and tuples:\n\n    iex> fun = &{&1, &2}\n    iex> fun.(1, 2)\n    {1, 2}\n\n    iex> fun = &[&1 | &2]\n    iex> fun.(1, [2, 3])\n    [1, 2, 3]\n\nThe only restrictions when creating anonymous functions is that at\nleast one placeholder must be present, i.e. it must contain at least\n`&1`, and that block expressions are not supported:\n\n    # No placeholder, fails to compile.\n    &(:foo)\n\n    # Block expression, fails to compile.\n    &(&1; &2)\n\n","title":"Kernel.SpecialForms.&/1","type":"macro"},{"doc":"Dot operator. Defines a remote call, a call to an anonymous function, or an alias. The dot ( . ) in Elixir can be used for remote calls: iex&gt; String . downcase ( &quot;FOO&quot; ) &quot;foo&quot; In this example above, we have used . to invoke downcase in the String module, passing &quot;FOO&quot; as argument. The dot may be used to invoke anonymous functions too: iex&gt; ( fn n -&gt; n end ) . ( 7 ) 7 in which case there is a function on the left hand side. We can also use the dot for creating aliases: iex&gt; Hello.World Hello.World This time, we have joined two aliases, defining the final alias Hello.World . Syntax The right side of . may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples: iex&gt; Kernel.Sample Kernel.Sample iex&gt; Kernel . length ( [ 1 , 2 , 3 ] ) 3 iex&gt; Kernel . + ( 1 , 2 ) 3 iex&gt; Kernel . &quot;+&quot; ( 1 , 2 ) 3 Wrapping the function name in single- or double-quotes is always a remote call. Therefore Kernel.&quot;Foo&quot; will attempt to call the function &quot;Foo&quot; and not return the alias Kernel.Foo . This is done by design as module names are more strict than function names. When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation: iex&gt; negate = fn n -&gt; - n end iex&gt; negate . ( 7 ) - 7 Quoted expression When . is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore): iex&gt; quote do ...&gt; String . downcase ( &quot;FOO&quot; ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , :downcase ] } , [ ] , [ &quot;FOO&quot; ] } Note that we have an inner tuple, containing the atom :. representing the dot as first element: { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , :downcase ] } This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias String and the atom :downcase . The second argument in a remote call is always an atom. In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary: iex&gt; quote do ...&gt; negate . ( 0 ) ...&gt; end { { :. , [ ] , [ { :negate , [ ] , __MODULE__ } ] } , [ ] , [ 0 ] } When the right side is an alias (i.e. starts with uppercase), we get instead: iex&gt; quote do ...&gt; Hello.World ...&gt; end { :__aliases__ , [ alias : false ] , [ :Hello , :World ] } We go into more details about aliases in the __aliases__/1 special form documentation. Unquoting We can also use unquote to generate a remote call in a quoted expression: iex&gt; x = :downcase iex&gt; quote do ...&gt; String . unquote ( x ) ( &quot;FOO&quot; ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , :downcase ] } , [ ] , [ &quot;FOO&quot; ] } Similar to Kernel.&quot;FUNCTION_NAME&quot; , unquote(x) will always generate a remote call, independent of the value of x . To generate an alias via the quoted expression, one needs to rely on Module.concat/2 : iex&gt; x = Sample iex&gt; quote do ...&gt; Module . concat ( String , unquote ( x ) ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :Module ] } , :concat ] } , [ ] , [ { :__aliases__ , [ alias : false ] , [ :String ] } , Sample ] }","ref":"Kernel.SpecialForms.html#./2","source_doc":"Dot operator. Defines a remote call, a call to an anonymous function, or an alias.\n\nThe dot (`.`) in Elixir can be used for remote calls:\n\n    iex> String.downcase(\"FOO\")\n    \"foo\"\n\nIn this example above, we have used `.` to invoke `downcase` in the\n`String` module, passing `\"FOO\"` as argument.\n\nThe dot may be used to invoke anonymous functions too:\n\n    iex> (fn n -> n end).(7)\n    7\n\nin which case there is a function on the left hand side.\n\nWe can also use the dot for creating aliases:\n\n    iex> Hello.World\n    Hello.World\n\nThis time, we have joined two aliases, defining the final alias\n`Hello.World`.\n\n## Syntax\n\nThe right side of `.` may be a word starting with an uppercase letter, which represents\nan alias, a word starting with lowercase or underscore, any valid language\noperator or any name wrapped in single- or double-quotes. Those are all valid\nexamples:\n\n    iex> Kernel.Sample\n    Kernel.Sample\n\n    iex> Kernel.length([1, 2, 3])\n    3\n\n    iex> Kernel.+(1, 2)\n    3\n\n    iex> Kernel.\"+\"(1, 2)\n    3\n\nWrapping the function name in single- or double-quotes is always a\nremote call. Therefore `Kernel.\"Foo\"` will attempt to call the function \"Foo\"\nand not return the alias `Kernel.Foo`. This is done by design as module names\nare more strict than function names.\n\nWhen the dot is used to invoke an anonymous function there is only one\noperand, but it is still written using a postfix notation:\n\n    iex> negate = fn n -> -n end\n    iex> negate.(7)\n    -7\n\n## Quoted expression\n\nWhen `.` is used, the quoted expression may take two distinct\nforms. When the right side starts with a lowercase letter (or\nunderscore):\n\n    iex> quote do\n    ...>   String.downcase(\"FOO\")\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n\nNote that we have an inner tuple, containing the atom `:.` representing\nthe dot as first element:\n\n    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n\nThis tuple follows the general quoted expression structure in Elixir,\nwith the name as first argument, some keyword list as metadata as second,\nand the list of arguments as third. In this case, the arguments are the\nalias `String` and the atom `:downcase`. The second argument in a remote call\nis **always** an atom.\n\nIn the case of calls to anonymous functions, the inner tuple with the dot\nspecial form has only one argument, reflecting the fact that the operator is\nunary:\n\n    iex> quote do\n    ...>   negate.(0)\n    ...> end\n    {{:., [], [{:negate, [], __MODULE__}]}, [], [0]}\n\nWhen the right side is an alias (i.e. starts with uppercase), we get instead:\n\n    iex> quote do\n    ...>   Hello.World\n    ...> end\n    {:__aliases__, [alias: false], [:Hello, :World]}\n\nWe go into more details about aliases in the `__aliases__/1` special form\ndocumentation.\n\n## Unquoting\n\nWe can also use unquote to generate a remote call in a quoted expression:\n\n    iex> x = :downcase\n    iex> quote do\n    ...>   String.unquote(x)(\"FOO\")\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n\nSimilar to `Kernel.\"FUNCTION_NAME\"`, `unquote(x)` will always generate a remote call,\nindependent of the value of `x`. To generate an alias via the quoted expression,\none needs to rely on `Module.concat/2`:\n\n    iex> x = Sample\n    iex> quote do\n    ...>   Module.concat(String, unquote(x))\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n     [{:__aliases__, [alias: false], [:String]}, Sample]}\n\n","title":"Kernel.SpecialForms../2","type":"macro"},{"doc":"Internal special form to hold aliases information. It is usually compiled to an atom: iex&gt; quote do ...&gt; Foo.Bar ...&gt; end { :__aliases__ , [ alias : false ] , [ :Foo , :Bar ] } Elixir represents Foo.Bar as __aliases__ so calls can be unambiguously identified by the operator :. . For example: iex&gt; quote do ...&gt; Foo . bar ( ) ...&gt; end { { :. , [ ] , [ { :__aliases__ , [ alias : false ] , [ :Foo ] } , :bar ] } , [ ] , [ ] } Whenever an expression iterator sees a :. as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom. On the other hand, aliases hold some properties: The head element of aliases can be any term that must expand to an atom at compilation time. The tail elements of aliases are guaranteed to always be atoms. When the head element of aliases is the atom :Elixir , no expansion happens.","ref":"Kernel.SpecialForms.html#__aliases__/1","source_doc":"Internal special form to hold aliases information.\n\nIt is usually compiled to an atom:\n\n    iex> quote do\n    ...>   Foo.Bar\n    ...> end\n    {:__aliases__, [alias: false], [:Foo, :Bar]}\n\nElixir represents `Foo.Bar` as `__aliases__` so calls can be\nunambiguously identified by the operator `:.`. For example:\n\n    iex> quote do\n    ...>   Foo.bar()\n    ...> end\n    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n\nWhenever an expression iterator sees a `:.` as the tuple key,\nit can be sure that it represents a call and the second argument\nin the list is an atom.\n\nOn the other hand, aliases hold some properties:\n\n  1. The head element of aliases can be any term that must expand to\n     an atom at compilation time.\n\n  2. The tail elements of aliases are guaranteed to always be atoms.\n\n  3. When the head element of aliases is the atom `:Elixir`, no expansion happens.\n\n","title":"Kernel.SpecialForms.__aliases__/1","type":"macro"},{"doc":"Internal special form for block expressions. This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly: iex&gt; quote do ...&gt; 1 ...&gt; 2 ...&gt; 3 ...&gt; end { :__block__ , [ ] , [ 1 , 2 , 3 ] }","ref":"Kernel.SpecialForms.html#__block__/1","source_doc":"Internal special form for block expressions.\n\nThis is the special form used whenever we have a block\nof expressions in Elixir. This special form is private\nand should not be invoked directly:\n\n    iex> quote do\n    ...>   1\n    ...>   2\n    ...>   3\n    ...> end\n    {:__block__, [], [1, 2, 3]}\n\n","title":"Kernel.SpecialForms.__block__/1","type":"macro"},{"doc":"Returns the current calling environment as a Macro.Env struct. In the environment you can access the filename, line numbers, set up aliases, the function and others.","ref":"Kernel.SpecialForms.html#__CALLER__/0","source_doc":"Returns the current calling environment as a `Macro.Env` struct.\n\nIn the environment you can access the filename, line numbers,\nset up aliases, the function and others.\n","title":"Kernel.SpecialForms.__CALLER__/0","type":"macro"},{"doc":"Returns the absolute path of the directory of the current file as a binary. Although the directory can be accessed as Path.dirname(__ENV__.file) , this macro is a convenient shortcut.","ref":"Kernel.SpecialForms.html#__DIR__/0","source_doc":"Returns the absolute path of the directory of the current file as a binary.\n\nAlthough the directory can be accessed as `Path.dirname(__ENV__.file)`,\nthis macro is a convenient shortcut.\n","title":"Kernel.SpecialForms.__DIR__/0","type":"macro"},{"doc":"Returns the current environment information as a Macro.Env struct. In the environment you can access the current filename, line numbers, set up aliases, the current function and others.","ref":"Kernel.SpecialForms.html#__ENV__/0","source_doc":"Returns the current environment information as a `Macro.Env` struct.\n\nIn the environment you can access the current filename,\nline numbers, set up aliases, the current function and others.\n","title":"Kernel.SpecialForms.__ENV__/0","type":"macro"},{"doc":"Returns the current module name as an atom or nil otherwise. Although the module can be accessed in the __ENV__/0 , this macro is a convenient shortcut.","ref":"Kernel.SpecialForms.html#__MODULE__/0","source_doc":"Returns the current module name as an atom or `nil` otherwise.\n\nAlthough the module can be accessed in the `__ENV__/0`, this macro\nis a convenient shortcut.\n","title":"Kernel.SpecialForms.__MODULE__/0","type":"macro"},{"doc":"Returns the stacktrace for the currently handled exception. It is available only in the catch and rescue clauses of try/1 expressions. To retrieve the stacktrace of the current process, use Process.info(self(), :current_stacktrace) instead.","ref":"Kernel.SpecialForms.html#__STACKTRACE__/0","source_doc":"Returns the stacktrace for the currently handled exception.\n\nIt is available only in the `catch` and `rescue` clauses of `try/1`\nexpressions.\n\nTo retrieve the stacktrace of the current process, use\n`Process.info(self(), :current_stacktrace)` instead.\n","title":"Kernel.SpecialForms.__STACKTRACE__/0","type":"macro"},{"doc":"Type operator. Used by types and bitstrings to specify types. This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself: @type number :: integer | float @spec add ( number , number ) :: number It may also be used in bit strings to specify the type of a given bit segment: &lt;&lt; int :: integer - little , rest :: bits &gt;&gt; = bits Read the documentation on the Typespecs page and &lt;&lt;&gt;&gt;/1 for more information on typespecs and bitstrings respectively.","ref":"Kernel.SpecialForms.html#::/2","source_doc":"Type operator. Used by types and bitstrings to specify types.\n\nThis operator is used in two distinct occasions in Elixir.\nIt is used in typespecs to specify the type of a variable,\nfunction or of a type itself:\n\n    @type number :: integer | float\n    @spec add(number, number) :: number\n\nIt may also be used in bit strings to specify the type\nof a given bit segment:\n\n    <<int::integer-little, rest::bits>> = bits\n\nRead the documentation on the [Typespecs page](typespecs.md) and\n`<<>>/1` for more information on typespecs and\nbitstrings respectively.\n","title":"Kernel.SpecialForms.::/2","type":"macro"},{"doc":"Defines a new bitstring. Examples iex&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; Types A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings: integer float bits (alias for bitstring ) bitstring binary bytes (alias for binary ) utf8 utf16 utf32 When no type is specified, the default is integer : iex&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; &lt;&lt; 1 , 2 , 3 &gt;&gt; Elixir also accepts by default the segment to be a literal string which expands to integers: iex&gt; &lt;&lt; 0 , &quot;foo&quot; &gt;&gt; &lt;&lt; 0 , 102 , 111 , 111 &gt;&gt; Binaries need to be explicitly tagged as binary : iex&gt; rest = &quot;oo&quot; iex&gt; &lt;&lt; 102 , rest :: binary &gt;&gt; &quot;foo&quot; The utf8 , utf16 , and utf32 types are for Unicode code points. They can also be applied to literal strings and charlists: iex&gt; &lt;&lt; &quot;foo&quot; :: utf16 &gt;&gt; &lt;&lt; 0 , 102 , 0 , 111 , 0 , 111 &gt;&gt; iex&gt; &lt;&lt; &quot;foo&quot; :: utf32 &gt;&gt; &lt;&lt; 0 , 0 , 0 , 102 , 0 , 0 , 0 , 111 , 0 , 0 , 0 , 111 &gt;&gt; Otherwise we get an ArgumentError when constructing the binary: rest = &quot;oo&quot; &lt;&lt; 102 , rest &gt;&gt; ** (ArgumentError) argument error Options Many options can be given by using - as separator. Order is arbitrary, so the following are all equivalent: &lt;&lt; 102 :: integer - native , rest :: binary &gt;&gt; &lt;&lt; 102 :: native - integer , rest :: binary &gt;&gt; &lt;&lt; 102 :: unsigned - big - integer , rest :: binary &gt;&gt; &lt;&lt; 102 :: unsigned - big - integer - size ( 8 ) , rest :: binary &gt;&gt; &lt;&lt; 102 :: unsigned - big - integer - 8 , rest :: binary &gt;&gt; &lt;&lt; 102 :: 8 - integer - big - unsigned , rest :: binary &gt;&gt; &lt;&lt; 102 , rest :: binary &gt;&gt; Unit and Size The length of the match is equal to the unit (a number of bits) times the size (the number of repeated segments of length unit ). Type Default Unit integer 1 bit float 1 bit binary 8 bits Sizes for types are a bit more nuanced. The default size for integers is 8. For floats, it is 64. For floats, size * unit must result in 16, 32, or 64, corresponding to IEEE 754 binary16, binary32, and binary64, respectively. For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example: iex&gt; &lt;&lt; name :: binary - size ( 5 ) , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; &quot;Frank the Walrus&quot; iex&gt; { name , species } { &quot;Frank&quot; , &quot;Walrus&quot; } The size can be a variable or any valid guard expression: iex&gt; name_size = 5 iex&gt; &lt;&lt; name :: binary - size ( name_size ) , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; iex&gt; { name , species } { &quot;Frank&quot; , &quot;Walrus&quot; } The size can access prior variables defined in the binary itself: iex&gt; &lt;&lt; name_size :: size ( 8 ) , name :: binary - size ( name_size ) , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; 5 , &quot;Frank the Walrus&quot; &gt;&gt; iex&gt; { name , species } { &quot;Frank&quot; , &quot;Walrus&quot; } However, it cannot access variables defined in the match outside of the binary/bitstring: { name_size , &lt;&lt; name :: binary - size ( name_size ) , _rest :: binary &gt;&gt; } = { 5 , &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; } ** (CompileError): undefined variable &quot;name_size&quot; in bitstring segment Failing to specify the size for the non-last causes compilation to fail: &lt;&lt; name :: binary , &quot; the &quot; , species :: binary &gt;&gt; = &lt;&lt; &quot;Frank the Walrus&quot; &gt;&gt; ** (CompileError): a binary field without size is only allowed at the end of a binary pattern Shortcut Syntax Size and unit can also be specified using a syntax shortcut when passing integer values: iex&gt; x = 1 iex&gt; &lt;&lt; x :: 8 &gt;&gt; == &lt;&lt; x :: size ( 8 ) &gt;&gt; true iex&gt; &lt;&lt; x :: 8 * 4 &gt;&gt; == &lt;&lt; x :: size ( 8 ) - unit ( 4 ) &gt;&gt; true This syntax reflects the fact the effective size is given by multiplying the size by the unit. Modifiers Some types have associated modifiers to clear up ambiguity in byte representation. Modifier Relevant Type(s) signed integer unsigned (default) integer little integer , float , utf16 , utf32 big (default) integer , float , utf16 , utf32 native integer , utf16 , utf32 Sign Integers can be signed or unsigned , defaulting to unsigned . iex&gt; &lt;&lt; int :: integer &gt;&gt; = &lt;&lt; - 100 &gt;&gt; &lt;&lt; 156 &gt;&gt; iex&gt; int 156 iex&gt; &lt;&lt; int :: integer - signed &gt;&gt; = &lt;&lt; - 100 &gt;&gt; &lt;&lt; 156 &gt;&gt; iex&gt; int - 100 signed and unsigned are only used for matching binaries (see below) and are only used for integers. iex&gt; &lt;&lt; - 100 :: signed , _rest :: binary &gt;&gt; = &lt;&lt; - 100 , &quot;foo&quot; &gt;&gt; &lt;&lt; 156 , 102 , 111 , 111 &gt;&gt; Endianness Elixir has three options for endianness: big , little , and native . The default is big : iex&gt; &lt;&lt; number :: little - integer - size ( 16 ) &gt;&gt; = &lt;&lt; 0 , 1 &gt;&gt; &lt;&lt; 0 , 1 &gt;&gt; iex&gt; number 256 iex&gt; &lt;&lt; number :: big - integer - size ( 16 ) &gt;&gt; = &lt;&lt; 0 , 1 &gt;&gt; &lt;&lt; 0 , 1 &gt;&gt; iex&gt; number 1 native is determined by the VM at startup and will depend on the host operating system. Binary/Bitstring Matching Binary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching. Binary matching can be used by itself to extract information from binaries: iex&gt; &lt;&lt; &quot;Hello, &quot; , place :: binary &gt;&gt; = &quot;Hello, World&quot; &quot;Hello, World&quot; iex&gt; place &quot;World&quot; Or as a part of function definitions to pattern match: defmodule ImageTyper do @png_signature &lt;&lt; 137 :: size ( 8 ) , 80 :: size ( 8 ) , 78 :: size ( 8 ) , 71 :: size ( 8 ) , 13 :: size ( 8 ) , 10 :: size ( 8 ) , 26 :: size ( 8 ) , 10 :: size ( 8 ) &gt;&gt; @jpg_signature &lt;&lt; 255 :: size ( 8 ) , 216 :: size ( 8 ) &gt;&gt; def type ( &lt;&lt; @png_signature , _rest :: binary &gt;&gt; ) , do : :png def type ( &lt;&lt; @jpg_signature , _rest :: binary &gt;&gt; ) , do : :jpg def type ( _ ) , do : :unknown end Performance &amp; Optimizations The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the bin_opt_info compiler option: ERL_COMPILER_OPTIONS = bin_opt_info mix compile To learn more about specific optimizations and performance considerations, check out the &quot;Constructing and matching binaries&quot; chapter of the Erlang's Efficiency Guide .","ref":"Kernel.SpecialForms.html#%3C%3C%3E%3E/1","source_doc":"Defines a new bitstring.\n\n## Examples\n\n    iex> <<1, 2, 3>>\n    <<1, 2, 3>>\n\n## Types\n\nA bitstring is made of many segments and each segment has a\ntype. There are 9 types used in bitstrings:\n\n- `integer`\n- `float`\n- `bits` (alias for `bitstring`)\n- `bitstring`\n- `binary`\n- `bytes` (alias for `binary`)\n- `utf8`\n- `utf16`\n- `utf32`\n\nWhen no type is specified, the default is `integer`:\n\n    iex> <<1, 2, 3>>\n    <<1, 2, 3>>\n\nElixir also accepts by default the segment to be a literal\nstring which expands to integers:\n\n    iex> <<0, \"foo\">>\n    <<0, 102, 111, 111>>\n\nBinaries need to be explicitly tagged as `binary`:\n\n    iex> rest = \"oo\"\n    iex> <<102, rest::binary>>\n    \"foo\"\n\nThe `utf8`, `utf16`, and `utf32` types are for Unicode code points. They\ncan also be applied to literal strings and charlists:\n\n    iex> <<\"foo\"::utf16>>\n    <<0, 102, 0, 111, 0, 111>>\n    iex> <<\"foo\"::utf32>>\n    <<0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111>>\n\nOtherwise we get an `ArgumentError` when constructing the binary:\n\n    rest = \"oo\"\n    <<102, rest>>\n    ** (ArgumentError) argument error\n\n## Options\n\nMany options can be given by using `-` as separator. Order is\narbitrary, so the following are all equivalent:\n\n    <<102::integer-native, rest::binary>>\n    <<102::native-integer, rest::binary>>\n    <<102::unsigned-big-integer, rest::binary>>\n    <<102::unsigned-big-integer-size(8), rest::binary>>\n    <<102::unsigned-big-integer-8, rest::binary>>\n    <<102::8-integer-big-unsigned, rest::binary>>\n    <<102, rest::binary>>\n\n### Unit and Size\n\nThe length of the match is equal to the `unit` (a number of bits) times the\n`size` (the number of repeated segments of length `unit`).\n\nType      | Default Unit\n--------- | ------------\n`integer` | 1 bit\n`float`   | 1 bit\n`binary`  | 8 bits\n\nSizes for types are a bit more nuanced. The default size for integers is 8.\n\nFor floats, it is 64. For floats, `size * unit` must result in 16, 32, or 64,\ncorresponding to [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)\nbinary16, binary32, and binary64, respectively.\n\nFor binaries, the default is the size of the binary. Only the last binary in a\nmatch can use the default size. All others must have their size specified\nexplicitly, even if the match is unambiguous. For example:\n\n    iex> <<name::binary-size(5), \" the \", species::binary>> = <<\"Frank the Walrus\">>\n    \"Frank the Walrus\"\n    iex> {name, species}\n    {\"Frank\", \"Walrus\"}\n\nThe size can be a variable or any valid guard expression:\n\n    iex> name_size = 5\n    iex> <<name::binary-size(name_size), \" the \", species::binary>> = <<\"Frank the Walrus\">>\n    iex> {name, species}\n    {\"Frank\", \"Walrus\"}\n\nThe size can access prior variables defined in the binary itself:\n\n    iex> <<name_size::size(8), name::binary-size(name_size), \" the \", species::binary>> = <<5, \"Frank the Walrus\">>\n    iex> {name, species}\n    {\"Frank\", \"Walrus\"}\n\nHowever, it cannot access variables defined in the match outside of the binary/bitstring:\n\n    {name_size, <<name::binary-size(name_size), _rest::binary>>} = {5, <<\"Frank the Walrus\">>}\n    ** (CompileError): undefined variable \"name_size\" in bitstring segment\n\nFailing to specify the size for the non-last causes compilation to fail:\n\n    <<name::binary, \" the \", species::binary>> = <<\"Frank the Walrus\">>\n    ** (CompileError): a binary field without size is only allowed at the end of a binary pattern\n\n#### Shortcut Syntax\n\nSize and unit can also be specified using a syntax shortcut\nwhen passing integer values:\n\n    iex> x = 1\n    iex> <<x::8>> == <<x::size(8)>>\n    true\n    iex> <<x::8*4>> == <<x::size(8)-unit(4)>>\n    true\n\nThis syntax reflects the fact the effective size is given by\nmultiplying the size by the unit.\n\n### Modifiers\n\nSome types have associated modifiers to clear up ambiguity in byte\nrepresentation.\n\nModifier             | Relevant Type(s)\n-------------------- | ----------------\n`signed`             | `integer`\n`unsigned` (default) | `integer`\n`little`             | `integer`, `float`, `utf16`, `utf32`\n`big` (default)      | `integer`, `float`, `utf16`, `utf32`\n`native`             | `integer`, `utf16`, `utf32`\n\n### Sign\n\nIntegers can be `signed` or `unsigned`, defaulting to `unsigned`.\n\n    iex> <<int::integer>> = <<-100>>\n    <<156>>\n    iex> int\n    156\n    iex> <<int::integer-signed>> = <<-100>>\n    <<156>>\n    iex> int\n    -100\n\n`signed` and `unsigned` are only used for matching binaries (see below) and\nare only used for integers.\n\n    iex> <<-100::signed, _rest::binary>> = <<-100, \"foo\">>\n    <<156, 102, 111, 111>>\n\n### Endianness\n\nElixir has three options for endianness: `big`, `little`, and `native`.\nThe default is `big`:\n\n    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n    <<0, 1>>\n    iex> number\n    256\n    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n    <<0, 1>>\n    iex> number\n    1\n\n`native` is determined by the VM at startup and will depend on the\nhost operating system.\n\n## Binary/Bitstring Matching\n\nBinary matching is a powerful feature in Elixir that is useful for extracting\ninformation from binaries as well as pattern matching.\n\nBinary matching can be used by itself to extract information from binaries:\n\n    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n    \"Hello, World\"\n    iex> place\n    \"World\"\n\nOr as a part of function definitions to pattern match:\n\n    defmodule ImageTyper do\n      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n                       13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n      @jpg_signature <<255::size(8), 216::size(8)>>\n\n      def type(<<@png_signature, _rest::binary>>), do: :png\n      def type(<<@jpg_signature, _rest::binary>>), do: :jpg\n      def type(_), do: :unknown\n    end\n\n### Performance & Optimizations\n\nThe Erlang compiler can provide a number of optimizations on binary creation\nand matching. To see optimization output, set the `bin_opt_info` compiler\noption:\n\n    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n\nTo learn more about specific optimizations and performance considerations,\ncheck out the\n[\"Constructing and matching binaries\" chapter of the Erlang's Efficiency Guide](https://www.erlang.org/doc/efficiency_guide/binaryhandling.html).\n","title":"Kernel.SpecialForms.<<>>/1","type":"macro"},{"doc":"Match operator. Matches the value on the right against the pattern on the left.","ref":"Kernel.SpecialForms.html#=/2","source_doc":"Match operator. Matches the value on the right against the pattern on the left.\n","title":"Kernel.SpecialForms.=/2","type":"macro"},{"doc":"alias/2 is used to set up aliases, often useful with modules' names. Examples alias/2 can be used to set up an alias for any module: defmodule Math do alias MyKeyword , as : Keyword end In the example above, we have set up MyKeyword to be aliased as Keyword . So now, any reference to Keyword will be automatically replaced by MyKeyword . In case one wants to access the original Keyword , it can be done by accessing Elixir : Keyword . values #=&gt; uses MyKeyword.values Elixir.Keyword . values #=&gt; uses Keyword.values Note that calling alias without the :as option automatically sets an alias based on the last part of the module. For example: alias Foo.Bar.Baz Is the same as: alias Foo.Bar.Baz , as : Baz We can also alias multiple modules in one line: alias Foo . { Bar , Baz , Biz } Is the same as: alias Foo.Bar alias Foo.Baz alias Foo.Biz Lexical scope import/2 , require/2 and alias/2 are called directives and all have lexical scope. This means you can set up aliases inside specific functions and it won't affect the overall scope. Warnings If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used. In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined. Both warning behaviours could be changed by explicitly setting the :warn option to true or false .","ref":"Kernel.SpecialForms.html#alias/2","source_doc":"`alias/2` is used to set up aliases, often useful with modules' names.\n\n## Examples\n\n`alias/2` can be used to set up an alias for any module:\n\n    defmodule Math do\n      alias MyKeyword, as: Keyword\n    end\n\nIn the example above, we have set up `MyKeyword` to be aliased\nas `Keyword`. So now, any reference to `Keyword` will be\nautomatically replaced by `MyKeyword`.\n\nIn case one wants to access the original `Keyword`, it can be done\nby accessing `Elixir`:\n\n    Keyword.values #=> uses MyKeyword.values\n    Elixir.Keyword.values #=> uses Keyword.values\n\nNote that calling `alias` without the `:as` option automatically\nsets an alias based on the last part of the module. For example:\n\n    alias Foo.Bar.Baz\n\nIs the same as:\n\n    alias Foo.Bar.Baz, as: Baz\n\nWe can also alias multiple modules in one line:\n\n    alias Foo.{Bar, Baz, Biz}\n\nIs the same as:\n\n    alias Foo.Bar\n    alias Foo.Baz\n    alias Foo.Biz\n\n## Lexical scope\n\n`import/2`, `require/2` and `alias/2` are called directives and all\nhave lexical scope. This means you can set up aliases inside\nspecific functions and it won't affect the overall scope.\n\n## Warnings\n\nIf you alias a module and you don't use the alias, Elixir is\ngoing to issue a warning implying the alias is not being used.\n\nIn case the alias is generated automatically by a macro,\nElixir won't emit any warnings though, since the alias\nwas not explicitly defined.\n\nBoth warning behaviours could be changed by explicitly\nsetting the `:warn` option to `true` or `false`.\n\n","title":"Kernel.SpecialForms.alias/2","type":"macro"},{"doc":"Matches the given expression against the given clauses. Examples case File . read ( file ) do { :ok , contents } when is_binary ( contents ) -&gt; String . split ( contents , &quot; \\n &quot; ) { :error , _reason } -&gt; Logger . warning &quot;could not find \#{ file } , assuming empty...&quot; [ ] end In the example above, we match the result of File.read/1 against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches. If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like _ ) which will always match. x = 10 case x do 0 -&gt; &quot;This clause won&#39;t match&quot; _ -&gt; &quot;This clause would match any value (x = \#{ x } )&quot; end #=&gt; &quot;This clause would match any value (x = 10)&quot; Variable handling Note that variables bound in a clause do not leak to the outer context: case data do { :ok , value } -&gt; value :error -&gt; nil end value #=&gt; unbound variable value Variables in the outer context cannot be overridden either: value = 7 case lucky? do false -&gt; value = 13 true -&gt; true end value #=&gt; 7 In the example above, value is going to be 7 regardless of the value of lucky? . The variable value bound in the clause and the variable value bound in the outer context are two entirely separate variables. If you want to pattern match against an existing variable, you need to use the ^/1 operator: x = 1 case 10 do ^ x -&gt; &quot;Won&#39;t match&quot; _ -&gt; &quot;Will match&quot; end #=&gt; &quot;Will match&quot; Using guards to match against multiple values While it is not possible to match against multiple patterns in a single clause, it's possible to match against multiple values by using guards: case data do value when value in [ :one , :two ] -&gt; &quot; \#{ value } has been matched&quot; :three -&gt; &quot;three has been matched&quot; end","ref":"Kernel.SpecialForms.html#case/2","source_doc":"Matches the given expression against the given clauses.\n\n## Examples\n\n    case File.read(file) do\n      {:ok, contents} when is_binary(contents) ->\n        String.split(contents, \"\\n\")\n\n      {:error, _reason} ->\n        Logger.warning \"could not find \#{file}, assuming empty...\"\n        []\n    end\n\nIn the example above, we match the result of `File.read/1`\nagainst each clause \"head\" and execute the clause \"body\"\ncorresponding to the first clause that matches.\n\nIf no clause matches, an error is raised. For this reason,\nit may be necessary to add a final catch-all clause (like `_`)\nwhich will always match.\n\n    x = 10\n\n    case x do\n      0 ->\n        \"This clause won't match\"\n\n      _ ->\n        \"This clause would match any value (x = \#{x})\"\n    end\n    #=> \"This clause would match any value (x = 10)\"\n\n## Variable handling\n\nNote that variables bound in a clause do not leak to the outer context:\n\n    case data do\n      {:ok, value} -> value\n      :error -> nil\n    end\n\n    value\n    #=> unbound variable value\n\nVariables in the outer context cannot be overridden either:\n\n    value = 7\n\n    case lucky? do\n      false -> value = 13\n      true -> true\n    end\n\n    value\n    #=> 7\n\nIn the example above, `value` is going to be `7` regardless of the value of\n`lucky?`. The variable `value` bound in the clause and the variable `value`\nbound in the outer context are two entirely separate variables.\n\nIf you want to pattern match against an existing variable,\nyou need to use the `^/1` operator:\n\n    x = 1\n\n    case 10 do\n      ^x -> \"Won't match\"\n      _ -> \"Will match\"\n    end\n    #=> \"Will match\"\n\n## Using guards to match against multiple values\n\nWhile it is not possible to match against multiple patterns in a single\nclause, it's possible to match against multiple values by using guards:\n\n    case data do\n      value when value in [:one, :two] ->\n        \"\#{value} has been matched\"\n\n      :three ->\n        \"three has been matched\"\n    end\n\n","title":"Kernel.SpecialForms.case/2","type":"macro"},{"doc":"Evaluates the expression corresponding to the first clause that evaluates to a truthy value. cond do hd ( [ 1 , 2 , 3 ] ) -&gt; &quot;1 is considered as true&quot; end #=&gt; &quot;1 is considered as true&quot; Raises an error if all conditions evaluate to nil or false . For this reason, it may be necessary to add a final always-truthy condition (anything non- false and non- nil ), which will always match. Examples cond do 1 + 1 == 1 -&gt; &quot;This will never match&quot; 2 * 2 != 4 -&gt; &quot;Nor this&quot; true -&gt; &quot;This will&quot; end #=&gt; &quot;This will&quot;","ref":"Kernel.SpecialForms.html#cond/1","source_doc":"Evaluates the expression corresponding to the first clause that\nevaluates to a truthy value.\n\n    cond do\n      hd([1, 2, 3]) ->\n        \"1 is considered as true\"\n    end\n    #=> \"1 is considered as true\"\n\nRaises an error if all conditions evaluate to `nil` or `false`.\nFor this reason, it may be necessary to add a final always-truthy condition\n(anything non-`false` and non-`nil`), which will always match.\n\n## Examples\n\n    cond do\n      1 + 1 == 1 ->\n        \"This will never match\"\n      2 * 2 != 4 ->\n        \"Nor this\"\n      true ->\n        \"This will\"\n    end\n    #=> \"This will\"\n\n","title":"Kernel.SpecialForms.cond/1","type":"macro"},{"doc":"Defines an anonymous function. See Function for more information. Examples iex&gt; add = fn a , b -&gt; a + b end iex&gt; add . ( 1 , 2 ) 3 Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments: iex&gt; negate = fn ...&gt; true -&gt; false ...&gt; false -&gt; true ...&gt; end iex&gt; negate . ( false ) true","ref":"Kernel.SpecialForms.html#fn/1","source_doc":"Defines an anonymous function.\n\nSee `Function` for more information.\n\n## Examples\n\n    iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true\n\n","title":"Kernel.SpecialForms.fn/1","type":"macro"},{"doc":"Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring. Let's start with an example: iex&gt; for n &lt;- [ 1 , 2 , 3 , 4 ] , do : n * 2 [ 2 , 4 , 6 , 8 ] A comprehension accepts many generators and filters. for uses the &lt;- operator to extract values from the enumerable on its right side and match them against the pattern on the left. We call them generators: # A list generator: iex&gt; for n &lt;- [ 1 , 2 , 3 , 4 ] , do : n * 2 [ 2 , 4 , 6 , 8 ] # A comprehension with two generators iex&gt; for x &lt;- [ 1 , 2 ] , y &lt;- [ 2 , 3 ] , do : x * y [ 2 , 3 , 4 , 6 ] Filters can also be given: # A comprehension with a generator and a filter iex&gt; for n &lt;- [ 1 , 2 , 3 , 4 , 5 , 6 ] , rem ( n , 2 ) == 0 , do : n [ 2 , 4 , 6 ] Filters must evaluate to truthy values (everything but nil and false ). If a filter is falsy, then the current value is discarded. Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;- : iex&gt; users = [ user : &quot;john&quot; , admin : &quot;meg&quot; , guest : &quot;barbara&quot; ] iex&gt; for { type , name } when type != :guest &lt;- users do ...&gt; String . upcase ( name ) ...&gt; end [ &quot;JOHN&quot; , &quot;MEG&quot; ] Bitstring generators are also supported and are very useful when you need to organize bitstring streams: iex&gt; pixels = &lt;&lt; 213 , 45 , 132 , 64 , 76 , 32 , 76 , 0 , 0 , 234 , 32 , 15 &gt;&gt; iex&gt; for &lt;&lt; r :: 8 , g :: 8 , b :: 8 &lt;- pixels &gt;&gt; , do : { r , g , b } [ { 213 , 45 , 132 } , { 64 , 76 , 32 } , { 76 , 0 , 0 } , { 234 , 32 , 15 } ] Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension. Variable assignments inside filters must still return a truthy value, otherwise values are discarded. Let's see an example. Imagine you have a keyword list where the key is a programming language and the value is its direct parent. Then let's try to compute the grandparent of each language. You could try this: iex&gt; languages = [ elixir : :erlang , erlang : :prolog , prolog : nil ] iex&gt; for { language , parent } &lt;- languages , grandparent = languages [ parent ] , do : { language , grandparent } [ elixir : :prolog ] Given the grandparents of Erlang and Prolog were nil, those values were filtered out. If you don't want this behaviour, a simple option is to move the filter inside the do-block: iex&gt; languages = [ elixir : :erlang , erlang : :prolog , prolog : nil ] iex&gt; for { language , parent } &lt;- languages do ...&gt; grandparent = languages [ parent ] ...&gt; { language , grandparent } ...&gt; end [ elixir : :prolog , erlang : nil , prolog : nil ] However, such option is not always available, as you may have further filters. An alternative is to convert the filter into a generator by wrapping the right side of = in a list: iex&gt; languages = [ elixir : :erlang , erlang : :prolog , prolog : nil ] iex&gt; for { language , parent } &lt;- languages , grandparent &lt;- [ languages [ parent ] ] , do : { language , grandparent } [ elixir : :prolog , erlang : nil , prolog : nil ] The :into and :uniq options In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an :into option, that accepts any structure as long as it implements the Collectable protocol. For example, we can use bitstring generators with the :into option to easily remove all spaces in a string: iex&gt; for &lt;&lt; c &lt;- &quot; hello world &quot; &gt;&gt; , c != ?\\s , into : &quot;&quot; , do : &lt;&lt; c &gt;&gt; &quot;helloworld&quot; The IO module provides streams, that are both Enumerable and Collectable , here is an upcase echo server using comprehensions: for line &lt;- IO . stream ( ) , into : IO . stream ( ) do String . upcase ( line ) end Similarly, uniq: true can also be given to comprehensions to guarantee the results are only added to the collection if they were not returned before. For example: iex&gt; for x &lt;- [ 1 , 1 , 2 , 3 ] , uniq : true , do : x * 2 [ 2 , 4 , 6 ] iex&gt; for &lt;&lt; x &lt;- &quot;abcabc&quot; &gt;&gt; , uniq : true , into : &quot;&quot; , do : &lt;&lt; x - 32 &gt;&gt; &quot;ABC&quot; The :reduce option While the :into option allows us to customize the comprehension behaviour to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough. For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string &quot;AbCabCABc&quot; , we want to return the map %{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 1} . If we were to use :into , we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself. A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke Enum.reduce/3 to build a map, for example: iex&gt; letters = for &lt;&lt; x &lt;- &quot;AbCabCABc&quot; &gt;&gt; , x in ?a .. ?z , do : &lt;&lt; x &gt;&gt; iex&gt; Enum . reduce ( letters , %{ } , fn x , acc -&gt; Map . update ( acc , x , 1 , &amp; &amp;1 + 1 ) end ) %{ &quot;a&quot; =&gt; 1 , &quot;b&quot; =&gt; 2 , &quot;c&quot; =&gt; 1 } While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive. Luckily, comprehensions also support the :reduce option, which would allow us to fuse both steps above into a single step: iex&gt; for &lt;&lt; x &lt;- &quot;AbCabCABc&quot; &gt;&gt; , x in ?a .. ?z , reduce : %{ } do ...&gt; acc -&gt; Map . update ( acc , &lt;&lt; x &gt;&gt; , 1 , &amp; &amp;1 + 1 ) ...&gt; end %{ &quot;a&quot; =&gt; 1 , &quot;b&quot; =&gt; 2 , &quot;c&quot; =&gt; 1 } When the :reduce key is given, its value is used as the initial accumulator and the do block must be changed to use -&gt; clauses, where the left side of -&gt; receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned.","ref":"Kernel.SpecialForms.html#for/1","source_doc":"Comprehensions allow you to quickly build a data structure from\nan enumerable or a bitstring.\n\nLet's start with an example:\n\n    iex> for n <- [1, 2, 3, 4], do: n * 2\n    [2, 4, 6, 8]\n\nA comprehension accepts many generators and filters. `for` uses\nthe `<-` operator to extract values from the enumerable on its\nright side and match them against the pattern on the left.\nWe call them generators:\n\n    # A list generator:\n    iex> for n <- [1, 2, 3, 4], do: n * 2\n    [2, 4, 6, 8]\n\n    # A comprehension with two generators\n    iex> for x <- [1, 2], y <- [2, 3], do: x * y\n    [2, 3, 4, 6]\n\nFilters can also be given:\n\n    # A comprehension with a generator and a filter\n    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n    [2, 4, 6]\n\nFilters must evaluate to truthy values (everything but `nil`\nand `false`). If a filter is falsy, then the current value is\ndiscarded.\n\nGenerators can also be used to filter as it removes any value\nthat doesn't match the pattern on the left side of `<-`:\n\n    iex> users = [user: \"john\", admin: \"meg\", guest: \"barbara\"]\n    iex> for {type, name} when type != :guest <- users do\n    ...>   String.upcase(name)\n    ...> end\n    [\"JOHN\", \"MEG\"]\n\nBitstring generators are also supported and are very useful when you\nneed to organize bitstring streams:\n\n    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n    iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}\n    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n\nVariable assignments inside the comprehension, be it in generators,\nfilters or inside the block, are not reflected outside of the\ncomprehension.\n\nVariable assignments inside filters must still return a truthy value,\notherwise values are discarded. Let's see an example. Imagine you have\na keyword list where the key is a programming language and the value\nis its direct parent. Then let's try to compute the grandparent of each\nlanguage. You could try this:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages, grandparent = languages[parent], do: {language, grandparent}\n    [elixir: :prolog]\n\nGiven the grandparents of Erlang and Prolog were nil, those values were\nfiltered out. If you don't want this behaviour, a simple option is to\nmove the filter inside the do-block:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages do\n    ...>   grandparent = languages[parent]\n    ...>   {language, grandparent}\n    ...> end\n    [elixir: :prolog, erlang: nil, prolog: nil]\n\nHowever, such option is not always available, as you may have further\nfilters. An alternative is to convert the filter into a generator by\nwrapping the right side of `=` in a list:\n\n    iex> languages = [elixir: :erlang, erlang: :prolog, prolog: nil]\n    iex> for {language, parent} <- languages, grandparent <- [languages[parent]], do: {language, grandparent}\n    [elixir: :prolog, erlang: nil, prolog: nil]\n\n## The `:into` and `:uniq` options\n\nIn the examples above, the result returned by the comprehension was\nalways a list. The returned result can be configured by passing an\n`:into` option, that accepts any structure as long as it implements\nthe `Collectable` protocol.\n\nFor example, we can use bitstring generators with the `:into` option\nto easily remove all spaces in a string:\n\n    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n    \"helloworld\"\n\nThe `IO` module provides streams, that are both `Enumerable` and\n`Collectable`, here is an upcase echo server using comprehensions:\n\n    for line <- IO.stream(), into: IO.stream() do\n      String.upcase(line)\n    end\n\nSimilarly, `uniq: true` can also be given to comprehensions to guarantee\nthe results are only added to the collection if they were not returned\nbefore. For example:\n\n    iex> for x <- [1, 1, 2, 3], uniq: true, do: x * 2\n    [2, 4, 6]\n\n    iex> for <<x <- \"abcabc\">>, uniq: true, into: \"\", do: <<x - 32>>\n    \"ABC\"\n\n## The `:reduce` option\n\nWhile the `:into` option allows us to customize the comprehension behaviour\nto a given data type, such as putting all of the values inside a map or inside\na binary, it is not always enough.\n\nFor example, imagine that you have a binary with letters where you want to\ncount how many times each lowercase letter happens, ignoring all uppercase\nones. For instance, for the string `\"AbCabCABc\"`, we want to return the map\n`%{\"a\" => 1, \"b\" => 2, \"c\" => 1}`.\n\nIf we were to use `:into`, we would need a data type that computes the\nfrequency of each element it holds. While there is no such data type in\nElixir, you could implement one yourself.\n\nA simpler option would be to use comprehensions for the mapping and\nfiltering of letters, and then we invoke `Enum.reduce/3` to build a map,\nfor example:\n\n    iex> letters = for <<x <- \"AbCabCABc\">>, x in ?a..?z, do: <<x>>\n    iex> Enum.reduce(letters, %{}, fn x, acc -> Map.update(acc, x, 1, & &1 + 1) end)\n    %{\"a\" => 1, \"b\" => 2, \"c\" => 1}\n\nWhile the above is straight-forward, it has the downside of traversing the\ndata at least twice. If you are expecting long strings as inputs, this can\nbe quite expensive.\n\nLuckily, comprehensions also support the `:reduce` option, which would allow\nus to fuse both steps above into a single step:\n\n    iex> for <<x <- \"AbCabCABc\">>, x in ?a..?z, reduce: %{} do\n    ...>   acc -> Map.update(acc, <<x>>, 1, & &1 + 1)\n    ...> end\n    %{\"a\" => 1, \"b\" => 2, \"c\" => 1}\n\nWhen the `:reduce` key is given, its value is used as the initial accumulator\nand the `do` block must be changed to use `->` clauses, where the left side\nof `->` receives the accumulated value of the previous iteration and the\nexpression on the right side must return the new accumulator value. Once there are no more\nelements, the final accumulated value is returned. If there are no elements\nat all, then the initial accumulator value is returned.\n","title":"Kernel.SpecialForms.for/1","type":"macro"},{"doc":"Imports functions and macros from other modules. import/2 allows one to easily access functions or macros from other modules without using the qualified name. Examples If you are using several functions from a given module, you can import those functions and reference them as local functions, for example: iex&gt; import List iex&gt; flatten ( [ 1 , [ 2 ] , 3 ] ) [ 1 , 2 , 3 ] Selector By default, Elixir imports functions and macros from the given module, except the ones starting with an underscore (which are usually callbacks): import List A developer can filter to import only functions, macros, or sigils (which can be functions or macros) via the :only option: import List , only : :functions import List , only : :macros import Kernel , only : :sigils Alternatively, Elixir allows a developer to pass pairs of name/arities to :only or :except as a fine grained control on what to import (or not): import List , only : [ flatten : 1 ] import String , except : [ split : 2 ] Importing the same module again will erase the previous imports, except when the except option is used, which is always exclusive on a previously declared import/2 . If there is no previous import, then it applies to all functions and macros in the module. For example: import List , only : [ flatten : 1 , keyfind : 4 ] import List , except : [ flatten : 1 ] After the two import calls above, only List.keyfind/4 will be imported. Underscore functions By default functions starting with _ are not imported. If you really want to import a function starting with _ you must explicitly include it in the :only selector. import File.Stream , only : [ __build__ : 3 ] Lexical scope It is important to note that import/2 is lexical. This means you can import specific macros inside specific functions: defmodule Math do def some_function do # 1) Disable &quot;if/2&quot; from Kernel import Kernel , except : [ if : 2 ] # 2) Require the new &quot;if/2&quot; macro from MyMacros import MyMacros # 3) Use the new macro if do_something , it_works end end In the example above, we imported macros from MyMacros , replacing the original if/2 implementation by our own within that specific function. All other functions in that module will still be able to use the original one. Warnings If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used. In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined. Both warning behaviours could be changed by explicitly setting the :warn option to true or false . Ambiguous function/macro names If two modules A and B are imported and they both contain a foo function with an arity of 1 , an error is only emitted if an ambiguous call to foo/1 is actually made; that is, the errors are emitted lazily, not eagerly.","ref":"Kernel.SpecialForms.html#import/2","source_doc":"Imports functions and macros from other modules.\n\n`import/2` allows one to easily access functions or macros from\nother modules without using the qualified name.\n\n## Examples\n\nIf you are using several functions from a given module, you can\nimport those functions and reference them as local functions,\nfor example:\n\n    iex> import List\n    iex> flatten([1, [2], 3])\n    [1, 2, 3]\n\n## Selector\n\nBy default, Elixir imports functions and macros from the given\nmodule, except the ones starting with an underscore (which are\nusually callbacks):\n\n    import List\n\nA developer can filter to import only functions, macros, or sigils\n(which can be functions or macros) via the `:only` option:\n\n    import List, only: :functions\n    import List, only: :macros\n    import Kernel, only: :sigils\n\nAlternatively, Elixir allows a developer to pass pairs of\nname/arities to `:only` or `:except` as a fine grained control\non what to import (or not):\n\n    import List, only: [flatten: 1]\n    import String, except: [split: 2]\n\nImporting the same module again will erase the previous imports,\nexcept when the `except` option is used, which is always exclusive\non a previously declared `import/2`. If there is no previous import,\nthen it applies to all functions and macros in the module. For\nexample:\n\n    import List, only: [flatten: 1, keyfind: 4]\n    import List, except: [flatten: 1]\n\nAfter the two import calls above, only `List.keyfind/4` will be\nimported.\n\n## Underscore functions\n\nBy default functions starting with `_` are not imported. If you really want\nto import a function starting with `_` you must explicitly include it in the\n`:only` selector.\n\n    import File.Stream, only: [__build__: 3]\n\n## Lexical scope\n\nIt is important to note that `import/2` is lexical. This means you\ncan import specific macros inside specific functions:\n\n    defmodule Math do\n      def some_function do\n        # 1) Disable \"if/2\" from Kernel\n        import Kernel, except: [if: 2]\n\n        # 2) Require the new \"if/2\" macro from MyMacros\n        import MyMacros\n\n        # 3) Use the new macro\n        if do_something, it_works\n      end\n    end\n\nIn the example above, we imported macros from `MyMacros`,\nreplacing the original `if/2` implementation by our own\nwithin that specific function. All other functions in that\nmodule will still be able to use the original one.\n\n## Warnings\n\nIf you import a module and you don't use any of the imported\nfunctions or macros from this module, Elixir is going to issue\na warning implying the import is not being used.\n\nIn case the import is generated automatically by a macro,\nElixir won't emit any warnings though, since the import\nwas not explicitly defined.\n\nBoth warning behaviours could be changed by explicitly\nsetting the `:warn` option to `true` or `false`.\n\n## Ambiguous function/macro names\n\nIf two modules `A` and `B` are imported and they both contain\na `foo` function with an arity of `1`, an error is only emitted\nif an ambiguous call to `foo/1` is actually made; that is, the\nerrors are emitted lazily, not eagerly.\n","title":"Kernel.SpecialForms.import/2","type":"macro"},{"doc":"Gets the representation of any expression. Examples iex&gt; quote do ...&gt; sum ( 1 , 2 , 3 ) ...&gt; end { :sum , [ ] , [ 1 , 2 , 3 ] } Elixir's AST (Abstract Syntax Tree) Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example: { :sum , [ ] , [ 1 , 2 , 3 ] } The tuple above represents a function call to sum passing 1, 2 and 3 as arguments. The tuple elements are: The first element of the tuple is always an atom or another tuple in the same representation. The second element of the tuple represents metadata . The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call). Besides the tuple described above, Elixir has a few literals that are also part of its AST. Those literals return themselves when quoted. They are: :sum #=&gt; Atoms 1 #=&gt; Integers 2.0 #=&gt; Floats [ 1 , 2 ] #=&gt; Lists &quot;strings&quot; #=&gt; Strings { key , value } #=&gt; Tuples with two elements Any other value, such as a map or a four-element tuple, must be escaped ( Macro.escape/1 ) before being introduced into an AST. Options :bind_quoted - passes a binding to the macro. Whenever a binding is given, unquote/1 is automatically disabled. :context - sets the resolution context. :generated - marks the given chunk as generated so it does not emit warnings. Currently it only works on special forms (for example, you can annotate a case but not an if ). :file - sets the quoted expressions to have the given file. :line - sets the quoted expressions to have the given line. :location - when set to :keep , keeps the current line and file from quote. Read the &quot;Stacktrace information&quot; section below for more information. :unquote - when false , disables unquoting. This means any unquote call will be kept as is in the AST, instead of replaced by the unquote arguments. For example: iex&gt; quote do ...&gt; unquote ( &quot;hello&quot; ) ...&gt; end &quot;hello&quot; iex&gt; quote unquote : false do ...&gt; unquote ( &quot;hello&quot; ) ...&gt; end { :unquote , [ ] , [ &quot;hello&quot; ] } Quote and macros quote/2 is commonly used with macros for code generation. As an exercise, let's define a macro that multiplies a number by itself (squared). In practice, there is no reason to define such a macro (and it would actually be seen as a bad practice), but it is simple enough that it allows us to focus on the important aspects of quotes and macros: defmodule Math do defmacro squared ( x ) do quote do unquote ( x ) * unquote ( x ) end end end We can invoke it as: import Math IO . puts ( &quot;Got \#{ squared ( 5 ) } &quot; ) At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, squared(5) becomes 5 * 5 . The argument 5 is duplicated in the produced code, we can see this behaviour in practice though because our macro actually has a bug: import Math my_number = fn -&gt; IO . puts ( &quot;Returning 5&quot; ) 5 end IO . puts ( &quot;Got \#{ squared ( my_number . ( ) ) } &quot; ) The example above will print: Returning 5 Returning 5 Got 25 Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that: squared ( my_number . ( ) ) Actually expands to: my_number . ( ) * my_number . ( ) Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behaviour, and that's why one of the first things you need to keep in mind when it comes to macros is to not unquote the same value more than once . Let's fix our macro: defmodule Math do defmacro squared ( x ) do quote do x = unquote ( x ) x * x end end end Now invoking squared(my_number.()) as before will print the value just once. In fact, this pattern is so common that most of the times you will want to use the bind_quoted option with quote/2 : defmodule Math do defmacro squared ( x ) do quote bind_quoted : [ x : x ] do x * x end end end :bind_quoted will translate to the same code as the example above. :bind_quoted can be used in many cases and is seen as good practice, not only because it helps prevent us from running into common mistakes, but also because it allows us to leverage other tools exposed by macros, such as unquote fragments discussed in some sections below. Before we finish this brief introduction, you will notice that, even though we defined a variable x inside our quote: quote do x = unquote ( x ) x * x end When we call: import Math squared ( 5 ) x ** (CompileError) undefined variable &quot;x&quot; We can see that x did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well. Hygiene in variables Consider the following example: defmodule Hygiene do defmacro no_interference do quote do a = 1 end end end require Hygiene a = 10 Hygiene . no_interference ( ) a #=&gt; 10 In the example above, a returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the var! macro: defmodule NoHygiene do defmacro interference do quote do var! ( a ) = 1 end end end require NoHygiene a = 10 NoHygiene . interference ( ) a #=&gt; 1 You cannot even access variables defined in the same module unless you explicitly give it a context: defmodule Hygiene do defmacro write do quote do a = 1 end end defmacro read do quote do a end end end Hygiene . write ( ) Hygiene . read ( ) ** (RuntimeError) undefined variable a or undefined function a/0 For such, you can explicitly pass the current module scope as argument: defmodule ContextHygiene do defmacro write do quote do var! ( a , ContextHygiene ) = 1 end end defmacro read do quote do var! ( a , ContextHygiene ) end end end ContextHygiene . write ( ) ContextHygiene . read ( ) #=&gt; 1 The contexts of a variable is identified by the third element of the tuple. The default context is nil and quote assigns another context to all variables within: quote ( do : var ) #=&gt; {:var, [], Elixir} In case of variables returned by macros, there may also be a :counter key in the metadata, which is used to further refine its contexts and guarantee isolation between macro invocations as seen in the previous example. Hygiene in aliases Aliases inside quote are hygienic by default. Consider the following example: defmodule Hygiene do alias Map , as : M defmacro no_interference do quote do M . new ( ) end end end require Hygiene Hygiene . no_interference ( ) #=&gt; %{} Note that, even though the alias M is not available in the context the macro is expanded, the code above works because M still expands to Map . Similarly, even if we defined an alias with the same name before invoking a macro, it won't affect the macro's result: defmodule Hygiene do alias Map , as : M defmacro no_interference do quote do M . new ( ) end end end require Hygiene alias SomethingElse , as : M Hygiene . no_interference ( ) #=&gt; %{} In some cases, you want to access an alias or a module defined in the caller. For such, you can use the alias! macro: defmodule Hygiene do # This will expand to Elixir.Nested.hello() defmacro no_interference do quote do Nested . hello ( ) end end # This will expand to Nested.hello() for # whatever is Nested in the caller defmacro interference do quote do alias! ( Nested ) . hello ( ) end end end defmodule Parent do defmodule Nested do def hello , do : &quot;world&quot; end require Hygiene Hygiene . no_interference ( ) ** (UndefinedFunctionError) ... Hygiene . interference ( ) #=&gt; &quot;world&quot; end Hygiene in imports Similar to aliases, imports in Elixir are hygienic. Consider the following code: defmodule Hygiene do defmacrop get_length do quote do length ( [ 1 , 2 , 3 ] ) end end def return_length do import Kernel , except : [ length : 1 ] get_length end end Hygiene . return_length ( ) #=&gt; 3 Notice how Hygiene.return_length/0 returns 3 even though the Kernel.length/1 function is not imported. In fact, even if return_length/0 imported a function with the same name and arity from another module, it wouldn't affect the function result: def return_length do import String , only : [ length : 1 ] get_length end Calling this new return_length/0 will still return 3 as result. Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call length([1, 2, 3]) inside quote, but no length/1 function is available, it is then expanded in the caller: defmodule Lazy do defmacrop get_length do import Kernel , except : [ length : 1 ] quote do length ( &quot;hello&quot; ) end end def return_length do import Kernel , except : [ length : 1 ] import String , only : [ length : 1 ] get_length end end Lazy . return_length ( ) #=&gt; 5 Stacktrace information When defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example: # adder.ex defmodule Adder do @doc &quot;Defines a function that adds two numbers&quot; defmacro defadd do quote location : :keep do def add ( a , b ) , do : a + b end end end # sample.ex defmodule Sample do import Adder defadd end require Sample Sample . add ( :one , :two ) ** (ArithmeticError) bad argument in arithmetic expression adder.ex:5: Sample.add/2 When using location: :keep and invalid arguments are given to Sample.add/2 , the stacktrace information will point to the file and line inside the quote. Without location: :keep , the error is reported to where defadd was invoked. location: :keep affects only definitions inside the quote. location: :keep and unquote Do not use location: :keep if the function definition also unquote s some of the macro arguments. If you do so, Elixir will store the file definition of the current location but the unquoted arguments may contain line information of the macro caller, leading to erroneous stacktraces. Binding and unquote fragments Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example: kv = [ foo : 1 , bar : 2 ] Enum . each ( kv , fn { k , v } -&gt; def unquote ( k ) ( ) , do : unquote ( v ) end ) In the example above, we have generated the functions foo/0 and bar/0 dynamically. Now, imagine that we want to convert this functionality into a macro: defmacro defkv ( kv ) do Enum . map ( kv , fn { k , v } -&gt; quote do def unquote ( k ) ( ) , do : unquote ( v ) end end ) end We can invoke this macro as: defkv [ foo : 1 , bar : 2 ] However, we can't invoke it as follows: kv = [ foo : 1 , bar : 2 ] defkv kv This is because the macro is expecting its arguments to be a keyword list at compilation time. Since in the example above we are passing the representation of the variable kv , our code fails. This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression: defmacro defkv ( kv ) do quote do Enum . each ( unquote ( kv ) , fn { k , v } -&gt; def unquote ( k ) ( ) , do : unquote ( v ) end ) end end If you try to run our new macro, you will notice it won't even compile, complaining that the variables k and v do not exist. This is because of the ambiguity: unquote(k) can either be an unquote fragment, as previously, or a regular unquote as in unquote(kv) . One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the kv representation into the tree. That's when the :bind_quoted option comes to the rescue (again!). By using :bind_quoted , we can automatically disable unquoting while still injecting the desired variables into the tree: defmacro defkv ( kv ) do quote bind_quoted : [ kv : kv ] do Enum . each ( kv , fn { k , v } -&gt; def unquote ( k ) ( ) , do : unquote ( v ) end ) end end In fact, the :bind_quoted option is recommended every time one desires to inject a value into the quote.","ref":"Kernel.SpecialForms.html#quote/2","source_doc":"Gets the representation of any expression.\n\n## Examples\n\n    iex> quote do\n    ...>   sum(1, 2, 3)\n    ...> end\n    {:sum, [], [1, 2, 3]}\n\n## Elixir's AST (Abstract Syntax Tree)\n\nAny Elixir code can be represented using Elixir data structures.\nThe building block of Elixir macros is a tuple with three elements,\nfor example:\n\n    {:sum, [], [1, 2, 3]}\n\nThe tuple above represents a function call to `sum` passing 1, 2 and\n3 as arguments. The tuple elements are:\n\n  * The first element of the tuple is always an atom or\n    another tuple in the same representation.\n\n  * The second element of the tuple represents [metadata](`t:Macro.metadata/0`).\n\n  * The third element of the tuple are the arguments for the\n    function call. The third argument may be an atom, which is\n    usually a variable (or a local call).\n\nBesides the tuple described above, Elixir has a few literals that\nare also part of its AST. Those literals return themselves when\nquoted. They are:\n\n    :sum         #=> Atoms\n    1            #=> Integers\n    2.0          #=> Floats\n    [1, 2]       #=> Lists\n    \"strings\"    #=> Strings\n    {key, value} #=> Tuples with two elements\n\nAny other value, such as a map or a four-element tuple, must be escaped\n(`Macro.escape/1`) before being introduced into an AST.\n\n## Options\n\n  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n    given, `unquote/1` is automatically disabled.\n\n  * `:context` - sets the resolution context.\n\n  * `:generated` - marks the given chunk as generated so it does not emit warnings.\n    Currently it only works on special forms (for example, you can annotate a `case`\n    but not an `if`).\n\n  * `:file` - sets the quoted expressions to have the given file.\n\n  * `:line` - sets the quoted expressions to have the given line.\n\n  * `:location` - when set to `:keep`, keeps the current line and file from\n    quote. Read the \"Stacktrace information\" section below for more information.\n\n  * `:unquote` - when `false`, disables unquoting. This means any `unquote`\n    call will be kept as is in the AST, instead of replaced by the `unquote`\n    arguments. For example:\n\n        iex> quote do\n        ...>   unquote(\"hello\")\n        ...> end\n        \"hello\"\n\n        iex> quote unquote: false do\n        ...>   unquote(\"hello\")\n        ...> end\n        {:unquote, [], [\"hello\"]}\n\n## Quote and macros\n\n`quote/2` is commonly used with macros for code generation. As an exercise,\nlet's define a macro that multiplies a number by itself (squared). In practice,\nthere is no reason to define such a macro (and it would actually be\nseen as a bad practice), but it is simple enough that it allows us to focus\non the important aspects of quotes and macros:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote do\n          unquote(x) * unquote(x)\n        end\n      end\n    end\n\nWe can invoke it as:\n\n    import Math\n    IO.puts(\"Got \#{squared(5)}\")\n\nAt first, there is nothing in this example that actually reveals it is a\nmacro. But what is happening is that, at compilation time, `squared(5)`\nbecomes `5 * 5`. The argument `5` is duplicated in the produced code, we\ncan see this behaviour in practice though because our macro actually has\na bug:\n\n    import Math\n    my_number = fn ->\n      IO.puts(\"Returning 5\")\n      5\n    end\n    IO.puts(\"Got \#{squared(my_number.())}\")\n\nThe example above will print:\n\n    Returning 5\n    Returning 5\n    Got 25\n\nNotice how \"Returning 5\" was printed twice, instead of just once. This is\nbecause a macro receives an expression and not a value (which is what we\nwould expect in a regular function). This means that:\n\n    squared(my_number.())\n\nActually expands to:\n\n    my_number.() * my_number.()\n\nWhich invokes the function twice, explaining why we get the printed value\ntwice! In the majority of the cases, this is actually unexpected behaviour,\nand that's why one of the first things you need to keep in mind when it\ncomes to macros is to **not unquote the same value more than once**.\n\nLet's fix our macro:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote do\n          x = unquote(x)\n          x * x\n        end\n      end\n    end\n\nNow invoking `squared(my_number.())` as before will print the value just\nonce.\n\nIn fact, this pattern is so common that most of the times you will want\nto use the `bind_quoted` option with `quote/2`:\n\n    defmodule Math do\n      defmacro squared(x) do\n        quote bind_quoted: [x: x] do\n          x * x\n        end\n      end\n    end\n\n`:bind_quoted` will translate to the same code as the example above.\n`:bind_quoted` can be used in many cases and is seen as good practice,\nnot only because it helps prevent us from running into common mistakes, but also\nbecause it allows us to leverage other tools exposed by macros, such as\nunquote fragments discussed in some sections below.\n\nBefore we finish this brief introduction, you will notice that, even though\nwe defined a variable `x` inside our quote:\n\n    quote do\n      x = unquote(x)\n      x * x\n    end\n\nWhen we call:\n\n    import Math\n    squared(5)\n    x\n    ** (CompileError) undefined variable \"x\"\n\nWe can see that `x` did not leak to the user context. This happens\nbecause Elixir macros are hygienic, a topic we will discuss at length\nin the next sections as well.\n\n## Hygiene in variables\n\nConsider the following example:\n\n    defmodule Hygiene do\n      defmacro no_interference do\n        quote do\n          a = 1\n        end\n      end\n    end\n\n    require Hygiene\n\n    a = 10\n    Hygiene.no_interference()\n    a\n    #=> 10\n\nIn the example above, `a` returns 10 even if the macro\nis apparently setting it to 1 because variables defined\nin the macro do not affect the context the macro is executed in.\nIf you want to set or get a variable in the caller's context, you\ncan do it with the help of the `var!` macro:\n\n    defmodule NoHygiene do\n      defmacro interference do\n        quote do\n          var!(a) = 1\n        end\n      end\n    end\n\n    require NoHygiene\n\n    a = 10\n    NoHygiene.interference()\n    a\n    #=> 1\n\nYou cannot even access variables defined in the same module unless\nyou explicitly give it a context:\n\n    defmodule Hygiene do\n      defmacro write do\n        quote do\n          a = 1\n        end\n      end\n\n      defmacro read do\n        quote do\n          a\n        end\n      end\n    end\n\n    Hygiene.write()\n    Hygiene.read()\n    ** (RuntimeError) undefined variable a or undefined function a/0\n\nFor such, you can explicitly pass the current module scope as\nargument:\n\n    defmodule ContextHygiene do\n      defmacro write do\n        quote do\n          var!(a, ContextHygiene) = 1\n        end\n      end\n\n      defmacro read do\n        quote do\n          var!(a, ContextHygiene)\n        end\n      end\n    end\n\n    ContextHygiene.write()\n    ContextHygiene.read()\n    #=> 1\n\nThe contexts of a variable is identified by the third element of the tuple.\nThe default context is `nil` and `quote` assigns another context to all\nvariables within:\n\n    quote(do: var)\n    #=> {:var, [], Elixir}\n\nIn case of variables returned by macros, there may also be a `:counter` key\nin the metadata, which is used to further refine its contexts and guarantee\nisolation between macro invocations as seen in the previous example.\n\n## Hygiene in aliases\n\nAliases inside quote are hygienic by default.\nConsider the following example:\n\n    defmodule Hygiene do\n      alias Map, as: M\n\n      defmacro no_interference do\n        quote do\n          M.new()\n        end\n      end\n    end\n\n    require Hygiene\n    Hygiene.no_interference()\n    #=> %{}\n\nNote that, even though the alias `M` is not available\nin the context the macro is expanded, the code above works\nbecause `M` still expands to `Map`.\n\nSimilarly, even if we defined an alias with the same name\nbefore invoking a macro, it won't affect the macro's result:\n\n    defmodule Hygiene do\n      alias Map, as: M\n\n      defmacro no_interference do\n        quote do\n          M.new()\n        end\n      end\n    end\n\n    require Hygiene\n    alias SomethingElse, as: M\n    Hygiene.no_interference()\n    #=> %{}\n\nIn some cases, you want to access an alias or a module defined\nin the caller. For such, you can use the `alias!` macro:\n\n    defmodule Hygiene do\n      # This will expand to Elixir.Nested.hello()\n      defmacro no_interference do\n        quote do\n          Nested.hello()\n        end\n      end\n\n      # This will expand to Nested.hello() for\n      # whatever is Nested in the caller\n      defmacro interference do\n        quote do\n          alias!(Nested).hello()\n        end\n      end\n    end\n\n    defmodule Parent do\n      defmodule Nested do\n        def hello, do: \"world\"\n      end\n\n      require Hygiene\n      Hygiene.no_interference()\n      ** (UndefinedFunctionError) ...\n\n      Hygiene.interference()\n      #=> \"world\"\n    end\n\n## Hygiene in imports\n\nSimilar to aliases, imports in Elixir are hygienic. Consider the\nfollowing code:\n\n    defmodule Hygiene do\n      defmacrop get_length do\n        quote do\n          length([1, 2, 3])\n        end\n      end\n\n      def return_length do\n        import Kernel, except: [length: 1]\n        get_length\n      end\n    end\n\n    Hygiene.return_length()\n    #=> 3\n\nNotice how `Hygiene.return_length/0` returns `3` even though the `Kernel.length/1`\nfunction is not imported. In fact, even if `return_length/0`\nimported a function with the same name and arity from another\nmodule, it wouldn't affect the function result:\n\n    def return_length do\n      import String, only: [length: 1]\n      get_length\n    end\n\nCalling this new `return_length/0` will still return `3` as result.\n\nElixir is smart enough to delay the resolution to the latest\npossible moment. So, if you call `length([1, 2, 3])` inside quote,\nbut no `length/1` function is available, it is then expanded in\nthe caller:\n\n    defmodule Lazy do\n      defmacrop get_length do\n        import Kernel, except: [length: 1]\n\n        quote do\n          length(\"hello\")\n        end\n      end\n\n      def return_length do\n        import Kernel, except: [length: 1]\n        import String, only: [length: 1]\n        get_length\n      end\n    end\n\n    Lazy.return_length()\n    #=> 5\n\n## Stacktrace information\n\nWhen defining functions via macros, developers have the option of\nchoosing if runtime errors will be reported from the caller or from\ninside the quote. Let's see an example:\n\n    # adder.ex\n    defmodule Adder do\n      @doc \"Defines a function that adds two numbers\"\n      defmacro defadd do\n        quote location: :keep do\n          def add(a, b), do: a + b\n        end\n      end\n    end\n\n    # sample.ex\n    defmodule Sample do\n      import Adder\n      defadd\n    end\n\n    require Sample\n    Sample.add(:one, :two)\n    ** (ArithmeticError) bad argument in arithmetic expression\n        adder.ex:5: Sample.add/2\n\nWhen using `location: :keep` and invalid arguments are given to\n`Sample.add/2`, the stacktrace information will point to the file\nand line inside the quote. Without `location: :keep`, the error is\nreported to where `defadd` was invoked. `location: :keep` affects\nonly definitions inside the quote.\n\n> #### `location: :keep` and unquote {: .warning}\n>\n> Do not use `location: :keep` if the function definition\n> also `unquote`s some of the macro arguments. If you do so, Elixir\n> will store the file definition of the current location but the\n> unquoted arguments may contain line information of the macro caller,\n> leading to erroneous stacktraces.\n\n## Binding and unquote fragments\n\nElixir quote/unquote mechanisms provide a functionality called\nunquote fragments. Unquote fragments provide an easy way to generate\nfunctions on the fly. Consider this example:\n\n    kv = [foo: 1, bar: 2]\n    Enum.each(kv, fn {k, v} ->\n      def unquote(k)(), do: unquote(v)\n    end)\n\nIn the example above, we have generated the functions `foo/0` and\n`bar/0` dynamically. Now, imagine that we want to convert this\nfunctionality into a macro:\n\n    defmacro defkv(kv) do\n      Enum.map(kv, fn {k, v} ->\n        quote do\n          def unquote(k)(), do: unquote(v)\n        end\n      end)\n    end\n\nWe can invoke this macro as:\n\n    defkv [foo: 1, bar: 2]\n\nHowever, we can't invoke it as follows:\n\n    kv = [foo: 1, bar: 2]\n    defkv kv\n\nThis is because the macro is expecting its arguments to be a\nkeyword list at **compilation** time. Since in the example above\nwe are passing the representation of the variable `kv`, our\ncode fails.\n\nThis is actually a common pitfall when developing macros. We are\nassuming a particular shape in the macro. We can work around it\nby unquoting the variable inside the quoted expression:\n\n    defmacro defkv(kv) do\n      quote do\n        Enum.each(unquote(kv), fn {k, v} ->\n          def unquote(k)(), do: unquote(v)\n        end)\n      end\n    end\n\nIf you try to run our new macro, you will notice it won't\neven compile, complaining that the variables `k` and `v`\ndo not exist. This is because of the ambiguity: `unquote(k)`\ncan either be an unquote fragment, as previously, or a regular\nunquote as in `unquote(kv)`.\n\nOne solution to this problem is to disable unquoting in the\nmacro, however, doing that would make it impossible to inject the\n`kv` representation into the tree. That's when the `:bind_quoted`\noption comes to the rescue (again!). By using `:bind_quoted`, we\ncan automatically disable unquoting while still injecting the\ndesired variables into the tree:\n\n    defmacro defkv(kv) do\n      quote bind_quoted: [kv: kv] do\n        Enum.each(kv, fn {k, v} ->\n          def unquote(k)(), do: unquote(v)\n        end)\n      end\n    end\n\nIn fact, the `:bind_quoted` option is recommended every time\none desires to inject a value into the quote.\n","title":"Kernel.SpecialForms.quote/2","type":"macro"},{"doc":"Checks if there is a message matching the given clauses in the current process mailbox. In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value. Examples receive do { :selector , number , name } when is_integer ( number ) -&gt; name name when is_atom ( name ) -&gt; name _ -&gt; IO . puts ( :stderr , &quot;Unexpected message received&quot; ) end An optional after clause can be given in case the message was not received after the given timeout period, specified in milliseconds: receive do { :selector , number , name } when is_integer ( number ) -&gt; name name when is_atom ( name ) -&gt; name _ -&gt; IO . puts ( :stderr , &quot;Unexpected message received&quot; ) after 5000 -&gt; IO . puts ( :stderr , &quot;No message in 5 seconds&quot; ) end The after clause can be specified even if there are no match clauses. The timeout value given to after can be any expression evaluating to one of the allowed values: :infinity - the process should wait indefinitely for a matching message, this is the same as not using the after clause 0 - if there is no matching message in the mailbox, the timeout will occur immediately positive integer smaller than or equal to 4_294_967_295 ( 0xFFFFFFFF in hexadecimal notation) - it should be possible to represent the timeout value as an unsigned 32-bit integer. Variable handling The receive/1 special form handles variables exactly as the case/2 special macro. For more information, check the docs for case/2 .","ref":"Kernel.SpecialForms.html#receive/1","source_doc":"Checks if there is a message matching the given clauses\nin the current process mailbox.\n\nIn case there is no such message, the current process hangs\nuntil a message arrives or waits until a given timeout value.\n\n## Examples\n\n    receive do\n      {:selector, number, name} when is_integer(number) ->\n        name\n      name when is_atom(name) ->\n        name\n      _ ->\n        IO.puts(:stderr, \"Unexpected message received\")\n    end\n\nAn optional `after` clause can be given in case the message was not\nreceived after the given timeout period, specified in milliseconds:\n\n    receive do\n      {:selector, number, name} when is_integer(number) ->\n        name\n      name when is_atom(name) ->\n        name\n      _ ->\n        IO.puts(:stderr, \"Unexpected message received\")\n    after\n      5000 ->\n        IO.puts(:stderr, \"No message in 5 seconds\")\n    end\n\nThe `after` clause can be specified even if there are no match clauses.\nThe timeout value given to `after` can be any expression evaluating to\none of the allowed values:\n\n  * `:infinity` - the process should wait indefinitely for a matching\n    message, this is the same as not using the after clause\n\n  * `0` - if there is no matching message in the mailbox, the timeout\n    will occur immediately\n\n  * positive integer smaller than or equal to `4_294_967_295` (`0xFFFFFFFF`\n    in hexadecimal notation) - it should be possible to represent the timeout\n    value as an unsigned 32-bit integer.\n\n## Variable handling\n\nThe `receive/1` special form handles variables exactly as the `case/2`\nspecial macro. For more information, check the docs for `case/2`.\n","title":"Kernel.SpecialForms.receive/1","type":"macro"},{"doc":"Requires a module in order to use its macros. Examples Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in. Let's suppose you created your own if/2 implementation in the module MyMacros . If you want to invoke it, you need to first explicitly require the MyMacros : defmodule Math do require MyMacros MyMacros . if do_something , it_works end An attempt to call a macro that was not loaded will raise an error. Alias shortcut require/2 also accepts :as as an option so it automatically sets up an alias. Please check alias/2 for more information.","ref":"Kernel.SpecialForms.html#require/2","source_doc":"Requires a module in order to use its macros.\n\n## Examples\n\nPublic functions in modules are globally available, but in order to use\nmacros, you need to opt-in by requiring the module they are defined in.\n\nLet's suppose you created your own `if/2` implementation in the module\n`MyMacros`. If you want to invoke it, you need to first explicitly\nrequire the `MyMacros`:\n\n    defmodule Math do\n      require MyMacros\n      MyMacros.if do_something, it_works\n    end\n\nAn attempt to call a macro that was not loaded will raise an error.\n\n## Alias shortcut\n\n`require/2` also accepts `:as` as an option so it automatically sets\nup an alias. Please check `alias/2` for more information.\n\n","title":"Kernel.SpecialForms.require/2","type":"macro"},{"doc":"Calls the overridden function when overriding it with Kernel.defoverridable/1 . See Kernel.defoverridable/1 for more information and documentation.","ref":"Kernel.SpecialForms.html#super/1","source_doc":"Calls the overridden function when overriding it with `Kernel.defoverridable/1`.\n\nSee `Kernel.defoverridable/1` for more information and documentation.\n","title":"Kernel.SpecialForms.super/1","type":"macro"},{"doc":"Evaluates the given expressions and handles any error, exit, or throw that may have happened. Examples try do do_something_that_may_fail ( some_arg ) rescue ArgumentError -&gt; IO . puts ( &quot;Invalid argument given&quot; ) catch value -&gt; IO . puts ( &quot;Caught \#{ inspect ( value ) } &quot; ) else value -&gt; IO . puts ( &quot;Success! The result was \#{ inspect ( value ) } &quot; ) after IO . puts ( &quot;This is printed regardless if it failed or succeeded&quot; ) end The rescue clause is used to handle exceptions while the catch clause can be used to catch thrown values and exits. The else clause can be used to control flow based on the result of the expression. catch , rescue , and else clauses work based on pattern matching (similar to the case special form). Calls inside try/1 are not tail recursive since the VM needs to keep the stacktrace in case an exception happens. To retrieve the stacktrace, access __STACKTRACE__/0 inside the rescue or catch clause. rescue clauses Besides relying on pattern matching, rescue clauses provide some conveniences around exceptions that allow one to rescue an exception by its name. All the following formats are valid patterns in rescue clauses: # Rescue a single exception without binding the exception # to a variable try do UndefinedModule . undefined_function rescue UndefinedFunctionError -&gt; nil end # Rescue any of the given exception without binding try do UndefinedModule . undefined_function rescue [ UndefinedFunctionError , ArgumentError ] -&gt; nil end # Rescue and bind the exception to the variable &quot;x&quot; try do UndefinedModule . undefined_function rescue x in [ UndefinedFunctionError ] -&gt; nil end # Rescue all kinds of exceptions and bind the rescued exception # to the variable &quot;x&quot; try do UndefinedModule . undefined_function rescue x -&gt; nil end Erlang errors Erlang errors are transformed into Elixir ones when rescuing: try do :erlang . error ( :badarg ) rescue ArgumentError -&gt; :ok end #=&gt; :ok The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic ErlangError : try do :erlang . error ( :unknown ) rescue ErlangError -&gt; :ok end #=&gt; :ok In fact, ErlangError can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier :badarg error too, prior to transformation: try do :erlang . error ( :badarg ) rescue ErlangError -&gt; :ok end #=&gt; :ok catch clauses The catch clause can be used to catch thrown values, exits, and errors. Catching thrown values catch can be used to catch values thrown by Kernel.throw/1 : try do throw ( :some_value ) catch thrown_value -&gt; IO . puts ( &quot;A value was thrown: \#{ inspect ( thrown_value ) } &quot; ) end Catching values of any kind The catch clause also supports catching exits and errors. To do that, it allows matching on both the kind of the caught value as well as the value itself: try do exit ( :shutdown ) catch :exit , value -&gt; IO . puts ( &quot;Exited with value \#{ inspect ( value ) } &quot; ) end try do exit ( :shutdown ) catch kind , value when kind in [ :exit , :throw ] -&gt; IO . puts ( &quot;Caught exit or throw with value \#{ inspect ( value ) } &quot; ) end The catch clause also supports :error alongside :exit and :throw as in Erlang, although this is commonly avoided in favor of raise / rescue control mechanisms. One reason for this is that when catching :error , the error is not automatically transformed into an Elixir error: try do :erlang . error ( :badarg ) catch :error , :badarg -&gt; :ok end #=&gt; :ok after clauses An after clause allows you to define cleanup logic that will be invoked both when the block of code passed to try/1 succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the after clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits. File . write! ( &quot;tmp/story.txt&quot; , &quot;Hello, World&quot; ) try do do_something_with ( &quot;tmp/story.txt&quot; ) after File . rm ( &quot;tmp/story.txt&quot; ) end Although after clauses are invoked whether or not there was an error, they do not modify the return value. All of the following examples return :return_me : try do :return_me after IO . puts ( &quot;I will be printed&quot; ) :not_returned end try do raise &quot;boom&quot; rescue _ -&gt; :return_me after IO . puts ( &quot;I will be printed&quot; ) :not_returned end else clauses else clauses allow the result of the body passed to try/1 to be pattern matched on: x = 2 try do 1 / x rescue ArithmeticError -&gt; :infinity else y when y &lt; 1 and y &gt; - 1 -&gt; :small _ -&gt; :large end If an else clause is not present and no exceptions are raised, the result of the expression will be returned: x = 1 ^ x = try do 1 / x rescue ArithmeticError -&gt; :infinity end However, when an else clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a catch or rescue in the same try : x = 1 try do try do 1 / x rescue # The TryClauseError cannot be rescued here: TryClauseError -&gt; :error_a else 0 -&gt; :small end rescue # The TryClauseError is rescued here: TryClauseError -&gt; :error_b end Similarly, an exception inside an else clause is not caught or rescued inside the same try : try do try do nil catch # The exit(1) call below can not be caught here: :exit , _ -&gt; :exit_a else _ -&gt; exit ( 1 ) end catch # The exit is caught here: :exit , _ -&gt; :exit_b end This means the VM no longer needs to keep the stacktrace once inside an else clause and so tail recursion is possible when using a try with a tail call as the final call inside an else clause. The same is true for rescue and catch clauses. Only the result of the tried expression falls down to the else clause. If the try ends up in the rescue or catch clauses, their result will not fall down to else : try do throw ( :catch_this ) catch :throw , :catch_this -&gt; :it_was_caught else # :it_was_caught will not fall down to this &quot;else&quot; clause. other -&gt; { :else , other } end Variable handling Since an expression inside try may not have been evaluated due to an exception, any variable created inside try cannot be accessed externally. For instance: try do x = 1 do_something_that_may_fail ( same_arg ) :ok catch _ , _ -&gt; :failed end x #=&gt; unbound variable &quot;x&quot; In the example above, x cannot be accessed since it was defined inside the try clause. A common practice to address this issue is to return the variables defined inside try : x = try do x = 1 do_something_that_may_fail ( same_arg ) x catch _ , _ -&gt; :failed end","ref":"Kernel.SpecialForms.html#try/1","source_doc":"Evaluates the given expressions and handles any error, exit,\nor throw that may have happened.\n\n## Examples\n\n    try do\n      do_something_that_may_fail(some_arg)\n    rescue\n      ArgumentError ->\n        IO.puts(\"Invalid argument given\")\n    catch\n      value ->\n        IO.puts(\"Caught \#{inspect(value)}\")\n    else\n      value ->\n        IO.puts(\"Success! The result was \#{inspect(value)}\")\n    after\n      IO.puts(\"This is printed regardless if it failed or succeeded\")\n    end\n\nThe `rescue` clause is used to handle exceptions while the `catch`\nclause can be used to catch thrown values and exits.\nThe `else` clause can be used to control flow based on the result of\nthe expression. `catch`, `rescue`, and `else` clauses work based on\npattern matching (similar to the `case` special form).\n\nCalls inside `try/1` are not tail recursive since the VM needs to keep\nthe stacktrace in case an exception happens. To retrieve the stacktrace,\naccess `__STACKTRACE__/0` inside the `rescue` or `catch` clause.\n\n## `rescue` clauses\n\nBesides relying on pattern matching, `rescue` clauses provide some\nconveniences around exceptions that allow one to rescue an\nexception by its name. All the following formats are valid patterns\nin `rescue` clauses:\n\n    # Rescue a single exception without binding the exception\n    # to a variable\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      UndefinedFunctionError -> nil\n    end\n\n    # Rescue any of the given exception without binding\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      [UndefinedFunctionError, ArgumentError] -> nil\n    end\n\n    # Rescue and bind the exception to the variable \"x\"\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      x in [UndefinedFunctionError] -> nil\n    end\n\n    # Rescue all kinds of exceptions and bind the rescued exception\n    # to the variable \"x\"\n    try do\n      UndefinedModule.undefined_function\n    rescue\n      x -> nil\n    end\n\n### Erlang errors\n\nErlang errors are transformed into Elixir ones when rescuing:\n\n    try do\n      :erlang.error(:badarg)\n    rescue\n      ArgumentError -> :ok\n    end\n    #=> :ok\n\nThe most common Erlang errors will be transformed into their\nElixir counterpart. Those which are not will be transformed\ninto the more generic `ErlangError`:\n\n    try do\n      :erlang.error(:unknown)\n    rescue\n      ErlangError -> :ok\n    end\n    #=> :ok\n\nIn fact, `ErlangError` can be used to rescue any error that is\nnot a proper Elixir error. For example, it can be used to rescue\nthe earlier `:badarg` error too, prior to transformation:\n\n    try do\n      :erlang.error(:badarg)\n    rescue\n      ErlangError -> :ok\n    end\n    #=> :ok\n\n## `catch` clauses\n\nThe `catch` clause can be used to catch thrown values, exits, and errors.\n\n### Catching thrown values\n\n`catch` can be used to catch values thrown by `Kernel.throw/1`:\n\n    try do\n      throw(:some_value)\n    catch\n      thrown_value ->\n        IO.puts(\"A value was thrown: \#{inspect(thrown_value)}\")\n    end\n\n### Catching values of any kind\n\nThe `catch` clause also supports catching exits and errors. To do that, it\nallows matching on both the *kind* of the caught value as well as the value\nitself:\n\n    try do\n      exit(:shutdown)\n    catch\n      :exit, value ->\n        IO.puts(\"Exited with value \#{inspect(value)}\")\n    end\n\n    try do\n      exit(:shutdown)\n    catch\n      kind, value when kind in [:exit, :throw] ->\n        IO.puts(\"Caught exit or throw with value \#{inspect(value)}\")\n    end\n\nThe `catch` clause also supports `:error` alongside `:exit` and `:throw` as\nin Erlang, although this is commonly avoided in favor of `raise`/`rescue` control\nmechanisms. One reason for this is that when catching `:error`, the error is\nnot automatically transformed into an Elixir error:\n\n    try do\n      :erlang.error(:badarg)\n    catch\n      :error, :badarg -> :ok\n    end\n    #=> :ok\n\n## `after` clauses\n\nAn `after` clause allows you to define cleanup logic that will be invoked both\nwhen the block of code passed to `try/1` succeeds and also when an error is raised. Note\nthat the process will exit as usual when receiving an exit signal that causes\nit to exit abruptly and so the `after` clause is not guaranteed to be executed.\nLuckily, most resources in Elixir (such as open files, ETS tables, ports, sockets,\nand so on) are linked to or monitor the owning process and will automatically clean\nthemselves up if that process exits.\n\n    File.write!(\"tmp/story.txt\", \"Hello, World\")\n    try do\n      do_something_with(\"tmp/story.txt\")\n    after\n      File.rm(\"tmp/story.txt\")\n    end\n\nAlthough `after` clauses are invoked whether or not there was an error, they do not\nmodify the return value. All of the following examples return `:return_me`:\n\n    try do\n      :return_me\n    after\n      IO.puts(\"I will be printed\")\n      :not_returned\n    end\n\n    try do\n      raise \"boom\"\n    rescue\n      _ -> :return_me\n    after\n      IO.puts(\"I will be printed\")\n      :not_returned\n    end\n\n## `else` clauses\n\n`else` clauses allow the result of the body passed to `try/1` to be pattern\nmatched on:\n\n    x = 2\n    try do\n      1 / x\n    rescue\n      ArithmeticError ->\n        :infinity\n    else\n      y when y < 1 and y > -1 ->\n        :small\n      _ ->\n        :large\n    end\n\nIf an `else` clause is not present and no exceptions are raised,\nthe result of the expression will be returned:\n\n    x = 1\n    ^x =\n      try do\n        1 / x\n      rescue\n        ArithmeticError ->\n          :infinity\n      end\n\nHowever, when an `else` clause is present but the result of the expression\ndoes not match any of the patterns then an exception will be raised. This\nexception will not be caught by a `catch` or `rescue` in the same `try`:\n\n    x = 1\n    try do\n      try do\n        1 / x\n      rescue\n        # The TryClauseError cannot be rescued here:\n        TryClauseError ->\n          :error_a\n      else\n        0 ->\n          :small\n      end\n    rescue\n      # The TryClauseError is rescued here:\n      TryClauseError ->\n        :error_b\n    end\n\nSimilarly, an exception inside an `else` clause is not caught or rescued\ninside the same `try`:\n\n    try do\n      try do\n        nil\n      catch\n        # The exit(1) call below can not be caught here:\n        :exit, _ ->\n          :exit_a\n      else\n        _ ->\n          exit(1)\n      end\n    catch\n      # The exit is caught here:\n      :exit, _ ->\n        :exit_b\n    end\n\nThis means the VM no longer needs to keep the stacktrace once inside\nan `else` clause and so tail recursion is possible when using a `try`\nwith a tail call as the final call inside an `else` clause. The same\nis true for `rescue` and `catch` clauses.\n\nOnly the result of the tried expression falls down to the `else` clause.\nIf the `try` ends up in the `rescue` or `catch` clauses, their result\nwill not fall down to `else`:\n\n    try do\n      throw(:catch_this)\n    catch\n      :throw, :catch_this ->\n        :it_was_caught\n    else\n      # :it_was_caught will not fall down to this \"else\" clause.\n      other ->\n        {:else, other}\n    end\n\n## Variable handling\n\nSince an expression inside `try` may not have been evaluated\ndue to an exception, any variable created inside `try` cannot\nbe accessed externally. For instance:\n\n    try do\n      x = 1\n      do_something_that_may_fail(same_arg)\n      :ok\n    catch\n      _, _ -> :failed\n    end\n\n    x\n    #=> unbound variable \"x\"\n\nIn the example above, `x` cannot be accessed since it was defined\ninside the `try` clause. A common practice to address this issue\nis to return the variables defined inside `try`:\n\n    x =\n      try do\n        x = 1\n        do_something_that_may_fail(same_arg)\n        x\n      catch\n        _, _ -> :failed\n      end\n\n","title":"Kernel.SpecialForms.try/1","type":"macro"},{"doc":"Unquotes the given expression inside a quoted expression. This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to unquote any value, such as a map or a four-element tuple, you should call Macro.escape/1 before unquoting. Examples Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be: value = quote do 13 end quote do sum ( 1 , value , 3 ) end Which the argument for the :sum function call is not the expected result: { :sum , [ ] , [ 1 , { :value , [ ] , Elixir } , 3 ] } For this, we use unquote : iex&gt; value = ...&gt; quote do ...&gt; 13 ...&gt; end iex&gt; quote do ...&gt; sum ( 1 , unquote ( value ) , 3 ) ...&gt; end { :sum , [ ] , [ 1 , 13 , 3 ] } If you want to unquote a value that is not a quoted expression, such as a map, you need to call Macro.escape/1 before: iex&gt; value = %{ foo : :bar } iex&gt; quote do ...&gt; process_map ( unquote ( Macro . escape ( value ) ) ) ...&gt; end { :process_map , [ ] , [ { :%{} , [ ] , [ foo : :bar ] } ] } If you forget to escape it, Elixir will raise an error when compiling the code.","ref":"Kernel.SpecialForms.html#unquote/1","source_doc":"Unquotes the given expression inside a quoted expression.\n\nThis function expects a valid Elixir AST, also known as\nquoted expression, as argument. If you would like to `unquote`\nany value, such as a map or a four-element tuple, you should\ncall `Macro.escape/1` before unquoting.\n\n## Examples\n\nImagine the situation you have a quoted expression and\nyou want to inject it inside some quote. The first attempt\nwould be:\n\n    value =\n      quote do\n        13\n      end\n\n    quote do\n      sum(1, value, 3)\n    end\n\n\nWhich the argument for the `:sum` function call is not the\nexpected result:\n\n    {:sum, [], [1, {:value, [], Elixir}, 3]}\n\nFor this, we use `unquote`:\n\n    iex> value =\n    ...>   quote do\n    ...>     13\n    ...>   end\n    iex> quote do\n    ...>   sum(1, unquote(value), 3)\n    ...> end\n    {:sum, [], [1, 13, 3]}\n\nIf you want to unquote a value that is not a quoted expression,\nsuch as a map, you need to call `Macro.escape/1` before:\n\n    iex> value = %{foo: :bar}\n    iex> quote do\n    ...>   process_map(unquote(Macro.escape(value)))\n    ...> end\n    {:process_map, [], [{:%{}, [], [foo: :bar]}]}\n\nIf you forget to escape it, Elixir will raise an error\nwhen compiling the code.\n","title":"Kernel.SpecialForms.unquote/1","type":"macro"},{"doc":"Unquotes the given list expanding its arguments. Similar to unquote/1 . Examples iex&gt; values = [ 2 , 3 , 4 ] iex&gt; quote do ...&gt; sum ( 1 , unquote_splicing ( values ) , 5 ) ...&gt; end { :sum , [ ] , [ 1 , 2 , 3 , 4 , 5 ] }","ref":"Kernel.SpecialForms.html#unquote_splicing/1","source_doc":"Unquotes the given list expanding its arguments.\n\nSimilar to `unquote/1`.\n\n## Examples\n\n    iex> values = [2, 3, 4]\n    iex> quote do\n    ...>   sum(1, unquote_splicing(values), 5)\n    ...> end\n    {:sum, [], [1, 2, 3, 4, 5]}\n\n","title":"Kernel.SpecialForms.unquote_splicing/1","type":"macro"},{"doc":"Combine matching clauses. One of the ways to understand with is to show which code patterns it improves. Imagine you have a map where the fields width and height are optional and you want to compute its area, as {:ok, area} or return :error . We could implement this function as: def area ( map ) do case Map . fetch ( opts , :width ) do { :ok , width } -&gt; case Map . fetch ( opts , :height ) do { :ok , height } -&gt; { :ok , width * height } :error -&gt; :error end :error -&gt; :error end end when called as area(%{width: 10, height: 15}) , it should return {:ok, 150} . If any of the fields are missing, it returns :error . While the code above works, it is quite verbose. Using with , we could rewrite it as: def area ( map ) do with { :ok , width } &lt;- Map . fetch ( opts , :width ) , { :ok , height } &lt;- Map . fetch ( opts , :height ) do { :ok , width * height } end end Instead of defining nested case s with clauses, we use with alongside the PATTERN &lt;- EXPRESSION operator to match expressions on its right side against the pattern on the left. Consider &lt;- as a sibling to = , except that, while = raises in case of not matches, &lt;- will simply abort the with chain and return the non-matched value. Let's give it a try on IEx: iex&gt; opts = %{ width : 10 , height : 15 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , width * height } ...&gt; end { :ok , 150 } If all clauses match, the do block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned: iex&gt; opts = %{ width : 10 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , width * height } ...&gt; end :error Guards can be used in patterns as well: iex&gt; users = %{ &quot;melany&quot; =&gt; &quot;guest&quot; , &quot;bob&quot; =&gt; :admin } iex&gt; with { :ok , role } when not is_binary ( role ) &lt;- Map . fetch ( users , &quot;bob&quot; ) do ...&gt; { :ok , to_string ( role ) } ...&gt; end { :ok , &quot;admin&quot; } As in for/1 , variables bound inside with/1 won't be accessible outside of with/1 . Expressions without &lt;- may also be used in clauses. For instance, you can perform regular matches with the = operator: iex&gt; width = nil iex&gt; opts = %{ width : 10 , height : 15 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; double_width = width * 2 , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , double_width * height } ...&gt; end { :ok , 300 } iex&gt; width nil The behaviour of any expression in a clause is the same as if it was written outside of with . For example, = will raise a MatchError instead of returning the non-matched value: with :foo = :bar , do : :ok ** (MatchError) no match of right hand side value: :bar As with any other function or macro call in Elixir, explicit parens can also be used around the arguments before the do - end block: iex&gt; opts = %{ width : 10 , height : 15 } iex&gt; with ( ...&gt; { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) ...&gt; ) do ...&gt; { :ok , width * height } ...&gt; end { :ok , 150 } The choice between parens and no parens is a matter of preference. Else clauses An else option can be given to modify what is being returned from with in the case of a failed match: iex&gt; opts = %{ width : 10 } iex&gt; with { :ok , width } &lt;- Map . fetch ( opts , :width ) , ...&gt; { :ok , height } &lt;- Map . fetch ( opts , :height ) do ...&gt; { :ok , width * height } ...&gt; else ...&gt; :error -&gt; ...&gt; { :error , :wrong_data } ...&gt; ...&gt; _other_error -&gt; ...&gt; :unexpected_error ...&gt; end { :error , :wrong_data } The else block works like a case clause: it can have multiple clauses, and the first match will be used. Variables bound inside with (such as width in this example) are not available in the else block. If an else block is used and there are no matching clauses, a WithClauseError exception is raised. Beware! Keep in mind that, one of potential drawback of with is that all failure clauses are flattened into a single else block. For example, take this code that checks if a given path points to an Elixir file and that it exists before creating a backup copy: with &quot;.ex&quot; &lt;- Path . extname ( path ) , true &lt;- File . exists? ( path ) do backup_path = path &lt;&gt; &quot;.backup&quot; File . cp! ( path , backup_path ) { :ok , backup_path } else binary when is_binary ( binary ) -&gt; { :error , :invalid_extension } false -&gt; { :error , :missing_file } end Note how we are having to reconstruct the result types of Path.extname/1 and File.exists?/1 to build error messages. In this case, it is better to refactor the code so each &lt;- already return the desired format in case of errors, like this: with :ok &lt;- validate_extension ( path ) , :ok &lt;- validate_exists ( path ) do backup_path = path &lt;&gt; &quot;.backup&quot; File . cp! ( path , backup_path ) { :ok , backup_path } end defp validate_extension ( path ) do if Path . extname ( path ) == &quot;.ex&quot; , do : :ok , else : { :error , :invalid_extension } end defp validate_exists ( path ) do if File . exists? ( path ) , do : :ok , else : { :error , :missing_file } end Note how the code above is better organized and clearer once we make sure each &lt;- in with returns a normalized format.","ref":"Kernel.SpecialForms.html#with/1","source_doc":"Combine matching clauses.\n\nOne of the ways to understand with is to show which code\npatterns it improves. Imagine you have a map where the fields\n`width` and `height` are optional and you want to compute its\narea, as `{:ok, area}` or return `:error`. We could implement\nthis function as:\n\n    def area(map) do\n      case Map.fetch(opts, :width) do\n        {:ok, width} ->\n          case Map.fetch(opts, :height) do\n            {:ok, height} -> {:ok, width * height}\n            :error -> :error\n          end\n\n        :error ->\n          :error\n      end\n    end\n\nwhen called as `area(%{width: 10, height: 15})`, it should return\n`{:ok, 150}`. If any of the fields are missing, it returns `:error`.\n\nWhile the code above works, it is quite verbose. Using `with`,\nwe could rewrite it as:\n\n    def area(map) do\n      with {:ok, width} <- Map.fetch(opts, :width),\n           {:ok, height} <- Map.fetch(opts, :height) do\n        {:ok, width * height}\n      end\n    end\n\nInstead of defining nested `case`s with clauses, we use `with`\nalongside the `PATTERN <- EXPRESSION` operator to match\nexpressions on its right side against the pattern on the left.\nConsider `<-` as a sibling to `=`, except that, while `=` raises\nin case of not matches, `<-` will simply abort the `with` chain\nand return the non-matched value.\n\nLet's give it a try on IEx:\n\n    iex> opts = %{width: 10, height: 15}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> end\n    {:ok, 150}\n\nIf all clauses match, the `do` block is executed, returning its result.\nOtherwise the chain is aborted and the non-matched value is returned:\n\n    iex> opts = %{width: 10}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> end\n    :error\n\nGuards can be used in patterns as well:\n\n    iex> users = %{\"melany\" => \"guest\", \"bob\" => :admin}\n    iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, \"bob\") do\n    ...>   {:ok, to_string(role)}\n    ...> end\n    {:ok, \"admin\"}\n\nAs in `for/1`, variables bound inside `with/1` won't be accessible\noutside of `with/1`.\n\nExpressions without `<-` may also be used in clauses. For instance,\nyou can perform regular matches with the `=` operator:\n\n    iex> width = nil\n    iex> opts = %{width: 10, height: 15}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      double_width = width * 2,\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, double_width * height}\n    ...> end\n    {:ok, 300}\n    iex> width\n    nil\n\nThe behaviour of any expression in a clause is the same as if it was\nwritten outside of `with`. For example, `=` will raise a `MatchError`\ninstead of returning the non-matched value:\n\n    with :foo = :bar, do: :ok\n    ** (MatchError) no match of right hand side value: :bar\n\nAs with any other function or macro call in Elixir, explicit parens can\nalso be used around the arguments before the `do`-`end` block:\n\n    iex> opts = %{width: 10, height: 15}\n    iex> with(\n    ...>   {:ok, width} <- Map.fetch(opts, :width),\n    ...>   {:ok, height} <- Map.fetch(opts, :height)\n    ...> ) do\n    ...>   {:ok, width * height}\n    ...> end\n    {:ok, 150}\n\nThe choice between parens and no parens is a matter of preference.\n\n## Else clauses\n\nAn `else` option can be given to modify what is being returned from\n`with` in the case of a failed match:\n\n    iex> opts = %{width: 10}\n    iex> with {:ok, width} <- Map.fetch(opts, :width),\n    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n    ...>   {:ok, width * height}\n    ...> else\n    ...>   :error ->\n    ...>     {:error, :wrong_data}\n    ...>\n    ...>   _other_error ->\n    ...>     :unexpected_error\n    ...> end\n    {:error, :wrong_data}\n\nThe `else` block works like a `case` clause: it can have multiple clauses,\nand the first match will be used. Variables bound inside `with` (such as\n`width` in this example) are not available in the `else` block.\n\nIf an `else` block is used and there are no matching clauses, a `WithClauseError`\nexception is raised.\n\n### Beware!\n\nKeep in mind that, one of potential drawback of `with` is that all\nfailure clauses are flattened into a single `else` block. For example,\ntake this code that checks if a given path points to an Elixir file\nand that it exists before creating a backup copy:\n\n    with \".ex\" <- Path.extname(path),\n         true <- File.exists?(path) do\n      backup_path = path <> \".backup\"\n      File.cp!(path, backup_path)\n      {:ok, backup_path}\n    else\n      binary when is_binary(binary) ->\n        {:error, :invalid_extension}\n\n      false ->\n        {:error, :missing_file}\n    end\n\nNote how we are having to reconstruct the result types of `Path.extname/1`\nand `File.exists?/1` to build error messages. In this case, it is better\nto refactor the code so each `<-` already return the desired format in case\nof errors, like this:\n\n    with :ok <- validate_extension(path),\n         :ok <- validate_exists(path) do\n      backup_path = path <> \".backup\"\n      File.cp!(path, backup_path)\n      {:ok, backup_path}\n    end\n\n    defp validate_extension(path) do\n      if Path.extname(path) == \".ex\", do: :ok, else: {:error, :invalid_extension}\n    end\n\n    defp validate_exists(path) do\n      if File.exists?(path), do: :ok, else: {:error, :missing_file}\n    end\n\nNote how the code above is better organized and clearer once we\nmake sure each `<-` in `with` returns a normalized format.\n","title":"Kernel.SpecialForms.with/1","type":"macro"},{"doc":"Pin operator. Accesses an already bound variable in match clauses. Examples Elixir allows variables to be rebound via static single assignment: iex&gt; x = 1 iex&gt; x = x + 1 iex&gt; x 2 However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the ^ special form, colloquially known as the pin operator: iex&gt; x = 1 iex&gt; ^ x = List . first ( [ 1 ] ) iex&gt; ^ x = List . first ( [ 2 ] ) ** (MatchError) no match of right hand side value: 2 Note that ^x always refers to the value of x prior to the match. The following example will match: iex&gt; x = 0 iex&gt; { x , ^ x } = { 1 , 0 } iex&gt; x 1","ref":"Kernel.SpecialForms.html#%5E/1","source_doc":"Pin operator. Accesses an already bound variable in match clauses.\n\n## Examples\n\nElixir allows variables to be rebound via static single assignment:\n\n    iex> x = 1\n    iex> x = x + 1\n    iex> x\n    2\n\nHowever, in some situations, it is useful to match against an existing\nvalue, instead of rebinding. This can be done with the `^` special form,\ncolloquially known as the pin operator:\n\n    iex> x = 1\n    iex> ^x = List.first([1])\n    iex> ^x = List.first([2])\n    ** (MatchError) no match of right hand side value: 2\n\nNote that `^x` always refers to the value of `x` prior to the match. The\nfollowing example will match:\n\n    iex> x = 0\n    iex> {x, ^x} = {1, 0}\n    iex> x\n    1\n\n","title":"Kernel.SpecialForms.^/1","type":"macro"},{"doc":"Creates a tuple. More information about the tuple data type and about functions to manipulate tuples can be found in the Tuple module; some functions for working with tuples are also available in Kernel (such as Kernel.elem/2 or Kernel.tuple_size/1 ). AST representation Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the :{} special form. iex&gt; quote do ...&gt; { 1 , 2 } ...&gt; end { 1 , 2 } iex&gt; quote do ...&gt; { 1 , 2 , 3 } ...&gt; end { :{} , [ ] , [ 1 , 2 , 3 ] }","ref":"Kernel.SpecialForms.html#%7B%7D/1","source_doc":"Creates a tuple.\n\nMore information about the tuple data type and about functions to manipulate\ntuples can be found in the `Tuple` module; some functions for working with\ntuples are also available in `Kernel` (such as `Kernel.elem/2` or\n`Kernel.tuple_size/1`).\n\n## AST representation\n\nOnly two-element tuples are considered literals in Elixir and return themselves\nwhen quoted. Therefore, all other tuples are represented in the AST as calls to\nthe `:{}` special form.\n\n    iex> quote do\n    ...>   {1, 2}\n    ...> end\n    {1, 2}\n\n    iex> quote do\n    ...>   {1, 2, 3}\n    ...> end\n    {:{}, [], [1, 2, 3]}\n\n","title":"Kernel.SpecialForms.{}/1","type":"macro"},{"doc":"Atoms are constants whose values are their own name. They are often useful to enumerate over distinct values, such as: iex&gt; :apple :apple iex&gt; :orange :orange iex&gt; :watermelon :watermelon Atoms are equal if their names are equal. iex&gt; :apple == :apple true iex&gt; :apple == :orange false Often they are used to express the state of an operation, by using values such as :ok and :error . The booleans true and false are also atoms: iex&gt; true == :true true iex&gt; is_atom ( false ) true iex&gt; is_boolean ( :false ) true Elixir allows you to skip the leading : for the atoms false , true , and nil . Atoms must be composed of Unicode characters such as letters, numbers, underscore, and @ . If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes: iex&gt; :&quot;this is an atom with spaces&quot; :&quot;this is an atom with spaces&quot;","ref":"Atom.html","source_doc":"Atoms are constants whose values are their own name.\n\nThey are often useful to enumerate over distinct values, such as:\n\n    iex> :apple\n    :apple\n    iex> :orange\n    :orange\n    iex> :watermelon\n    :watermelon\n\nAtoms are equal if their names are equal.\n\n    iex> :apple == :apple\n    true\n    iex> :apple == :orange\n    false\n\nOften they are used to express the state of an operation, by using\nvalues such as `:ok` and `:error`.\n\nThe booleans `true` and `false` are also atoms:\n\n    iex> true == :true\n    true\n    iex> is_atom(false)\n    true\n    iex> is_boolean(:false)\n    true\n\nElixir allows you to skip the leading `:` for the atoms `false`, `true`,\nand `nil`.\n\nAtoms must be composed of Unicode characters such as letters, numbers,\nunderscore, and `@`. If the keyword has a character that does not\nbelong to the category above, such as spaces, you can wrap it in\nquotes:\n\n    iex> :\"this is an atom with spaces\"\n    :\"this is an atom with spaces\"\n\n","title":"Atom","type":"module"},{"doc":"Converts an atom to a charlist. Inlined by the compiler. Examples iex&gt; Atom . to_charlist ( :&quot;An atom&quot; ) &#39;An atom&#39;","ref":"Atom.html#to_charlist/1","source_doc":"Converts an atom to a charlist.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Atom.to_charlist(:\"An atom\")\n    'An atom'\n\n","title":"Atom.to_charlist/1","type":"function"},{"doc":"Converts an atom to a string. Inlined by the compiler. Examples iex&gt; Atom . to_string ( :foo ) &quot;foo&quot;","ref":"Atom.html#to_string/1","source_doc":"Converts an atom to a string.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Atom.to_string(:foo)\n    \"foo\"\n\n","title":"Atom.to_string/1","type":"function"},{"doc":"This module provides data encoding and decoding functions according to RFC 4648 . This document defines the commonly used base 16, base 32, and base 64 encoding schemes. Base 16 alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 0 4 4 8 8 12 C 1 1 5 5 9 9 13 D 2 2 6 6 10 A 14 E 3 3 7 7 11 B 15 F Base 32 alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 9 J 18 S 27 3 1 B 10 K 19 T 28 4 2 C 11 L 20 U 29 5 3 D 12 M 21 V 30 6 4 E 13 N 22 W 31 7 5 F 14 O 23 X 6 G 15 P 24 Y (pad) = 7 H 16 Q 25 Z 8 I 17 R 26 2 Base 32 (extended hex) alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 0 9 9 18 I 27 R 1 1 10 A 19 J 28 S 2 2 11 B 20 K 29 T 3 3 12 C 21 L 30 U 4 4 13 D 22 M 31 V 5 5 14 E 23 N 6 6 15 F 24 O (pad) = 7 7 16 G 25 P 8 8 17 H 26 Q Base 64 alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y Base 64 (URL and filename safe) alphabet Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 - 12 M 29 d 46 u 63 _ 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y","ref":"Base.html","source_doc":"This module provides data encoding and decoding functions\naccording to [RFC 4648](https://tools.ietf.org/html/rfc4648).\n\nThis document defines the commonly used base 16, base 32, and base\n64 encoding schemes.\n\n## Base 16 alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | 0        |     4 | 4        |     8 | 8        |    12 | C        |\n|     1 | 1        |     5 | 5        |     9 | 9        |    13 | D        |\n|     2 | 2        |     6 | 6        |    10 | A        |    14 | E        |\n|     3 | 3        |     7 | 7        |    11 | B        |    15 | F        |\n\n## Base 32 alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A        |     9 | J        |    18 | S        |    27 | 3        |\n|     1 | B        |    10 | K        |    19 | T        |    28 | 4        |\n|     2 | C        |    11 | L        |    20 | U        |    29 | 5        |\n|     3 | D        |    12 | M        |    21 | V        |    30 | 6        |\n|     4 | E        |    13 | N        |    22 | W        |    31 | 7        |\n|     5 | F        |    14 | O        |    23 | X        |       |          |\n|     6 | G        |    15 | P        |    24 | Y        | (pad) | =        |\n|     7 | H        |    16 | Q        |    25 | Z        |       |          |\n|     8 | I        |    17 | R        |    26 | 2        |       |          |\n\n\n## Base 32 (extended hex) alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | 0        |     9 | 9        |    18 | I        |    27 | R        |\n|     1 | 1        |    10 | A        |    19 | J        |    28 | S        |\n|     2 | 2        |    11 | B        |    20 | K        |    29 | T        |\n|     3 | 3        |    12 | C        |    21 | L        |    30 | U        |\n|     4 | 4        |    13 | D        |    22 | M        |    31 | V        |\n|     5 | 5        |    14 | E        |    23 | N        |       |          |\n|     6 | 6        |    15 | F        |    24 | O        | (pad) | =        |\n|     7 | 7        |    16 | G        |    25 | P        |       |          |\n|     8 | 8        |    17 | H        |    26 | Q        |       |          |\n\n## Base 64 alphabet\n\n| Value |  Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:----------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A         |    17 | R        |    34 | i        |    51 | z        |\n|     1 | B         |    18 | S        |    35 | j        |    52 | 0        |\n|     2 | C         |    19 | T        |    36 | k        |    53 | 1        |\n|     3 | D         |    20 | U        |    37 | l        |    54 | 2        |\n|     4 | E         |    21 | V        |    38 | m        |    55 | 3        |\n|     5 | F         |    22 | W        |    39 | n        |    56 | 4        |\n|     6 | G         |    23 | X        |    40 | o        |    57 | 5        |\n|     7 | H         |    24 | Y        |    41 | p        |    58 | 6        |\n|     8 | I         |    25 | Z        |    42 | q        |    59 | 7        |\n|     9 | J         |    26 | a        |    43 | r        |    60 | 8        |\n|    10 | K         |    27 | b        |    44 | s        |    61 | 9        |\n|    11 | L         |    28 | c        |    45 | t        |    62 | +        |\n|    12 | M         |    29 | d        |    46 | u        |    63 | /        |\n|    13 | N         |    30 | e        |    47 | v        |       |          |\n|    14 | O         |    31 | f        |    48 | w        | (pad) | =        |\n|    15 | P         |    32 | g        |    49 | x        |       |          |\n|    16 | Q         |    33 | h        |    50 | y        |       |          |\n\n## Base 64 (URL and filename safe) alphabet\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n|------:|:---------|------:|:---------|------:|:---------|------:|:---------|\n|     0 | A        |    17 | R        |    34 | i        |    51 | z        |\n|     1 | B        |    18 | S        |    35 | j        |    52 | 0        |\n|     2 | C        |    19 | T        |    36 | k        |    53 | 1        |\n|     3 | D        |    20 | U        |    37 | l        |    54 | 2        |\n|     4 | E        |    21 | V        |    38 | m        |    55 | 3        |\n|     5 | F        |    22 | W        |    39 | n        |    56 | 4        |\n|     6 | G        |    23 | X        |    40 | o        |    57 | 5        |\n|     7 | H        |    24 | Y        |    41 | p        |    58 | 6        |\n|     8 | I        |    25 | Z        |    42 | q        |    59 | 7        |\n|     9 | J        |    26 | a        |    43 | r        |    60 | 8        |\n|    10 | K        |    27 | b        |    44 | s        |    61 | 9        |\n|    11 | L        |    28 | c        |    45 | t        |    62 | -        |\n|    12 | M        |    29 | d        |    46 | u        |    63 | _        |\n|    13 | N        |    30 | e        |    47 | v        |       |          |\n|    14 | O        |    31 | f        |    48 | w        | (pad) | =        |\n|    15 | P        |    32 | g        |    49 | x        |       |          |\n|    16 | Q        |    33 | h        |    50 | y        |       |          |\n\n","title":"Base","type":"module"},{"doc":"Decodes a base 16 encoded string into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters Examples iex&gt; Base . decode16 ( &quot;666F6F626172&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode16 ( &quot;666f6f626172&quot; , case : :lower ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode16 ( &quot;666f6F626172&quot; , case : :mixed ) { :ok , &quot;foobar&quot; }","ref":"Base.html#decode16/2","source_doc":"Decodes a base 16 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\n## Examples\n\n    iex> Base.decode16(\"666F6F626172\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6f626172\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n    {:ok, \"foobar\"}\n\n","title":"Base.decode16/2","type":"function"},{"doc":"Decodes a base 16 encoded string into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Examples iex&gt; Base . decode16! ( &quot;666F6F626172&quot; ) &quot;foobar&quot; iex&gt; Base . decode16! ( &quot;666f6f626172&quot; , case : :lower ) &quot;foobar&quot; iex&gt; Base . decode16! ( &quot;666f6F626172&quot; , case : :mixed ) &quot;foobar&quot;","ref":"Base.html#decode16!/2","source_doc":"Decodes a base 16 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.decode16!(\"666F6F626172\")\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n    \"foobar\"\n\n","title":"Base.decode16!/2","type":"function"},{"doc":"Decodes a base 32 encoded string into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . decode32 ( &quot;MZXW6YTBOI======&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode32 ( &quot;mzxw6ytboi======&quot; , case : :lower ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode32 ( &quot;mzXW6ytBOi======&quot; , case : :mixed ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode32 ( &quot;MZXW6YTBOI&quot; , padding : false ) { :ok , &quot;foobar&quot; }","ref":"Base.html#decode32/2","source_doc":"Decodes a base 32 encoded string into a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows  upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.decode32(\"MZXW6YTBOI======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode32(\"MZXW6YTBOI\", padding: false)\n    {:ok, \"foobar\"}\n\n","title":"Base.decode32/2","type":"function"},{"doc":"Decodes a base 32 encoded string into a binary string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . decode32! ( &quot;MZXW6YTBOI======&quot; ) &quot;foobar&quot; iex&gt; Base . decode32! ( &quot;mzxw6ytboi======&quot; , case : :lower ) &quot;foobar&quot; iex&gt; Base . decode32! ( &quot;mzXW6ytBOi======&quot; , case : :mixed ) &quot;foobar&quot; iex&gt; Base . decode32! ( &quot;MZXW6YTBOI&quot; , padding : false ) &quot;foobar&quot;","ref":"Base.html#decode32!/2","source_doc":"Decodes a base 32 encoded string into a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.decode32!(\"MZXW6YTBOI======\")\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.decode32!(\"MZXW6YTBOI\", padding: false)\n    \"foobar\"\n\n","title":"Base.decode32!/2","type":"function"},{"doc":"Decodes a base 64 encoded string into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. Examples iex&gt; Base . decode64 ( &quot;Zm9vYmFy&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode64 ( &quot;Zm9vYmFy \\n &quot; , ignore : :whitespace ) { :ok , &quot;foobar&quot; } iex&gt; Base . decode64 ( &quot;Zm9vYg==&quot; ) { :ok , &quot;foob&quot; } iex&gt; Base . decode64 ( &quot;Zm9vYg&quot; , padding : false ) { :ok , &quot;foob&quot; }","ref":"Base.html#decode64/2","source_doc":"Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\n## Examples\n\n    iex> Base.decode64(\"Zm9vYmFy\")\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    {:ok, \"foobar\"}\n\n    iex> Base.decode64(\"Zm9vYg==\")\n    {:ok, \"foob\"}\n\n    iex> Base.decode64(\"Zm9vYg\", padding: false)\n    {:ok, \"foob\"}\n\n","title":"Base.decode64/2","type":"function"},{"doc":"Decodes a base 64 encoded string into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Examples iex&gt; Base . decode64! ( &quot;Zm9vYmFy&quot; ) &quot;foobar&quot; iex&gt; Base . decode64! ( &quot;Zm9vYmFy \\n &quot; , ignore : :whitespace ) &quot;foobar&quot; iex&gt; Base . decode64! ( &quot;Zm9vYg==&quot; ) &quot;foob&quot; iex&gt; Base . decode64! ( &quot;Zm9vYg&quot; , padding : false ) &quot;foob&quot;","ref":"Base.html#decode64!/2","source_doc":"Decodes a base 64 encoded string into a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.decode64!(\"Zm9vYmFy\")\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYmFy\\n\", ignore: :whitespace)\n    \"foobar\"\n\n    iex> Base.decode64!(\"Zm9vYg==\")\n    \"foob\"\n\n    iex> Base.decode64!(\"Zm9vYg\", padding: false)\n    \"foob\"\n\n","title":"Base.decode64!/2","type":"function"},{"doc":"Encodes a binary string into a base 16 encoded string. Options The accepted options are: :case - specifies the character case to use when encoding The values for :case can be: :upper - uses upper case characters (default) :lower - uses lower case characters Examples iex&gt; Base . encode16 ( &quot;foobar&quot; ) &quot;666F6F626172&quot; iex&gt; Base . encode16 ( &quot;foobar&quot; , case : :lower ) &quot;666f6f626172&quot;","ref":"Base.html#encode16/2","source_doc":"Encodes a binary string into a base 16 encoded string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\n## Examples\n\n    iex> Base.encode16(\"foobar\")\n    \"666F6F626172\"\n\n    iex> Base.encode16(\"foobar\", case: :lower)\n    \"666f6f626172\"\n\n","title":"Base.encode16/2","type":"function"},{"doc":"Encodes a binary string into a base 32 encoded string. Options The accepted options are: :case - specifies the character case to use when encoding :padding - specifies whether to apply padding The values for :case can be: :upper - uses upper case characters (default) :lower - uses lower case characters The values for :padding can be: true - pad the output string to the nearest multiple of 8 (default) false - omit padding from the output string Examples iex&gt; Base . encode32 ( &quot;foobar&quot; ) &quot;MZXW6YTBOI======&quot; iex&gt; Base . encode32 ( &quot;foobar&quot; , case : :lower ) &quot;mzxw6ytboi======&quot; iex&gt; Base . encode32 ( &quot;foobar&quot; , padding : false ) &quot;MZXW6YTBOI&quot;","ref":"Base.html#encode32/2","source_doc":"Encodes a binary string into a base 32 encoded string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string\n\n## Examples\n\n    iex> Base.encode32(\"foobar\")\n    \"MZXW6YTBOI======\"\n\n    iex> Base.encode32(\"foobar\", case: :lower)\n    \"mzxw6ytboi======\"\n\n    iex> Base.encode32(\"foobar\", padding: false)\n    \"MZXW6YTBOI\"\n\n","title":"Base.encode32/2","type":"function"},{"doc":"Encodes a binary string into a base 64 encoded string. Accepts padding: false option which will omit padding from the output string. Examples iex&gt; Base . encode64 ( &quot;foobar&quot; ) &quot;Zm9vYmFy&quot; iex&gt; Base . encode64 ( &quot;foob&quot; ) &quot;Zm9vYg==&quot; iex&gt; Base . encode64 ( &quot;foob&quot; , padding : false ) &quot;Zm9vYg&quot;","ref":"Base.html#encode64/2","source_doc":"Encodes a binary string into a base 64 encoded string.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.\n\n## Examples\n\n    iex> Base.encode64(\"foobar\")\n    \"Zm9vYmFy\"\n\n    iex> Base.encode64(\"foob\")\n    \"Zm9vYg==\"\n\n    iex> Base.encode64(\"foob\", padding: false)\n    \"Zm9vYg\"\n\n","title":"Base.encode64/2","type":"function"},{"doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . hex_decode32 ( &quot;CPNMUOJ1E8======&quot; ) { :ok , &quot;foobar&quot; } iex&gt; Base . hex_decode32 ( &quot;cpnmuoj1e8======&quot; , case : :lower ) { :ok , &quot;foobar&quot; } iex&gt; Base . hex_decode32 ( &quot;cpnMuOJ1E8======&quot; , case : :mixed ) { :ok , &quot;foobar&quot; } iex&gt; Base . hex_decode32 ( &quot;CPNMUOJ1E8&quot; , padding : false ) { :ok , &quot;foobar&quot; }","ref":"Base.html#hex_decode32/2","source_doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n    {:ok, \"foobar\"}\n\n    iex> Base.hex_decode32(\"CPNMUOJ1E8\", padding: false)\n    {:ok, \"foobar\"}\n\n","title":"Base.hex_decode32/2","type":"function"},{"doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Options The accepted options are: :case - specifies the character case to accept when decoding :padding - specifies whether to require padding The values for :case can be: :upper - only allows upper case characters (default) :lower - only allows lower case characters :mixed - allows mixed case characters The values for :padding can be: true - requires the input string to be padded to the nearest multiple of 8 (default) false - ignores padding from the input string Examples iex&gt; Base . hex_decode32! ( &quot;CPNMUOJ1E8======&quot; ) &quot;foobar&quot; iex&gt; Base . hex_decode32! ( &quot;cpnmuoj1e8======&quot; , case : :lower ) &quot;foobar&quot; iex&gt; Base . hex_decode32! ( &quot;cpnMuOJ1E8======&quot; , case : :mixed ) &quot;foobar&quot; iex&gt; Base . hex_decode32! ( &quot;CPNMUOJ1E8&quot; , padding : false ) &quot;foobar&quot;","ref":"Base.html#hex_decode32!/2","source_doc":"Decodes a base 32 encoded string with extended hexadecimal alphabet\ninto a binary string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to accept when decoding\n  * `:padding` - specifies whether to require padding\n\nThe values for `:case` can be:\n\n  * `:upper` - only allows upper case characters (default)\n  * `:lower` - only allows lower case characters\n  * `:mixed` - allows mixed case characters\n\nThe values for `:padding` can be:\n\n  * `true` - requires the input string to be padded to the nearest multiple of 8 (default)\n  * `false` - ignores padding from the input string\n\n## Examples\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n    \"foobar\"\n\n    iex> Base.hex_decode32!(\"CPNMUOJ1E8\", padding: false)\n    \"foobar\"\n\n","title":"Base.hex_decode32!/2","type":"function"},{"doc":"Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet. Options The accepted options are: :case - specifies the character case to use when encoding :padding - specifies whether to apply padding The values for :case can be: :upper - uses upper case characters (default) :lower - uses lower case characters The values for :padding can be: true - pad the output string to the nearest multiple of 8 (default) false - omit padding from the output string Examples iex&gt; Base . hex_encode32 ( &quot;foobar&quot; ) &quot;CPNMUOJ1E8======&quot; iex&gt; Base . hex_encode32 ( &quot;foobar&quot; , case : :lower ) &quot;cpnmuoj1e8======&quot; iex&gt; Base . hex_encode32 ( &quot;foobar&quot; , padding : false ) &quot;CPNMUOJ1E8&quot;","ref":"Base.html#hex_encode32/2","source_doc":"Encodes a binary string into a base 32 encoded string with an\nextended hexadecimal alphabet.\n\n## Options\n\nThe accepted options are:\n\n  * `:case` - specifies the character case to use when encoding\n  * `:padding` - specifies whether to apply padding\n\nThe values for `:case` can be:\n\n  * `:upper` - uses upper case characters (default)\n  * `:lower` - uses lower case characters\n\nThe values for `:padding` can be:\n\n  * `true` - pad the output string to the nearest multiple of 8 (default)\n  * `false` - omit padding from the output string\n\n## Examples\n\n    iex> Base.hex_encode32(\"foobar\")\n    \"CPNMUOJ1E8======\"\n\n    iex> Base.hex_encode32(\"foobar\", case: :lower)\n    \"cpnmuoj1e8======\"\n\n    iex> Base.hex_encode32(\"foobar\", padding: false)\n    \"CPNMUOJ1E8\"\n\n","title":"Base.hex_encode32/2","type":"function"},{"doc":"Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. Examples iex&gt; Base . url_decode64 ( &quot;_3_-_A==&quot; ) { :ok , &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; } iex&gt; Base . url_decode64 ( &quot;_3_-_A== \\n &quot; , ignore : :whitespace ) { :ok , &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; } iex&gt; Base . url_decode64 ( &quot;_3_-_A&quot; , padding : false ) { :ok , &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; }","ref":"Base.html#url_decode64/2","source_doc":"Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\n## Examples\n\n    iex> Base.url_decode64(\"_3_-_A==\")\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A==\\n\", ignore: :whitespace)\n    {:ok, <<255, 127, 254, 252>>}\n\n    iex> Base.url_decode64(\"_3_-_A\", padding: false)\n    {:ok, <<255, 127, 254, 252>>}\n\n","title":"Base.url_decode64/2","type":"function"},{"doc":"Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string. Accepts ignore: :whitespace option which will ignore all the whitespace characters in the input string. Accepts padding: false option which will ignore padding from the input string. An ArgumentError exception is raised if the padding is incorrect or a non-alphabet character is present in the string. Examples iex&gt; Base . url_decode64! ( &quot;_3_-_A==&quot; ) &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; iex&gt; Base . url_decode64! ( &quot;_3_-_A== \\n &quot; , ignore : :whitespace ) &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; iex&gt; Base . url_decode64! ( &quot;_3_-_A&quot; , padding : false ) &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt;","ref":"Base.html#url_decode64!/2","source_doc":"Decodes a base 64 encoded string with URL and filename safe alphabet\ninto a binary string.\n\nAccepts `ignore: :whitespace` option which will ignore all the\nwhitespace characters in the input string.\n\nAccepts `padding: false` option which will ignore padding from\nthe input string.\n\nAn `ArgumentError` exception is raised if the padding is incorrect or\na non-alphabet character is present in the string.\n\n## Examples\n\n    iex> Base.url_decode64!(\"_3_-_A==\")\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A==\\n\", ignore: :whitespace)\n    <<255, 127, 254, 252>>\n\n    iex> Base.url_decode64!(\"_3_-_A\", padding: false)\n    <<255, 127, 254, 252>>\n\n","title":"Base.url_decode64!/2","type":"function"},{"doc":"Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet. Accepts padding: false option which will omit padding from the output string. Examples iex&gt; Base . url_encode64 ( &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; ) &quot;_3_-_A==&quot; iex&gt; Base . url_encode64 ( &lt;&lt; 255 , 127 , 254 , 252 &gt;&gt; , padding : false ) &quot;_3_-_A&quot;","ref":"Base.html#url_encode64/2","source_doc":"Encodes a binary string into a base 64 encoded string with URL and filename\nsafe alphabet.\n\nAccepts `padding: false` option which will omit padding from\nthe output string.\n\n## Examples\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>)\n    \"_3_-_A==\"\n\n    iex> Base.url_encode64(<<255, 127, 254, 252>>, padding: false)\n    \"_3_-_A\"\n\n","title":"Base.url_encode64/2","type":"function"},{"doc":"","ref":"Base.html#t:decode_case/0","source_doc":false,"title":"Base.decode_case/0","type":"type"},{"doc":"","ref":"Base.html#t:encode_case/0","source_doc":false,"title":"Base.encode_case/0","type":"type"},{"doc":"A set of functions that perform calculations on bits. All bitwise functions work only on integers; otherwise an ArithmeticError is raised. The functions band/2 , bor/2 , bsl/2 , and bsr/2 also have operators, respectively: &amp;&amp;&amp;/2 , |||/2 , &lt;&lt;&lt;/2 , and &gt;&gt;&gt;/2 . Guards All bitwise functions can be used in guards: iex&gt; odd? = fn ...&gt; int when Bitwise . band ( int , 1 ) == 1 -&gt; true ...&gt; _ -&gt; false ...&gt; end iex&gt; odd? . ( 1 ) true All functions in this module are inlined by the compiler.","ref":"Bitwise.html","source_doc":"A set of functions that perform calculations on bits.\n\nAll bitwise functions work only on integers; otherwise an\n`ArithmeticError` is raised. The functions `band/2`,\n`bor/2`, `bsl/2`, and `bsr/2` also have operators,\nrespectively: `&&&/2`, `|||/2`, `<<</2`, and `>>>/2`.\n\n## Guards\n\nAll bitwise functions can be used in guards:\n\n    iex> odd? = fn\n    ...>   int when Bitwise.band(int, 1) == 1 -> true\n    ...>   _ -> false\n    ...> end\n    iex> odd?.(1)\n    true\n\nAll functions in this module are inlined by the compiler.\n","title":"Bitwise","type":"module"},{"doc":"Bitwise AND operator. Calculates the bitwise AND of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 9 &amp;&amp;&amp; 3 1","ref":"Bitwise.html#&&&/2","source_doc":"Bitwise AND operator.\n\nCalculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 9 &&& 3\n    1\n\n","title":"Bitwise.&&&/2","type":"function"},{"doc":"Arithmetic left bitshift operator. Calculates the result of an arithmetic left bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &lt;&lt;&lt; 2 4 iex&gt; 1 &lt;&lt;&lt; - 2 0 iex&gt; - 1 &lt;&lt;&lt; 2 - 4 iex&gt; - 1 &lt;&lt;&lt; - 2 - 1","ref":"Bitwise.html#%3C%3C%3C/2","source_doc":"Arithmetic left bitshift operator.\n\nCalculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 <<< 2\n    4\n\n    iex> 1 <<< -2\n    0\n\n    iex> -1 <<< 2\n    -4\n\n    iex> -1 <<< -2\n    -1\n\n","title":"Bitwise.<<</2","type":"function"},{"doc":"Arithmetic right bitshift operator. Calculates the result of an arithmetic right bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 1 &gt;&gt;&gt; 2 0 iex&gt; 1 &gt;&gt;&gt; - 2 4 iex&gt; - 1 &gt;&gt;&gt; 2 - 1 iex&gt; - 1 &gt;&gt;&gt; - 2 - 4","ref":"Bitwise.html#%3E%3E%3E/2","source_doc":"Arithmetic right bitshift operator.\n\nCalculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 1 >>> 2\n    0\n\n    iex> 1 >>> -2\n    4\n\n    iex> -1 >>> 2\n    -1\n\n    iex> -1 >>> -2\n    -4\n\n","title":"Bitwise.>>>/2","type":"function"},{"doc":"Calculates the bitwise AND of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; band ( 9 , 3 ) 1","ref":"Bitwise.html#band/2","source_doc":"Calculates the bitwise AND of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> band(9, 3)\n    1\n\n","title":"Bitwise.band/2","type":"function"},{"doc":"Calculates the bitwise NOT of the argument. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bnot ( 2 ) - 3 iex&gt; bnot ( 2 ) &amp;&amp;&amp; 3 1","ref":"Bitwise.html#bnot/1","source_doc":"Calculates the bitwise NOT of the argument.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bnot(2)\n    -3\n\n    iex> bnot(2) &&& 3\n    1\n\n","title":"Bitwise.bnot/1","type":"function"},{"doc":"Calculates the bitwise OR of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bor ( 9 , 3 ) 11","ref":"Bitwise.html#bor/2","source_doc":"Calculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bor(9, 3)\n    11\n\n","title":"Bitwise.bor/2","type":"function"},{"doc":"Calculates the result of an arithmetic left bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bsl ( 1 , 2 ) 4 iex&gt; bsl ( 1 , - 2 ) 0 iex&gt; bsl ( - 1 , 2 ) - 4 iex&gt; bsl ( - 1 , - 2 ) - 1","ref":"Bitwise.html#bsl/2","source_doc":"Calculates the result of an arithmetic left bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bsl(1, 2)\n    4\n\n    iex> bsl(1, -2)\n    0\n\n    iex> bsl(-1, 2)\n    -4\n\n    iex> bsl(-1, -2)\n    -1\n\n","title":"Bitwise.bsl/2","type":"function"},{"doc":"Calculates the result of an arithmetic right bitshift. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bsr ( 1 , 2 ) 0 iex&gt; bsr ( 1 , - 2 ) 4 iex&gt; bsr ( - 1 , 2 ) - 1 iex&gt; bsr ( - 1 , - 2 ) - 4","ref":"Bitwise.html#bsr/2","source_doc":"Calculates the result of an arithmetic right bitshift.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bsr(1, 2)\n    0\n\n    iex> bsr(1, -2)\n    4\n\n    iex> bsr(-1, 2)\n    -1\n\n    iex> bsr(-1, -2)\n    -4\n\n","title":"Bitwise.bsr/2","type":"function"},{"doc":"Calculates the bitwise XOR of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; bxor ( 9 , 3 ) 10","ref":"Bitwise.html#bxor/2","source_doc":"Calculates the bitwise XOR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> bxor(9, 3)\n    10\n\n","title":"Bitwise.bxor/2","type":"function"},{"doc":"Bitwise OR operator. Calculates the bitwise OR of its arguments. Allowed in guard tests. Inlined by the compiler. Examples iex&gt; 9 ||| 3 11","ref":"Bitwise.html#%7C%7C%7C/2","source_doc":"Bitwise OR operator.\n\nCalculates the bitwise OR of its arguments.\n\nAllowed in guard tests. Inlined by the compiler.\n\n## Examples\n\n    iex> 9 ||| 3\n    11\n\n","title":"Bitwise.|||/2","type":"function"},{"doc":"A Date struct and functions. The Date struct contains the fields year, month, day and calendar. New dates can be built with the new/3 function or using the ~D (see sigil_D/2 ) sigil: iex&gt; ~D[2000-01-01] ~D[2000-01-01] Both new/3 and sigil return a struct where the date fields can be accessed directly: iex&gt; date = ~D[2000-01-01] iex&gt; date . year 2000 iex&gt; date . month 1 The functions on this module work with the Date struct as well as any struct that contains the same fields as the Date struct, such as NaiveDateTime and DateTime . Such functions expect Calendar.date/0 in their typespecs (instead of t/0 ). Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries. Comparing dates Comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and similar are structural and based on the Date struct fields. For proper comparison between dates, use the compare/2 function. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum date of an Enum . For example: iex&gt; Enum . min ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-03-31] Using epochs The add/2 and diff/2 functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01): iex&gt; Date . diff ( ~D[2010-04-17] , ~D[1970-01-01] ) 14716 iex&gt; Date . add ( ~D[1970-01-01] , 14716 ) ~D[2010-04-17] Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).","ref":"Date.html","source_doc":"A Date struct and functions.\n\nThe Date struct contains the fields year, month, day and calendar.\nNew dates can be built with the `new/3` function or using the\n`~D` (see `sigil_D/2`) sigil:\n\n    iex> ~D[2000-01-01]\n    ~D[2000-01-01]\n\nBoth `new/3` and sigil return a struct where the date fields can\nbe accessed directly:\n\n    iex> date = ~D[2000-01-01]\n    iex> date.year\n    2000\n    iex> date.month\n    1\n\nThe functions on this module work with the `Date` struct as well\nas any struct that contains the same fields as the `Date` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.date/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Date structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.\n\n## Comparing dates\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Date` struct fields. For proper comparison between\ndates, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum date of an `Enum`. For example:\n\n    iex>  Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]\n\n## Using epochs\n\nThe `add/2` and `diff/2` functions can be used for computing dates\nor retrieving the number of days between instants. For example, if there\nis an interest in computing the number of days from the Unix epoch\n(1970-01-01):\n\n    iex> Date.diff(~D[2010-04-17], ~D[1970-01-01])\n    14716\n\n    iex> Date.add(~D[1970-01-01], 14716)\n    ~D[2010-04-17]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01).\n","title":"Date","type":"module"},{"doc":"Adds the number of days to the given date . The days are counted as Gregorian days. The date is returned in the same calendar as it was given in. Examples iex&gt; Date . add ( ~D[2000-01-03] , - 2 ) ~D[2000-01-01] iex&gt; Date . add ( ~D[2000-01-01] , 2 ) ~D[2000-01-03] iex&gt; Date . add ( ~N[2000-01-01 09:00:00] , 2 ) ~D[2000-01-03] iex&gt; Date . add ( ~D[-0010-01-01] , - 2 ) ~D[-0011-12-30]","ref":"Date.html#add/2","source_doc":"Adds the number of days to the given `date`.\n\nThe days are counted as Gregorian days. The date is returned in the same\ncalendar as it was given in.\n\n## Examples\n\n    iex> Date.add(~D[2000-01-03], -2)\n    ~D[2000-01-01]\n    iex> Date.add(~D[2000-01-01], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~N[2000-01-01 09:00:00], 2)\n    ~D[2000-01-03]\n    iex> Date.add(~D[-0010-01-01], -2)\n    ~D[-0011-12-30]\n\n","title":"Date.add/2","type":"function"},{"doc":"Returns true if the first date is strictly later than the second. Examples iex&gt; Date . after? ( ~D[2022-02-02] , ~D[2021-01-01] ) true iex&gt; Date . after? ( ~D[2021-01-01] , ~D[2021-01-01] ) false iex&gt; Date . after? ( ~D[2021-01-01] , ~D[2022-02-02] ) false","ref":"Date.html#after?/2","source_doc":"Returns true if the first date is strictly later than the second.\n\n## Examples\n\n    iex> Date.after?(~D[2022-02-02], ~D[2021-01-01])\n    true\n    iex> Date.after?(~D[2021-01-01], ~D[2021-01-01])\n    false\n    iex> Date.after?(~D[2021-01-01], ~D[2022-02-02])\n    false\n\n","title":"Date.after?/2","type":"function"},{"doc":"Returns true if the first date is strictly earlier than the second. Examples iex&gt; Date . before? ( ~D[2021-01-01] , ~D[2022-02-02] ) true iex&gt; Date . before? ( ~D[2021-01-01] , ~D[2021-01-01] ) false iex&gt; Date . before? ( ~D[2022-02-02] , ~D[2021-01-01] ) false","ref":"Date.html#before?/2","source_doc":"Returns true if the first date is strictly earlier than the second.\n\n## Examples\n\n    iex> Date.before?(~D[2021-01-01], ~D[2022-02-02])\n    true\n    iex> Date.before?(~D[2021-01-01], ~D[2021-01-01])\n    false\n    iex> Date.before?(~D[2022-02-02], ~D[2021-01-01])\n    false\n\n","title":"Date.before?/2","type":"function"},{"doc":"Calculates a date that is the first day of the month for the given date . Examples iex&gt; Date . beginning_of_month ( ~D[2000-01-31] ) ~D[2000-01-01] iex&gt; Date . beginning_of_month ( ~D[2000-01-01] ) ~D[2000-01-01] iex&gt; Date . beginning_of_month ( ~N[2000-01-31 01:23:45] ) ~D[2000-01-01]","ref":"Date.html#beginning_of_month/1","source_doc":"Calculates a date that is the first day of the month for the given `date`.\n\n## Examples\n\n    iex> Date.beginning_of_month(~D[2000-01-31])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~D[2000-01-01])\n    ~D[2000-01-01]\n    iex> Date.beginning_of_month(~N[2000-01-31 01:23:45])\n    ~D[2000-01-01]\n\n","title":"Date.beginning_of_month/1","type":"function"},{"doc":"Calculates a date that is the first day of the week for the given date . If the day is already the first day of the week, it returns the day itself. For the built-in ISO calendar, the week starts on Monday. A weekday rather than :default can be given as starting_on . Examples iex&gt; Date . beginning_of_week ( ~D[2020-07-11] ) ~D[2020-07-06] iex&gt; Date . beginning_of_week ( ~D[2020-07-06] ) ~D[2020-07-06] iex&gt; Date . beginning_of_week ( ~D[2020-07-11] , :sunday ) ~D[2020-07-05] iex&gt; Date . beginning_of_week ( ~D[2020-07-11] , :saturday ) ~D[2020-07-11] iex&gt; Date . beginning_of_week ( ~N[2020-07-11 01:23:45] ) ~D[2020-07-06]","ref":"Date.html#beginning_of_week/2","source_doc":"Calculates a date that is the first day of the week for the given `date`.\n\nIf the day is already the first day of the week, it returns the\nday itself. For the built-in ISO calendar, the week starts on Monday.\nA weekday rather than `:default` can be given as `starting_on`.\n\n## Examples\n\n    iex> Date.beginning_of_week(~D[2020-07-11])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-06])\n    ~D[2020-07-06]\n    iex> Date.beginning_of_week(~D[2020-07-11], :sunday)\n    ~D[2020-07-05]\n    iex> Date.beginning_of_week(~D[2020-07-11], :saturday)\n    ~D[2020-07-11]\n    iex> Date.beginning_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-06]\n\n","title":"Date.beginning_of_week/2","type":"function"},{"doc":"Compares two date structs. Returns :gt if first date is later than the second and :lt for vice versa. If the two dates are equal :eq is returned. Examples iex&gt; Date . compare ( ~D[2016-04-16] , ~D[2016-04-28] ) :lt This function can also be used to compare across more complex calendar types by considering only the date fields: iex&gt; Date . compare ( ~D[2016-04-16] , ~N[2016-04-28 01:23:45] ) :lt iex&gt; Date . compare ( ~D[2016-04-16] , ~N[2016-04-16 01:23:45] ) :eq iex&gt; Date . compare ( ~N[2016-04-16 12:34:56] , ~N[2016-04-16 01:23:45] ) :eq","ref":"Date.html#compare/2","source_doc":"Compares two date structs.\n\nReturns `:gt` if first date is later than the second\nand `:lt` for vice versa. If the two dates are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n    :lt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the date fields:\n\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n    :lt\n    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n    :eq\n    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n    :eq\n\n","title":"Date.compare/2","type":"function"},{"doc":"Converts the given date from its calendar to the given calendar . Returns {:ok, date} if the calendars are compatible, or {:error, :incompatible_calendars} if they are not. See also Calendar.compatible_calendars?/2 . Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Date . convert ( ~D[2000-01-01] , Calendar.Holocene ) { :ok , % Date { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 } }","ref":"Date.html#convert/2","source_doc":"Converts the given `date` from its calendar to the given `calendar`.\n\nReturns `{:ok, date}` if the calendars are compatible,\nor `{:error, :incompatible_calendars}` if they are not.\n\nSee also `Calendar.compatible_calendars?/2`.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert(~D[2000-01-01], Calendar.Holocene)\n    {:ok, %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}}\n\n","title":"Date.convert/2","type":"function"},{"doc":"Similar to Date.convert/2 , but raises an ArgumentError if the conversion between the two calendars is not possible. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Date . convert! ( ~D[2000-01-01] , Calendar.Holocene ) % Date { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 }","ref":"Date.html#convert!/2","source_doc":"Similar to `Date.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Date.convert!(~D[2000-01-01], Calendar.Holocene)\n    %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}\n\n","title":"Date.convert!/2","type":"function"},{"doc":"Calculates the day-of-era and era for a given calendar date . Returns a tuple {day, era} representing the day within the era and the era number. Examples iex&gt; Date . day_of_era ( ~D[0001-01-01] ) { 1 , 1 } iex&gt; Date . day_of_era ( ~D[0000-12-31] ) { 1 , 0 }","ref":"Date.html#day_of_era/1","source_doc":"Calculates the day-of-era and era for a given\ncalendar `date`.\n\nReturns a tuple `{day, era}` representing the\nday within the era and the era number.\n\n## Examples\n\n    iex> Date.day_of_era(~D[0001-01-01])\n    {1, 1}\n\n    iex> Date.day_of_era(~D[0000-12-31])\n    {1, 0}\n\n","title":"Date.day_of_era/1","type":"function"},{"doc":"Calculates the day of the week of a given date . Returns the day of the week as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 7, where 1 is Monday and 7 is Sunday. An optional starting_on value may be supplied, which configures the weekday the week starts on. The default value for it is :default , which translates to :monday for the built-in ISO calendar. Any other weekday may be given to. Examples iex&gt; Date . day_of_week ( ~D[2016-10-31] ) 1 iex&gt; Date . day_of_week ( ~D[2016-11-01] ) 2 iex&gt; Date . day_of_week ( ~N[2016-11-01 01:23:45] ) 2 iex&gt; Date . day_of_week ( ~D[-0015-10-30] ) 3 iex&gt; Date . day_of_week ( ~D[2016-10-31] , :sunday ) 2 iex&gt; Date . day_of_week ( ~D[2016-11-01] , :sunday ) 3 iex&gt; Date . day_of_week ( ~N[2016-11-01 01:23:45] , :sunday ) 3 iex&gt; Date . day_of_week ( ~D[-0015-10-30] , :sunday ) 4","ref":"Date.html#day_of_week/2","source_doc":"Calculates the day of the week of a given `date`.\n\nReturns the day of the week as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 7, where\n1 is Monday and 7 is Sunday.\n\nAn optional `starting_on` value may be supplied, which\nconfigures the weekday the week starts on. The default value\nfor it is `:default`, which translates to `:monday` for the\nbuilt-in ISO calendar. Any other weekday may be given to.\n\n## Examples\n\n    iex> Date.day_of_week(~D[2016-10-31])\n    1\n    iex> Date.day_of_week(~D[2016-11-01])\n    2\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n    2\n    iex> Date.day_of_week(~D[-0015-10-30])\n    3\n\n    iex> Date.day_of_week(~D[2016-10-31], :sunday)\n    2\n    iex> Date.day_of_week(~D[2016-11-01], :sunday)\n    3\n    iex> Date.day_of_week(~N[2016-11-01 01:23:45], :sunday)\n    3\n    iex> Date.day_of_week(~D[-0015-10-30], :sunday)\n    4\n\n","title":"Date.day_of_week/2","type":"function"},{"doc":"Calculates the day of the year of a given date . Returns the day of the year as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 366. Examples iex&gt; Date . day_of_year ( ~D[2016-01-01] ) 1 iex&gt; Date . day_of_year ( ~D[2016-11-01] ) 306 iex&gt; Date . day_of_year ( ~D[-0015-10-30] ) 303 iex&gt; Date . day_of_year ( ~D[2004-12-31] ) 366","ref":"Date.html#day_of_year/1","source_doc":"Calculates the day of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 366.\n\n## Examples\n\n    iex> Date.day_of_year(~D[2016-01-01])\n    1\n    iex> Date.day_of_year(~D[2016-11-01])\n    306\n    iex> Date.day_of_year(~D[-0015-10-30])\n    303\n    iex> Date.day_of_year(~D[2004-12-31])\n    366\n\n","title":"Date.day_of_year/1","type":"function"},{"doc":"Returns the number of days in the given date month. Examples iex&gt; Date . days_in_month ( ~D[1900-01-13] ) 31 iex&gt; Date . days_in_month ( ~D[1900-02-09] ) 28 iex&gt; Date . days_in_month ( ~N[2000-02-20 01:23:45] ) 29","ref":"Date.html#days_in_month/1","source_doc":"Returns the number of days in the given `date` month.\n\n## Examples\n\n    iex> Date.days_in_month(~D[1900-01-13])\n    31\n    iex> Date.days_in_month(~D[1900-02-09])\n    28\n    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n    29\n\n","title":"Date.days_in_month/1","type":"function"},{"doc":"Calculates the difference between two dates, in a full number of days. It returns the number of Gregorian days between the dates. Only Date structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise. Examples iex&gt; Date . diff ( ~D[2000-01-03] , ~D[2000-01-01] ) 2 iex&gt; Date . diff ( ~D[2000-01-01] , ~D[2000-01-03] ) - 2 iex&gt; Date . diff ( ~D[0000-01-02] , ~D[-0001-12-30] ) 3 iex&gt; Date . diff ( ~D[2000-01-01] , ~N[2000-01-03 09:00:00] ) - 2","ref":"Date.html#diff/2","source_doc":"Calculates the difference between two dates, in a full number of days.\n\nIt returns the number of Gregorian days between the dates. Only `Date`\nstructs that follow the same or compatible calendars can be compared\nthis way. If two calendars are not compatible, it will raise.\n\n## Examples\n\n    iex> Date.diff(~D[2000-01-03], ~D[2000-01-01])\n    2\n    iex> Date.diff(~D[2000-01-01], ~D[2000-01-03])\n    -2\n    iex> Date.diff(~D[0000-01-02], ~D[-0001-12-30])\n    3\n    iex> Date.diff(~D[2000-01-01], ~N[2000-01-03 09:00:00])\n    -2\n\n","title":"Date.diff/2","type":"function"},{"doc":"Calculates a date that is the last day of the month for the given date . Examples iex&gt; Date . end_of_month ( ~D[2000-01-01] ) ~D[2000-01-31] iex&gt; Date . end_of_month ( ~D[2000-01-31] ) ~D[2000-01-31] iex&gt; Date . end_of_month ( ~N[2000-01-01 01:23:45] ) ~D[2000-01-31]","ref":"Date.html#end_of_month/1","source_doc":"Calculates a date that is the last day of the month for the given `date`.\n\n## Examples\n\n    iex> Date.end_of_month(~D[2000-01-01])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~D[2000-01-31])\n    ~D[2000-01-31]\n    iex> Date.end_of_month(~N[2000-01-01 01:23:45])\n    ~D[2000-01-31]\n\n","title":"Date.end_of_month/1","type":"function"},{"doc":"Calculates a date that is the last day of the week for the given date . If the day is already the last day of the week, it returns the day itself. For the built-in ISO calendar, the week ends on Sunday. A weekday rather than :default can be given as starting_on . Examples iex&gt; Date . end_of_week ( ~D[2020-07-11] ) ~D[2020-07-12] iex&gt; Date . end_of_week ( ~D[2020-07-05] ) ~D[2020-07-05] iex&gt; Date . end_of_week ( ~D[2020-07-06] , :sunday ) ~D[2020-07-11] iex&gt; Date . end_of_week ( ~D[2020-07-06] , :saturday ) ~D[2020-07-10] iex&gt; Date . end_of_week ( ~N[2020-07-11 01:23:45] ) ~D[2020-07-12]","ref":"Date.html#end_of_week/2","source_doc":"Calculates a date that is the last day of the week for the given `date`.\n\nIf the day is already the last day of the week, it returns the\nday itself. For the built-in ISO calendar, the week ends on Sunday.\nA weekday rather than `:default` can be given as `starting_on`.\n\n## Examples\n\n    iex> Date.end_of_week(~D[2020-07-11])\n    ~D[2020-07-12]\n    iex> Date.end_of_week(~D[2020-07-05])\n    ~D[2020-07-05]\n    iex> Date.end_of_week(~D[2020-07-06], :sunday)\n    ~D[2020-07-11]\n    iex> Date.end_of_week(~D[2020-07-06], :saturday)\n    ~D[2020-07-10]\n    iex> Date.end_of_week(~N[2020-07-11 01:23:45])\n    ~D[2020-07-12]\n\n","title":"Date.end_of_week/2","type":"function"},{"doc":"Converts an Erlang date tuple to a Date struct. Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple. Examples iex&gt; Date . from_erl ( { 2000 , 1 , 1 } ) { :ok , ~D[2000-01-01] } iex&gt; Date . from_erl ( { 2000 , 13 , 1 } ) { :error , :invalid_date }","ref":"Date.html#from_erl/2","source_doc":"Converts an Erlang date tuple to a `Date` struct.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will return an error tuple.\n\n## Examples\n\n    iex> Date.from_erl({2000, 1, 1})\n    {:ok, ~D[2000-01-01]}\n    iex> Date.from_erl({2000, 13, 1})\n    {:error, :invalid_date}\n\n","title":"Date.from_erl/2","type":"function"},{"doc":"Converts an Erlang date tuple but raises for invalid dates. Examples iex&gt; Date . from_erl! ( { 2000 , 1 , 1 } ) ~D[2000-01-01] iex&gt; Date . from_erl! ( { 2000 , 13 , 1 } ) ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date","ref":"Date.html#from_erl!/2","source_doc":"Converts an Erlang date tuple but raises for invalid dates.\n\n## Examples\n\n    iex> Date.from_erl!({2000, 1, 1})\n    ~D[2000-01-01]\n    iex> Date.from_erl!({2000, 13, 1})\n    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date\n\n","title":"Date.from_erl!/2","type":"function"},{"doc":"Converts a number of gregorian days to a Date struct. Examples iex&gt; Date . from_gregorian_days ( 1 ) ~D[0000-01-02] iex&gt; Date . from_gregorian_days ( 730_485 ) ~D[2000-01-01] iex&gt; Date . from_gregorian_days ( - 1 ) ~D[-0001-12-31]","ref":"Date.html#from_gregorian_days/2","source_doc":"Converts a number of gregorian days to a `Date` struct.\n\n## Examples\n\n    iex> Date.from_gregorian_days(1)\n    ~D[0000-01-02]\n    iex> Date.from_gregorian_days(730_485)\n    ~D[2000-01-01]\n    iex> Date.from_gregorian_days(-1)\n    ~D[-0001-12-31]\n\n","title":"Date.from_gregorian_days/2","type":"function"},{"doc":"Parses the extended &quot;Dates&quot; format described by ISO 8601:2019 . The year parsed by this function is limited to four digits. Examples iex&gt; Date . from_iso8601 ( &quot;2015-01-23&quot; ) { :ok , ~D[2015-01-23] } iex&gt; Date . from_iso8601 ( &quot;2015:01:23&quot; ) { :error , :invalid_format } iex&gt; Date . from_iso8601 ( &quot;2015-01-32&quot; ) { :error , :invalid_date }","ref":"Date.html#from_iso8601/2","source_doc":"Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nThe year parsed by this function is limited to four digits.\n\n## Examples\n\n    iex> Date.from_iso8601(\"2015-01-23\")\n    {:ok, ~D[2015-01-23]}\n\n    iex> Date.from_iso8601(\"2015:01:23\")\n    {:error, :invalid_format}\n\n    iex> Date.from_iso8601(\"2015-01-32\")\n    {:error, :invalid_date}\n\n","title":"Date.from_iso8601/2","type":"function"},{"doc":"Parses the extended &quot;Dates&quot; format described by ISO 8601:2019 . Raises if the format is invalid. Examples iex&gt; Date . from_iso8601! ( &quot;2015-01-23&quot; ) ~D[2015-01-23] iex&gt; Date . from_iso8601! ( &quot;2015:01:23&quot; ) ** (ArgumentError) cannot parse &quot;2015:01:23&quot; as date, reason: :invalid_format","ref":"Date.html#from_iso8601!/2","source_doc":"Parses the extended \"Dates\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Date.from_iso8601!(\"2015-01-23\")\n    ~D[2015-01-23]\n    iex> Date.from_iso8601!(\"2015:01:23\")\n    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :invalid_format\n\n","title":"Date.from_iso8601!/2","type":"function"},{"doc":"Returns true if the year in the given date is a leap year. Examples iex&gt; Date . leap_year? ( ~D[2000-01-01] ) true iex&gt; Date . leap_year? ( ~D[2001-01-01] ) false iex&gt; Date . leap_year? ( ~D[2004-01-01] ) true iex&gt; Date . leap_year? ( ~D[1900-01-01] ) false iex&gt; Date . leap_year? ( ~N[2004-01-01 01:23:45] ) true","ref":"Date.html#leap_year?/1","source_doc":"Returns `true` if the year in the given `date` is a leap year.\n\n## Examples\n\n    iex> Date.leap_year?(~D[2000-01-01])\n    true\n    iex> Date.leap_year?(~D[2001-01-01])\n    false\n    iex> Date.leap_year?(~D[2004-01-01])\n    true\n    iex> Date.leap_year?(~D[1900-01-01])\n    false\n    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n    true\n\n","title":"Date.leap_year?/1","type":"function"},{"doc":"Returns the number of months in the given date year. Example iex&gt; Date . months_in_year ( ~D[1900-01-13] ) 12","ref":"Date.html#months_in_year/1","source_doc":"Returns the number of months in the given `date` year.\n\n## Example\n\n    iex> Date.months_in_year(~D[1900-01-13])\n    12\n\n","title":"Date.months_in_year/1","type":"function"},{"doc":"Builds a new ISO date. Expects all values to be integers. Returns {:ok, date} if each entry fits its appropriate range, returns {:error, reason} otherwise. Examples iex&gt; Date . new ( 2000 , 1 , 1 ) { :ok , ~D[2000-01-01] } iex&gt; Date . new ( 2000 , 13 , 1 ) { :error , :invalid_date } iex&gt; Date . new ( 2000 , 2 , 29 ) { :ok , ~D[2000-02-29] } iex&gt; Date . new ( 2000 , 2 , 30 ) { :error , :invalid_date } iex&gt; Date . new ( 2001 , 2 , 29 ) { :error , :invalid_date }","ref":"Date.html#new/4","source_doc":"Builds a new ISO date.\n\nExpects all values to be integers. Returns `{:ok, date}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Date.new(2000, 1, 1)\n    {:ok, ~D[2000-01-01]}\n    iex> Date.new(2000, 13, 1)\n    {:error, :invalid_date}\n    iex> Date.new(2000, 2, 29)\n    {:ok, ~D[2000-02-29]}\n\n    iex> Date.new(2000, 2, 30)\n    {:error, :invalid_date}\n    iex> Date.new(2001, 2, 29)\n    {:error, :invalid_date}\n\n","title":"Date.new/4","type":"function"},{"doc":"Builds a new ISO date. Expects all values to be integers. Returns date if each entry fits its appropriate range, raises if the date is invalid. Examples iex&gt; Date . new! ( 2000 , 1 , 1 ) ~D[2000-01-01] iex&gt; Date . new! ( 2000 , 13 , 1 ) ** (ArgumentError) cannot build date, reason: :invalid_date iex&gt; Date . new! ( 2000 , 2 , 29 ) ~D[2000-02-29]","ref":"Date.html#new!/4","source_doc":"Builds a new ISO date.\n\nExpects all values to be integers. Returns `date` if each\nentry fits its appropriate range, raises if the date is invalid.\n\n## Examples\n\n    iex> Date.new!(2000, 1, 1)\n    ~D[2000-01-01]\n    iex> Date.new!(2000, 13, 1)\n    ** (ArgumentError) cannot build date, reason: :invalid_date\n    iex> Date.new!(2000, 2, 29)\n    ~D[2000-02-29]\n","title":"Date.new!/4","type":"function"},{"doc":"Calculates the quarter of the year of a given date . Returns the day of the year as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 4. Examples iex&gt; Date . quarter_of_year ( ~D[2016-10-31] ) 4 iex&gt; Date . quarter_of_year ( ~D[2016-01-01] ) 1 iex&gt; Date . quarter_of_year ( ~N[2016-04-01 01:23:45] ) 2 iex&gt; Date . quarter_of_year ( ~D[-0015-09-30] ) 3","ref":"Date.html#quarter_of_year/1","source_doc":"Calculates the quarter of the year of a given `date`.\n\nReturns the day of the year as an integer. For the ISO 8601\ncalendar (the default), it is an integer from 1 to 4.\n\n## Examples\n\n    iex> Date.quarter_of_year(~D[2016-10-31])\n    4\n    iex> Date.quarter_of_year(~D[2016-01-01])\n    1\n    iex> Date.quarter_of_year(~N[2016-04-01 01:23:45])\n    2\n    iex> Date.quarter_of_year(~D[-0015-09-30])\n    3\n\n","title":"Date.quarter_of_year/1","type":"function"},{"doc":"Returns a range of dates. A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars. Ranges of dates can be either increasing ( first &lt;= last ) or decreasing ( first &gt; last ). They are also always inclusive. Examples iex&gt; Date . range ( ~D[1999-01-01] , ~D[2000-01-01] ) Date . range ( ~D[1999-01-01] , ~D[2000-01-01] ) A range of dates implements the Enumerable protocol, which means functions in the Enum module can be used to work with ranges: iex&gt; range = Date . range ( ~D[2001-01-01] , ~D[2002-01-01] ) iex&gt; range Date . range ( ~D[2001-01-01] , ~D[2002-01-01] ) iex&gt; Enum . count ( range ) 366 iex&gt; ~D[2001-02-01] in range true iex&gt; Enum . take ( range , 3 ) [ ~D[2001-01-01] , ~D[2001-01-02] , ~D[2001-01-03] ] iex&gt; for d &lt;- Date . range ( ~D[2023-03-01] , ~D[2023-04-01] ) , Date . day_of_week ( d ) == 7 , do : d [ ~D[2023-03-05] , ~D[2023-03-12] , ~D[2023-03-19] , ~D[2023-03-26] ]","ref":"Date.html#range/2","source_doc":"Returns a range of dates.\n\nA range of dates represents a discrete number of dates where\nthe first and last values are dates with matching calendars.\n\nRanges of dates can be either increasing (`first <= last`) or\ndecreasing (`first > last`). They are also always inclusive.\n\n## Examples\n\n    iex> Date.range(~D[1999-01-01], ~D[2000-01-01])\n    Date.range(~D[1999-01-01], ~D[2000-01-01])\n\nA range of dates implements the `Enumerable` protocol, which means\nfunctions in the `Enum` module can be used to work with\nranges:\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01])\n    iex> Enum.count(range)\n    366\n    iex> ~D[2001-02-01] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-02], ~D[2001-01-03]]\n    iex> for d <- Date.range(~D[2023-03-01], ~D[2023-04-01]), Date.day_of_week(d) == 7, do: d\n    [~D[2023-03-05], ~D[2023-03-12], ~D[2023-03-19], ~D[2023-03-26]]\n\n","title":"Date.range/2","type":"function"},{"doc":"Returns a range of dates with a step. Examples iex&gt; range = Date . range ( ~D[2001-01-01] , ~D[2002-01-01] , 2 ) iex&gt; range Date . range ( ~D[2001-01-01] , ~D[2002-01-01] , 2 ) iex&gt; Enum . count ( range ) 183 iex&gt; ~D[2001-01-03] in range true iex&gt; Enum . take ( range , 3 ) [ ~D[2001-01-01] , ~D[2001-01-03] , ~D[2001-01-05] ]","ref":"Date.html#range/3","source_doc":"Returns a range of dates with a step.\n\n## Examples\n\n    iex> range = Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> range\n    Date.range(~D[2001-01-01], ~D[2002-01-01], 2)\n    iex> Enum.count(range)\n    183\n    iex> ~D[2001-01-03] in range\n    true\n    iex> Enum.take(range, 3)\n    [~D[2001-01-01], ~D[2001-01-03], ~D[2001-01-05]]\n\n","title":"Date.range/3","type":"function"},{"doc":"Converts the given date to an Erlang date tuple. Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise. Examples iex&gt; Date . to_erl ( ~D[2000-01-01] ) { 2000 , 1 , 1 } iex&gt; Date . to_erl ( ~N[2000-01-01 00:00:00] ) { 2000 , 1 , 1 }","ref":"Date.html#to_erl/1","source_doc":"Converts the given `date` to an Erlang date tuple.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise.\n\n## Examples\n\n    iex> Date.to_erl(~D[2000-01-01])\n    {2000, 1, 1}\n\n    iex> Date.to_erl(~N[2000-01-01 00:00:00])\n    {2000, 1, 1}\n\n","title":"Date.to_erl/1","type":"function"},{"doc":"Converts a date struct to a number of gregorian days. Examples iex&gt; Date . to_gregorian_days ( ~D[0000-01-02] ) 1 iex&gt; Date . to_gregorian_days ( ~D[2000-01-01] ) 730_485 iex&gt; Date . to_gregorian_days ( ~N[2000-01-01 00:00:00] ) 730_485","ref":"Date.html#to_gregorian_days/1","source_doc":"Converts a `date` struct to a number of gregorian days.\n\n## Examples\n\n    iex> Date.to_gregorian_days(~D[0000-01-02])\n    1\n    iex> Date.to_gregorian_days(~D[2000-01-01])\n    730_485\n    iex> Date.to_gregorian_days(~N[2000-01-01 00:00:00])\n    730_485\n\n","title":"Date.to_gregorian_days/1","type":"function"},{"doc":"Converts the given date to ISO 8601:2019 . By default, Date.to_iso8601/2 returns dates formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an ArgumentError . Examples iex&gt; Date . to_iso8601 ( ~D[2000-02-28] ) &quot;2000-02-28&quot; iex&gt; Date . to_iso8601 ( ~D[2000-02-28] , :basic ) &quot;20000228&quot; iex&gt; Date . to_iso8601 ( ~N[2000-02-28 00:00:00] ) &quot;2000-02-28&quot;","ref":"Date.html#to_iso8601/2","source_doc":"Converts the given `date` to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Date.to_iso8601/2` returns dates formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting dates which are in the ISO calendar,\nor other calendars in which the days also start at midnight.\nAttempting to convert dates from other calendars will raise an `ArgumentError`.\n\n### Examples\n\n    iex> Date.to_iso8601(~D[2000-02-28])\n    \"2000-02-28\"\n\n    iex> Date.to_iso8601(~D[2000-02-28], :basic)\n    \"20000228\"\n\n    iex> Date.to_iso8601(~N[2000-02-28 00:00:00])\n    \"2000-02-28\"\n\n","title":"Date.to_iso8601/2","type":"function"},{"doc":"Converts the given date to a string according to its calendar. Examples iex&gt; Date . to_string ( ~D[2000-02-28] ) &quot;2000-02-28&quot; iex&gt; Date . to_string ( ~N[2000-02-28 01:23:45] ) &quot;2000-02-28&quot; iex&gt; Date . to_string ( ~D[-0100-12-15] ) &quot;-0100-12-15&quot;","ref":"Date.html#to_string/1","source_doc":"Converts the given date to a string according to its calendar.\n\n### Examples\n\n    iex> Date.to_string(~D[2000-02-28])\n    \"2000-02-28\"\n    iex> Date.to_string(~N[2000-02-28 01:23:45])\n    \"2000-02-28\"\n    iex> Date.to_string(~D[-0100-12-15])\n    \"-0100-12-15\"\n\n","title":"Date.to_string/1","type":"function"},{"doc":"Returns the current date in UTC. Examples iex&gt; date = Date . utc_today ( ) iex&gt; date . year &gt;= 2016 true","ref":"Date.html#utc_today/1","source_doc":"Returns the current date in UTC.\n\n## Examples\n\n    iex> date = Date.utc_today()\n    iex> date.year >= 2016\n    true\n\n","title":"Date.utc_today/1","type":"function"},{"doc":"Calculates the year-of-era and era for a given calendar year. Returns a tuple {year, era} representing the year within the era and the era number. Examples iex&gt; Date . year_of_era ( ~D[0001-01-01] ) { 1 , 1 } iex&gt; Date . year_of_era ( ~D[0000-12-31] ) { 1 , 0 } iex&gt; Date . year_of_era ( ~D[-0001-01-01] ) { 2 , 0 }","ref":"Date.html#year_of_era/1","source_doc":"Calculates the year-of-era and era for a given\ncalendar year.\n\nReturns a tuple `{year, era}` representing the\nyear within the era and the era number.\n\n## Examples\n\n    iex> Date.year_of_era(~D[0001-01-01])\n    {1, 1}\n    iex> Date.year_of_era(~D[0000-12-31])\n    {1, 0}\n    iex> Date.year_of_era(~D[-0001-01-01])\n    {2, 0}\n\n","title":"Date.year_of_era/1","type":"function"},{"doc":"","ref":"Date.html#t:t/0","source_doc":false,"title":"Date.t/0","type":"type"},{"doc":"A datetime implementation with a time zone. This datetime can be seen as a snapshot of a date and time at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes. Note future datetimes are not necessarily guaranteed to exist, as time zones may change any time in the future due to geopolitical reasons. See the &quot;Datetimes as snapshots&quot; section for more information. Remember, comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the compare/2 function. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum datetime of an Enum . For example: iex&gt; Enum . min ( [ ~U[2022-01-12 00:01:00.00Z] , ~U[2021-01-12 00:01:00.00Z] ] , DateTime ) ~U[2021-01-12 00:01:00.00Z] Developers should avoid creating the DateTime struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries. Time zone database Many functions in this module require a time zone database. By default, it uses the default time zone database returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes and returns {:error, :utc_only_time_zone_database} for any other time zone. Other time zone databases can also be configured. Here are some available options and libraries: time_zone_info tz tzdata zoneinfo - recommended for embedded devices To use them, first make sure it is added as a dependency in mix.exs . It can then be configured either via configuration: config :elixir , :time_zone_database , Tz.TimeZoneDatabase or by calling Calendar.put_time_zone_database/1 : Calendar . put_time_zone_database ( Tz.TimeZoneDatabase ) See the proper names in the library installation instructions. Datetimes as snapshots In the first section, we described datetimes as a &quot;snapshot of a date and time at a given time zone&quot;. To understand precisely what we mean, let's see an example. Imagine someone in Poland wants to schedule a meeting with someone in Brazil in the next year. The meeting will happen at 2:30 AM in the Polish time zone. At what time will the meeting happen in Brazil? You can consult the time zone database today, one year before, using the API in this module and it will give you an answer that is valid right now. However, this answer may not be valid in the future. Why? Because both Brazil and Poland may change their timezone rules, ultimately affecting the result. For example, a country may choose to enter or abandon &quot;Daylight Saving Time&quot;, which is a process where we adjust the clock one hour forward or one hour back once per year. Whenener the rules change, the exact instant that 2:30 AM in Polish time will be in Brazil may change. In other words, whenever working with future DateTimes, there is no guarantee the results you get will always be correct, until the event actually happens. Therefore, when you ask for a future time, the answers you get are a snapshot that reflects the current state of the time zone rules. For datetimes in the past, this is not a problem, because time zone rules do not change for past events. To make matters worse, it may be that the 2:30 AM in Polish time does not actually even exist or it is ambiguous. If a certain time zone observes &quot;Daylight Saving Time&quot;, they will move their clock forward once a year. When this happens, there is a whole hour that does not exist. Then, when they move the clock back, there is a certain hour that will happen twice. So if you want to schedule a meeting when this shift back happens, you would need to explicitly say which of the 2:30 AM you precisely mean. Applications that are date and time sensitive, need to take these scenarios into account and correctly communicate them to users. The good news is: Elixir contains all of the building blocks necessary to tackle those problems. The default timezone database used by Elixir, Calendar.UTCOnlyTimeZoneDatabase , only works with UTC, which does not observe those issues. Once you bring a proper time zone database, the functions in this module will query the database and return the relevant information. For example, look at how DateTime.new/4 returns different results based on the scenarios described in this section.","ref":"DateTime.html","source_doc":"A datetime implementation with a time zone.\n\nThis datetime can be seen as a snapshot of a date and time\nat a given time zone. For such purposes, it also includes both\nUTC and Standard offsets, as well as the zone abbreviation\nfield used exclusively for formatting purposes. Note future\ndatetimes are not necessarily guaranteed to exist, as time\nzones may change any time in the future due to geopolitical\nreasons. See the \"Datetimes as snapshots\" section for more\ninformation.\n\nRemember, comparisons in Elixir using `==/2`, `>/2`, `</2` and friends\nare structural and based on the DateTime struct fields. For proper\ncomparison between datetimes, use the `compare/2` function. The\nexistence of the `compare/2` function in this module also allows\nusing `Enum.min/2` and `Enum.max/2` functions to get the minimum and\nmaximum datetime of an `Enum`. For example:\n\n    iex> Enum.min([~U[2022-01-12 00:01:00.00Z], ~U[2021-01-12 00:01:00.00Z]], DateTime)\n    ~U[2021-01-12 00:01:00.00Z]\n\nDevelopers should avoid creating the `DateTime` struct directly\nand instead rely on the functions provided by this module as\nwell as the ones in third-party calendar libraries.\n\n## Time zone database\n\nMany functions in this module require a time zone database.\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\"\ndatetimes and returns `{:error, :utc_only_time_zone_database}`\nfor any other time zone.\n\nOther time zone databases can also be configured. Here are some\navailable options and libraries:\n\n  * [`time_zone_info`](https://github.com/hrzndhrn/time_zone_info)\n  * [`tz`](https://github.com/mathieuprog/tz)\n  * [`tzdata`](https://github.com/lau/tzdata)\n  * [`zoneinfo`](https://github.com/smartrent/zoneinfo) -\n    recommended for embedded devices\n\nTo use them, first make sure it is added as a dependency in `mix.exs`.\nIt can then be configured either via configuration:\n\n    config :elixir, :time_zone_database, Tz.TimeZoneDatabase\n\nor by calling `Calendar.put_time_zone_database/1`:\n\n    Calendar.put_time_zone_database(Tz.TimeZoneDatabase)\n\nSee the proper names in the library installation instructions.\n\n## Datetimes as snapshots\n\nIn the first section, we described datetimes as a \"snapshot of\na date and time at a given time zone\". To understand precisely\nwhat we mean, let's see an example.\n\nImagine someone in Poland wants to schedule a meeting with someone\nin Brazil in the next year. The meeting will happen at 2:30 AM\nin the Polish time zone. At what time will the meeting happen in\nBrazil?\n\nYou can consult the time zone database today, one year before,\nusing the API in this module and it will give you an answer that\nis valid right now. However, this answer may not be valid in the\nfuture. Why? Because both Brazil and Poland may change their timezone\nrules, ultimately affecting the result. For example, a country may\nchoose to enter or abandon \"Daylight Saving Time\", which is a\nprocess where we adjust the clock one hour forward or one hour\nback once per year. Whenener the rules change, the exact instant\nthat 2:30 AM in Polish time will be in Brazil may change.\n\nIn other words, whenever working with future DateTimes, there is\nno guarantee the results you get will always be correct, until\nthe event actually happens. Therefore, when you ask for a future\ntime, the answers you get are a snapshot that reflects the current\nstate of the time zone rules. For datetimes in the past, this is\nnot a problem, because time zone rules do not change for past\nevents.\n\nTo make matters worse, it may be that the 2:30 AM in Polish time\ndoes not actually even exist or it is ambiguous. If a certain\ntime zone observes \"Daylight Saving Time\", they will move their\nclock forward once a year. When this happens, there is a whole\nhour that does not exist. Then, when they move the clock back,\nthere is a certain hour that will happen twice. So if you want\nto schedule a meeting when this shift back happens, you would\nneed to explicitly say which of the 2:30 AM you precisely mean.\nApplications that are date and time sensitive, need to take\nthese scenarios into account and correctly communicate them to\nusers.\n\nThe good news is: Elixir contains all of the building blocks\nnecessary to tackle those problems. The default timezone database\nused by Elixir, `Calendar.UTCOnlyTimeZoneDatabase`, only works\nwith UTC, which does not observe those issues. Once you bring\na proper time zone database, the functions in this module will\nquery the database and return the relevant information. For\nexample, look at how `DateTime.new/4` returns different results\nbased on the scenarios described in this section.\n","title":"DateTime","type":"module"},{"doc":"Adds a specified amount of time to a DateTime . Accepts an amount_to_add in any unit . unit can be :day , :hour , :minute , :second or any subsecond precision from System.time_unit/0 . It defaults to :second . Negative values will move backwards in time. This function always consider the unit to be computed according to the Calendar.ISO . This function uses relies on a contiguous representation of time, ignoring the wall time and timezone changes. For example, if you add one day when there are summer time/daylight saving time changes, it will also change the time forward or backward by one hour, so the elapsed time is precisely 24 hours. Similarly, adding just a few seconds to a datetime just before &quot;spring forward&quot; can cause wall time to increase by more than an hour. While this means this function is precise in terms of elapsed time, its result may be misleading in certain use cases. For example, if a user requests a meeting to happen every day at 15:00 and you use this function to compute all future meetings by adding day after day, this function may change the meeting time to 14:00 or 16:00 if there are changes to the current timezone. Computing of recurring datetimes is not currently supported in Elixir's standard library but it is available by third-party libraries. Examples iex&gt; dt = DateTime . from_naive! ( ~N[2018-11-15 10:00:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; dt |&gt; DateTime . add ( 3600 , :second , FakeTimeZoneDatabase ) # DateTime &lt; 2018 - 11 - 15 11 : 00 : 00 + 01 : 00 CET Europe / Copenhagen &gt; iex&gt; DateTime . add ( ~U[2018-11-15 10:00:00Z] , 3600 , :second ) ~U[2018-11-15 11:00:00Z] When adding 3 seconds just before &quot;spring forward&quot; we go from 1:59:59 to 3:00:02: iex&gt; dt = DateTime . from_naive! ( ~N[2019-03-31 01:59:59.123] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; dt |&gt; DateTime . add ( 3 , :second , FakeTimeZoneDatabase ) # DateTime &lt; 2019 - 03 - 31 03 : 00 : 02.123 + 02 : 00 CEST Europe / Copenhagen &gt; When adding 1 day during &quot;spring forward&quot;, the hour also changes: iex&gt; dt = DateTime . from_naive! ( ~N[2019-03-31 01:00:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; dt |&gt; DateTime . add ( 1 , :day , FakeTimeZoneDatabase ) # DateTime &lt; 2019 - 04 - 01 02 : 00 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; This operation merges the precision of the naive date time with the given unit: iex&gt; result = DateTime . add ( ~U[2014-10-02 00:29:10Z] , 21 , :millisecond ) ~U[2014-10-02 00:29:10.021Z] iex&gt; result . microsecond { 21000 , 3 }","ref":"DateTime.html#add/4","source_doc":"Adds a specified amount of time to a `DateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nThis function uses relies on a contiguous representation of time,\nignoring the wall time and timezone changes. For example, if you add\none day when there are summer time/daylight saving time changes,\nit will also change the time forward or backward by one hour,\nso the elapsed time is precisely 24 hours. Similarly, adding just\na few seconds to a datetime just before \"spring forward\" can cause\nwall time to increase by more than an hour.\n\nWhile this means this function is precise in terms of elapsed time,\nits result may be misleading in certain use cases. For example, if a\nuser requests a meeting to happen every day at 15:00 and you use this\nfunction to compute all future meetings by adding day after day, this\nfunction may change the meeting time to 14:00 or 16:00 if there are\nchanges to the current timezone. Computing of recurring datetimes is\nnot currently supported in Elixir's standard library but it is available\nby third-party libraries.\n\n### Examples\n\n    iex> dt = DateTime.from_naive!(~N[2018-11-15 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3600, :second, FakeTimeZoneDatabase)\n    #DateTime<2018-11-15 11:00:00+01:00 CET Europe/Copenhagen>\n\n    iex> DateTime.add(~U[2018-11-15 10:00:00Z], 3600, :second)\n    ~U[2018-11-15 11:00:00Z]\n\nWhen adding 3 seconds just before \"spring forward\" we go from 1:59:59 to 3:00:02:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:59:59.123], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(3, :second, FakeTimeZoneDatabase)\n    #DateTime<2019-03-31 03:00:02.123+02:00 CEST Europe/Copenhagen>\n\nWhen adding 1 day during \"spring forward\", the hour also changes:\n\n    iex> dt = DateTime.from_naive!(~N[2019-03-31 01:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> dt |> DateTime.add(1, :day, FakeTimeZoneDatabase)\n    #DateTime<2019-04-01 02:00:00+02:00 CEST Europe/Copenhagen>\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = DateTime.add(~U[2014-10-02 00:29:10Z], 21, :millisecond)\n    ~U[2014-10-02 00:29:10.021Z]\n    iex> result.microsecond\n    {21000, 3}\n\n","title":"DateTime.add/4","type":"function"},{"doc":"Returns true if the first datetime is strictly later than the second. Examples iex&gt; DateTime . after? ( ~U[2022-02-02 11:00:00Z] , ~U[2021-01-01 11:00:00Z] ) true iex&gt; DateTime . after? ( ~U[2021-01-01 11:00:00Z] , ~U[2021-01-01 11:00:00Z] ) false iex&gt; DateTime . after? ( ~U[2021-01-01 11:00:00Z] , ~U[2022-02-02 11:00:00Z] ) false","ref":"DateTime.html#after?/2","source_doc":"Returns true if the first datetime is strictly later than the second.\n\n## Examples\n\n    iex> DateTime.after?(~U[2022-02-02 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    true\n    iex> DateTime.after?(~U[2021-01-01 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    false\n    iex> DateTime.after?(~U[2021-01-01 11:00:00Z], ~U[2022-02-02 11:00:00Z])\n    false\n\n","title":"DateTime.after?/2","type":"function"},{"doc":"Returns true if the first datetime is strictly earlier than the second. Examples iex&gt; DateTime . before? ( ~U[2021-01-01 11:00:00Z] , ~U[2022-02-02 11:00:00Z] ) true iex&gt; DateTime . before? ( ~U[2021-01-01 11:00:00Z] , ~U[2021-01-01 11:00:00Z] ) false iex&gt; DateTime . before? ( ~U[2022-02-02 11:00:00Z] , ~U[2021-01-01 11:00:00Z] ) false","ref":"DateTime.html#before?/2","source_doc":"Returns true if the first datetime is strictly earlier than the second.\n\n## Examples\n\n    iex> DateTime.before?(~U[2021-01-01 11:00:00Z], ~U[2022-02-02 11:00:00Z])\n    true\n    iex> DateTime.before?(~U[2021-01-01 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    false\n    iex> DateTime.before?(~U[2022-02-02 11:00:00Z], ~U[2021-01-01 11:00:00Z])\n    false\n\n","title":"DateTime.before?/2","type":"function"},{"doc":"Compares two datetime structs. Returns :gt if the first datetime is later than the second and :lt for vice versa. If the two datetimes are equal :eq is returned. Note that both UTC and Standard offsets will be taken into account when comparison is done. Examples iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; dt2 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . compare ( dt1 , dt2 ) :gt","ref":"DateTime.html#compare/2","source_doc":"Compares two datetime structs.\n\nReturns `:gt` if the first datetime is later than the second\nand `:lt` for vice versa. If the two datetimes are equal\n`:eq` is returned.\n\nNote that both UTC and Standard offsets will be taken into\naccount when comparison is done.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.compare(dt1, dt2)\n    :gt\n\n","title":"DateTime.compare/2","type":"function"},{"doc":"Converts a given datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an {:error, :incompatible_calendars} tuple is returned. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . convert ( dt1 , Calendar.Holocene ) { :ok , % DateTime { calendar : Calendar.Holocene , day : 29 , hour : 23 , microsecond : { 0 , 0 } , minute : 0 , month : 2 , second : 7 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; , utc_offset : - 14400 , year : 12000 , zone_abbr : &quot;AMT&quot; } }","ref":"DateTime.html#convert/2","source_doc":"Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert(dt1, Calendar.Holocene)\n    {:ok, %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n                    microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n                    time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n                    zone_abbr: \"AMT\"}}\n\n","title":"DateTime.convert/2","type":"function"},{"doc":"Converts a given datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an ArgumentError is raised. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . convert! ( dt1 , Calendar.Holocene ) % DateTime { calendar : Calendar.Holocene , day : 29 , hour : 23 , microsecond : { 0 , 0 } , minute : 0 , month : 2 , second : 7 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; , utc_offset : - 14400 , year : 12000 , zone_abbr : &quot;AMT&quot; }","ref":"DateTime.html#convert!/2","source_doc":"Converts a given `datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.convert!(dt1, Calendar.Holocene)\n    %DateTime{calendar: Calendar.Holocene, day: 29, hour: 23,\n              microsecond: {0, 0}, minute: 0, month: 2, second: 7, std_offset: 0,\n              time_zone: \"America/Manaus\", utc_offset: -14400, year: 12000,\n              zone_abbr: \"AMT\"}\n\n","title":"DateTime.convert!/2","type":"function"},{"doc":"Subtracts datetime2 from datetime1 . The answer can be returned in any :day , :hour , :minute , or any unit available from System.time_unit/0 . The unit is measured according to Calendar.ISO and defaults to :second . Fractional results are not supported and are truncated. Examples iex&gt; dt1 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; dt2 = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . diff ( dt1 , dt2 ) 18000 iex&gt; DateTime . diff ( dt2 , dt1 ) - 18000 iex&gt; DateTime . diff ( dt1 , dt2 , :hour ) 5 iex&gt; DateTime . diff ( dt2 , dt1 , :hour ) - 5","ref":"DateTime.html#diff/3","source_doc":"Subtracts `datetime2` from `datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.diff(dt1, dt2)\n    18000\n    iex> DateTime.diff(dt2, dt1)\n    -18000\n    iex> DateTime.diff(dt1, dt2, :hour)\n    5\n    iex> DateTime.diff(dt2, dt1, :hour)\n    -5\n\n","title":"DateTime.diff/3","type":"function"},{"doc":"Converts a number of gregorian seconds to a DateTime struct. The returned DateTime will have UTC timezone, if you want other timezone, please use DateTime.shift_zone/3 . Examples iex&gt; DateTime . from_gregorian_seconds ( 1 ) ~U[0000-01-01 00:00:01Z] iex&gt; DateTime . from_gregorian_seconds ( 63_755_511_991 , { 5000 , 3 } ) ~U[2020-05-01 00:26:31.005Z] iex&gt; DateTime . from_gregorian_seconds ( - 1 ) ~U[-0001-12-31 23:59:59Z]","ref":"DateTime.html#from_gregorian_seconds/3","source_doc":"Converts a number of gregorian seconds to a `DateTime` struct.\n\nThe returned `DateTime` will have `UTC` timezone, if you want other timezone, please use\n`DateTime.shift_zone/3`.\n\n## Examples\n\n    iex> DateTime.from_gregorian_seconds(1)\n    ~U[0000-01-01 00:00:01Z]\n    iex> DateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~U[2020-05-01 00:26:31.005Z]\n    iex> DateTime.from_gregorian_seconds(-1)\n    ~U[-0001-12-31 23:59:59Z]\n\n","title":"DateTime.from_gregorian_seconds/3","type":"function"},{"doc":"Parses the extended &quot;Date and time of day&quot; format described by ISO 8601:2019 . Since ISO 8601 does not include the proper time zone, the given string will be converted to UTC and its offset in seconds will be returned as part of this function. Therefore offset information must be present in the string. As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function. Note leap seconds are not supported by the built-in Calendar.ISO. Examples iex&gt; { :ok , datetime , 0 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07Z&quot; ) iex&gt; datetime ~U[2015-01-23 23:50:07Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123+02:30&quot; ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07,123+02:30&quot; ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z] iex&gt; { :ok , datetime , 0 } = DateTime . from_iso8601 ( &quot;-2015-01-23T23:50:07Z&quot; ) iex&gt; datetime ~U[-2015-01-23 23:50:07Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;-2015-01-23T23:50:07,123+02:30&quot; ) iex&gt; datetime ~U[-2015-01-23 21:20:07.123Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;20150123T235007.123+0230&quot; , :basic ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z] iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23P23:50:07&quot; ) { :error , :invalid_format } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07&quot; ) { :error , :missing_offset } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23 23:50:61&quot; ) { :error , :invalid_time } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-32 23:50:07&quot; ) { :error , :invalid_date } iex&gt; DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-00:00&quot; ) { :error , :invalid_format }","ref":"DateTime.html#from_iso8601/2","source_doc":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nSince ISO 8601 does not include the proper time zone, the given\nstring will be converted to UTC and its offset in seconds will be\nreturned as part of this function. Therefore offset information\nmust be present in the string.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 0} = DateTime.from_iso8601(\"-2015-01-23T23:50:07Z\")\n    iex> datetime\n    ~U[-2015-01-23 23:50:07Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"-2015-01-23T23:50:07,123+02:30\")\n    iex> datetime\n    ~U[-2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:error, :missing_offset}\n    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n\n","title":"DateTime.from_iso8601/2","type":"function"},{"doc":"Converts to ISO8601 specifying both a calendar and a mode. See from_iso8601/2 for more information. Examples iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;2015-01-23T23:50:07,123+02:30&quot; , Calendar.ISO , :extended ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z] iex&gt; { :ok , datetime , 9000 } = DateTime . from_iso8601 ( &quot;20150123T235007.123+0230&quot; , Calendar.ISO , :basic ) iex&gt; datetime ~U[2015-01-23 21:20:07.123Z]","ref":"DateTime.html#from_iso8601/3","source_doc":"Converts to ISO8601 specifying both a calendar and a mode.\n\nSee `from_iso8601/2` for more information.\n\n## Examples\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"2015-01-23T23:50:07,123+02:30\", Calendar.ISO, :extended)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n    iex> {:ok, datetime, 9000} = DateTime.from_iso8601(\"20150123T235007.123+0230\", Calendar.ISO, :basic)\n    iex> datetime\n    ~U[2015-01-23 21:20:07.123Z]\n\n","title":"DateTime.from_iso8601/3","type":"function"},{"doc":"Converts the given NaiveDateTime to DateTime . It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . from_naive ( ~N[2016-05-24 13:26:08.003] , &quot;Etc/UTC&quot; ) { :ok , ~U[2016-05-24 13:26:08.003Z] } When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned in a tuple. The first datetime is also the one which comes first chronologically, while the second one comes last. iex&gt; { :ambiguous , first_dt , second_dt } = DateTime . from_naive ( ~N[2018-10-28 02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; first_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; iex&gt; second_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 01 : 00 CET Europe / Copenhagen &gt; When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap. iex&gt; { :gap , just_before , just_after } = DateTime . from_naive ( ~N[2019-03-31 02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; just_before # DateTime &lt; 2019 - 03 - 31 01 : 59 : 59.999999 + 01 : 00 CET Europe / Copenhagen &gt; iex&gt; just_after # DateTime &lt; 2019 - 03 - 31 03 : 00 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone. iex&gt; { :ok , datetime } = DateTime . from_naive ( ~N[2018-07-28 12:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; datetime # DateTime &lt; 2018 - 07 - 28 12 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; This function accepts any map or struct that contains at least the same fields as a NaiveDateTime struct. The most common example of that is a DateTime . In this case the information about the time zone of that DateTime is completely ignored. This is the same principle as passing a DateTime to Date.to_iso8601/2 . Date.to_iso8601/2 extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others. This way if you have a DateTime in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a DateTime for 2018-08-24 10:00:00 in UTC you can do: iex&gt; cph_datetime = DateTime . from_naive! ( ~N[2018-08-24 10:00:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; { :ok , utc_datetime } = DateTime . from_naive ( cph_datetime , &quot;Etc/UTC&quot; , FakeTimeZoneDatabase ) iex&gt; utc_datetime ~U[2018-08-24 10:00:00Z] If instead you want a DateTime for the same point time in a different time zone see the DateTime.shift_zone/3 function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.","ref":"DateTime.html#from_naive/3","source_doc":"Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the `NaiveDateTime` in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.from_naive(~N[2018-10-28 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.from_naive(~N[2019-03-31 02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.from_naive(~N[2018-07-28 12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\nThis function accepts any map or struct that contains at least the same fields as a `NaiveDateTime`\nstruct. The most common example of that is a `DateTime`. In this case the information about the time\nzone of that `DateTime` is completely ignored. This is the same principle as passing a `DateTime` to\n`Date.to_iso8601/2`. `Date.to_iso8601/2` extracts only the date-specific fields (calendar, year,\nmonth and day) of the given structure and ignores all others.\n\nThis way if you have a `DateTime` in one time zone, you can get the same wall time in another time zone.\nFor instance if you have 2018-08-24 10:00:00 in Copenhagen and want a `DateTime` for 2018-08-24 10:00:00\nin UTC you can do:\n\n    iex> cph_datetime = DateTime.from_naive!(~N[2018-08-24 10:00:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> {:ok, utc_datetime} = DateTime.from_naive(cph_datetime, \"Etc/UTC\", FakeTimeZoneDatabase)\n    iex> utc_datetime\n    ~U[2018-08-24 10:00:00Z]\n\nIf instead you want a `DateTime` for the same point time in a different time zone see the\n`DateTime.shift_zone/3` function which would convert 2018-08-24 10:00:00 in Copenhagen\nto 2018-08-24 08:00:00 in UTC.\n","title":"DateTime.from_naive/3","type":"function"},{"doc":"Converts the given NaiveDateTime to DateTime . It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . from_naive! ( ~N[2016-05-24 13:26:08.003] , &quot;Etc/UTC&quot; ) ~U[2016-05-24 13:26:08.003Z] iex&gt; DateTime . from_naive! ( ~N[2018-05-24 13:26:08.003] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) # DateTime &lt; 2018 - 05 - 24 13 : 26 : 08.003 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#from_naive!/3","source_doc":"Converts the given `NaiveDateTime` to `DateTime`.\n\nIt expects a time zone to put the NaiveDateTime in.\nIf the time zone is \"Etc/UTC\", it always succeeds. Otherwise,\nthe NaiveDateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\n    iex> DateTime.from_naive!(~N[2018-05-24 13:26:08.003], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    #DateTime<2018-05-24 13:26:08.003+02:00 CEST Europe/Copenhagen>\n\n","title":"DateTime.from_naive!/3","type":"function"},{"doc":"Converts the given Unix time to DateTime . The integer can be given in different unit according to System.convert_time_unit/3 and it will be converted to microseconds internally. Up to 253402300799 seconds is supported. Unix times are always in UTC and therefore the DateTime will be returned in UTC. Examples iex&gt; { :ok , datetime } = DateTime . from_unix ( 1_464_096_368 ) iex&gt; datetime ~U[2016-05-24 13:26:08Z] iex&gt; { :ok , datetime } = DateTime . from_unix ( 1_432_560_368_868_569 , :microsecond ) iex&gt; datetime ~U[2015-05-25 13:26:08.868569Z] iex&gt; { :ok , datetime } = DateTime . from_unix ( 253_402_300_799 ) iex&gt; datetime ~U[9999-12-31 23:59:59Z] iex&gt; { :error , :invalid_unix_time } = DateTime . from_unix ( 253_402_300_800 ) The unit can also be an integer as in System.time_unit/0 : iex&gt; { :ok , datetime } = DateTime . from_unix ( 143_256_036_886_856 , 1024 ) iex&gt; datetime ~U[6403-03-17 07:05:22.320312Z] Negative Unix times are supported up to -377705116800 seconds: iex&gt; { :ok , datetime } = DateTime . from_unix ( - 377_705_116_800 ) iex&gt; datetime ~U[-9999-01-01 00:00:00Z] iex&gt; { :error , :invalid_unix_time } = DateTime . from_unix ( - 377_705_116_801 )","ref":"DateTime.html#from_unix/3","source_doc":"Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally. Up to\n253402300799 seconds is supported.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.\n\n## Examples\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_464_096_368)\n    iex> datetime\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(1_432_560_368_868_569, :microsecond)\n    iex> datetime\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> {:ok, datetime} = DateTime.from_unix(253_402_300_799)\n    iex> datetime\n    ~U[9999-12-31 23:59:59Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(253_402_300_800)\n\nThe unit can also be an integer as in `t:System.time_unit/0`:\n\n    iex> {:ok, datetime} = DateTime.from_unix(143_256_036_886_856, 1024)\n    iex> datetime\n    ~U[6403-03-17 07:05:22.320312Z]\n\nNegative Unix times are supported up to -377705116800 seconds:\n\n    iex> {:ok, datetime} = DateTime.from_unix(-377_705_116_800)\n    iex> datetime\n    ~U[-9999-01-01 00:00:00Z]\n\n    iex> {:error, :invalid_unix_time} = DateTime.from_unix(-377_705_116_801)\n\n","title":"DateTime.from_unix/3","type":"function"},{"doc":"Converts the given Unix time to DateTime . The integer can be given in different unit according to System.convert_time_unit/3 and it will be converted to microseconds internally. Unix times are always in UTC and therefore the DateTime will be returned in UTC. Examples # An easy way to get the Unix epoch is passing 0 to this function iex&gt; DateTime . from_unix! ( 0 ) ~U[1970-01-01 00:00:00Z] iex&gt; DateTime . from_unix! ( 1_464_096_368 ) ~U[2016-05-24 13:26:08Z] iex&gt; DateTime . from_unix! ( 1_432_560_368_868_569 , :microsecond ) ~U[2015-05-25 13:26:08.868569Z] iex&gt; DateTime . from_unix! ( 143_256_036_886_856 , 1024 ) ~U[6403-03-17 07:05:22.320312Z]","ref":"DateTime.html#from_unix!/3","source_doc":"Converts the given Unix time to `DateTime`.\n\nThe integer can be given in different unit\naccording to `System.convert_time_unit/3` and it will\nbe converted to microseconds internally.\n\nUnix times are always in UTC and therefore the DateTime\nwill be returned in UTC.\n\n## Examples\n\n    # An easy way to get the Unix epoch is passing 0 to this function\n    iex> DateTime.from_unix!(0)\n    ~U[1970-01-01 00:00:00Z]\n\n    iex> DateTime.from_unix!(1_464_096_368)\n    ~U[2016-05-24 13:26:08Z]\n\n    iex> DateTime.from_unix!(1_432_560_368_868_569, :microsecond)\n    ~U[2015-05-25 13:26:08.868569Z]\n\n    iex> DateTime.from_unix!(143_256_036_886_856, 1024)\n    ~U[6403-03-17 07:05:22.320312Z]\n\n","title":"DateTime.from_unix!/3","type":"function"},{"doc":"Builds a datetime from date and time structs. It expects a time zone to put the DateTime in. If the time zone is not passed it will default to &quot;Etc/UTC&quot; , which always succeeds. Otherwise, the DateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . new ( ~D[2016-05-24] , ~T[13:26:08.003] , &quot;Etc/UTC&quot; ) { :ok , ~U[2016-05-24 13:26:08.003Z] } When the datetime is ambiguous - for instance during changing from summer to winter time - the two possible valid datetimes are returned in a tuple. The first datetime is also the one which comes first chronologically, while the second one comes last. iex&gt; { :ambiguous , first_dt , second_dt } = DateTime . new ( ~D[2018-10-28] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; first_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; iex&gt; second_dt # DateTime &lt; 2018 - 10 - 28 02 : 30 : 00 + 01 : 00 CET Europe / Copenhagen &gt; When there is a gap in wall time - for instance in spring when the clocks are turned forward - the latest valid datetime just before the gap and the first valid datetime just after the gap. iex&gt; { :gap , just_before , just_after } = DateTime . new ( ~D[2019-03-31] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; just_before # DateTime &lt; 2019 - 03 - 31 01 : 59 : 59.999999 + 01 : 00 CET Europe / Copenhagen &gt; iex&gt; just_after # DateTime &lt; 2019 - 03 - 31 03 : 00 : 00 + 02 : 00 CEST Europe / Copenhagen &gt; Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone. iex&gt; { :ok , datetime } = DateTime . new ( ~D[2018-07-28] , ~T[12:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; datetime # DateTime &lt; 2018 - 07 - 28 12 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#new/4","source_doc":"Builds a datetime from date and time structs.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the `DateTime` is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.new(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    {:ok, ~U[2016-05-24 13:26:08.003Z]}\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - the two possible valid datetimes are returned in a tuple.\nThe first datetime is also the one which comes first chronologically, while\nthe second one comes last.\n\n    iex> {:ambiguous, first_dt, second_dt} = DateTime.new(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> first_dt\n    #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen>\n    iex> second_dt\n    #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - the latest valid datetime just before the gap and the first\nvalid datetime just after the gap.\n\n    iex> {:gap, just_before, just_after} = DateTime.new(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> just_before\n    #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen>\n    iex> just_after\n    #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> {:ok, datetime} = DateTime.new(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\n","title":"DateTime.new/4","type":"function"},{"doc":"Builds a datetime from date and time structs, raising on errors. It expects a time zone to put the DateTime in. If the time zone is not passed it will default to &quot;Etc/UTC&quot; , which always succeeds. Otherwise, the DateTime is checked against the time zone database given as time_zone_database . See the &quot;Time zone database&quot; section in the module documentation. Examples iex&gt; DateTime . new! ( ~D[2016-05-24] , ~T[13:26:08.003] , &quot;Etc/UTC&quot; ) ~U[2016-05-24 13:26:08.003Z] When the datetime is ambiguous - for instance during changing from summer to winter time - an error will be raised. iex&gt; DateTime . new! ( ~D[2018-10-28] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime&lt;2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen&gt; and #DateTime&lt;2018-10-28 02:30:00+01:00 CET Europe/Copenhagen&gt; When there is a gap in wall time - for instance in spring when the clocks are turned forward - an error will be raised. iex&gt; DateTime . new! ( ~D[2019-03-31] , ~T[02:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime&lt;2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen&gt; and #DateTime&lt;2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen&gt; Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone. iex&gt; datetime = DateTime . new! ( ~D[2018-07-28] , ~T[12:30:00] , &quot;Europe/Copenhagen&quot; , FakeTimeZoneDatabase ) iex&gt; datetime # DateTime &lt; 2018 - 07 - 28 12 : 30 : 00 + 02 : 00 CEST Europe / Copenhagen &gt;","ref":"DateTime.html#new!/4","source_doc":"Builds a datetime from date and time structs, raising on errors.\n\nIt expects a time zone to put the `DateTime` in.\nIf the time zone is not passed it will default to `\"Etc/UTC\"`,\nwhich always succeeds. Otherwise, the DateTime is checked against the time zone database\ngiven as `time_zone_database`. See the \"Time zone database\"\nsection in the module documentation.\n\n## Examples\n\n    iex> DateTime.new!(~D[2016-05-24], ~T[13:26:08.003], \"Etc/UTC\")\n    ~U[2016-05-24 13:26:08.003Z]\n\nWhen the datetime is ambiguous - for instance during changing from summer\nto winter time - an error will be raised.\n\n    iex> DateTime.new!(~D[2018-10-28], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2018-10-28] and ~T[02:30:00] because such instant is ambiguous in time zone Europe/Copenhagen as there is an overlap between #DateTime<2018-10-28 02:30:00+02:00 CEST Europe/Copenhagen> and #DateTime<2018-10-28 02:30:00+01:00 CET Europe/Copenhagen>\n\nWhen there is a gap in wall time - for instance in spring when the clocks are\nturned forward - an error will be raised.\n\n    iex> DateTime.new!(~D[2019-03-31], ~T[02:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot build datetime with ~D[2019-03-31] and ~T[02:30:00] because such instant does not exist in time zone Europe/Copenhagen as there is a gap between #DateTime<2019-03-31 01:59:59.999999+01:00 CET Europe/Copenhagen> and #DateTime<2019-03-31 03:00:00+02:00 CEST Europe/Copenhagen>\n\nMost of the time there is one, and just one, valid datetime for a certain\ndate and time in a certain time zone.\n\n    iex> datetime = DateTime.new!(~D[2018-07-28], ~T[12:30:00], \"Europe/Copenhagen\", FakeTimeZoneDatabase)\n    iex> datetime\n    #DateTime<2018-07-28 12:30:00+02:00 CEST Europe/Copenhagen>\n\n","title":"DateTime.new!/4","type":"function"},{"doc":"Returns the current datetime in the provided time zone. By default, it uses the default time_zone returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes. Other time zone databases can be passed as argument or set globally. See the &quot;Time zone database&quot; section in the module docs. Examples iex&gt; { :ok , datetime } = DateTime . now ( &quot;Etc/UTC&quot; ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot; iex&gt; DateTime . now ( &quot;Europe/Copenhagen&quot; ) { :error , :utc_only_time_zone_database } iex&gt; DateTime . now ( &quot;bad timezone&quot; , FakeTimeZoneDatabase ) { :error , :time_zone_not_found }","ref":"DateTime.html#now/2","source_doc":"Returns the current datetime in the provided time zone.\n\nBy default, it uses the default time_zone returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.\n\n## Examples\n\n    iex> {:ok, datetime} = DateTime.now(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now(\"Europe/Copenhagen\")\n    {:error, :utc_only_time_zone_database}\n\n    iex> DateTime.now(\"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}\n\n","title":"DateTime.now/2","type":"function"},{"doc":"Returns the current datetime in the provided time zone or raises on errors See now/2 for more information. Examples iex&gt; datetime = DateTime . now! ( &quot;Etc/UTC&quot; ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot; iex&gt; DateTime . now! ( &quot;Europe/Copenhagen&quot; ) ** (ArgumentError) cannot get current datetime in &quot;Europe/Copenhagen&quot; time zone, reason: :utc_only_time_zone_database iex&gt; DateTime . now! ( &quot;bad timezone&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot get current datetime in &quot;bad timezone&quot; time zone, reason: :time_zone_not_found","ref":"DateTime.html#now!/2","source_doc":"Returns the current datetime in the provided time zone or raises on errors\n\nSee `now/2` for more information.\n\n## Examples\n\n    iex> datetime = DateTime.now!(\"Etc/UTC\")\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> DateTime.now!(\"Europe/Copenhagen\")\n    ** (ArgumentError) cannot get current datetime in \"Europe/Copenhagen\" time zone, reason: :utc_only_time_zone_database\n\n    iex> DateTime.now!(\"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot get current datetime in \"bad timezone\" time zone, reason: :time_zone_not_found\n\n","title":"DateTime.now!/2","type":"function"},{"doc":"Changes the time zone of a DateTime . Returns a DateTime for the same point in time, but instead at the time zone provided. It assumes that DateTime is valid and exists in the given time zone and calendar. By default, it uses the default time zone database returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase which only handles &quot;Etc/UTC&quot; datetimes. Other time zone databases can be passed as argument or set globally. See the &quot;Time zone database&quot; section in the module docs. Examples iex&gt; { :ok , pacific_datetime } = DateTime . shift_zone ( ~U[2018-07-16 10:00:00Z] , &quot;America/Los_Angeles&quot; , FakeTimeZoneDatabase ) iex&gt; pacific_datetime # DateTime &lt; 2018 - 07 - 16 03 : 00 : 00 - 07 : 00 PDT America / Los_Angeles &gt; iex&gt; DateTime . shift_zone ( ~U[2018-07-16 10:00:00Z] , &quot;bad timezone&quot; , FakeTimeZoneDatabase ) { :error , :time_zone_not_found }","ref":"DateTime.html#shift_zone/3","source_doc":"Changes the time zone of a `DateTime`.\n\nReturns a `DateTime` for the same point in time, but instead at\nthe time zone provided. It assumes that `DateTime` is valid and\nexists in the given time zone and calendar.\n\nBy default, it uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase` which only handles \"Etc/UTC\" datetimes.\nOther time zone databases can be passed as argument or set globally.\nSee the \"Time zone database\" section in the module docs.\n\n## Examples\n\n    iex> {:ok, pacific_datetime} = DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    iex> pacific_datetime\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    {:error, :time_zone_not_found}\n\n","title":"DateTime.shift_zone/3","type":"function"},{"doc":"Changes the time zone of a DateTime or raises on errors. See shift_zone/3 for more information. Examples iex&gt; DateTime . shift_zone! ( ~U[2018-07-16 10:00:00Z] , &quot;America/Los_Angeles&quot; , FakeTimeZoneDatabase ) # DateTime &lt; 2018 - 07 - 16 03 : 00 : 00 - 07 : 00 PDT America / Los_Angeles &gt; iex&gt; DateTime . shift_zone! ( ~U[2018-07-16 10:00:00Z] , &quot;bad timezone&quot; , FakeTimeZoneDatabase ) ** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to &quot;bad timezone&quot; time zone, reason: :time_zone_not_found","ref":"DateTime.html#shift_zone!/3","source_doc":"Changes the time zone of a `DateTime` or raises on errors.\n\nSee `shift_zone/3` for more information.\n\n## Examples\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"America/Los_Angeles\", FakeTimeZoneDatabase)\n    #DateTime<2018-07-16 03:00:00-07:00 PDT America/Los_Angeles>\n\n    iex> DateTime.shift_zone!(~U[2018-07-16 10:00:00Z], \"bad timezone\", FakeTimeZoneDatabase)\n    ** (ArgumentError) cannot shift ~U[2018-07-16 10:00:00Z] to \"bad timezone\" time zone, reason: :time_zone_not_found\n\n","title":"DateTime.shift_zone!/3","type":"function"},{"doc":"Converts a DateTime into a Date . Because Date does not hold time nor time zone information, data will be lost during the conversion. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_date ( dt ) ~D[2000-02-29]","ref":"DateTime.html#to_date/1","source_doc":"Converts a `DateTime` into a `Date`.\n\nBecause `Date` does not hold time nor time zone information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_date(dt)\n    ~D[2000-02-29]\n\n","title":"DateTime.to_date/1","type":"function"},{"doc":"Converts a DateTime struct to a number of gregorian seconds and microseconds. Examples iex&gt; dt = % DateTime { year : 0000 , month : 1 , day : 1 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 0 , minute : 0 , second : 1 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_gregorian_seconds ( dt ) { 1 , 0 } iex&gt; dt = % DateTime { year : 2020 , month : 5 , day : 1 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 0 , minute : 26 , second : 31 , microsecond : { 5000 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_gregorian_seconds ( dt ) { 63_755_511_991 , 5000 } iex&gt; dt = % DateTime { year : 2020 , month : 5 , day : 1 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 1 , minute : 26 , second : 31 , microsecond : { 5000 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_gregorian_seconds ( dt ) { 63_755_511_991 , 5000 }","ref":"DateTime.html#to_gregorian_seconds/1","source_doc":"Converts a `DateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> dt = %DateTime{year: 0000, month: 1, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 0, second: 1, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {1, 0}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"UTC\",\n    ...>                hour: 0, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}\n\n    iex> dt = %DateTime{year: 2020, month: 5, day: 1, zone_abbr: \"CET\",\n    ...>                hour: 1, minute: 26, second: 31, microsecond: {5000, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_gregorian_seconds(dt)\n    {63_755_511_991, 5000}\n\n","title":"DateTime.to_gregorian_seconds/1","type":"function"},{"doc":"Converts the given datetime to ISO 8601:2019 format. By default, DateTime.to_iso8601/2 returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise. You can also optionally specify an offset for the formatted string. WARNING: the ISO 8601 datetime format does not contain the time zone nor its abbreviation, which means information is lost when converting to such format. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_iso8601 ( dt ) &quot;2000-02-29T23:00:07+01:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_iso8601 ( dt ) &quot;2000-02-29T23:00:07Z&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended ) &quot;2000-02-29T23:00:07-04:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :basic ) &quot;20000229T230007-0400&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended , 3600 ) &quot;2000-03-01T04:00:07+01:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended , 0 ) &quot;2000-03-01T03:00:07+00:00&quot; iex&gt; dt = % DateTime { year : 2000 , month : 3 , day : 01 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 03 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_iso8601 ( dt , :extended , 0 ) &quot;2000-03-01T03:00:07Z&quot; iex&gt; { :ok , dt , offset } = DateTime . from_iso8601 ( &quot;2000-03-01T03:00:07Z&quot; ) iex&gt; &quot;2000-03-01T03:00:07Z&quot; = DateTime . to_iso8601 ( dt , :extended , offset )","ref":"DateTime.html#to_iso8601/3","source_doc":"Converts the given datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601) format.\n\nBy default, `DateTime.to_iso8601/2` returns datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting datetimes which are in the ISO calendar,\nattempting to convert datetimes from other calendars will raise.\nYou can also optionally specify an offset for the formatted string.\n\nWARNING: the ISO 8601 datetime format does not contain the time zone nor\nits abbreviation, which means information is lost when converting to such\nformat.\n\n### Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended)\n    \"2000-02-29T23:00:07-04:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :basic)\n    \"20000229T230007-0400\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 3600)\n    \"2000-03-01T04:00:07+01:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07+00:00\"\n\n    iex> dt = %DateTime{year: 2000, month: 3, day: 01, zone_abbr: \"UTC\",\n    ...>                hour: 03, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_iso8601(dt, :extended, 0)\n    \"2000-03-01T03:00:07Z\"\n\n    iex> {:ok, dt, offset} = DateTime.from_iso8601(\"2000-03-01T03:00:07Z\")\n    iex> \"2000-03-01T03:00:07Z\" = DateTime.to_iso8601(dt, :extended, offset)\n","title":"DateTime.to_iso8601/3","type":"function"},{"doc":"Converts the given datetime into a NaiveDateTime . Because NaiveDateTime does not hold time zone information, any time zone related data will be lost during the conversion. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 1 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_naive ( dt ) ~N[2000-02-29 23:00:07.0]","ref":"DateTime.html#to_naive/1","source_doc":"Converts the given `datetime` into a `NaiveDateTime`.\n\nBecause `NaiveDateTime` does not hold time zone information,\nany time zone related data will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_naive(dt)\n    ~N[2000-02-29 23:00:07.0]\n\n","title":"DateTime.to_naive/1","type":"function"},{"doc":"Converts the given datetime to a string according to its calendar. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_string ( dt ) &quot;2000-02-29 23:00:07+01:00 CET Europe/Warsaw&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;UTC&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 0 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; } iex&gt; DateTime . to_string ( dt ) &quot;2000-02-29 23:00:07Z&quot; iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;AMT&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : - 14400 , std_offset : 0 , time_zone : &quot;America/Manaus&quot; } iex&gt; DateTime . to_string ( dt ) &quot;2000-02-29 23:00:07-04:00 AMT America/Manaus&quot; iex&gt; dt = % DateTime { year : - 100 , month : 12 , day : 19 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 3 , minute : 20 , second : 31 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Stockholm&quot; } iex&gt; DateTime . to_string ( dt ) &quot;-0100-12-19 03:20:31+01:00 CET Europe/Stockholm&quot;","ref":"DateTime.html#to_string/1","source_doc":"Converts the given `datetime` to a string according to its calendar.\n\n### Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07Z\"\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n    iex> DateTime.to_string(dt)\n    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n\n    iex> dt = %DateTime{year: -100, month: 12, day: 19, zone_abbr: \"CET\",\n    ...>                hour: 3, minute: 20, second: 31, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Stockholm\"}\n    iex> DateTime.to_string(dt)\n    \"-0100-12-19 03:20:31+01:00 CET Europe/Stockholm\"\n\n","title":"DateTime.to_string/1","type":"function"},{"doc":"Converts a DateTime into Time . Because Time does not hold date nor time zone information, data will be lost during the conversion. Examples iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 1 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; DateTime . to_time ( dt ) ~T[23:00:07.0]","ref":"DateTime.html#to_time/1","source_doc":"Converts a `DateTime` into `Time`.\n\nBecause `Time` does not hold date nor time zone information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> DateTime.to_time(dt)\n    ~T[23:00:07.0]\n\n","title":"DateTime.to_time/1","type":"function"},{"doc":"Converts the given datetime to Unix time. The datetime is expected to be using the ISO calendar with a year greater than or equal to 0. It will return the integer with the given unit, according to System.convert_time_unit/3 . Examples iex&gt; 1_464_096_368 |&gt; DateTime . from_unix! ( ) |&gt; DateTime . to_unix ( ) 1464096368 iex&gt; dt = % DateTime { calendar : Calendar.ISO , day : 20 , hour : 18 , microsecond : { 273806 , 6 } , ...&gt; minute : 58 , month : 11 , second : 19 , time_zone : &quot;America/Montevideo&quot; , ...&gt; utc_offset : - 10800 , std_offset : 3600 , year : 2014 , zone_abbr : &quot;UYST&quot; } iex&gt; DateTime . to_unix ( dt ) 1416517099 iex&gt; flamel = % DateTime { calendar : Calendar.ISO , day : 22 , hour : 8 , microsecond : { 527771 , 6 } , ...&gt; minute : 2 , month : 3 , second : 25 , std_offset : 0 , time_zone : &quot;Etc/UTC&quot; , ...&gt; utc_offset : 0 , year : 1418 , zone_abbr : &quot;UTC&quot; } iex&gt; DateTime . to_unix ( flamel ) - 17412508655","ref":"DateTime.html#to_unix/2","source_doc":"Converts the given `datetime` to Unix time.\n\nThe `datetime` is expected to be using the ISO calendar\nwith a year greater than or equal to 0.\n\nIt will return the integer with the given unit,\naccording to `System.convert_time_unit/3`.\n\n## Examples\n\n    iex> 1_464_096_368 |> DateTime.from_unix!() |> DateTime.to_unix()\n    1464096368\n\n    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},\n    ...>                minute: 58, month: 11, second: 19, time_zone: \"America/Montevideo\",\n    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: \"UYST\"}\n    iex> DateTime.to_unix(dt)\n    1416517099\n\n    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, microsecond: {527771, 6},\n    ...>                minute: 2, month: 3, second: 25, std_offset: 0, time_zone: \"Etc/UTC\",\n    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n    iex> DateTime.to_unix(flamel)\n    -17412508655\n\n","title":"DateTime.to_unix/2","type":"function"},{"doc":"Returns the given datetime with the microsecond field truncated to the given precision ( :microsecond , :millisecond or :second ). The given datetime is returned unchanged if it already has lower precision than the given precision. Examples iex&gt; dt1 = % DateTime { year : 2017 , month : 11 , day : 7 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 11 , minute : 45 , second : 18 , microsecond : { 123456 , 6 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Paris&quot; } iex&gt; DateTime . truncate ( dt1 , :microsecond ) # DateTime &lt; 2017 - 11 - 07 11 : 45 : 18.123456 + 01 : 00 CET Europe / Paris &gt; iex&gt; dt2 = % DateTime { year : 2017 , month : 11 , day : 7 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 11 , minute : 45 , second : 18 , microsecond : { 123456 , 6 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Paris&quot; } iex&gt; DateTime . truncate ( dt2 , :millisecond ) # DateTime &lt; 2017 - 11 - 07 11 : 45 : 18.123 + 01 : 00 CET Europe / Paris &gt; iex&gt; dt3 = % DateTime { year : 2017 , month : 11 , day : 7 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 11 , minute : 45 , second : 18 , microsecond : { 123456 , 6 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Paris&quot; } iex&gt; DateTime . truncate ( dt3 , :second ) # DateTime &lt; 2017 - 11 - 07 11 : 45 : 18 + 01 : 00 CET Europe / Paris &gt;","ref":"DateTime.html#truncate/2","source_doc":"Returns the given datetime with the microsecond field truncated to the given\nprecision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given datetime is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> dt1 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt1, :microsecond)\n    #DateTime<2017-11-07 11:45:18.123456+01:00 CET Europe/Paris>\n\n    iex> dt2 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt2, :millisecond)\n    #DateTime<2017-11-07 11:45:18.123+01:00 CET Europe/Paris>\n\n    iex> dt3 = %DateTime{year: 2017, month: 11, day: 7, zone_abbr: \"CET\",\n    ...>                 hour: 11, minute: 45, second: 18, microsecond: {123456, 6},\n    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Paris\"}\n    iex> DateTime.truncate(dt3, :second)\n    #DateTime<2017-11-07 11:45:18+01:00 CET Europe/Paris>\n\n","title":"DateTime.truncate/2","type":"function"},{"doc":"Returns the current datetime in UTC. If you want the current time in Unix seconds, use System.os_time/1 instead. You can also pass a time unit to automatically truncate the resulting datetime. This is available since v1.15.0. Examples iex&gt; datetime = DateTime . utc_now ( ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot; iex&gt; datetime = DateTime . utc_now ( :second ) iex&gt; datetime . microsecond { 0 , 0 }","ref":"DateTime.html#utc_now/1","source_doc":"Returns the current datetime in UTC.\n\nIf you want the current time in Unix seconds,\nuse `System.os_time/1` instead.\n\nYou can also pass a time unit to automatically\ntruncate the resulting datetime. This is available\nsince v1.15.0.\n\n## Examples\n\n    iex> datetime = DateTime.utc_now()\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> datetime = DateTime.utc_now(:second)\n    iex> datetime.microsecond\n    {0, 0}\n\n","title":"DateTime.utc_now/1","type":"function"},{"doc":"Returns the current datetime in UTC, supporting a specific calendar and precision. If you want the current time in Unix seconds, use System.os_time/1 instead. Examples iex&gt; datetime = DateTime . utc_now ( :microsecond , Calendar.ISO ) iex&gt; datetime . time_zone &quot;Etc/UTC&quot; iex&gt; datetime = DateTime . utc_now ( :second , Calendar.ISO ) iex&gt; datetime . microsecond { 0 , 0 }","ref":"DateTime.html#utc_now/2","source_doc":"Returns the current datetime in UTC, supporting \na specific calendar and precision.\n\nIf you want the current time in Unix seconds,\nuse `System.os_time/1` instead.\n\n## Examples\n\n    iex> datetime = DateTime.utc_now(:microsecond, Calendar.ISO)\n    iex> datetime.time_zone\n    \"Etc/UTC\"\n\n    iex> datetime = DateTime.utc_now(:second, Calendar.ISO)\n    iex> datetime.microsecond\n    {0, 0}\n\n","title":"DateTime.utc_now/2","type":"function"},{"doc":"","ref":"DateTime.html#t:t/0","source_doc":false,"title":"DateTime.t/0","type":"type"},{"doc":"Functions to format throw/catch/exit and exceptions. Note that stacktraces in Elixir are only available inside catch and rescue by using the __STACKTRACE__/0 variable. Do not rely on the particular format returned by the format* functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.","ref":"Exception.html","source_doc":"Functions to format throw/catch/exit and exceptions.\n\nNote that stacktraces in Elixir are only available inside\ncatch and rescue by using the `__STACKTRACE__/0` variable.\n\nDo not rely on the particular format returned by the `format*`\nfunctions in this module. They may be changed in future releases\nin order to better suit Elixir's tool chain. In other words,\nby using the functions in this module it is guaranteed you will\nformat exceptions as in the current Elixir version being used.\n","title":"Exception","type":"behaviour"},{"doc":"Called from Exception.blame/3 to augment the exception struct. Can be used to collect additional information about the exception or do some additional expensive computation.","ref":"Exception.html#c:blame/2","source_doc":"Called from `Exception.blame/3` to augment the exception struct.\n\nCan be used to collect additional information about the exception\nor do some additional expensive computation.\n","title":"Exception.blame/2","type":"callback"},{"doc":"Attaches information to exceptions for extra debugging. This operation is potentially expensive, as it reads data from the file system, parses beam files, evaluates code and so on. If the exception module implements the optional blame/2 callback, it will be invoked to perform the computation.","ref":"Exception.html#blame/3","source_doc":"Attaches information to exceptions for extra debugging.\n\nThis operation is potentially expensive, as it reads data\nfrom the file system, parses beam files, evaluates code and\nso on.\n\nIf the exception module implements the optional `c:blame/2`\ncallback, it will be invoked to perform the computation.\n","title":"Exception.blame/3","type":"function"},{"doc":"Blames the invocation of the given module, function and arguments. This function will retrieve the available clauses from bytecode and evaluate them against the given arguments. The clauses are returned as a list of {args, guards} pairs where each argument and each top-level condition in a guard separated by and / or is wrapped in a tuple with blame metadata. This function returns either {:ok, definition, clauses} or :error . Where definition is :def , :defp , :defmacro or :defmacrop .","ref":"Exception.html#blame_mfa/3","source_doc":"Blames the invocation of the given module, function and arguments.\n\nThis function will retrieve the available clauses from bytecode\nand evaluate them against the given arguments. The clauses are\nreturned as a list of `{args, guards}` pairs where each argument\nand each top-level condition in a guard separated by `and`/`or`\nis wrapped in a tuple with blame metadata.\n\nThis function returns either `{:ok, definition, clauses}` or `:error`.\nWhere `definition` is `:def`, `:defp`, `:defmacro` or `:defmacrop`.\n","title":"Exception.blame_mfa/3","type":"function"},{"doc":"","ref":"Exception.html#c:exception/1","source_doc":false,"title":"Exception.exception/1","type":"callback"},{"doc":"Normalizes and formats throw/errors/exits and stacktraces. It relies on format_banner/3 and format_stacktrace/1 to generate the final format. If kind is {:EXIT, pid} , it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.","ref":"Exception.html#format/3","source_doc":"Normalizes and formats throw/errors/exits and stacktraces.\n\nIt relies on `format_banner/3` and `format_stacktrace/1`\nto generate the final format.\n\nIf `kind` is `{:EXIT, pid}`, it does not generate a stacktrace,\nas such exits are retrieved as messages without stacktraces.\n","title":"Exception.format/3","type":"function"},{"doc":"Normalizes and formats any throw/error/exit. The message is formatted and displayed in the same format as used by Elixir's CLI. The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.","ref":"Exception.html#format_banner/3","source_doc":"Normalizes and formats any throw/error/exit.\n\nThe message is formatted and displayed in the same\nformat as used by Elixir's CLI.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.\n","title":"Exception.format_banner/3","type":"function"},{"doc":"Formats an exit. It returns a string. Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.","ref":"Exception.html#format_exit/1","source_doc":"Formats an exit. It returns a string.\n\nOften there are errors/exceptions inside exits. Exits are often\nwrapped by the caller and provide stacktraces too. This function\nformats exits in a way to nicely show the exit reason, caller\nand stacktrace.\n","title":"Exception.format_exit/1","type":"function"},{"doc":"Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments. Examples Exception . format_fa ( fn -&gt; nil end , 1 ) #=&gt; &quot;#Function&lt;...&gt;/1&quot;","ref":"Exception.html#format_fa/2","source_doc":"Receives an anonymous function and arity and formats it as\nshown in stacktraces. The arity may also be a list of arguments.\n\n## Examples\n\n    Exception.format_fa(fn -> nil end, 1)\n    #=> \"#Function<...>/1\"\n\n","title":"Exception.format_fa/2","type":"function"},{"doc":"Formats the given file and line as shown in stacktraces. If any of the values are nil , they are omitted. Examples iex&gt; Exception . format_file_line ( &quot;foo&quot; , 1 ) &quot;foo:1:&quot; iex&gt; Exception . format_file_line ( &quot;foo&quot; , nil ) &quot;foo:&quot; iex&gt; Exception . format_file_line ( nil , nil ) &quot;&quot;","ref":"Exception.html#format_file_line/3","source_doc":"Formats the given `file` and `line` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.\n\n## Examples\n\n    iex> Exception.format_file_line(\"foo\", 1)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line(\"foo\", nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line(nil, nil)\n    \"\"\n\n","title":"Exception.format_file_line/3","type":"function"},{"doc":"Formats the given file , line , and column as shown in stacktraces. If any of the values are nil , they are omitted. Examples iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , 1 , 2 ) &quot;foo:1:2:&quot; iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , 1 , nil ) &quot;foo:1:&quot; iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , nil , nil ) &quot;foo:&quot; iex&gt; Exception . format_file_line_column ( &quot;foo&quot; , nil , 2 ) &quot;foo:&quot; iex&gt; Exception . format_file_line_column ( nil , nil , nil ) &quot;&quot;","ref":"Exception.html#format_file_line_column/4","source_doc":"Formats the given `file`, `line`, and `column` as shown in stacktraces.\n\nIf any of the values are `nil`, they are omitted.\n\n## Examples\n\n    iex> Exception.format_file_line_column(\"foo\", 1, 2)\n    \"foo:1:2:\"\n\n    iex> Exception.format_file_line_column(\"foo\", 1, nil)\n    \"foo:1:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, nil)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(\"foo\", nil, 2)\n    \"foo:\"\n\n    iex> Exception.format_file_line_column(nil, nil, nil)\n    \"\"\n\n","title":"Exception.format_file_line_column/4","type":"function"},{"doc":"Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments. Examples iex&gt; Exception . format_mfa ( Foo , :bar , 1 ) &quot;Foo.bar/1&quot; iex&gt; Exception . format_mfa ( Foo , :bar , [ ] ) &quot;Foo.bar()&quot; iex&gt; Exception . format_mfa ( nil , :bar , [ ] ) &quot;nil.bar()&quot; Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to &quot;anonymous fn in func/arity&quot;","ref":"Exception.html#format_mfa/3","source_doc":"Receives a module, fun and arity and formats it\nas shown in stacktraces. The arity may also be a list\nof arguments.\n\n## Examples\n\n    iex> Exception.format_mfa(Foo, :bar, 1)\n    \"Foo.bar/1\"\n\n    iex> Exception.format_mfa(Foo, :bar, [])\n    \"Foo.bar()\"\n\n    iex> Exception.format_mfa(nil, :bar, [])\n    \"nil.bar()\"\n\nAnonymous functions are reported as -func/arity-anonfn-count-,\nwhere func is the name of the enclosing function. Convert to\n\"anonymous fn in func/arity\"\n","title":"Exception.format_mfa/3","type":"function"},{"doc":"Formats the stacktrace. A stacktrace must be given as an argument. If not, the stacktrace is retrieved from Process.info/2 .","ref":"Exception.html#format_stacktrace/1","source_doc":"Formats the stacktrace.\n\nA stacktrace must be given as an argument. If not, the stacktrace\nis retrieved from `Process.info/2`.\n","title":"Exception.format_stacktrace/1","type":"function"},{"doc":"Receives a stacktrace entry and formats it into a string.","ref":"Exception.html#format_stacktrace_entry/1","source_doc":"Receives a stacktrace entry and formats it into a string.\n","title":"Exception.format_stacktrace_entry/1","type":"function"},{"doc":"Gets the message for an exception .","ref":"Exception.html#message/1","source_doc":"Gets the message for an `exception`.\n","title":"Exception.message/1","type":"function"},{"doc":"","ref":"Exception.html#c:message/1","source_doc":false,"title":"Exception.message/1","type":"callback"},{"doc":"Normalizes an exception, converting Erlang exceptions to Elixir exceptions. It takes the kind spilled by catch as an argument and normalizes only :error , returning the untouched payload for others. The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.","ref":"Exception.html#normalize/3","source_doc":"Normalizes an exception, converting Erlang exceptions\nto Elixir exceptions.\n\nIt takes the `kind` spilled by `catch` as an argument and\nnormalizes only `:error`, returning the untouched payload\nfor others.\n\nThe third argument is the stacktrace which is used to enrich\na normalized error with more information. It is only used when\nthe kind is an error.\n","title":"Exception.normalize/3","type":"function"},{"doc":"","ref":"Exception.html#t:arity_or_args/0","source_doc":false,"title":"Exception.arity_or_args/0","type":"type"},{"doc":"The kind handled by formatting functions","ref":"Exception.html#t:kind/0","source_doc":"The kind handled by formatting functions","title":"Exception.kind/0","type":"type"},{"doc":"","ref":"Exception.html#t:location/0","source_doc":false,"title":"Exception.location/0","type":"type"},{"doc":"","ref":"Exception.html#t:non_error_kind/0","source_doc":false,"title":"Exception.non_error_kind/0","type":"type"},{"doc":"","ref":"Exception.html#t:stacktrace/0","source_doc":false,"title":"Exception.stacktrace/0","type":"type"},{"doc":"","ref":"Exception.html#t:stacktrace_entry/0","source_doc":false,"title":"Exception.stacktrace_entry/0","type":"type"},{"doc":"The exception type","ref":"Exception.html#t:t/0","source_doc":"The exception type","title":"Exception.t/0","type":"type"},{"doc":"Functions for working with floating-point numbers. Kernel functions There are functions related to floating-point numbers on the Kernel module too. Here is a list of them: Kernel.round/1 : rounds a number to the nearest integer. Kernel.trunc/1 : returns the integer part of a number. Known issues There are some very well known problems with floating-point numbers and arithmetic due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself. For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case: The closest representable number to 0.1 is 0.1000000014 The closest representable number to 0.01 is 0.0099999997 Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014, the result is 0.010000000000000002, and because this is not the closest representable number to 0.01, you'll get the wrong result for this operation There are also other known problems like flooring or rounding numbers. See round/2 and floor/2 for more details about them. To learn more about floating-point arithmetic visit: 0.30000000000000004.com What Every Programmer Should Know About Floating-Point Arithmetic","ref":"Float.html","source_doc":"Functions for working with floating-point numbers.\n\n## Kernel functions\n\nThere are functions related to floating-point numbers on the `Kernel` module\ntoo. Here is a list of them:\n\n  * `Kernel.round/1`: rounds a number to the nearest integer.\n  * `Kernel.trunc/1`: returns the integer part of a number.\n\n## Known issues\n\nThere are some very well known problems with floating-point numbers\nand arithmetic due to the fact most decimal fractions cannot be\nrepresented by a floating-point binary and most operations are not exact,\nbut operate on approximations. Those issues are not specific\nto Elixir, they are a property of floating point representation itself.\n\nFor example, the numbers 0.1 and 0.01 are two of them, what means the result\nof squaring 0.1 does not give 0.01 neither the closest representable. Here is\nwhat happens in this case:\n\n  * The closest representable number to 0.1 is 0.1000000014\n  * The closest representable number to 0.01 is 0.0099999997\n  * Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014,\n    the result is 0.010000000000000002, and because this is not the closest\n    representable number to 0.01, you'll get the wrong result for this operation\n\nThere are also other known problems like flooring or rounding numbers. See\n`round/2` and `floor/2` for more details about them.\n\nTo learn more about floating-point arithmetic visit:\n\n  * [0.30000000000000004.com](http://0.30000000000000004.com/)\n  * [What Every Programmer Should Know About Floating-Point Arithmetic](https://floating-point-gui.de/)\n\n","title":"Float","type":"module"},{"doc":"Rounds a float to the smallest integer greater than or equal to num . ceil/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15). The operation is performed on the binary floating point, without a conversion to decimal. The behaviour of ceil/2 for floats can be surprising. For example: iex&gt; Float . ceil ( - 12.52 , 2 ) - 12.51 One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behaviour above. This function always returns floats. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards. Examples iex&gt; Float . ceil ( 34.25 ) 35.0 iex&gt; Float . ceil ( - 56.5 ) - 56.0 iex&gt; Float . ceil ( 34.251 , 2 ) 34.26","ref":"Float.html#ceil/2","source_doc":"Rounds a float to the smallest integer greater than or equal to `num`.\n\n`ceil/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\n\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThe behaviour of `ceil/2` for floats can be surprising. For example:\n\n    iex> Float.ceil(-12.52, 2)\n    -12.51\n\nOne may have expected it to ceil to -12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as -12.51999999,\nwhich explains the behaviour above.\n\nThis function always returns floats. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.\n\n## Examples\n\n    iex> Float.ceil(34.25)\n    35.0\n    iex> Float.ceil(-56.5)\n    -56.0\n    iex> Float.ceil(34.251, 2)\n    34.26\n\n","title":"Float.ceil/2","type":"function"},{"doc":"Rounds a float to the largest number less than or equal to num . floor/2 also accepts a precision to round a floating-point value down to an arbitrary number of fractional digits (between 0 and 15). The operation is performed on the binary floating point, without a conversion to decimal. This function always returns a float. Kernel.trunc/1 may be used instead to truncate the result to an integer afterwards. Known issues The behaviour of floor/2 for floats can be surprising. For example: iex&gt; Float . floor ( 12.52 , 2 ) 12.51 One may have expected it to floor to 12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 12.51999999, which explains the behaviour above. Examples iex&gt; Float . floor ( 34.25 ) 34.0 iex&gt; Float . floor ( - 56.5 ) - 57.0 iex&gt; Float . floor ( 34.259 , 2 ) 34.25","ref":"Float.html#floor/2","source_doc":"Rounds a float to the largest number less than or equal to `num`.\n\n`floor/2` also accepts a precision to round a floating-point value down\nto an arbitrary number of fractional digits (between 0 and 15).\nThe operation is performed on the binary floating point, without a\nconversion to decimal.\n\nThis function always returns a float. `Kernel.trunc/1` may be used instead to\ntruncate the result to an integer afterwards.\n\n## Known issues\n\nThe behaviour of `floor/2` for floats can be surprising. For example:\n\n    iex> Float.floor(12.52, 2)\n    12.51\n\nOne may have expected it to floor to 12.52. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 12.51999999,\nwhich explains the behaviour above.\n\n## Examples\n\n    iex> Float.floor(34.25)\n    34.0\n    iex> Float.floor(-56.5)\n    -57.0\n    iex> Float.floor(34.259, 2)\n    34.25\n\n","title":"Float.floor/2","type":"function"},{"doc":"Returns the maximum finite value for a float. Examples iex&gt; Float . max_finite ( ) 1.7976931348623157e308","ref":"Float.html#max_finite/0","source_doc":"Returns the maximum finite value for a float.\n\n## Examples\n\n    iex> Float.max_finite()\n    1.7976931348623157e308\n\n","title":"Float.max_finite/0","type":"function"},{"doc":"Returns the minimum finite value for a float. Examples iex&gt; Float . min_finite ( ) - 1.7976931348623157e308","ref":"Float.html#min_finite/0","source_doc":"Returns the minimum finite value for a float.\n\n## Examples\n\n    iex> Float.min_finite()\n    -1.7976931348623157e308\n\n","title":"Float.min_finite/0","type":"function"},{"doc":"Parses a binary into a float. If successful, returns a tuple in the form of {float, remainder_of_binary} ; when the binary cannot be coerced into a valid float, the atom :error is returned. If the size of float exceeds the maximum size of 1.7976931348623157e+308 , :error is returned even though the textual representation itself might be well formed. If you want to convert a string-formatted float directly to a float, String.to_float/1 can be used instead. Examples iex&gt; Float . parse ( &quot;34&quot; ) { 34.0 , &quot;&quot; } iex&gt; Float . parse ( &quot;34.25&quot; ) { 34.25 , &quot;&quot; } iex&gt; Float . parse ( &quot;56.5xyz&quot; ) { 56.5 , &quot;xyz&quot; } iex&gt; Float . parse ( &quot;pi&quot; ) :error iex&gt; Float . parse ( &quot;1.7976931348623159e+308&quot; ) :error","ref":"Float.html#parse/1","source_doc":"Parses a binary into a float.\n\nIf successful, returns a tuple in the form of `{float, remainder_of_binary}`;\nwhen the binary cannot be coerced into a valid float, the atom `:error` is\nreturned.\n\nIf the size of float exceeds the maximum size of `1.7976931348623157e+308`,\n`:error` is returned even though the textual representation itself might be\nwell formed.\n\nIf you want to convert a string-formatted float directly to a float,\n`String.to_float/1` can be used instead.\n\n## Examples\n\n    iex> Float.parse(\"34\")\n    {34.0, \"\"}\n    iex> Float.parse(\"34.25\")\n    {34.25, \"\"}\n    iex> Float.parse(\"56.5xyz\")\n    {56.5, \"xyz\"}\n\n    iex> Float.parse(\"pi\")\n    :error\n    iex> Float.parse(\"1.7976931348623159e+308\")\n    :error\n\n","title":"Float.parse/1","type":"function"},{"doc":"Computes base raised to power of exponent . base must be a float and exponent can be any number. However, if a negative base and a fractional exponent are given, it raises ArithmeticError . It always returns a float. See Integer.pow/2 for exponentiation that returns integers. Examples iex&gt; Float . pow ( 2.0 , 0 ) 1.0 iex&gt; Float . pow ( 2.0 , 1 ) 2.0 iex&gt; Float . pow ( 2.0 , 10 ) 1024.0 iex&gt; Float . pow ( 2.0 , - 1 ) 0.5 iex&gt; Float . pow ( 2.0 , - 3 ) 0.125 iex&gt; Float . pow ( 3.0 , 1.5 ) 5.196152422706632 iex&gt; Float . pow ( - 2.0 , 3 ) - 8.0 iex&gt; Float . pow ( - 2.0 , 4 ) 16.0 iex&gt; Float . pow ( - 1.0 , 0.5 ) ** (ArithmeticError) bad argument in arithmetic expression","ref":"Float.html#pow/2","source_doc":"Computes `base` raised to power of `exponent`.\n\n`base` must be a float and `exponent` can be any number.\nHowever, if a negative base and a fractional exponent\nare given, it raises `ArithmeticError`.\n\nIt always returns a float. See `Integer.pow/2` for\nexponentiation that returns integers.\n\n## Examples\n\n    iex> Float.pow(2.0, 0)\n    1.0\n    iex> Float.pow(2.0, 1)\n    2.0\n    iex> Float.pow(2.0, 10)\n    1024.0\n    iex> Float.pow(2.0, -1)\n    0.5\n    iex> Float.pow(2.0, -3)\n    0.125\n\n    iex> Float.pow(3.0, 1.5)\n    5.196152422706632\n\n    iex> Float.pow(-2.0, 3)\n    -8.0\n    iex> Float.pow(-2.0, 4)\n    16.0\n\n    iex> Float.pow(-1.0, 0.5)\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n","title":"Float.pow/2","type":"function"},{"doc":"Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator. Examples iex&gt; Float . ratio ( 0.0 ) { 0 , 1 } iex&gt; Float . ratio ( 3.14 ) { 7070651414971679 , 2251799813685248 } iex&gt; Float . ratio ( - 3.14 ) { - 7070651414971679 , 2251799813685248 } iex&gt; Float . ratio ( 1.5 ) { 3 , 2 } iex&gt; Float . ratio ( - 1.5 ) { - 3 , 2 } iex&gt; Float . ratio ( 16.0 ) { 16 , 1 } iex&gt; Float . ratio ( - 16.0 ) { - 16 , 1 }","ref":"Float.html#ratio/1","source_doc":"Returns a pair of integers whose ratio is exactly equal\nto the original float and with a positive denominator.\n\n## Examples\n\n    iex> Float.ratio(0.0)\n    {0, 1}\n    iex> Float.ratio(3.14)\n    {7070651414971679, 2251799813685248}\n    iex> Float.ratio(-3.14)\n    {-7070651414971679, 2251799813685248}\n    iex> Float.ratio(1.5)\n    {3, 2}\n    iex> Float.ratio(-1.5)\n    {-3, 2}\n    iex> Float.ratio(16.0)\n    {16, 1}\n    iex> Float.ratio(-16.0)\n    {-16, 1}\n\n","title":"Float.ratio/1","type":"function"},{"doc":"Rounds a floating-point value to an arbitrary number of fractional digits (between 0 and 15). The rounding direction always ties to half up. The operation is performed on the binary floating point, without a conversion to decimal. This function only accepts floats and always returns a float. Use Kernel.round/1 if you want a function that accepts both floats and integers and always returns an integer. Known issues The behaviour of round/2 for floats can be surprising. For example: iex&gt; Float . round ( 5.5675 , 3 ) 5.567 One may have expected it to round to the half up 5.568. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 5.567499999, which explains the behaviour above. If you want exact rounding for decimals, you must use a decimal library. The behaviour above is also in accordance to reference implementations, such as &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot; by David M. Gay. Examples iex&gt; Float . round ( 12.5 ) 13.0 iex&gt; Float . round ( 5.5674 , 3 ) 5.567 iex&gt; Float . round ( 5.5675 , 3 ) 5.567 iex&gt; Float . round ( - 5.5674 , 3 ) - 5.567 iex&gt; Float . round ( - 5.5675 ) - 6.0 iex&gt; Float . round ( 12.341444444444441 , 15 ) 12.341444444444441","ref":"Float.html#round/2","source_doc":"Rounds a floating-point value to an arbitrary number of fractional\ndigits (between 0 and 15).\n\nThe rounding direction always ties to half up. The operation is\nperformed on the binary floating point, without a conversion to decimal.\n\nThis function only accepts floats and always returns a float. Use\n`Kernel.round/1` if you want a function that accepts both floats\nand integers and always returns an integer.\n\n## Known issues\n\nThe behaviour of `round/2` for floats can be surprising. For example:\n\n    iex> Float.round(5.5675, 3)\n    5.567\n\nOne may have expected it to round to the half up 5.568. This is not a bug.\nMost decimal fractions cannot be represented as a binary floating point\nand therefore the number above is internally represented as 5.567499999,\nwhich explains the behaviour above. If you want exact rounding for decimals,\nyou must use a decimal library. The behaviour above is also in accordance\nto reference implementations, such as \"Correctly Rounded Binary-Decimal and\nDecimal-Binary Conversions\" by David M. Gay.\n\n## Examples\n\n    iex> Float.round(12.5)\n    13.0\n    iex> Float.round(5.5674, 3)\n    5.567\n    iex> Float.round(5.5675, 3)\n    5.567\n    iex> Float.round(-5.5674, 3)\n    -5.567\n    iex> Float.round(-5.5675)\n    -6.0\n    iex> Float.round(12.341444444444441, 15)\n    12.341444444444441\n\n","title":"Float.round/2","type":"function"},{"doc":"Returns a charlist which corresponds to the shortest text representation of the given float. The underlying algorithm changes depending on the Erlang/OTP version: For OTP &gt;= 24, it uses the algorithm presented in &quot;Ryū: fast float-to-string conversion&quot; in Proceedings of the SIGPLAN '2018 Conference on Programming Language Design and Implementation. For OTP &lt; 24, it uses the algorithm presented in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '1996 Conference on Programming Language Design and Implementation. For a configurable representation, use :erlang.float_to_list/2 . Examples iex&gt; Float . to_charlist ( 7.0 ) &#39;7.0&#39;","ref":"Float.html#to_charlist/1","source_doc":"Returns a charlist which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"Ryū: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_list/2`.\n\n## Examples\n\n    iex> Float.to_charlist(7.0)\n    '7.0'\n\n","title":"Float.to_charlist/1","type":"function"},{"doc":"Returns a binary which corresponds to the shortest text representation of the given float. The underlying algorithm changes depending on the Erlang/OTP version: For OTP &gt;= 24, it uses the algorithm presented in &quot;Ryū: fast float-to-string conversion&quot; in Proceedings of the SIGPLAN '2018 Conference on Programming Language Design and Implementation. For OTP &lt; 24, it uses the algorithm presented in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '1996 Conference on Programming Language Design and Implementation. For a configurable representation, use :erlang.float_to_binary/2 . Examples iex&gt; Float . to_string ( 7.0 ) &quot;7.0&quot;","ref":"Float.html#to_string/1","source_doc":"Returns a binary which corresponds to the shortest text representation\nof the given float.\n\nThe underlying algorithm changes depending on the Erlang/OTP version:\n\n  * For OTP >= 24, it uses the algorithm presented in \"Ryū: fast\n    float-to-string conversion\" in Proceedings of the SIGPLAN '2018\n    Conference on Programming Language Design and Implementation.\n\n  * For OTP < 24, it uses the algorithm presented in \"Printing Floating-Point\n    Numbers Quickly and Accurately\" in Proceedings of the SIGPLAN '1996\n    Conference on Programming Language Design and Implementation.\n\nFor a configurable representation, use `:erlang.float_to_binary/2`.\n\n## Examples\n\n    iex> Float.to_string(7.0)\n    \"7.0\"\n\n","title":"Float.to_string/1","type":"function"},{"doc":"","ref":"Float.html#t:precision_range/0","source_doc":false,"title":"Float.precision_range/0","type":"type"},{"doc":"A set of functions for working with functions. Anonymous functions are typically created by using fn : iex&gt; add = fn a , b -&gt; a + b end iex&gt; add . ( 1 , 2 ) 3 Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments: iex&gt; negate = fn ...&gt; true -&gt; false ...&gt; false -&gt; true ...&gt; end iex&gt; negate . ( false ) true The capture operator It is also possible to capture public module functions and pass them around as if they were anonymous functions by using the capture operator &amp;/1 : iex&gt; add = &amp; Kernel . + / 2 iex&gt; add . ( 1 , 2 ) 3 iex&gt; length = &amp; String . length / 1 iex&gt; length . ( &quot;hello&quot; ) 5 To capture a definition within the current module, you can skip the module prefix, such as &amp;my_fun/2 . In those cases, the captured function can be public ( def ) or private ( defp ). The capture operator can also be used to create anonymous functions that expect at least one argument: iex&gt; add = &amp; ( &amp;1 + &amp;2 ) iex&gt; add . ( 1 , 2 ) 3 In such cases, using the capture operator is no different than using fn . Internal and external functions We say that functions that point to definitions residing in modules, such as &amp;String.length/1 , are external functions. All other functions are local and they are always bound to the file or module that defined them. Besides the functions in this module to work with functions, Kernel also has an apply/2 function that invokes a function with a dynamic number of arguments, as well as is_function/1 and is_function/2 , to check respectively if a given value is a function or a function of a given arity.","ref":"Function.html","source_doc":"A set of functions for working with functions.\n\nAnonymous functions are typically created by using `fn`:\n\n    iex> add = fn a, b -> a + b end\n    iex> add.(1, 2)\n    3\n\nAnonymous functions can also have multiple clauses. All clauses\nshould expect the same number of arguments:\n\n    iex> negate = fn\n    ...>   true -> false\n    ...>   false -> true\n    ...> end\n    iex> negate.(false)\n    true\n\n## The capture operator\n\nIt is also possible to capture public module functions and pass them\naround as if they were anonymous functions by using the capture\noperator `&/1`:\n\n    iex> add = &Kernel.+/2\n    iex> add.(1, 2)\n    3\n\n    iex> length = &String.length/1\n    iex> length.(\"hello\")\n    5\n\nTo capture a definition within the current module, you can skip the\nmodule prefix, such as `&my_fun/2`. In those cases, the captured\nfunction can be public (`def`) or private (`defp`).\n\nThe capture operator can also be used to create anonymous functions\nthat expect at least one argument:\n\n    iex> add = &(&1 + &2)\n    iex> add.(1, 2)\n    3\n\nIn such cases, using the capture operator is no different than using `fn`.\n\n## Internal and external functions\n\nWe say that functions that point to definitions residing in modules, such\nas `&String.length/1`, are **external** functions. All other functions are\n**local** and they are always bound to the file or module that defined them.\n\nBesides the functions in this module to work with functions, `Kernel` also\nhas an `apply/2` function that invokes a function with a dynamic number of\narguments, as well as `is_function/1` and `is_function/2`, to check\nrespectively if a given value is a function or a function of a given arity.\n","title":"Function","type":"module"},{"doc":"Captures the given function. Inlined by the compiler. Examples iex&gt; Function . capture ( String , :length , 1 ) &amp; String . length / 1","ref":"Function.html#capture/3","source_doc":"Captures the given function.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Function.capture(String, :length, 1)\n    &String.length/1\n\n","title":"Function.capture/3","type":"function"},{"doc":"Returns its input value . This function can be passed as an anonymous function to transformation functions. Examples iex&gt; Function . identity ( &quot;Hello world!&quot; ) &quot;Hello world!&quot; iex&gt; ~c&quot;abcdaabccc&quot; |&gt; Enum . sort ( ) |&gt; Enum . chunk_by ( &amp; Function . identity / 1 ) [ ~c&quot;aaa&quot; , ~c&quot;bb&quot; , ~c&quot;cccc&quot; , ~c&quot;d&quot; ] iex&gt; Enum . group_by ( ~c&quot;abracadabra&quot; , &amp; Function . identity / 1 ) %{ 97 =&gt; ~c&quot;aaaaa&quot; , 98 =&gt; ~c&quot;bb&quot; , 99 =&gt; ~c&quot;c&quot; , 100 =&gt; ~c&quot;d&quot; , 114 =&gt; ~c&quot;rr&quot; } iex&gt; Enum . map ( [ 1 , 2 , 3 , 4 ] , &amp; Function . identity / 1 ) [ 1 , 2 , 3 , 4 ]","ref":"Function.html#identity/1","source_doc":"Returns its input `value`. This function can be passed as an anonymous function\nto transformation functions.\n\n## Examples\n\n    iex> Function.identity(\"Hello world!\")\n    \"Hello world!\"\n\n    iex> ~c\"abcdaabccc\" |> Enum.sort() |> Enum.chunk_by(&Function.identity/1)\n    [~c\"aaa\", ~c\"bb\", ~c\"cccc\", ~c\"d\"]\n\n    iex> Enum.group_by(~c\"abracadabra\", &Function.identity/1)\n    %{97 => ~c\"aaaaa\", 98 => ~c\"bb\", 99 => ~c\"c\", 100 => ~c\"d\", 114 => ~c\"rr\"}\n\n    iex> Enum.map([1, 2, 3, 4], &Function.identity/1)\n    [1, 2, 3, 4]\n\n","title":"Function.identity/1","type":"function"},{"doc":"Returns a keyword list with information about a function. The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following: :type - :local (for anonymous functions) or :external (for named functions). :module - an atom which is the module where the function is defined when anonymous or the module which the function refers to when it's a named function. :arity - (integer) the number of arguments the function is to be called with. :name - (atom) the name of the function. :env - a list of the environment or free variables. For named functions, the returned list is always empty. When fun is an anonymous function (that is, the type is :local ), the following additional keys are returned: :pid - PID of the process that originally created the function. :index - (integer) an index into the module function table. :new_index - (integer) an index into the module function table. :new_uniq - (binary) a unique value for this function. It's calculated from the compiled code for the entire module. :uniq - (integer) a unique value for this function. This integer is calculated from the compiled code for the entire module. Note : this function must be used only for debugging purposes. Inlined by the compiler. Examples iex&gt; fun = fn x -&gt; x end iex&gt; info = Function . info ( fun ) iex&gt; Keyword . get ( info , :arity ) 1 iex&gt; Keyword . get ( info , :type ) :local iex&gt; fun = &amp; String . length / 1 iex&gt; info = Function . info ( fun ) iex&gt; Keyword . get ( info , :type ) :external iex&gt; Keyword . get ( info , :name ) :length","ref":"Function.html#info/1","source_doc":"Returns a keyword list with information about a function.\n\nThe returned keys (with the corresponding possible values) for\nall types of functions (local and external) are the following:\n\n  * `:type` - `:local` (for anonymous functions) or `:external` (for\n    named functions).\n\n  * `:module` - an atom which is the module where the function is defined when\n  anonymous or the module which the function refers to when it's a named function.\n\n  * `:arity` - (integer) the number of arguments the function is to be called with.\n\n  * `:name` - (atom) the name of the function.\n\n  * `:env` - a list of the environment or free variables. For named\n    functions, the returned list is always empty.\n\nWhen `fun` is an anonymous function (that is, the type is `:local`), the following\nadditional keys are returned:\n\n  * `:pid` - PID of the process that originally created the function.\n\n  * `:index` - (integer) an index into the module function table.\n\n  * `:new_index` - (integer) an index into the module function table.\n\n  * `:new_uniq` - (binary) a unique value for this function. It's\n    calculated from the compiled code for the entire module.\n\n  * `:uniq` - (integer) a unique value for this function. This integer is\n    calculated from the compiled code for the entire module.\n\n**Note**: this function must be used only for debugging purposes.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> fun = fn x -> x end\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :arity)\n    1\n    iex> Keyword.get(info, :type)\n    :local\n\n    iex> fun = &String.length/1\n    iex> info = Function.info(fun)\n    iex> Keyword.get(info, :type)\n    :external\n    iex> Keyword.get(info, :name)\n    :length\n\n","title":"Function.info/1","type":"function"},{"doc":"Returns a specific information about the function. The returned information is a two-element tuple in the shape of {info, value} . For any function, the information asked for can be any of the atoms :module , :name , :arity , :env , or :type . For anonymous functions, there is also information about any of the atoms :index , :new_index , :new_uniq , :uniq , and :pid . For a named function, the value of any of these items is always the atom :undefined . For more information on each of the possible returned values, see info/1 . Inlined by the compiler. Examples iex&gt; f = fn x -&gt; x end iex&gt; Function . info ( f , :arity ) { :arity , 1 } iex&gt; Function . info ( f , :type ) { :type , :local } iex&gt; fun = &amp; String . length / 1 iex&gt; Function . info ( fun , :name ) { :name , :length } iex&gt; Function . info ( fun , :pid ) { :pid , :undefined }","ref":"Function.html#info/2","source_doc":"Returns a specific information about the function.\n\nThe returned information is a two-element tuple in the shape of\n`{info, value}`.\n\nFor any function, the information asked for can be any of the atoms\n`:module`, `:name`, `:arity`, `:env`, or `:type`.\n\nFor anonymous functions, there is also information about any of the\natoms `:index`, `:new_index`, `:new_uniq`, `:uniq`, and `:pid`.\nFor a named function, the value of any of these items is always the\natom `:undefined`.\n\nFor more information on each of the possible returned values, see\n`info/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> f = fn x -> x end\n    iex> Function.info(f, :arity)\n    {:arity, 1}\n    iex> Function.info(f, :type)\n    {:type, :local}\n\n    iex> fun = &String.length/1\n    iex> Function.info(fun, :name)\n    {:name, :length}\n    iex> Function.info(fun, :pid)\n    {:pid, :undefined}\n\n","title":"Function.info/2","type":"function"},{"doc":"","ref":"Function.html#t:information/0","source_doc":false,"title":"Function.information/0","type":"type"},{"doc":"Functions for working with integers. Some functions that work on integers are found in Kernel : Kernel.abs/1 Kernel.div/2 Kernel.max/2 Kernel.min/2 Kernel.rem/2","ref":"Integer.html","source_doc":"Functions for working with integers.\n\nSome functions that work on integers are found in `Kernel`:\n\n  * `Kernel.abs/1`\n  * `Kernel.div/2`\n  * `Kernel.max/2`\n  * `Kernel.min/2`\n  * `Kernel.rem/2`\n\n","title":"Integer","type":"module"},{"doc":"Returns the ordered digits for the given integer . An optional base value may be provided representing the radix for the returned digits. This one must be an integer &gt;= 2. Examples iex&gt; Integer . digits ( 123 ) [ 1 , 2 , 3 ] iex&gt; Integer . digits ( 170 , 2 ) [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] iex&gt; Integer . digits ( - 170 , 2 ) [ - 1 , 0 , - 1 , 0 , - 1 , 0 , - 1 , 0 ]","ref":"Integer.html#digits/2","source_doc":"Returns the ordered digits for the given `integer`.\n\nAn optional `base` value may be provided representing the radix for the returned\ndigits. This one must be an integer >= 2.\n\n## Examples\n\n    iex> Integer.digits(123)\n    [1, 2, 3]\n\n    iex> Integer.digits(170, 2)\n    [1, 0, 1, 0, 1, 0, 1, 0]\n\n    iex> Integer.digits(-170, 2)\n    [-1, 0, -1, 0, -1, 0, -1, 0]\n\n","title":"Integer.digits/2","type":"function"},{"doc":"Returns the extended greatest common divisor of the two given integers. This function uses the extended Euclidean algorithm to return a three-element tuple with the gcd and the coefficients m and n of Bézout's identity such that: gcd ( a , b ) = m * a + n * b By convention, extended_gcd(0, 0) returns {0, 0, 0} . Examples iex&gt; Integer . extended_gcd ( 240 , 46 ) { 2 , - 9 , 47 } iex&gt; Integer . extended_gcd ( 46 , 240 ) { 2 , 47 , - 9 } iex&gt; Integer . extended_gcd ( - 46 , 240 ) { 2 , - 47 , - 9 } iex&gt; Integer . extended_gcd ( - 46 , - 240 ) { 2 , - 47 , 9 } iex&gt; Integer . extended_gcd ( 14 , 21 ) { 7 , - 1 , 1 } iex&gt; Integer . extended_gcd ( 10 , 0 ) { 10 , 1 , 0 } iex&gt; Integer . extended_gcd ( 0 , 10 ) { 10 , 0 , 1 } iex&gt; Integer . extended_gcd ( 0 , 0 ) { 0 , 0 , 0 }","ref":"Integer.html#extended_gcd/2","source_doc":"Returns the extended greatest common divisor of the two given integers.\n\nThis function uses the extended Euclidean algorithm to return a three-element tuple with the `gcd`\nand the coefficients `m` and `n` of Bézout's identity such that:\n\n    gcd(a, b) = m*a + n*b\n\nBy convention, `extended_gcd(0, 0)` returns `{0, 0, 0}`.\n\n## Examples\n\n    iex> Integer.extended_gcd(240, 46)\n    {2, -9, 47}\n    iex> Integer.extended_gcd(46, 240)\n    {2, 47, -9}\n    iex> Integer.extended_gcd(-46, 240)\n    {2, -47, -9}\n    iex> Integer.extended_gcd(-46, -240)\n    {2, -47, 9}\n\n    iex> Integer.extended_gcd(14, 21)\n    {7, -1, 1}\n\n    iex> Integer.extended_gcd(10, 0)\n    {10, 1, 0}\n    iex> Integer.extended_gcd(0, 10)\n    {10, 0, 1}\n    iex> Integer.extended_gcd(0, 0)\n    {0, 0, 0}\n\n","title":"Integer.extended_gcd/2","type":"function"},{"doc":"Performs a floored integer division. Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . This function performs a floored integer division, which means that the result will always be rounded towards negative infinity. If you want to perform truncated integer division (rounding towards zero), use Kernel.div/2 instead. Examples iex&gt; Integer . floor_div ( 5 , 2 ) 2 iex&gt; Integer . floor_div ( 6 , - 4 ) - 2 iex&gt; Integer . floor_div ( - 99 , 2 ) - 50","ref":"Integer.html#floor_div/2","source_doc":"Performs a floored integer division.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\nThis function performs a *floored* integer division, which means that\nthe result will always be rounded towards negative infinity.\n\nIf you want to perform truncated integer division (rounding towards zero),\nuse `Kernel.div/2` instead.\n\n## Examples\n\n    iex> Integer.floor_div(5, 2)\n    2\n    iex> Integer.floor_div(6, -4)\n    -2\n    iex> Integer.floor_div(-99, 2)\n    -50\n\n","title":"Integer.floor_div/2","type":"function"},{"doc":"Returns the greatest common divisor of the two given integers. The greatest common divisor (GCD) of integer1 and integer2 is the largest positive integer that divides both integer1 and integer2 without leaving a remainder. By convention, gcd(0, 0) returns 0 . Examples iex&gt; Integer . gcd ( 2 , 3 ) 1 iex&gt; Integer . gcd ( 8 , 12 ) 4 iex&gt; Integer . gcd ( 8 , - 12 ) 4 iex&gt; Integer . gcd ( 10 , 0 ) 10 iex&gt; Integer . gcd ( 7 , 7 ) 7 iex&gt; Integer . gcd ( 0 , 0 ) 0","ref":"Integer.html#gcd/2","source_doc":"Returns the greatest common divisor of the two given integers.\n\nThe greatest common divisor (GCD) of `integer1` and `integer2` is the largest positive\ninteger that divides both `integer1` and `integer2` without leaving a remainder.\n\nBy convention, `gcd(0, 0)` returns `0`.\n\n## Examples\n\n    iex> Integer.gcd(2, 3)\n    1\n\n    iex> Integer.gcd(8, 12)\n    4\n\n    iex> Integer.gcd(8, -12)\n    4\n\n    iex> Integer.gcd(10, 0)\n    10\n\n    iex> Integer.gcd(7, 7)\n    7\n\n    iex> Integer.gcd(0, 0)\n    0\n\n","title":"Integer.gcd/2","type":"function"},{"doc":"Determines if an integer is even. Returns true if the given integer is an even number, otherwise it returns false . Allowed in guard clauses. Examples iex&gt; Integer . is_even ( 10 ) true iex&gt; Integer . is_even ( 5 ) false iex&gt; Integer . is_even ( - 10 ) true iex&gt; Integer . is_even ( 0 ) true","ref":"Integer.html#is_even/1","source_doc":"Determines if an `integer` is even.\n\nReturns `true` if the given `integer` is an even number,\notherwise it returns `false`.\n\nAllowed in guard clauses.\n\n## Examples\n\n    iex> Integer.is_even(10)\n    true\n\n    iex> Integer.is_even(5)\n    false\n\n    iex> Integer.is_even(-10)\n    true\n\n    iex> Integer.is_even(0)\n    true\n\n","title":"Integer.is_even/1","type":"macro"},{"doc":"Determines if integer is odd. Returns true if the given integer is an odd number, otherwise it returns false . Allowed in guard clauses. Examples iex&gt; Integer . is_odd ( 5 ) true iex&gt; Integer . is_odd ( 6 ) false iex&gt; Integer . is_odd ( - 5 ) true iex&gt; Integer . is_odd ( 0 ) false","ref":"Integer.html#is_odd/1","source_doc":"Determines if `integer` is odd.\n\nReturns `true` if the given `integer` is an odd number,\notherwise it returns `false`.\n\nAllowed in guard clauses.\n\n## Examples\n\n    iex> Integer.is_odd(5)\n    true\n\n    iex> Integer.is_odd(6)\n    false\n\n    iex> Integer.is_odd(-5)\n    true\n\n    iex> Integer.is_odd(0)\n    false\n\n","title":"Integer.is_odd/1","type":"macro"},{"doc":"Computes the modulo remainder of an integer division. This function performs a floored division , which means that the result will always have the sign of the divisor . Raises an ArithmeticError exception if one of the arguments is not an integer, or when the divisor is 0 . Examples iex&gt; Integer . mod ( 5 , 2 ) 1 iex&gt; Integer . mod ( 6 , - 4 ) - 2","ref":"Integer.html#mod/2","source_doc":"Computes the modulo remainder of an integer division.\n\nThis function performs a [floored division](`floor_div/2`), which means that\nthe result will always have the sign of the `divisor`.\n\nRaises an `ArithmeticError` exception if one of the arguments is not an\ninteger, or when the `divisor` is `0`.\n\n## Examples\n\n    iex> Integer.mod(5, 2)\n    1\n    iex> Integer.mod(6, -4)\n    -2\n\n","title":"Integer.mod/2","type":"function"},{"doc":"Parses a text representation of an integer. An optional base to the corresponding integer can be provided. If base is not given, 10 will be used. If successful, returns a tuple in the form of {integer, remainder_of_binary} . Otherwise :error . Raises an error if base is less than 2 or more than 36. If you want to convert a string-formatted integer directly to an integer, String.to_integer/1 or String.to_integer/2 can be used instead. Examples iex&gt; Integer . parse ( &quot;34&quot; ) { 34 , &quot;&quot; } iex&gt; Integer . parse ( &quot;34.5&quot; ) { 34 , &quot;.5&quot; } iex&gt; Integer . parse ( &quot;three&quot; ) :error iex&gt; Integer . parse ( &quot;34&quot; , 10 ) { 34 , &quot;&quot; } iex&gt; Integer . parse ( &quot;f4&quot; , 16 ) { 244 , &quot;&quot; } iex&gt; Integer . parse ( &quot;Awww++&quot; , 36 ) { 509216 , &quot;++&quot; } iex&gt; Integer . parse ( &quot;fab&quot; , 10 ) :error iex&gt; Integer . parse ( &quot;a2&quot; , 38 ) ** (ArgumentError) invalid base 38","ref":"Integer.html#parse/2","source_doc":"Parses a text representation of an integer.\n\nAn optional `base` to the corresponding integer can be provided.\nIf `base` is not given, 10 will be used.\n\nIf successful, returns a tuple in the form of `{integer, remainder_of_binary}`.\nOtherwise `:error`.\n\nRaises an error if `base` is less than 2 or more than 36.\n\nIf you want to convert a string-formatted integer directly to an integer,\n`String.to_integer/1` or `String.to_integer/2` can be used instead.\n\n## Examples\n\n    iex> Integer.parse(\"34\")\n    {34, \"\"}\n\n    iex> Integer.parse(\"34.5\")\n    {34, \".5\"}\n\n    iex> Integer.parse(\"three\")\n    :error\n\n    iex> Integer.parse(\"34\", 10)\n    {34, \"\"}\n\n    iex> Integer.parse(\"f4\", 16)\n    {244, \"\"}\n\n    iex> Integer.parse(\"Awww++\", 36)\n    {509216, \"++\"}\n\n    iex> Integer.parse(\"fab\", 10)\n    :error\n\n    iex> Integer.parse(\"a2\", 38)\n    ** (ArgumentError) invalid base 38\n\n","title":"Integer.parse/2","type":"function"},{"doc":"Computes base raised to power of exponent . Both base and exponent must be integers. The exponent must be zero or positive. See Float.pow/2 for exponentiation of negative exponents as well as floats. Examples iex&gt; Integer . pow ( 2 , 0 ) 1 iex&gt; Integer . pow ( 2 , 1 ) 2 iex&gt; Integer . pow ( 2 , 10 ) 1024 iex&gt; Integer . pow ( 2 , 11 ) 2048 iex&gt; Integer . pow ( 2 , 64 ) 0x10000000000000000 iex&gt; Integer . pow ( 3 , 4 ) 81 iex&gt; Integer . pow ( 4 , 3 ) 64 iex&gt; Integer . pow ( - 2 , 3 ) - 8 iex&gt; Integer . pow ( - 2 , 4 ) 16 iex&gt; Integer . pow ( 2 , - 2 ) ** (ArithmeticError) bad argument in arithmetic expression","ref":"Integer.html#pow/2","source_doc":"Computes `base` raised to power of `exponent`.\n\nBoth `base` and `exponent` must be integers.\nThe exponent must be zero or positive.\n\nSee `Float.pow/2` for exponentiation of negative\nexponents as well as floats.\n\n## Examples\n\n    iex> Integer.pow(2, 0)\n    1\n    iex> Integer.pow(2, 1)\n    2\n    iex> Integer.pow(2, 10)\n    1024\n    iex> Integer.pow(2, 11)\n    2048\n    iex> Integer.pow(2, 64)\n    0x10000000000000000\n\n    iex> Integer.pow(3, 4)\n    81\n    iex> Integer.pow(4, 3)\n    64\n\n    iex> Integer.pow(-2, 3)\n    -8\n    iex> Integer.pow(-2, 4)\n    16\n\n    iex> Integer.pow(2, -2)\n    ** (ArithmeticError) bad argument in arithmetic expression\n\n","title":"Integer.pow/2","type":"function"},{"doc":"Returns a charlist which corresponds to the text representation of integer in the given base . base can be an integer between 2 and 36. If no base is given, it defaults to 10 . Inlined by the compiler. Examples iex&gt; Integer . to_charlist ( 123 ) &#39;123&#39; iex&gt; Integer . to_charlist ( + 456 ) &#39;456&#39; iex&gt; Integer . to_charlist ( - 789 ) &#39;-789&#39; iex&gt; Integer . to_charlist ( 0123 ) &#39;123&#39; iex&gt; Integer . to_charlist ( 100 , 16 ) &#39;64&#39; iex&gt; Integer . to_charlist ( - 100 , 16 ) &#39;-64&#39; iex&gt; Integer . to_charlist ( 882_681_651 , 36 ) &#39;ELIXIR&#39;","ref":"Integer.html#to_charlist/2","source_doc":"Returns a charlist which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_charlist(123)\n    '123'\n\n    iex> Integer.to_charlist(+456)\n    '456'\n\n    iex> Integer.to_charlist(-789)\n    '-789'\n\n    iex> Integer.to_charlist(0123)\n    '123'\n\n    iex> Integer.to_charlist(100, 16)\n    '64'\n\n    iex> Integer.to_charlist(-100, 16)\n    '-64'\n\n    iex> Integer.to_charlist(882_681_651, 36)\n    'ELIXIR'\n\n","title":"Integer.to_charlist/2","type":"function"},{"doc":"Returns a binary which corresponds to the text representation of integer in the given base . base can be an integer between 2 and 36. If no base is given, it defaults to 10 . Inlined by the compiler. Examples iex&gt; Integer . to_string ( 123 ) &quot;123&quot; iex&gt; Integer . to_string ( + 456 ) &quot;456&quot; iex&gt; Integer . to_string ( - 789 ) &quot;-789&quot; iex&gt; Integer . to_string ( 0123 ) &quot;123&quot; iex&gt; Integer . to_string ( 100 , 16 ) &quot;64&quot; iex&gt; Integer . to_string ( - 100 , 16 ) &quot;-64&quot; iex&gt; Integer . to_string ( 882_681_651 , 36 ) &quot;ELIXIR&quot;","ref":"Integer.html#to_string/2","source_doc":"Returns a binary which corresponds to the text representation\nof `integer` in the given `base`.\n\n`base` can be an integer between 2 and 36. If no `base` is given,\nit defaults to `10`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Integer.to_string(123)\n    \"123\"\n\n    iex> Integer.to_string(+456)\n    \"456\"\n\n    iex> Integer.to_string(-789)\n    \"-789\"\n\n    iex> Integer.to_string(0123)\n    \"123\"\n\n    iex> Integer.to_string(100, 16)\n    \"64\"\n\n    iex> Integer.to_string(-100, 16)\n    \"-64\"\n\n    iex> Integer.to_string(882_681_651, 36)\n    \"ELIXIR\"\n\n","title":"Integer.to_string/2","type":"function"},{"doc":"Returns the integer represented by the ordered digits . An optional base value may be provided representing the radix for the digits . Base has to be an integer greater than or equal to 2 . Examples iex&gt; Integer . undigits ( [ 1 , 2 , 3 ] ) 123 iex&gt; Integer . undigits ( [ 1 , 4 ] , 16 ) 20 iex&gt; Integer . undigits ( [ ] ) 0","ref":"Integer.html#undigits/2","source_doc":"Returns the integer represented by the ordered `digits`.\n\nAn optional `base` value may be provided representing the radix for the `digits`.\nBase has to be an integer greater than or equal to `2`.\n\n## Examples\n\n    iex> Integer.undigits([1, 2, 3])\n    123\n\n    iex> Integer.undigits([1, 4], 16)\n    20\n\n    iex> Integer.undigits([])\n    0\n\n","title":"Integer.undigits/2","type":"function"},{"doc":"Provides functions to deal with modules during compilation time. It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth. After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the __info__/1 function attached to each compiled module. Module attributes Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir: @after_compile A hook that will be invoked right after the current module is compiled. Accepts a module or a {module, function_name} . See the &quot;Compile callbacks&quot; section below. @after_verify (since v1.14.0) A hook that will be invoked right after the current module is verified for undefined functions, deprecations, etc. Accepts a module or a {module, function_name} . See the &quot;Compile callbacks&quot; section below. @before_compile A hook that will be invoked before the module is compiled. Accepts a module or a {module, function_or_macro_name} tuple. See the &quot;Compile callbacks&quot; section below. @behaviour Note the British spelling! Behaviours can be referenced by modules to ensure they implement required specific function signatures defined by @callback . For example, you could specify a URI.Parser behaviour as follows: defmodule URI.Parser do @doc &quot;Defines a default port&quot; @callback default_port ( ) :: integer @doc &quot;Parses the given URL&quot; @callback parse ( uri_info :: URI . t ( ) ) :: URI . t ( ) end And then a module may use it as: defmodule URI.HTTP do @behaviour URI.Parser def default_port ( ) , do : 80 def parse ( info ) , do : info end If the behaviour changes or URI.HTTP does not implement one of the callbacks, a warning will be raised. For detailed documentation, see the behaviour typespec documentation . @impl (since v1.5.0) To aid in the correct implementation of behaviours, you may optionally declare @impl for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases: if you mark a function with @impl when that function is not a callback. if you don't mark a function with @impl when other functions are marked with @impl . If you mark one function with @impl , you must mark all other callbacks for that behaviour as @impl . @impl works on a per-context basis. If you generate a function through a macro and mark it with @impl , that won't affect the module where that function is generated in. @impl also helps with maintainability by making it clear to other developers that the function is implementing a callback. Using @impl , the example above can be rewritten as: defmodule URI.HTTP do @behaviour URI.Parser @impl true def default_port ( ) , do : 80 @impl true def parse ( info ) , do : info end You may pass either false , true , or a specific behaviour to @impl . defmodule Foo do @behaviour Bar @behaviour Baz # Will warn if neither Bar nor Baz specify a callback named bar/0. @impl true def bar ( ) , do : :ok # Will warn if Baz does not specify a callback named baz/0. @impl Baz def baz ( ) , do : :ok end The code is now more readable, as it is now clear which functions are part of your API and which ones are callback implementations. To reinforce this idea, @impl true automatically marks the function as @doc false , disabling documentation unless @doc is explicitly set. @compile Defines options for module compilation. This is used to configure both Elixir and Erlang compilers, as any other compilation pass added by external tools. For example: defmodule MyModule do @compile { :inline , my_fun : 1 } def my_fun ( arg ) do to_string ( arg ) end end Multiple uses of @compile will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below. @deprecated (since v1.6.0) Provides the deprecation reason for a function. For example: defmodule Keyword do @deprecated &quot;Use Kernel.length/1 instead&quot; def size ( keyword ) do length ( keyword ) end end The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation. Using the @deprecated attribute will also be reflected in the documentation of the given function and macro. You can choose between the @deprecated attribute and the documentation metadata to provide hard-deprecations (with warnings) and soft-deprecations (without warnings): This is a soft-deprecation as it simply annotates the documentation as deprecated: @doc deprecated : &quot;Use Kernel.length/1 instead&quot; def size ( keyword ) This is a hard-deprecation as it emits warnings and annotates the documentation as deprecated: @deprecated &quot;Use Kernel.length/1 instead&quot; def size ( keyword ) Currently @deprecated only supports functions and macros. However you can use the :deprecated key in the annotation metadata to annotate the docs of modules, types and callbacks too. We recommend using this feature with care, especially library authors. Deprecating code always pushes the burden towards library users. We also recommend for deprecated functionality to be maintained for long periods of time, even after deprecation, giving developers plenty of time to update (except for cases where keeping the deprecated API is undesired, such as in the presence of security issues). @doc and @typedoc Provides documentation for the entity that follows the attribute. @doc is to be used with a function, macro, callback, or macrocallback, while @typedoc with a type (public or opaque). Accepts one of these: a string (often a heredoc) false , which will make the entity invisible to documentation-extraction tools like ExDoc a keyword list, since Elixir 1.7.0 For example: defmodule MyModule do @typedoc &quot;This type&quot; @typedoc since : &quot;1.1.0&quot; @type t :: term @doc &quot;Hello world&quot; @doc since : &quot;1.1.0&quot; def hello do &quot;world&quot; end @doc &quot;&quot;&quot; Sums `a` to `b`. &quot;&quot;&quot; def sum ( a , b ) do a + b end end As can be seen in the example above, since Elixir 1.7.0 @doc and @typedoc also accept a keyword list that serves as a way to provide arbitrary metadata about the entity. Tools like ExDoc and IEx may use this information to display annotations. A common use case is the :since key, which may be used to annotate in which version the function was introduced. As illustrated in the example, it is possible to use these attributes more than once before an entity. However, the compiler will warn if used twice with binaries as that replaces the documentation text from the preceding use. Multiple uses with keyword lists will merge the lists into one. Note that since the compiler also defines some additional metadata, there are a few reserved keys that will be ignored and warned if used. Currently these are: :opaque and :defaults . Once this module is compiled, this information becomes available via the Code.fetch_docs/1 function. @dialyzer Defines warnings to request or suppress when using :dialyzer . Accepts an atom, a tuple, or a list of atoms and tuples. For example: defmodule MyModule do @dialyzer { :nowarn_function , [ my_fun : 1 ] } def my_fun ( arg ) do M . not_a_function ( arg ) end end For the list of supported warnings, see :dialyzer module . Multiple uses of @dialyzer will accumulate instead of overriding previous ones. @external_resource Specifies an external resource for the current module. Sometimes a module embeds information from an external file. This attribute allows the module to annotate which external resources have been used. Tools may use this information to ensure the module is recompiled in case any of the external resources change, see for example: mix compile.elixir . The specified file path provided is interpreted as relative to the folder containing the project's mix.exs , which is the current working directory, not the file where @external_resource is declared. If the external resource does not exist, the module still has a dependency on it, causing the module to be recompiled as soon as the file is added. @file Changes the filename used in stacktraces for the function or macro that follows the attribute, such as: defmodule MyModule do @doc &quot;Hello world&quot; @file &quot;hello.ex&quot; def hello do &quot;world&quot; end end @moduledoc Provides documentation for the current module. defmodule MyModule do @moduledoc &quot;&quot;&quot; A very useful module. &quot;&quot;&quot; @moduledoc authors : [ &quot;Alice&quot; , &quot;Bob&quot; ] end Accepts a string (often a heredoc) or false where @moduledoc false will make the module invisible to documentation extraction tools like ExDoc . Similarly to @doc also accepts a keyword list to provide metadata about the module. For more details, see the documentation of @doc above. Once this module is compiled, this information becomes available via the Code.fetch_docs/1 function. @on_definition A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions. Accepts a module or a {module, function_name} tuple. The function must take 6 arguments: the module environment the kind of the function/macro: :def , :defp , :defmacro , or :defmacrop the function/macro name the list of quoted arguments the list of quoted guards the quoted function body If the function/macro being defined has multiple clauses, the hook will be called for each clause. Unlike other hooks, @on_definition will only invoke functions and never macros. This is to avoid @on_definition callbacks from redefining functions that have just been defined in favor of more explicit approaches. When just a module is provided, the function is assumed to be __on_definition__/6 . Example defmodule Hooks do def on_def ( _env , kind , name , args , guards , body ) do IO . puts ( &quot;Defining \#{ kind } named \#{ name } with args:&quot; ) IO . inspect ( args ) IO . puts ( &quot;and guards&quot; ) IO . inspect ( guards ) IO . puts ( &quot;and body&quot; ) IO . puts ( Macro . to_string ( body ) ) end end defmodule MyModule do @on_definition { Hooks , :on_def } def hello ( arg ) when is_binary ( arg ) or is_list ( arg ) do &quot;Hello&quot; &lt;&gt; to_string ( arg ) end def hello ( _ ) do :ok end end @on_load A hook that will be invoked whenever the module is loaded. Accepts the function name (as an atom) of a function in the current module. The function must have an arity of 0 (no arguments). If the function does not return :ok , the loading of the module will be aborted. For example: defmodule MyModule do @on_load :load_check def load_check do if some_condition ( ) do :ok else :abort end end def some_condition do false end end @vsn Specify the module version. Accepts any valid Elixir value, for example: defmodule MyModule do @vsn &quot;1.0&quot; end Struct attributes @derive - derives an implementation for the given protocol for the struct defined in the current module @enforce_keys - ensures the given keys are always set when building the struct defined in the current module See defstruct/1 for more information on building and using structs. Typespec attributes The following attributes are part of typespecs and are also built-in in Elixir: @type - defines a type to be used in @spec @typep - defines a private type to be used in @spec @opaque - defines an opaque type to be used in @spec @spec - provides a specification for a function @callback - provides a specification for a behaviour callback @macrocallback - provides a specification for a macro behaviour callback @optional_callbacks - specifies which behaviour callbacks and macro behaviour callbacks are optional @impl - declares an implementation of a callback function or macro For detailed documentation, see the typespec documentation . Custom attributes In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the @/1 operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value: defmodule MyModule do @custom_attr [ some : &quot;stuff&quot; ] end For more advanced options available when defining custom attributes, see register_attribute/3 . Compile callbacks There are three compilation callbacks, invoked in this order: @before_compile , @after_compile , and @after_verify . They are described next. @before_compile A hook that will be invoked before the module is compiled. This is often used to change how the current module is being compiled. Accepts a module or a {module, function_or_macro_name} tuple. The function/macro must take one argument: the module environment. If it's a macro, its returned value will be injected at the end of the module definition before the compilation starts. When just a module is provided, the function/macro is assumed to be __before_compile__/1 . Callbacks will run in the order they are registered. Any overridable definition will be made concrete before the first callback runs. A definition may be made overridable again in another before compile callback and it will be made concrete one last time after all callbacks run. Note : the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist). Example defmodule A do defmacro __before_compile__ ( _env ) do quote do def hello , do : &quot;world&quot; end end end defmodule B do @before_compile A end B . hello ( ) #=&gt; &quot;world&quot; @after_compile A hook that will be invoked right after the current module is compiled. Accepts a module or a {module, function_name} tuple. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be __after_compile__/2 . Callbacks will run in the order they are registered. Module functions expecting not yet compiled modules (such as definitions_in/1 ) are still available at the time @after_compile is invoked. Example defmodule MyModule do @after_compile __MODULE__ def __after_compile__ ( env , _bytecode ) do IO . inspect ( env ) end end @after_verify A hook that will be invoked right after the current module is verified for undefined functions, deprecations, etc. A module is always verified after it is compiled. In Mix projects, a module is also verified when any of its runtime dependencies change. Therefore this is useful to perform verification of the current module while avoiding compile-time dependencies. Accepts a module or a {module, function_name} tuple. The function must take one argument: the module name. When just a module is provided, the function is assumed to be __after_verify__/1 . Callbacks will run in the order they are registered. Module functions expecting not yet compiled modules are no longer available at the time @after_verify is invoked. Example defmodule MyModule do @after_verify __MODULE__ def __after_verify__ ( module ) do IO . inspect ( module ) :ok end end Compile options The @compile attribute accepts different options that are used by both Elixir and Erlang compilers. Some of the common use cases are documented below: @compile :debug_info - includes :debug_info regardless of the corresponding setting in Code.get_compiler_option/1 @compile {:debug_info, false} - disables :debug_info regardless of the corresponding setting in Code.get_compiler_option/1 . Note disabling :debug_info is not recommended as it removes the ability of the Elixir compiler and other tools to static analyse the code. If you want to remove the :debug_info while deploying, tools like mix release already do such by default. @compile {:inline, some_fun: 2, other_fun: 3} - inlines the given name/arity pairs. Inlining is applied locally, calls from another module are not affected by this option @compile {:autoload, false} - disables automatic loading of modules after compilation. Instead, the module will be loaded after it is dispatched to @compile {:no_warn_undefined, Mod} or @compile {:no_warn_undefined, {Mod, fun, arity}} - does not warn if the given module or the given Mod.fun/arity are not defined","ref":"Module.html","source_doc":"Provides functions to deal with modules during compilation time.\n\nIt allows a developer to dynamically add, delete and register\nattributes, attach documentation and so forth.\n\nAfter a module is compiled, using many of the functions in\nthis module will raise errors, since it is out of their scope\nto inspect runtime data. Most of the runtime data can be inspected\nvia the [`__info__/1`](`c:Module.__info__/1`) function attached to\neach compiled module.\n\n## Module attributes\n\nEach module can be decorated with one or more attributes. The following ones\nare currently defined by Elixir:\n\n### `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\nAccepts a module or a `{module, function_name}`. See the \"Compile callbacks\"\nsection below.\n\n### `@after_verify` (since v1.14.0)\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. Accepts a module or a `{module, function_name}`.\nSee the \"Compile callbacks\" section below.\n\n### `@before_compile`\n\nA hook that will be invoked before the module is compiled.\nAccepts a module or a `{module, function_or_macro_name}` tuple.\nSee the \"Compile callbacks\" section below.\n\n### `@behaviour`\n\nNote the British spelling!\n\nBehaviours can be referenced by modules to ensure they implement\nrequired specific function signatures defined by `@callback`.\n\nFor example, you could specify a `URI.Parser` behaviour as follows:\n\n    defmodule URI.Parser do\n      @doc \"Defines a default port\"\n      @callback default_port() :: integer\n\n      @doc \"Parses the given URL\"\n      @callback parse(uri_info :: URI.t()) :: URI.t()\n    end\n\nAnd then a module may use it as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n      def default_port(), do: 80\n      def parse(info), do: info\n    end\n\nIf the behaviour changes or `URI.HTTP` does not implement\none of the callbacks, a warning will be raised.\n\nFor detailed documentation, see the\n[behaviour typespec documentation](typespecs.md#behaviours).\n\n### `@impl` (since v1.5.0)\n\nTo aid in the correct implementation of behaviours, you may optionally declare\n`@impl` for implemented callbacks of a behaviour. This makes callbacks\nexplicit and can help you to catch errors in your code. The compiler will warn\nin these cases:\n\n  * if you mark a function with `@impl` when that function is not a callback.\n\n  * if you don't mark a function with `@impl` when other functions are marked\n    with `@impl`. If you mark one function with `@impl`, you must mark all\n    other callbacks for that behaviour as `@impl`.\n\n`@impl` works on a per-context basis. If you generate a function through a macro\nand mark it with `@impl`, that won't affect the module where that function is\ngenerated in.\n\n`@impl` also helps with maintainability by making it clear to other developers\nthat the function is implementing a callback.\n\nUsing `@impl`, the example above can be rewritten as:\n\n    defmodule URI.HTTP do\n      @behaviour URI.Parser\n\n      @impl true\n      def default_port(), do: 80\n\n      @impl true\n      def parse(info), do: info\n    end\n\nYou may pass either `false`, `true`, or a specific behaviour to `@impl`.\n\n    defmodule Foo do\n      @behaviour Bar\n      @behaviour Baz\n\n      # Will warn if neither Bar nor Baz specify a callback named bar/0.\n      @impl true\n      def bar(), do: :ok\n\n      # Will warn if Baz does not specify a callback named baz/0.\n      @impl Baz\n      def baz(), do: :ok\n    end\n\nThe code is now more readable, as it is now clear which functions are\npart of your API and which ones are callback implementations. To reinforce this\nidea, `@impl true` automatically marks the function as `@doc false`, disabling\ndocumentation unless `@doc` is explicitly set.\n\n### `@compile`\n\nDefines options for module compilation. This is used to configure\nboth Elixir and Erlang compilers, as any other compilation pass\nadded by external tools. For example:\n\n    defmodule MyModule do\n      @compile {:inline, my_fun: 1}\n\n      def my_fun(arg) do\n        to_string(arg)\n      end\n    end\n\nMultiple uses of `@compile` will accumulate instead of overriding\nprevious ones. See the \"Compile options\" section below.\n\n### `@deprecated` (since v1.6.0)\n\nProvides the deprecation reason for a function. For example:\n\n    defmodule Keyword do\n      @deprecated \"Use Kernel.length/1 instead\"\n      def size(keyword) do\n        length(keyword)\n      end\n    end\n\nThe Mix compiler automatically looks for calls to deprecated modules\nand emit warnings during compilation.\n\nUsing the `@deprecated` attribute will also be reflected in the\ndocumentation of the given function and macro. You can choose between\nthe `@deprecated` attribute and the documentation metadata to provide\nhard-deprecations (with warnings) and soft-deprecations (without warnings):\n\nThis is a soft-deprecation as it simply annotates the documentation\nas deprecated:\n\n    @doc deprecated: \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nThis is a hard-deprecation as it emits warnings and annotates the\ndocumentation as deprecated:\n\n    @deprecated \"Use Kernel.length/1 instead\"\n    def size(keyword)\n\nCurrently `@deprecated` only supports functions and macros. However\nyou can use the `:deprecated` key in the annotation metadata to\nannotate the docs of modules, types and callbacks too.\n\nWe recommend using this feature with care, especially library authors.\nDeprecating code always pushes the burden towards library users. We\nalso recommend for deprecated functionality to be maintained for long\nperiods of time, even after deprecation, giving developers plenty of\ntime to update (except for cases where keeping the deprecated API is\nundesired, such as in the presence of security issues).\n\n### `@doc` and `@typedoc`\n\nProvides documentation for the entity that follows the attribute.\n`@doc` is to be used with a function, macro, callback, or\nmacrocallback, while `@typedoc` with a type (public or opaque).\n\nAccepts one of these:\n\n  * a string (often a heredoc)\n  * `false`, which will make the entity invisible to documentation-extraction\n    tools like [`ExDoc`](https://hexdocs.pm/ex_doc/)\n  * a keyword list, since Elixir 1.7.0\n\nFor example:\n\n    defmodule MyModule do\n      @typedoc \"This type\"\n      @typedoc since: \"1.1.0\"\n      @type t :: term\n\n      @doc \"Hello world\"\n      @doc since: \"1.1.0\"\n      def hello do\n        \"world\"\n      end\n\n      @doc \"\"\"\n      Sums `a` to `b`.\n      \"\"\"\n      def sum(a, b) do\n        a + b\n      end\n    end\n\nAs can be seen in the example above, since Elixir 1.7.0 `@doc` and `@typedoc`\nalso accept a keyword list that serves as a way to provide arbitrary metadata\nabout the entity. Tools like [`ExDoc`](https://hexdocs.pm/ex_doc/) and\n`IEx` may use this information to display annotations. A common use\ncase is the `:since` key, which may be used to annotate in which version the\nfunction was introduced.\n\nAs illustrated in the example, it is possible to use these attributes\nmore than once before an entity. However, the compiler will warn if\nused twice with binaries as that replaces the documentation text from\nthe preceding use. Multiple uses with keyword lists will merge the\nlists into one.\n\nNote that since the compiler also defines some additional metadata,\nthere are a few reserved keys that will be ignored and warned if used.\nCurrently these are: `:opaque` and `:defaults`.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function.\n\n### `@dialyzer`\n\nDefines warnings to request or suppress when using `:dialyzer`.\n\nAccepts an atom, a tuple, or a list of atoms and tuples. For example:\n\n    defmodule MyModule do\n      @dialyzer {:nowarn_function, [my_fun: 1]}\n\n      def my_fun(arg) do\n        M.not_a_function(arg)\n      end\n    end\n\nFor the list of supported warnings, see [`:dialyzer` module](`:dialyzer`).\n\nMultiple uses of `@dialyzer` will accumulate instead of overriding\nprevious ones.\n\n### `@external_resource`\n\nSpecifies an external resource for the current module.\n\nSometimes a module embeds information from an external file. This\nattribute allows the module to annotate which external resources\nhave been used.\n\nTools may use this information to ensure the module is recompiled\nin case any of the external resources change, see for example:\n[`mix compile.elixir`](https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html).\n\nThe specified file path provided is interpreted as relative to\nthe folder containing the project's `mix.exs`, which is the\ncurrent working directory, not the file where `@external_resource`\nis declared.\n\nIf the external resource does not exist, the module still has\na dependency on it, causing the module to be recompiled as soon\nas the file is added.\n\n### `@file`\n\nChanges the filename used in stacktraces for the function or macro that\nfollows the attribute, such as:\n\n    defmodule MyModule do\n      @doc \"Hello world\"\n      @file \"hello.ex\"\n      def hello do\n        \"world\"\n      end\n    end\n\n### `@moduledoc`\n\nProvides documentation for the current module.\n\n    defmodule MyModule do\n      @moduledoc \"\"\"\n      A very useful module.\n      \"\"\"\n      @moduledoc authors: [\"Alice\", \"Bob\"]\n    end\n\nAccepts a string (often a heredoc) or `false` where `@moduledoc false`\nwill make the module invisible to documentation extraction tools like\n[`ExDoc`](https://hexdocs.pm/ex_doc/).\n\nSimilarly to `@doc` also accepts a keyword list to provide metadata\nabout the module. For more details, see the documentation of `@doc`\nabove.\n\nOnce this module is compiled, this information becomes available via\nthe `Code.fetch_docs/1` function.\n\n### `@on_definition`\n\nA hook that will be invoked when each function or macro in the current\nmodule is defined. Useful when annotating functions.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take 6 arguments:\n\n  * the module environment\n  * the kind of the function/macro: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n  * the function/macro name\n  * the list of quoted arguments\n  * the list of quoted guards\n  * the quoted function body\n\nIf the function/macro being defined has multiple clauses, the hook will\nbe called for each clause.\n\nUnlike other hooks, `@on_definition` will only invoke functions and\nnever macros. This is to avoid `@on_definition` callbacks from\nredefining functions that have just been defined in favor of more\nexplicit approaches.\n\nWhen just a module is provided, the function is assumed to be\n`__on_definition__/6`.\n\n#### Example\n\n    defmodule Hooks do\n      def on_def(_env, kind, name, args, guards, body) do\n        IO.puts(\"Defining \#{kind} named \#{name} with args:\")\n        IO.inspect(args)\n        IO.puts(\"and guards\")\n        IO.inspect(guards)\n        IO.puts(\"and body\")\n        IO.puts(Macro.to_string(body))\n      end\n    end\n\n    defmodule MyModule do\n      @on_definition {Hooks, :on_def}\n\n      def hello(arg) when is_binary(arg) or is_list(arg) do\n        \"Hello\" <> to_string(arg)\n      end\n\n      def hello(_) do\n        :ok\n      end\n    end\n\n### `@on_load`\n\nA hook that will be invoked whenever the module is loaded.\n\nAccepts the function name (as an atom) of a function in the current module.\nThe function must have an arity of 0 (no arguments). If the function does\nnot return `:ok`, the loading of the module will be aborted.\nFor example:\n\n    defmodule MyModule do\n      @on_load :load_check\n\n      def load_check do\n        if some_condition() do\n          :ok\n        else\n          :abort\n        end\n      end\n\n      def some_condition do\n        false\n      end\n    end\n\n### `@vsn`\n\nSpecify the module version. Accepts any valid Elixir value, for example:\n\n    defmodule MyModule do\n      @vsn \"1.0\"\n    end\n\n### Struct attributes\n\n  * `@derive` - derives an implementation for the given protocol for the\n    struct defined in the current module\n\n  * `@enforce_keys` - ensures the given keys are always set when building\n    the struct defined in the current module\n\nSee `defstruct/1` for more information on building and using structs.\n\n### Typespec attributes\n\nThe following attributes are part of typespecs and are also built-in in\nElixir:\n\n  * `@type` - defines a type to be used in `@spec`\n  * `@typep` - defines a private type to be used in `@spec`\n  * `@opaque` - defines an opaque type to be used in `@spec`\n  * `@spec` - provides a specification for a function\n  * `@callback` - provides a specification for a behaviour callback\n  * `@macrocallback` - provides a specification for a macro behaviour callback\n  * `@optional_callbacks` - specifies which behaviour callbacks and macro\n    behaviour callbacks are optional\n  * `@impl` - declares an implementation of a callback function or macro\n\nFor detailed documentation, see the [typespec documentation](typespecs.md).\n\n### Custom attributes\n\nIn addition to the built-in attributes outlined above, custom attributes may\nalso be added. Custom attributes are expressed using the `@/1` operator followed\nby a valid variable name. The value given to the custom attribute must be a valid\nElixir value:\n\n    defmodule MyModule do\n      @custom_attr [some: \"stuff\"]\n    end\n\nFor more advanced options available when defining custom attributes, see\n`register_attribute/3`.\n\n## Compile callbacks\n\nThere are three compilation callbacks, invoked in this order:\n`@before_compile`, `@after_compile`, and `@after_verify`.\nThey are described next.\n\n### `@before_compile`\n\nA hook that will be invoked before the module is compiled. This is\noften used to change how the current module is being compiled.\n\nAccepts a module or a `{module, function_or_macro_name}` tuple. The\nfunction/macro must take one argument: the module environment. If\nit's a macro, its returned value will be injected at the end of the\nmodule definition before the compilation starts.\n\nWhen just a module is provided, the function/macro is assumed to be\n`__before_compile__/1`.\n\nCallbacks will run in the order they are registered. Any overridable\ndefinition will be made concrete before the first callback runs.\nA definition may be made overridable again in another before compile\ncallback and it will be made concrete one last time after all callbacks\nrun.\n\n*Note*: the callback function/macro must be placed in a separate module\n(because when the callback is invoked, the current module does not yet exist).\n\n#### Example\n\n    defmodule A do\n      defmacro __before_compile__(_env) do\n        quote do\n          def hello, do: \"world\"\n        end\n      end\n    end\n\n    defmodule B do\n      @before_compile A\n    end\n\n    B.hello()\n    #=> \"world\"\n\n### `@after_compile`\n\nA hook that will be invoked right after the current module is compiled.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take two arguments: the module environment and its bytecode.\nWhen just a module is provided, the function is assumed to be\n`__after_compile__/2`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules (such as `definitions_in/1`)\nare still available at the time `@after_compile` is invoked.\n\n#### Example\n\n    defmodule MyModule do\n      @after_compile __MODULE__\n\n      def __after_compile__(env, _bytecode) do\n        IO.inspect(env)\n      end\n    end\n\n### `@after_verify`\n\nA hook that will be invoked right after the current module is verified for\nundefined functions, deprecations, etc. A module is always verified after\nit is compiled. In Mix projects, a module is also verified when any of its\nruntime dependencies change. Therefore this is useful to perform verification\nof the current module while avoiding compile-time dependencies.\n\nAccepts a module or a `{module, function_name}` tuple. The function\nmust take one argument: the module name. When just a module is provided,\nthe function is assumed to be `__after_verify__/1`.\n\nCallbacks will run in the order they are registered.\n\n`Module` functions expecting not yet compiled modules are no longer available\nat the time `@after_verify` is invoked.\n\n#### Example\n\n    defmodule MyModule do\n      @after_verify __MODULE__\n\n      def __after_verify__(module) do\n        IO.inspect(module)\n        :ok\n      end\n    end\n\n## Compile options\n\nThe `@compile` attribute accepts different options that are used by both\nElixir and Erlang compilers. Some of the common use cases are documented\nbelow:\n\n  * `@compile :debug_info` - includes `:debug_info` regardless of the\n    corresponding setting in `Code.get_compiler_option/1`\n\n  * `@compile {:debug_info, false}` - disables `:debug_info` regardless\n    of the corresponding setting in `Code.get_compiler_option/1`. Note\n    disabling `:debug_info` is not recommended as it removes the ability\n    of the Elixir compiler and other tools to static analyse the code.\n    If you want to remove the `:debug_info` while deploying, tools like\n    `mix release` already do such by default.\n\n  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n    name/arity pairs. Inlining is applied locally, calls from another\n    module are not affected by this option\n\n  * `@compile {:autoload, false}` - disables automatic loading of\n    modules after compilation. Instead, the module will be loaded after\n    it is dispatched to\n\n  * `@compile {:no_warn_undefined, Mod}` or\n    `@compile {:no_warn_undefined, {Mod, fun, arity}}` - does not warn if\n    the given module or the given `Mod.fun/arity` are not defined\n\n","title":"Module","type":"behaviour"},{"doc":"Provides runtime information about functions, macros, and other information defined by the module. Each module gets an __info__/1 function when it's compiled. The function takes one of the following items: :attributes - a keyword list with all persisted attributes :compile - a list with compiler metadata :functions - a keyword list of public functions and their arities :macros - a keyword list of public macros and their arities :md5 - the MD5 of the module :module - the module atom name :struct - (since v1.14.0) if the module defines a struct and if so each field in order","ref":"Module.html#c:__info__/1","source_doc":"Provides runtime information about functions, macros, and other information\ndefined by the module.\n\nEach module gets an `__info__/1` function when it's compiled. The function\ntakes one of the following items:\n\n  * `:attributes` - a keyword list with all persisted attributes\n\n  * `:compile` - a list with compiler metadata\n\n  * `:functions` - a keyword list of public functions and their arities\n\n  * `:macros` - a keyword list of public macros and their arities\n\n  * `:md5` - the MD5 of the module\n\n  * `:module` - the module atom name\n\n  * `:struct` - (since v1.14.0) if the module defines a struct and if so each field in order\n\n","title":"Module.__info__/1","type":"callback"},{"doc":"Returns all module attributes names defined in module . This function can only be used on modules that have not yet been compiled. Examples defmodule Example do @foo 1 Module . register_attribute ( __MODULE__ , :bar , accumulate : true ) :foo in Module . attributes_in ( __MODULE__ ) #=&gt; true :bar in Module . attributes_in ( __MODULE__ ) #=&gt; true end","ref":"Module.html#attributes_in/1","source_doc":"Returns all module attributes names defined in `module`.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      @foo 1\n      Module.register_attribute(__MODULE__, :bar, accumulate: true)\n\n      :foo in Module.attributes_in(__MODULE__)\n      #=> true\n\n      :bar in Module.attributes_in(__MODULE__)\n      #=> true\n    end\n\n","title":"Module.attributes_in/1","type":"function"},{"doc":"Concatenates a list of aliases and returns a new alias. It handles binaries and atoms. Examples iex&gt; Module . concat ( [ Foo , Bar ] ) Foo.Bar iex&gt; Module . concat ( [ Foo , &quot;Bar&quot; ] ) Foo.Bar","ref":"Module.html#concat/1","source_doc":"Concatenates a list of aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat([Foo, Bar])\n    Foo.Bar\n\n    iex> Module.concat([Foo, \"Bar\"])\n    Foo.Bar\n\n","title":"Module.concat/1","type":"function"},{"doc":"Concatenates two aliases and returns a new alias. It handles binaries and atoms. Examples iex&gt; Module . concat ( Foo , Bar ) Foo.Bar iex&gt; Module . concat ( Foo , &quot;Bar&quot; ) Foo.Bar","ref":"Module.html#concat/2","source_doc":"Concatenates two aliases and returns a new alias.\n\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.concat(Foo, Bar)\n    Foo.Bar\n\n    iex> Module.concat(Foo, \"Bar\")\n    Foo.Bar\n\n","title":"Module.concat/2","type":"function"},{"doc":"Creates a module with the given name and defined by the given quoted expressions. The line where the module is defined and its file must be passed as options. It returns a tuple of shape {:module, module, binary, term} where module is the module name, binary is the module bytecode and term is the result of the last expression in quoted . Similar to Kernel.defmodule/2 , the binary will only be written to disk as a .beam file if Module.create/3 is invoked in a file that is currently being compiled. Examples contents = quote do def world , do : true end Module . create ( Hello , contents , Macro.Env . location ( __ENV__ ) ) Hello . world ( ) #=&gt; true Differences from defmodule Module.create/3 works similarly to Kernel.defmodule/2 and return the same results. While one could also use Kernel.defmodule/2 to define modules dynamically, this function is preferred when the module body is given by a quoted expression. Another important distinction is that Module.create/3 allows you to control the environment variables used when defining the module, while Kernel.defmodule/2 automatically uses the environment it is invoked at.","ref":"Module.html#create/3","source_doc":"Creates a module with the given name and defined by\nthe given quoted expressions.\n\nThe line where the module is defined and its file **must**\nbe passed as options.\n\nIt returns a tuple of shape `{:module, module, binary, term}`\nwhere `module` is the module name, `binary` is the module\nbytecode and `term` is the result of the last expression in\n`quoted`.\n\nSimilar to `Kernel.defmodule/2`, the binary will only be\nwritten to disk as a `.beam` file if `Module.create/3` is\ninvoked in a file that is currently being compiled.\n\n## Examples\n\n    contents =\n      quote do\n        def world, do: true\n      end\n\n    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n\n    Hello.world()\n    #=> true\n\n## Differences from `defmodule`\n\n`Module.create/3` works similarly to `Kernel.defmodule/2`\nand return the same results. While one could also use\n`Kernel.defmodule/2` to define modules dynamically, this function\nis preferred when the module body is given by a quoted\nexpression.\n\nAnother important distinction is that `Module.create/3`\nallows you to control the environment variables used\nwhen defining the module, while `Kernel.defmodule/2`\nautomatically uses the environment it is invoked at.\n","title":"Module.create/3","type":"function"},{"doc":"Checks if the module defines the given function or macro. Use defines?/3 to assert for a specific type. This function can only be used on modules that have not yet been compiled. Use Kernel.function_exported?/3 and Kernel.macro_exported?/3 to check for public functions and macros respectively in compiled modules. Note that defines? returns false for functions and macros that have been defined but then marked as overridable and no other implementation has been provided. You can check the overridable status by calling overridable?/2 . Examples defmodule Example do Module . defines? ( __MODULE__ , { :version , 0 } ) #=&gt; false def version , do : 1 Module . defines? ( __MODULE__ , { :version , 0 } ) #=&gt; true end","ref":"Module.html#defines?/2","source_doc":"Checks if the module defines the given function or macro.\n\nUse `defines?/3` to assert for a specific type.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\nNote that `defines?` returns false for functions and macros that have\nbeen defined but then marked as overridable and no other implementation\nhas been provided. You can check the overridable status by calling\n`overridable?/2`.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}) #=> true\n    end\n\n","title":"Module.defines?/2","type":"function"},{"doc":"Checks if the module defines a function or macro of the given kind . kind can be any of :def , :defp , :defmacro , or :defmacrop . This function can only be used on modules that have not yet been compiled. Use Kernel.function_exported?/3 and Kernel.macro_exported?/3 to check for public functions and macros respectively in compiled modules. Examples defmodule Example do Module . defines? ( __MODULE__ , { :version , 0 } , :def ) #=&gt; false def version , do : 1 Module . defines? ( __MODULE__ , { :version , 0 } , :def ) #=&gt; true end","ref":"Module.html#defines?/3","source_doc":"Checks if the module defines a function or macro of the\ngiven `kind`.\n\n`kind` can be any of `:def`, `:defp`, `:defmacro`, or `:defmacrop`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse `Kernel.function_exported?/3` and `Kernel.macro_exported?/3` to check for\npublic functions and macros respectively in compiled modules.\n\n## Examples\n\n    defmodule Example do\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> false\n      def version, do: 1\n      Module.defines?(__MODULE__, {:version, 0}, :def) #=> true\n    end\n\n","title":"Module.defines?/3","type":"function"},{"doc":"Checks if the current module defines the given type (private, opaque or not). This function is only available for modules being compiled.","ref":"Module.html#defines_type?/2","source_doc":"Checks if the current module defines the given type (private, opaque or not).\n\nThis function is only available for modules being compiled.\n","title":"Module.defines_type?/2","type":"function"},{"doc":"Returns all functions and macros defined in module . It returns a list with all defined functions and macros, public and private, in the shape of [{name, arity}, ...] . This function can only be used on modules that have not yet been compiled. Use the Module.__info__/1 callback to get the public functions and macros in compiled modules. Examples defmodule Example do def version , do : 1 defmacrop test ( arg ) , do : arg Module . definitions_in ( __MODULE__ ) #=&gt; [{:version, 0}, {:test, 1}] end","ref":"Module.html#definitions_in/1","source_doc":"Returns all functions and macros defined in `module`.\n\nIt returns a list with all defined functions and macros, public and private,\nin the shape of `[{name, arity}, ...]`.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      defmacrop test(arg), do: arg\n      Module.definitions_in(__MODULE__) #=> [{:version, 0}, {:test, 1}]\n    end\n\n","title":"Module.definitions_in/1","type":"function"},{"doc":"Returns all functions defined in module , according to its kind. This function can only be used on modules that have not yet been compiled. Use the Module.__info__/1 callback to get the public functions and macros in compiled modules. Examples defmodule Example do def version , do : 1 Module . definitions_in ( __MODULE__ , :def ) #=&gt; [{:version, 0}] Module . definitions_in ( __MODULE__ , :defp ) #=&gt; [] end","ref":"Module.html#definitions_in/2","source_doc":"Returns all functions defined in `module`, according\nto its kind.\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get the public functions and macros in\ncompiled modules.\n\n## Examples\n\n    defmodule Example do\n      def version, do: 1\n      Module.definitions_in(__MODULE__, :def)  #=> [{:version, 0}]\n      Module.definitions_in(__MODULE__, :defp) #=> []\n    end\n\n","title":"Module.definitions_in/2","type":"function"},{"doc":"Deletes the entry (or entries) for the given module attribute. It returns the deleted attribute value. If the attribute has not been set nor configured to accumulate, it returns nil . If the attribute is set to accumulate, then this function always returns a list. Deleting the attribute removes existing entries but the attribute will still accumulate. Examples defmodule MyModule do Module . put_attribute ( __MODULE__ , :custom_threshold_for_lib , 10 ) Module . delete_attribute ( __MODULE__ , :custom_threshold_for_lib ) end","ref":"Module.html#delete_attribute/2","source_doc":"Deletes the entry (or entries) for the given module attribute.\n\nIt returns the deleted attribute value. If the attribute has not\nbeen set nor configured to accumulate, it returns `nil`.\n\nIf the attribute is set to accumulate, then this function always\nreturns a list. Deleting the attribute removes existing entries\nbut the attribute will still accumulate.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n      Module.delete_attribute(__MODULE__, :custom_threshold_for_lib)\n    end\n\n","title":"Module.delete_attribute/2","type":"function"},{"doc":"Deletes a definition from a module. It returns true if the definition exists and it was removed, otherwise it returns false.","ref":"Module.html#delete_definition/2","source_doc":"Deletes a definition from a module.\n\nIt returns true if the definition exists and it was removed,\notherwise it returns false.\n","title":"Module.delete_definition/2","type":"function"},{"doc":"Evaluates the quoted contents in the given module's context. A list of environment options can also be given as argument. See Code.eval_string/3 for more information. Raises an error if the module was already compiled. Examples defmodule Foo do contents = quote do def sum ( a , b ) , do : a + b end Module . eval_quoted ( __MODULE__ , contents ) end Foo . sum ( 1 , 2 ) #=&gt; 3 For convenience, you can pass any Macro.Env struct, such as __ENV__/0 , as the first argument or as options. Both the module and all options will be automatically extracted from the environment: defmodule Foo do contents = quote do def sum ( a , b ) , do : a + b end Module . eval_quoted ( __ENV__ , contents ) end Foo . sum ( 1 , 2 ) #=&gt; 3 Note that if you pass a Macro.Env struct as first argument while also passing opts , they will be merged with opts having precedence.","ref":"Module.html#eval_quoted/4","source_doc":"Evaluates the quoted contents in the given module's context.\n\nA list of environment options can also be given as argument.\nSee `Code.eval_string/3` for more information.\n\nRaises an error if the module was already compiled.\n\n## Examples\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__MODULE__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nFor convenience, you can pass any `Macro.Env` struct, such\nas  `__ENV__/0`, as the first argument or as options. Both\nthe module and all options will be automatically extracted\nfrom the environment:\n\n    defmodule Foo do\n      contents =\n        quote do\n          def sum(a, b), do: a + b\n        end\n\n      Module.eval_quoted(__ENV__, contents)\n    end\n\n    Foo.sum(1, 2)\n    #=> 3\n\nNote that if you pass a `Macro.Env` struct as first argument\nwhile also passing `opts`, they will be merged with `opts`\nhaving precedence.\n","title":"Module.eval_quoted/4","type":"function"},{"doc":"Gets the given attribute from a module. If the attribute was marked with accumulate with Module.register_attribute/3 , a list is always returned. nil is returned if the attribute has not been marked with accumulate and has not been set to any value. The @ macro compiles to a call to this function. For example, the following code: @foo Expands to something akin to: Module . get_attribute ( __MODULE__ , :foo ) This function can only be used on modules that have not yet been compiled. Use the Module.__info__/1 callback to get all persisted attributes, or Code.fetch_docs/1 to retrieve all documentation related attributes in compiled modules. Examples defmodule Foo do Module . put_attribute ( __MODULE__ , :value , 1 ) Module . get_attribute ( __MODULE__ , :value ) #=&gt; 1 Module . get_attribute ( __MODULE__ , :value , :default ) #=&gt; 1 Module . get_attribute ( __MODULE__ , :not_found , :default ) #=&gt; :default Module . register_attribute ( __MODULE__ , :value , accumulate : true ) Module . put_attribute ( __MODULE__ , :value , 1 ) Module . get_attribute ( __MODULE__ , :value ) #=&gt; [1] end","ref":"Module.html#get_attribute/3","source_doc":"Gets the given attribute from a module.\n\nIf the attribute was marked with `accumulate` with\n`Module.register_attribute/3`, a list is always returned.\n`nil` is returned if the attribute has not been marked with\n`accumulate` and has not been set to any value.\n\nThe `@` macro compiles to a call to this function. For example,\nthe following code:\n\n    @foo\n\nExpands to something akin to:\n\n    Module.get_attribute(__MODULE__, :foo)\n\nThis function can only be used on modules that have not yet been compiled.\nUse the `c:Module.__info__/1` callback to get all persisted attributes, or\n`Code.fetch_docs/1` to retrieve all documentation related attributes in\ncompiled modules.\n\n## Examples\n\n    defmodule Foo do\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> 1\n\n      Module.get_attribute(__MODULE__, :value, :default) #=> 1\n      Module.get_attribute(__MODULE__, :not_found, :default) #=> :default\n\n      Module.register_attribute(__MODULE__, :value, accumulate: true)\n      Module.put_attribute(__MODULE__, :value, 1)\n      Module.get_attribute(__MODULE__, :value) #=> [1]\n    end\n\n","title":"Module.get_attribute/3","type":"function"},{"doc":"Returns the definition for the given name-arity pair. It returns a tuple with the version , the kind , the definition metadata , and a list with each clause. Each clause is a four-element tuple with metadata, the arguments, the guards, and the clause AST. The clauses are returned in the Elixir AST but a subset that has already been expanded and normalized. This makes it useful for analyzing code but it cannot be reinjected into the module as it will have lost some of its original context. Given this AST representation is mostly internal, it is versioned and it may change at any time. Therefore, use this API with caution . Options :skip_clauses (since v1.14.0) - returns [] instead of returning the clauses. This is useful when there is only an interest in fetching the kind and the metadata","ref":"Module.html#get_definition/3","source_doc":"Returns the definition for the given name-arity pair.\n\nIt returns a tuple with the `version`, the `kind`,\nthe definition `metadata`, and a list with each clause.\nEach clause is a four-element tuple with metadata,\nthe arguments, the guards, and the clause AST.\n\nThe clauses are returned in the Elixir AST but a subset\nthat has already been expanded and normalized. This makes\nit useful for analyzing code but it cannot be reinjected\ninto the module as it will have lost some of its original\ncontext. Given this AST representation is mostly internal,\nit is versioned and it may change at any time. Therefore,\n**use this API with caution**.\n\n## Options\n\n  * `:skip_clauses` (since v1.14.0) - returns `[]` instead\n    of returning the clauses. This is useful when there is\n    only an interest in fetching the kind and the metadata\n\n","title":"Module.get_definition/3","type":"function"},{"doc":"Checks if the given attribute has been defined. An attribute is defined if it has been registered with register_attribute/3 or assigned a value. If an attribute has been deleted with delete_attribute/2 it is no longer considered defined. This function can only be used on modules that have not yet been compiled. Examples defmodule MyModule do @value 1 Module . register_attribute ( __MODULE__ , :other_value ) Module . put_attribute ( __MODULE__ , :another_value , 1 ) Module . has_attribute? ( __MODULE__ , :value ) #=&gt; true Module . has_attribute? ( __MODULE__ , :other_value ) #=&gt; true Module . has_attribute? ( __MODULE__ , :another_value ) #=&gt; true Module . has_attribute? ( __MODULE__ , :undefined ) #=&gt; false Module . delete_attribute ( __MODULE__ , :value ) Module . has_attribute? ( __MODULE__ , :value ) #=&gt; false end","ref":"Module.html#has_attribute?/2","source_doc":"Checks if the given attribute has been defined.\n\nAn attribute is defined if it has been registered with `register_attribute/3`\nor assigned a value. If an attribute has been deleted with `delete_attribute/2`\nit is no longer considered defined.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule MyModule do\n      @value 1\n      Module.register_attribute(__MODULE__, :other_value)\n      Module.put_attribute(__MODULE__, :another_value, 1)\n\n      Module.has_attribute?(__MODULE__, :value) #=> true\n      Module.has_attribute?(__MODULE__, :other_value) #=> true\n      Module.has_attribute?(__MODULE__, :another_value) #=> true\n\n      Module.has_attribute?(__MODULE__, :undefined) #=> false\n\n      Module.delete_attribute(__MODULE__, :value)\n      Module.has_attribute?(__MODULE__, :value) #=> false\n    end\n\n","title":"Module.has_attribute?/2","type":"function"},{"doc":"Makes the given functions in module overridable. An overridable function is lazily defined, allowing a developer to customize it. See Kernel.defoverridable/1 for more information and documentation. Once a function or a macro is marked as overridable, it will no longer be listed under definitions_in/1 or return true when given to defines?/2 until another implementation is given.","ref":"Module.html#make_overridable/2","source_doc":"Makes the given functions in `module` overridable.\n\nAn overridable function is lazily defined, allowing a\ndeveloper to customize it. See `Kernel.defoverridable/1` for\nmore information and documentation.\n\nOnce a function or a macro is marked as overridable, it will\nno longer be listed under `definitions_in/1` or return true\nwhen given to `defines?/2` until another implementation is\ngiven.\n","title":"Module.make_overridable/2","type":"function"},{"doc":"Checks if a module is open. A module is &quot;open&quot; if it is currently being defined and its attributes and functions can be modified.","ref":"Module.html#open?/1","source_doc":"Checks if a module is open.\n\nA module is \"open\" if it is currently being defined and its attributes and\nfunctions can be modified.\n","title":"Module.open?/1","type":"function"},{"doc":"Returns true if tuple in module was marked as overridable at some point. Note overridable?/2 returns true even if the definition was already overridden. You can use defines?/2 to see if a definition exists or one is pending.","ref":"Module.html#overridable?/2","source_doc":"Returns `true` if `tuple` in `module` was marked as overridable\nat some point.\n\nNote `overridable?/2` returns true even if the definition was\nalready overridden. You can use `defines?/2` to see if a definition\nexists or one is pending.\n","title":"Module.overridable?/2","type":"function"},{"doc":"Returns all overridable definitions in module . Note a definition is included even if it was was already overridden. You can use defines?/2 to see if a definition exists or one is pending. This function can only be used on modules that have not yet been compiled. Examples defmodule Example do def foo , do : 1 def bar , do : 2 defoverridable foo : 0 , bar : 0 def foo , do : 3 [ bar : 0 , foo : 0 ] = Module . overridables_in ( __MODULE__ ) |&gt; Enum . sort ( ) end","ref":"Module.html#overridables_in/1","source_doc":"Returns all overridable definitions in `module`.\n\nNote a definition is included even if it was was already overridden.\nYou can use `defines?/2` to see if a definition exists or one is pending.\n\nThis function can only be used on modules that have not yet been compiled.\n\n## Examples\n\n    defmodule Example do\n      def foo, do: 1\n      def bar, do: 2\n\n      defoverridable foo: 0, bar: 0\n      def foo, do: 3\n\n      [bar: 0, foo: 0] = Module.overridables_in(__MODULE__) |> Enum.sort()\n    end\n\n","title":"Module.overridables_in/1","type":"function"},{"doc":"Puts a module attribute with key and value in the given module . Examples defmodule MyModule do Module . put_attribute ( __MODULE__ , :custom_threshold_for_lib , 10 ) end","ref":"Module.html#put_attribute/3","source_doc":"Puts a module attribute with `key` and `value` in the given `module`.\n\n## Examples\n\n    defmodule MyModule do\n      Module.put_attribute(__MODULE__, :custom_threshold_for_lib, 10)\n    end\n\n","title":"Module.put_attribute/3","type":"function"},{"doc":"Registers an attribute. By registering an attribute, a developer is able to customize how Elixir will store and accumulate the attribute values. Options When registering an attribute, two options can be given: :accumulate - several calls to the same attribute will accumulate instead of overriding the previous one. New attributes are always added to the top of the accumulated list. :persist - the attribute will be persisted in the Erlang Abstract Format. Useful when interfacing with Erlang libraries. By default, both options are false . Once an attribute has been set to accumulate or persist, the behaviour cannot be reverted. Examples defmodule MyModule do Module . register_attribute ( __MODULE__ , :custom_threshold_for_lib , accumulate : true ) @custom_threshold_for_lib 10 @custom_threshold_for_lib 20 @custom_threshold_for_lib #=&gt; [20, 10] end","ref":"Module.html#register_attribute/3","source_doc":"Registers an attribute.\n\nBy registering an attribute, a developer is able to customize\nhow Elixir will store and accumulate the attribute values.\n\n## Options\n\nWhen registering an attribute, two options can be given:\n\n  * `:accumulate` - several calls to the same attribute will\n    accumulate instead of overriding the previous one. New attributes\n    are always added to the top of the accumulated list.\n\n  * `:persist` - the attribute will be persisted in the Erlang\n    Abstract Format. Useful when interfacing with Erlang libraries.\n\nBy default, both options are `false`. Once an attribute has been\nset to accumulate or persist, the behaviour cannot be reverted.\n\n## Examples\n\n    defmodule MyModule do\n      Module.register_attribute(__MODULE__, :custom_threshold_for_lib, accumulate: true)\n\n      @custom_threshold_for_lib 10\n      @custom_threshold_for_lib 20\n      @custom_threshold_for_lib #=> [20, 10]\n    end\n\n","title":"Module.register_attribute/3","type":"function"},{"doc":"Returns information about module attributes used by Elixir. See the &quot;Module attributes&quot; section in the module documentation for more information on each attribute. Examples iex&gt; map = Module . reserved_attributes ( ) iex&gt; Map . has_key? ( map , :moduledoc ) true iex&gt; Map . has_key? ( map , :doc ) true","ref":"Module.html#reserved_attributes/0","source_doc":"Returns information about module attributes used by Elixir.\n\nSee the \"Module attributes\" section in the module documentation for more\ninformation on each attribute.\n\n## Examples\n\n    iex> map = Module.reserved_attributes()\n    iex> Map.has_key?(map, :moduledoc)\n    true\n    iex> Map.has_key?(map, :doc)\n    true\n\n","title":"Module.reserved_attributes/0","type":"function"},{"doc":"Concatenates a list of aliases and returns a new alias only if the alias was already referenced. If the alias was not referenced yet, fails with ArgumentError . It handles binaries and atoms. Examples iex&gt; Module . safe_concat ( [ List , Chars ] ) List.Chars","ref":"Module.html#safe_concat/1","source_doc":"Concatenates a list of aliases and returns a new alias only if the alias\nwas already referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat([List, Chars])\n    List.Chars\n\n","title":"Module.safe_concat/1","type":"function"},{"doc":"Concatenates two aliases and returns a new alias only if the alias was already referenced. If the alias was not referenced yet, fails with ArgumentError . It handles binaries and atoms. Examples iex&gt; Module . safe_concat ( List , Chars ) List.Chars","ref":"Module.html#safe_concat/2","source_doc":"Concatenates two aliases and returns a new alias only if the alias was\nalready referenced.\n\nIf the alias was not referenced yet, fails with `ArgumentError`.\nIt handles binaries and atoms.\n\n## Examples\n\n    iex> Module.safe_concat(List, Chars)\n    List.Chars\n\n","title":"Module.safe_concat/2","type":"function"},{"doc":"Copies the given spec as a callback. Returns true if there is such a spec and it was copied as a callback. If the function associated to the spec has documentation defined prior to invoking this function, the docs are copied too.","ref":"Module.html#spec_to_callback/2","source_doc":"Copies the given spec as a callback.\n\nReturns `true` if there is such a spec and it was copied as a callback.\nIf the function associated to the spec has documentation defined prior to\ninvoking this function, the docs are copied too.\n","title":"Module.spec_to_callback/2","type":"function"},{"doc":"Splits the given module name into binary parts. module has to be an Elixir module, as split/1 won't work with Erlang-style modules (for example, split(:lists) raises an error). split/1 also supports splitting the string representation of Elixir modules (that is, the result of calling Atom.to_string/1 with the module name). Examples iex&gt; Module . split ( Very.Long.Module.Name.And.Even.Longer ) [ &quot;Very&quot; , &quot;Long&quot; , &quot;Module&quot; , &quot;Name&quot; , &quot;And&quot; , &quot;Even&quot; , &quot;Longer&quot; ] iex&gt; Module . split ( &quot;Elixir.String.Chars&quot; ) [ &quot;String&quot; , &quot;Chars&quot; ]","ref":"Module.html#split/1","source_doc":"Splits the given module name into binary parts.\n\n`module` has to be an Elixir module, as `split/1` won't work with Erlang-style\nmodules (for example, `split(:lists)` raises an error).\n\n`split/1` also supports splitting the string representation of Elixir modules\n(that is, the result of calling `Atom.to_string/1` with the module name).\n\n## Examples\n\n    iex> Module.split(Very.Long.Module.Name.And.Even.Longer)\n    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n    iex> Module.split(\"Elixir.String.Chars\")\n    [\"String\", \"Chars\"]\n\n","title":"Module.split/1","type":"function"},{"doc":"","ref":"Module.html#t:def_kind/0","source_doc":false,"title":"Module.def_kind/0","type":"type"},{"doc":"","ref":"Module.html#t:definition/0","source_doc":false,"title":"Module.definition/0","type":"type"},{"doc":"A NaiveDateTime struct (without a time zone) and functions. The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the new/2 and new/8 functions or using the ~N (see sigil_N/2 ) sigil: iex&gt; ~N[2000-01-01 23:00:07] ~N[2000-01-01 23:00:07] The date and time fields in the struct can be accessed directly: iex&gt; naive = ~N[2000-01-01 23:00:07] iex&gt; naive . year 2000 iex&gt; naive . second 7 We call them &quot;naive&quot; because this datetime representation does not have a time zone. This means the datetime may not actually exist in certain areas in the world even though it is valid. For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since NaiveDateTime is not validated against a time zone, such errors would go unnoticed. Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries. Comparing naive date times Comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and similar are structural and based on the NaiveDateTime struct fields. For proper comparison between naive datetimes, use the compare/2 function. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum naive datetime of an Enum . For example: iex&gt; Enum . min ( [ ~N[2020-01-01 23:00:07] , ~N[2000-01-01 23:00:07] ] , NaiveDateTime ) ~N[2000-01-01 23:00:07] Using epochs The add/3 and diff/3 functions can be used for computing date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00): iex&gt; NaiveDateTime . diff ( ~N[2010-04-17 14:00:00] , ~N[1970-01-01 00:00:00] ) 1271512800 iex&gt; NaiveDateTime . add ( ~N[1970-01-01 00:00:00] , 1_271_512_800 ) ~N[2010-04-17 14:00:00] Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).","ref":"NaiveDateTime.html","source_doc":"A NaiveDateTime struct (without a time zone) and functions.\n\nThe NaiveDateTime struct contains the fields year, month, day, hour,\nminute, second, microsecond and calendar. New naive datetimes can be\nbuilt with the `new/2` and `new/8` functions or using the\n`~N` (see `sigil_N/2`) sigil:\n\n    iex> ~N[2000-01-01 23:00:07]\n    ~N[2000-01-01 23:00:07]\n\nThe date and time fields in the struct can be accessed directly:\n\n    iex> naive = ~N[2000-01-01 23:00:07]\n    iex> naive.year\n    2000\n    iex> naive.second\n    7\n\nWe call them \"naive\" because this datetime representation does not\nhave a time zone. This means the datetime may not actually exist in\ncertain areas in the world even though it is valid.\n\nFor example, when daylight saving changes are applied by a region,\nthe clock typically moves forward or backward by one hour. This means\ncertain datetimes never occur or may occur more than once. Since\n`NaiveDateTime` is not validated against a time zone, such errors\nwould go unnoticed.\n\nDevelopers should avoid creating the NaiveDateTime structs directly\nand instead, rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.\n\n## Comparing naive date times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `NaiveDateTime` struct fields. For proper comparison\nbetween naive datetimes, use the `compare/2` function. The existence of the\n`compare/2` function in this module also allows using `Enum.min/2` and\n`Enum.max/2` functions to get the minimum and maximum naive datetime of an\n`Enum`. For example:\n\n    iex> Enum.min([~N[2020-01-01 23:00:07], ~N[2000-01-01 23:00:07]], NaiveDateTime)\n    ~N[2000-01-01 23:00:07]\n\n## Using epochs\n\nThe `add/3` and `diff/3` functions can be used for computing date\ntimes or retrieving the number of seconds between instants.\nFor example, if there is an interest in computing the number of\nseconds from the Unix epoch (1970-01-01 00:00:00):\n\n    iex> NaiveDateTime.diff(~N[2010-04-17 14:00:00], ~N[1970-01-01 00:00:00])\n    1271512800\n\n    iex> NaiveDateTime.add(~N[1970-01-01 00:00:00], 1_271_512_800)\n    ~N[2010-04-17 14:00:00]\n\nThose functions are optimized to deal with common epochs, such\nas the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).\n","title":"NaiveDateTime","type":"module"},{"doc":"Adds a specified amount of time to a NaiveDateTime . Accepts an amount_to_add in any unit . unit can be :day , :hour , :minute , :second or any subsecond precision from System.time_unit/0 . It defaults to :second . Negative values will move backwards in time. This function always consider the unit to be computed according to the Calendar.ISO . Examples It uses seconds by default: # adds seconds by default iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , 2 ) ~N[2014-10-02 00:29:12] # accepts negative offsets iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , - 2 ) ~N[2014-10-02 00:29:08] It can also work with subsecond precisions: iex&gt; NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , 2_000 , :millisecond ) ~N[2014-10-02 00:29:12.000] As well as days/hours/minutes: iex&gt; NaiveDateTime . add ( ~N[2015-02-28 00:29:10] , 2 , :day ) ~N[2015-03-02 00:29:10] iex&gt; NaiveDateTime . add ( ~N[2015-02-28 00:29:10] , 36 , :hour ) ~N[2015-03-01 12:29:10] iex&gt; NaiveDateTime . add ( ~N[2015-02-28 00:29:10] , 60 , :minute ) ~N[2015-02-28 01:29:10] This operation merges the precision of the naive date time with the given unit: iex&gt; result = NaiveDateTime . add ( ~N[2014-10-02 00:29:10] , 21 , :millisecond ) ~N[2014-10-02 00:29:10.021] iex&gt; result . microsecond { 21000 , 3 } Operations on top of gregorian seconds or the Unix epoch are optimized: # from Gregorian seconds iex&gt; NaiveDateTime . add ( ~N[0000-01-01 00:00:00] , 63_579_428_950 ) ~N[2014-10-02 00:29:10] Passing a DateTime automatically converts it to NaiveDateTime , discarding the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . add ( dt , 21 , :second ) ~N[2000-02-29 23:00:28]","ref":"NaiveDateTime.html#add/3","source_doc":"Adds a specified amount of time to a `NaiveDateTime`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be `:day`,\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\n## Examples\n\nIt uses seconds by default:\n\n    # adds seconds by default\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n    ~N[2014-10-02 00:29:12]\n\n    # accepts negative offsets\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n    ~N[2014-10-02 00:29:08]\n\nIt can also work with subsecond precisions:\n\n    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n    ~N[2014-10-02 00:29:12.000]\n\nAs well as days/hours/minutes:\n\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 2, :day)\n    ~N[2015-03-02 00:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 36, :hour)\n    ~N[2015-03-01 12:29:10]\n    iex> NaiveDateTime.add(~N[2015-02-28 00:29:10], 60, :minute)\n    ~N[2015-02-28 01:29:10]\n\nThis operation merges the precision of the naive date time with the given unit:\n\n    iex> result = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)\n    ~N[2014-10-02 00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\nOperations on top of gregorian seconds or the Unix epoch are optimized:\n\n    # from Gregorian seconds\n    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63_579_428_950)\n    ~N[2014-10-02 00:29:10]\n\nPassing a `DateTime` automatically converts it to `NaiveDateTime`,\ndiscarding the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.add(dt, 21, :second)\n    ~N[2000-02-29 23:00:28]\n\n","title":"NaiveDateTime.add/3","type":"function"},{"doc":"Returns true if the first NaiveDateTime is strictly later than the second. Examples iex&gt; NaiveDateTime . after? ( ~N[2022-02-02 11:00:00] , ~N[2021-01-01 11:00:00] ) true iex&gt; NaiveDateTime . after? ( ~N[2021-01-01 11:00:00] , ~N[2021-01-01 11:00:00] ) false iex&gt; NaiveDateTime . after? ( ~N[2021-01-01 11:00:00] , ~N[2022-02-02 11:00:00] ) false","ref":"NaiveDateTime.html#after?/2","source_doc":"Returns true if the first `NaiveDateTime` is strictly later than the second.\n\n## Examples\n\n    iex> NaiveDateTime.after?(~N[2022-02-02 11:00:00], ~N[2021-01-01 11:00:00])\n    true\n    iex> NaiveDateTime.after?(~N[2021-01-01 11:00:00], ~N[2021-01-01 11:00:00])\n    false\n    iex> NaiveDateTime.after?(~N[2021-01-01 11:00:00], ~N[2022-02-02 11:00:00])\n    false\n\n","title":"NaiveDateTime.after?/2","type":"function"},{"doc":"Returns true if the first NaiveDateTime is strictly earlier than the second. Examples iex&gt; NaiveDateTime . before? ( ~N[2021-01-01 11:00:00] , ~N[2022-02-02 11:00:00] ) true iex&gt; NaiveDateTime . before? ( ~N[2021-01-01 11:00:00] , ~N[2021-01-01 11:00:00] ) false iex&gt; NaiveDateTime . before? ( ~N[2022-02-02 11:00:00] , ~N[2021-01-01 11:00:00] ) false","ref":"NaiveDateTime.html#before?/2","source_doc":"Returns true if the first `NaiveDateTime` is strictly earlier than the second.\n\n## Examples\n\n    iex> NaiveDateTime.before?(~N[2021-01-01 11:00:00], ~N[2022-02-02 11:00:00])\n    true\n    iex> NaiveDateTime.before?(~N[2021-01-01 11:00:00], ~N[2021-01-01 11:00:00])\n    false\n    iex> NaiveDateTime.before?(~N[2022-02-02 11:00:00], ~N[2021-01-01 11:00:00])\n    false\n\n","title":"NaiveDateTime.before?/2","type":"function"},{"doc":"Calculates a NaiveDateTime that is the first moment for the given NaiveDateTime . To calculate the beginning of day of a DateTime , call this function, then convert back to a DateTime : datetime |&gt; NaiveDateTime . beginning_of_day ( ) |&gt; DateTime . from_naive ( datetime . timezone ) Note that the beginning of the day may not exist or be ambiguous in a given timezone, so you must handle those cases accordingly. Examples iex&gt; NaiveDateTime . beginning_of_day ( ~N[2000-01-01 23:00:07.123456] ) ~N[2000-01-01 00:00:00.000000]","ref":"NaiveDateTime.html#beginning_of_day/1","source_doc":"Calculates a `NaiveDateTime` that is the first moment for the given `NaiveDateTime`.\n\nTo calculate the beginning of day of a `DateTime`, call this function, then convert back to a `DateTime`:\n\n    datetime\n    |> NaiveDateTime.beginning_of_day()\n    |> DateTime.from_naive(datetime.timezone)\n\nNote that the beginning of the day may not exist or be ambiguous\nin a given timezone, so you must handle those cases accordingly.\n\n## Examples\n\n    iex> NaiveDateTime.beginning_of_day(~N[2000-01-01 23:00:07.123456])\n    ~N[2000-01-01 00:00:00.000000]\n\n","title":"NaiveDateTime.beginning_of_day/1","type":"function"},{"doc":"Compares two NaiveDateTime structs. Returns :gt if first is later than the second and :lt for vice versa. If the two NaiveDateTime are equal :eq is returned. Examples iex&gt; NaiveDateTime . compare ( ~N[2016-04-16 13:30:15] , ~N[2016-04-28 16:19:25] ) :lt iex&gt; NaiveDateTime . compare ( ~N[2016-04-16 13:30:15.1] , ~N[2016-04-16 13:30:15.01] ) :gt This function can also be used to compare a DateTime without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . compare ( dt , ~N[2000-02-29 23:00:07] ) :eq iex&gt; NaiveDateTime . compare ( dt , ~N[2000-01-29 23:00:07] ) :gt iex&gt; NaiveDateTime . compare ( dt , ~N[2000-03-29 23:00:07] ) :lt","ref":"NaiveDateTime.html#compare/2","source_doc":"Compares two `NaiveDateTime` structs.\n\nReturns `:gt` if first is later than the second\nand `:lt` for vice versa. If the two NaiveDateTime\nare equal `:eq` is returned.\n\n## Examples\n\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])\n    :lt\n    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])\n    :gt\n\nThis function can also be used to compare a DateTime without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n    :eq\n    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n    :gt\n    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n    :lt\n\n","title":"NaiveDateTime.compare/2","type":"function"},{"doc":"Converts the given naive_datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an {:error, :incompatible_calendars} tuple is returned. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; NaiveDateTime . convert ( ~N[2000-01-01 13:30:15] , Calendar.Holocene ) { :ok , % NaiveDateTime { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } } }","ref":"NaiveDateTime.html#convert/2","source_doc":"Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an `{:error, :incompatible_calendars}` tuple\nis returned.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    {:ok, %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                         hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}\n\n","title":"NaiveDateTime.convert/2","type":"function"},{"doc":"Converts the given naive_datetime from one calendar to another. If it is not possible to convert unambiguously between the calendars (see Calendar.compatible_calendars?/2 ), an ArgumentError is raised. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; NaiveDateTime . convert! ( ~N[2000-01-01 13:30:15] , Calendar.Holocene ) % NaiveDateTime { calendar : Calendar.Holocene , year : 12000 , month : 1 , day : 1 , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } }","ref":"NaiveDateTime.html#convert!/2","source_doc":"Converts the given `naive_datetime` from one calendar to another.\n\nIf it is not possible to convert unambiguously between the calendars\n(see `Calendar.compatible_calendars?/2`), an ArgumentError is raised.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> NaiveDateTime.convert!(~N[2000-01-01 13:30:15], Calendar.Holocene)\n    %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,\n                   hour: 13, minute: 30, second: 15, microsecond: {0, 0}}\n\n","title":"NaiveDateTime.convert!/2","type":"function"},{"doc":"Subtracts naive_datetime2 from naive_datetime1 . The answer can be returned in any :day , :hour , :minute , or any unit available from System.time_unit/0 . The unit is measured according to Calendar.ISO and defaults to :second . Fractional results are not supported and are truncated. Examples iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:12] , ~N[2014-10-02 00:29:10] ) 2 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:12] , ~N[2014-10-02 00:29:10] , :microsecond ) 2_000_000 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:10.042] , ~N[2014-10-02 00:29:10.021] ) 0 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:10.042] , ~N[2014-10-02 00:29:10.021] , :millisecond ) 21 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:29:10] , ~N[2014-10-02 00:29:12] ) - 2 iex&gt; NaiveDateTime . diff ( ~N[-0001-10-02 00:29:10] , ~N[-0001-10-02 00:29:12] ) - 2 It can also compute the difference in days, hours, or minutes: iex&gt; NaiveDateTime . diff ( ~N[2014-10-10 00:29:10] , ~N[2014-10-02 00:29:10] , :day ) 8 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 12:29:10] , ~N[2014-10-02 00:29:10] , :hour ) 12 iex&gt; NaiveDateTime . diff ( ~N[2014-10-02 00:39:10] , ~N[2014-10-02 00:29:10] , :minute ) 10 But it also rounds incomplete days to zero: iex&gt; NaiveDateTime . diff ( ~N[2014-10-10 00:29:09] , ~N[2014-10-02 00:29:10] , :day ) 7","ref":"NaiveDateTime.html#diff/3","source_doc":"Subtracts `naive_datetime2` from `naive_datetime1`.\n\nThe answer can be returned in any `:day`, `:hour`, `:minute`, or any `unit`\navailable from `t:System.time_unit/0`. The unit is measured according to\n`Calendar.ISO` and defaults to `:second`.\n\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])\n    2\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)\n    2_000_000\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021])\n    0\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)\n    21\n\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[2014-10-02 00:29:12])\n    -2\n    iex> NaiveDateTime.diff(~N[-0001-10-02 00:29:10], ~N[-0001-10-02 00:29:12])\n    -2\n\nIt can also compute the difference in days, hours, or minutes:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:10], ~N[2014-10-02 00:29:10], :day)\n    8\n    iex> NaiveDateTime.diff(~N[2014-10-02 12:29:10], ~N[2014-10-02 00:29:10], :hour)\n    12\n    iex> NaiveDateTime.diff(~N[2014-10-02 00:39:10], ~N[2014-10-02 00:29:10], :minute)\n    10\n\nBut it also rounds incomplete days to zero:\n\n    iex> NaiveDateTime.diff(~N[2014-10-10 00:29:09], ~N[2014-10-02 00:29:10], :day)\n    7\n\n","title":"NaiveDateTime.diff/3","type":"function"},{"doc":"Calculates a NaiveDateTime that is the last moment for the given NaiveDateTime . To calculate the end of day of a DateTime , call this function, then convert back to a DateTime : datetime |&gt; NaiveDateTime . beginning_of_day ( ) |&gt; DateTime . from_naive ( datetime . timezone ) Note that the end of the day may not exist or be ambiguous in a given timezone, so you must handle those cases accordingly. Examples iex&gt; NaiveDateTime . end_of_day ( ~N[2000-01-01 23:00:07.123456] ) ~N[2000-01-01 23:59:59.999999]","ref":"NaiveDateTime.html#end_of_day/1","source_doc":"Calculates a `NaiveDateTime` that is the last moment for the given `NaiveDateTime`.\n\nTo calculate the end of day of a `DateTime`, call this function, then convert back to a `DateTime`:\n\n    datetime\n    |> NaiveDateTime.beginning_of_day()\n    |> DateTime.from_naive(datetime.timezone)\n\nNote that the end of the day may not exist or be ambiguous\nin a given timezone, so you must handle those cases accordingly.\n\n## Examples\n\n    iex> NaiveDateTime.end_of_day(~N[2000-01-01 23:00:07.123456])\n    ~N[2000-01-01 23:59:59.999999]\n\n","title":"NaiveDateTime.end_of_day/1","type":"function"},{"doc":"Converts an Erlang datetime tuple to a NaiveDateTime struct. Attempting to convert an invalid ISO calendar date will produce an error tuple. Examples iex&gt; NaiveDateTime . from_erl ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } ) { :ok , ~N[2000-01-01 13:30:15] } iex&gt; NaiveDateTime . from_erl ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } , { 5000 , 3 } ) { :ok , ~N[2000-01-01 13:30:15.005] } iex&gt; NaiveDateTime . from_erl ( { { 2000 , 13 , 1 } , { 13 , 30 , 15 } } ) { :error , :invalid_date } iex&gt; NaiveDateTime . from_erl ( { { 2000 , 13 , 1 } , { 13 , 30 , 15 } } ) { :error , :invalid_date }","ref":"NaiveDateTime.html#from_erl/3","source_doc":"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n    {:ok, ~N[2000-01-01 13:30:15]}\n    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    {:ok, ~N[2000-01-01 13:30:15.005]}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n    {:error, :invalid_date}\n\n","title":"NaiveDateTime.from_erl/3","type":"function"},{"doc":"Converts an Erlang datetime tuple to a NaiveDateTime struct. Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple. Examples iex&gt; NaiveDateTime . from_erl! ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } ) ~N[2000-01-01 13:30:15] iex&gt; NaiveDateTime . from_erl! ( { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } , { 5000 , 3 } ) ~N[2000-01-01 13:30:15.005] iex&gt; NaiveDateTime . from_erl! ( { { 2000 , 13 , 1 } , { 13 , 30 , 15 } } ) ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date","ref":"NaiveDateTime.html#from_erl!/3","source_doc":"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n\nRaises if the datetime is invalid.\nAttempting to convert an invalid ISO calendar date will produce an error tuple.\n\n## Examples\n\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n    ~N[2000-01-01 13:30:15]\n    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n    ~N[2000-01-01 13:30:15.005]\n    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date\n\n","title":"NaiveDateTime.from_erl!/3","type":"function"},{"doc":"Converts a number of gregorian seconds to a NaiveDateTime struct. Examples iex&gt; NaiveDateTime . from_gregorian_seconds ( 1 ) ~N[0000-01-01 00:00:01] iex&gt; NaiveDateTime . from_gregorian_seconds ( 63_755_511_991 , { 5000 , 3 } ) ~N[2020-05-01 00:26:31.005] iex&gt; NaiveDateTime . from_gregorian_seconds ( - 1 ) ~N[-0001-12-31 23:59:59]","ref":"NaiveDateTime.html#from_gregorian_seconds/3","source_doc":"Converts a number of gregorian seconds to a `NaiveDateTime` struct.\n\n## Examples\n\n    iex> NaiveDateTime.from_gregorian_seconds(1)\n    ~N[0000-01-01 00:00:01]\n    iex> NaiveDateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})\n    ~N[2020-05-01 00:26:31.005]\n    iex> NaiveDateTime.from_gregorian_seconds(-1)\n    ~N[-0001-12-31 23:59:59]\n\n","title":"NaiveDateTime.from_gregorian_seconds/3","type":"function"},{"doc":"Parses the extended &quot;Date and time of day&quot; format described by ISO 8601:2019 . Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times. As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function. Note leap seconds are not supported by the built-in Calendar.ISO. Examples iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07&quot; ) { :ok , ~N[2015-01-23 23:50:07] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07&quot; ) { :ok , ~N[2015-01-23 23:50:07] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07Z&quot; ) { :ok , ~N[2015-01-23 23:50:07] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07.0&quot; ) { :ok , ~N[2015-01-23 23:50:07.0] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07,0123456&quot; ) { :ok , ~N[2015-01-23 23:50:07.012345] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07.0123456&quot; ) { :ok , ~N[2015-01-23 23:50:07.012345] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123Z&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23P23:50:07&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015:01:23 23-50-07&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:07A&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23 23:50:61&quot; ) { :error , :invalid_time } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-32 23:50:07&quot; ) { :error , :invalid_date } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123+02:30&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123+00:00&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-02:30&quot; ) { :ok , ~N[2015-01-23 23:50:07.123] } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-00:00&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-00:60&quot; ) { :error , :invalid_format } iex&gt; NaiveDateTime . from_iso8601 ( &quot;2015-01-23T23:50:07.123-24:00&quot; ) { :error , :invalid_format }","ref":"NaiveDateTime.html#from_iso8601/2","source_doc":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in naive date\ntimes.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\nNote leap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n    {:ok, ~N[2015-01-23 23:50:07]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n    {:ok, ~N[2015-01-23 23:50:07.0]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07,0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n    {:ok, ~N[2015-01-23 23:50:07.012345]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n    {:error, :invalid_time}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n    {:ok, ~N[2015-01-23 23:50:07.123]}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n    {:error, :invalid_format}\n    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n    {:error, :invalid_format}\n\n","title":"NaiveDateTime.from_iso8601/2","type":"function"},{"doc":"Parses the extended &quot;Date and time of day&quot; format described by ISO 8601:2019 . Raises if the format is invalid. Examples iex&gt; NaiveDateTime . from_iso8601! ( &quot;2015-01-23T23:50:07.123Z&quot; ) ~N[2015-01-23 23:50:07.123] iex&gt; NaiveDateTime . from_iso8601! ( &quot;2015-01-23T23:50:07,123Z&quot; ) ~N[2015-01-23 23:50:07.123] iex&gt; NaiveDateTime . from_iso8601! ( &quot;2015-01-23P23:50:07&quot; ) ** (ArgumentError) cannot parse &quot;2015-01-23P23:50:07&quot; as naive datetime, reason: :invalid_format","ref":"NaiveDateTime.html#from_iso8601!/2","source_doc":"Parses the extended \"Date and time of day\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07,123Z\")\n    ~N[2015-01-23 23:50:07.123]\n    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive datetime, reason: :invalid_format\n\n","title":"NaiveDateTime.from_iso8601!/2","type":"function"},{"doc":"Returns the &quot;local time&quot; for the machine the Elixir program is running on. WARNING: This function can cause insidious bugs. It depends on the time zone configuration at run time. This can changed and be set to a time zone that has daylight saving jumps (spring forward or fall back). This function can be used to display what the time is right now for the time zone configuration that the machine happens to have. An example would be a desktop program displaying a clock to the user. For any other uses it is probably a bad idea to use this function. For most cases, use DateTime.now/2 or DateTime.utc_now/1 instead. Does not include fractional seconds. Examples iex&gt; naive_datetime = NaiveDateTime . local_now ( ) iex&gt; naive_datetime . year &gt;= 2019 true","ref":"NaiveDateTime.html#local_now/1","source_doc":"Returns the \"local time\" for the machine the Elixir program is running on.\n\nWARNING: This function can cause insidious bugs. It depends on the time zone\nconfiguration at run time. This can changed and be set to a time zone that has\ndaylight saving jumps (spring forward or fall back).\n\nThis function can be used to display what the time is right now for the time\nzone configuration that the machine happens to have. An example would be a\ndesktop program displaying a clock to the user. For any other uses it is\nprobably a bad idea to use this function.\n\nFor most cases, use `DateTime.now/2` or `DateTime.utc_now/1` instead.\n\nDoes not include fractional seconds.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.local_now()\n    iex> naive_datetime.year >= 2019\n    true\n\n","title":"NaiveDateTime.local_now/1","type":"function"},{"doc":"Builds a naive datetime from date and time structs. Examples iex&gt; NaiveDateTime . new ( ~D[2010-01-13] , ~T[23:00:07.005] ) { :ok , ~N[2010-01-13 23:00:07.005] }","ref":"NaiveDateTime.html#new/2","source_doc":"Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n    {:ok, ~N[2010-01-13 23:00:07.005]}\n\n","title":"NaiveDateTime.new/2","type":"function"},{"doc":"Builds a new ISO naive datetime. Expects all values to be integers. Returns {:ok, naive_datetime} if each entry fits its appropriate range, returns {:error, reason} otherwise. Examples iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 0 , 0 , 0 ) { :ok , ~N[2000-01-01 00:00:00] } iex&gt; NaiveDateTime . new ( 2000 , 13 , 1 , 0 , 0 , 0 ) { :error , :invalid_date } iex&gt; NaiveDateTime . new ( 2000 , 2 , 29 , 0 , 0 , 0 ) { :ok , ~N[2000-02-29 00:00:00] } iex&gt; NaiveDateTime . new ( 2000 , 2 , 30 , 0 , 0 , 0 ) { :error , :invalid_date } iex&gt; NaiveDateTime . new ( 2001 , 2 , 29 , 0 , 0 , 0 ) { :error , :invalid_date } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } ) { :ok , ~N[2000-01-01 23:59:59.0] } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , 999_999 ) { :ok , ~N[2000-01-01 23:59:59.999999] } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 24 , 59 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 60 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 60 , 999_999 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , 1_000_000 ) { :error , :invalid_time } iex&gt; NaiveDateTime . new ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } , Calendar.ISO ) { :ok , ~N[2000-01-01 23:59:59.0] }","ref":"NaiveDateTime.html#new/8","source_doc":"Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `{:ok, naive_datetime}`\nif each entry fits its appropriate range, returns `{:error, reason}`\notherwise.\n\n## Examples\n\n    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n    {:ok, ~N[2000-01-01 00:00:00]}\n    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n    {:ok, ~N[2000-02-29 00:00:00]}\n    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n    {:error, :invalid_date}\n    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n    {:error, :invalid_date}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n    {:ok, ~N[2000-01-01 23:59:59.999999]}\n    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    {:ok, ~N[2000-01-01 23:59:59.0]}\n\n","title":"NaiveDateTime.new/8","type":"function"},{"doc":"Builds a naive datetime from date and time structs. Examples iex&gt; NaiveDateTime . new! ( ~D[2010-01-13] , ~T[23:00:07.005] ) ~N[2010-01-13 23:00:07.005]","ref":"NaiveDateTime.html#new!/2","source_doc":"Builds a naive datetime from date and time structs.\n\n## Examples\n\n    iex> NaiveDateTime.new!(~D[2010-01-13], ~T[23:00:07.005])\n    ~N[2010-01-13 23:00:07.005]\n\n","title":"NaiveDateTime.new!/2","type":"function"},{"doc":"Builds a new ISO naive datetime. Expects all values to be integers. Returns naive_datetime if each entry fits its appropriate range, raises if time or date is invalid. Examples iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 0 , 0 , 0 ) ~N[2000-01-01 00:00:00] iex&gt; NaiveDateTime . new! ( 2000 , 2 , 29 , 0 , 0 , 0 ) ~N[2000-02-29 00:00:00] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } ) ~N[2000-01-01 23:59:59.0] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 23 , 59 , 59 , 999_999 ) ~N[2000-01-01 23:59:59.999999] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 23 , 59 , 59 , { 0 , 1 } , Calendar.ISO ) ~N[2000-01-01 23:59:59.0] iex&gt; NaiveDateTime . new! ( 2000 , 1 , 1 , 24 , 59 , 59 , 999_999 ) ** (ArgumentError) cannot build naive datetime, reason: :invalid_time","ref":"NaiveDateTime.html#new!/8","source_doc":"Builds a new ISO naive datetime.\n\nExpects all values to be integers. Returns `naive_datetime`\nif each entry fits its appropriate range, raises if\ntime or date is invalid.\n\n## Examples\n\n    iex> NaiveDateTime.new!(2000, 1, 1, 0, 0, 0)\n    ~N[2000-01-01 00:00:00]\n    iex> NaiveDateTime.new!(2000, 2, 29, 0, 0, 0)\n    ~N[2000-02-29 00:00:00]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1})\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, 999_999)\n    ~N[2000-01-01 23:59:59.999999]\n    iex> NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)\n    ~N[2000-01-01 23:59:59.0]\n    iex> NaiveDateTime.new!(2000, 1, 1, 24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build naive datetime, reason: :invalid_time\n\n","title":"NaiveDateTime.new!/8","type":"function"},{"doc":"Converts a NaiveDateTime into a Date . Because Date does not hold time information, data will be lost during the conversion. Examples iex&gt; NaiveDateTime . to_date ( ~N[2002-01-13 23:00:07] ) ~D[2002-01-13]","ref":"NaiveDateTime.html#to_date/1","source_doc":"Converts a `NaiveDateTime` into a `Date`.\n\nBecause `Date` does not hold time information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n    ~D[2002-01-13]\n\n","title":"NaiveDateTime.to_date/1","type":"function"},{"doc":"Converts a NaiveDateTime struct to an Erlang datetime tuple. Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise. WARNING: Loss of precision may occur, as Erlang time tuples only store hour/minute/second. Examples iex&gt; NaiveDateTime . to_erl ( ~N[2000-01-01 13:30:15] ) { { 2000 , 1 , 1 } , { 13 , 30 , 15 } } This function can also be used to convert a DateTime to an Erlang datetime tuple without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . to_erl ( dt ) { { 2000 , 2 , 29 } , { 23 , 00 , 07 } }","ref":"NaiveDateTime.html#to_erl/1","source_doc":"Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\nWARNING: Loss of precision may occur, as Erlang time tuples only store\nhour/minute/second.\n\n## Examples\n\n    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n    {{2000, 1, 1}, {13, 30, 15}}\n\nThis function can also be used to convert a DateTime to an Erlang\ndatetime tuple without the time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_erl(dt)\n    {{2000, 2, 29}, {23, 00, 07}}\n\n","title":"NaiveDateTime.to_erl/1","type":"function"},{"doc":"Converts a NaiveDateTime struct to a number of gregorian seconds and microseconds. Examples iex&gt; NaiveDateTime . to_gregorian_seconds ( ~N[0000-01-01 00:00:01] ) { 1 , 0 } iex&gt; NaiveDateTime . to_gregorian_seconds ( ~N[2020-05-01 00:26:31.005] ) { 63_755_511_991 , 5000 }","ref":"NaiveDateTime.html#to_gregorian_seconds/1","source_doc":"Converts a `NaiveDateTime` struct to a number of gregorian seconds and microseconds.\n\n## Examples\n\n    iex> NaiveDateTime.to_gregorian_seconds(~N[0000-01-01 00:00:01])\n    {1, 0}\n    iex> NaiveDateTime.to_gregorian_seconds(~N[2020-05-01 00:26:31.005])\n    {63_755_511_991, 5000}\n\n","title":"NaiveDateTime.to_gregorian_seconds/1","type":"function"},{"doc":"Converts the given naive datetime to ISO 8601:2019 . By default, NaiveDateTime.to_iso8601/2 returns naive datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise. Examples iex&gt; NaiveDateTime . to_iso8601 ( ~N[2000-02-28 23:00:13] ) &quot;2000-02-28T23:00:13&quot; iex&gt; NaiveDateTime . to_iso8601 ( ~N[2000-02-28 23:00:13.001] ) &quot;2000-02-28T23:00:13.001&quot; iex&gt; NaiveDateTime . to_iso8601 ( ~N[2000-02-28 23:00:13.001] , :basic ) &quot;20000228T230013.001&quot; This function can also be used to convert a DateTime to ISO 8601 without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . to_iso8601 ( dt ) &quot;2000-02-29T23:00:07&quot;","ref":"NaiveDateTime.html#to_iso8601/2","source_doc":"Converts the given naive datetime to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `NaiveDateTime.to_iso8601/2` returns naive datetimes formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through passing the `:basic` option.\n\nOnly supports converting naive datetimes which are in the ISO calendar,\nattempting to convert naive datetimes from other calendars will raise.\n\n### Examples\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n    \"2000-02-28T23:00:13\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28T23:00:13.001\"\n\n    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001], :basic)\n    \"20000228T230013.001\"\n\nThis function can also be used to convert a DateTime to ISO 8601 without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_iso8601(dt)\n    \"2000-02-29T23:00:07\"\n\n","title":"NaiveDateTime.to_iso8601/2","type":"function"},{"doc":"Converts the given naive datetime to a string according to its calendar. Examples iex&gt; NaiveDateTime . to_string ( ~N[2000-02-28 23:00:13] ) &quot;2000-02-28 23:00:13&quot; iex&gt; NaiveDateTime . to_string ( ~N[2000-02-28 23:00:13.001] ) &quot;2000-02-28 23:00:13.001&quot; iex&gt; NaiveDateTime . to_string ( ~N[-0100-12-15 03:20:31] ) &quot;-0100-12-15 03:20:31&quot; This function can also be used to convert a DateTime to a string without the time zone information: iex&gt; dt = % DateTime { year : 2000 , month : 2 , day : 29 , zone_abbr : &quot;CET&quot; , ...&gt; hour : 23 , minute : 0 , second : 7 , microsecond : { 0 , 0 } , ...&gt; utc_offset : 3600 , std_offset : 0 , time_zone : &quot;Europe/Warsaw&quot; } iex&gt; NaiveDateTime . to_string ( dt ) &quot;2000-02-29 23:00:07&quot;","ref":"NaiveDateTime.html#to_string/1","source_doc":"Converts the given naive datetime to a string according to its calendar.\n\n### Examples\n\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n    \"2000-02-28 23:00:13\"\n    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n    \"2000-02-28 23:00:13.001\"\n    iex> NaiveDateTime.to_string(~N[-0100-12-15 03:20:31])\n    \"-0100-12-15 03:20:31\"\n\nThis function can also be used to convert a DateTime to a string without\nthe time zone information:\n\n    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n    iex> NaiveDateTime.to_string(dt)\n    \"2000-02-29 23:00:07\"\n\n","title":"NaiveDateTime.to_string/1","type":"function"},{"doc":"Converts a NaiveDateTime into Time . Because Time does not hold date information, data will be lost during the conversion. Examples iex&gt; NaiveDateTime . to_time ( ~N[2002-01-13 23:00:07] ) ~T[23:00:07]","ref":"NaiveDateTime.html#to_time/1","source_doc":"Converts a `NaiveDateTime` into `Time`.\n\nBecause `Time` does not hold date information,\ndata will be lost during the conversion.\n\n## Examples\n\n    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n    ~T[23:00:07]\n\n","title":"NaiveDateTime.to_time/1","type":"function"},{"doc":"Returns the given naive datetime with the microsecond field truncated to the given precision ( :microsecond , :millisecond or :second ). The given naive datetime is returned unchanged if it already has lower precision than the given precision. Examples iex&gt; NaiveDateTime . truncate ( ~N[2017-11-06 00:23:51.123456] , :microsecond ) ~N[2017-11-06 00:23:51.123456] iex&gt; NaiveDateTime . truncate ( ~N[2017-11-06 00:23:51.123456] , :millisecond ) ~N[2017-11-06 00:23:51.123] iex&gt; NaiveDateTime . truncate ( ~N[2017-11-06 00:23:51.123456] , :second ) ~N[2017-11-06 00:23:51]","ref":"NaiveDateTime.html#truncate/2","source_doc":"Returns the given naive datetime with the microsecond field truncated to the\ngiven precision (`:microsecond`, `:millisecond` or `:second`).\n\nThe given naive datetime is returned unchanged if it already has lower precision\nthan the given precision.\n\n## Examples\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :microsecond)\n    ~N[2017-11-06 00:23:51.123456]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :millisecond)\n    ~N[2017-11-06 00:23:51.123]\n\n    iex> NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :second)\n    ~N[2017-11-06 00:23:51]\n\n","title":"NaiveDateTime.truncate/2","type":"function"},{"doc":"Returns the current naive datetime in UTC. Prefer using DateTime.utc_now/0 when possible as, opposite to NaiveDateTime , it will keep the time zone information. You can also provide a time unit to automatically truncate the naive datetime. This is available since v1.15.0. Examples iex&gt; naive_datetime = NaiveDateTime . utc_now ( ) iex&gt; naive_datetime . year &gt;= 2016 true iex&gt; naive_datetime = NaiveDateTime . utc_now ( :second ) iex&gt; naive_datetime . microsecond { 0 , 0 }","ref":"NaiveDateTime.html#utc_now/1","source_doc":"Returns the current naive datetime in UTC.\n\nPrefer using `DateTime.utc_now/0` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.\n\nYou can also provide a time unit to automatically truncate\nthe naive datetime. This is available since v1.15.0.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.utc_now()\n    iex> naive_datetime.year >= 2016\n    true\n\n    iex> naive_datetime = NaiveDateTime.utc_now(:second)\n    iex> naive_datetime.microsecond\n    {0, 0}\n\n","title":"NaiveDateTime.utc_now/1","type":"function"},{"doc":"Returns the current naive datetime in UTC, supporting a specific calendar and precision. Prefer using DateTime.utc_now/2 when possible as, opposite to NaiveDateTime , it will keep the time zone information. Examples iex&gt; naive_datetime = NaiveDateTime . utc_now ( :second , Calendar.ISO ) iex&gt; naive_datetime . year &gt;= 2016 true iex&gt; naive_datetime = NaiveDateTime . utc_now ( :second , Calendar.ISO ) iex&gt; naive_datetime . microsecond { 0 , 0 }","ref":"NaiveDateTime.html#utc_now/2","source_doc":"Returns the current naive datetime in UTC, supporting a specific\ncalendar and precision.\n\nPrefer using `DateTime.utc_now/2` when possible as, opposite\nto `NaiveDateTime`, it will keep the time zone information.\n\n## Examples\n\n    iex> naive_datetime = NaiveDateTime.utc_now(:second, Calendar.ISO)\n    iex> naive_datetime.year >= 2016\n    true\n\n    iex> naive_datetime = NaiveDateTime.utc_now(:second, Calendar.ISO)\n    iex> naive_datetime.microsecond\n    {0, 0}\n\n","title":"NaiveDateTime.utc_now/2","type":"function"},{"doc":"","ref":"NaiveDateTime.html#t:t/0","source_doc":false,"title":"NaiveDateTime.t/0","type":"type"},{"doc":"Module to work with, define, and import records. Records are simply tuples where the first element is an atom: iex&gt; Record . is_record ( { User , &quot;john&quot; , 27 } ) true This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples' compact structure. In Elixir, records are used mostly in two situations: to work with short, internal data to interface with Erlang records The macros defrecord/3 and defrecordp/3 can be used to create records while extract/2 and extract_all/1 can be used to extract records from Erlang files. Types Types can be defined for tuples with the record/2 macro (only available in typespecs). This macro will expand to a tuple as seen in the example below: defmodule MyModule do require Record Record . defrecord ( :user , name : &quot;john&quot; , age : 25 ) @type user :: record ( :user , name : String . t ( ) , age : integer ) # expands to: &quot;@type user :: {:user, String.t(), integer}&quot; end Reflection A list of all records in a module, if any, can be retrieved by reading the @__records__ module attribute. It returns a list of maps with the record kind, name, tag, and fields. The attribute is only available inside the module definition.","ref":"Record.html","source_doc":"Module to work with, define, and import records.\n\nRecords are simply tuples where the first element is an atom:\n\n    iex> Record.is_record({User, \"john\", 27})\n    true\n\nThis module provides conveniences for working with records at\ncompilation time, where compile-time field names are used to\nmanipulate the tuples, providing fast operations on top of\nthe tuples' compact structure.\n\nIn Elixir, records are used mostly in two situations:\n\n  1. to work with short, internal data\n  2. to interface with Erlang records\n\nThe macros `defrecord/3` and `defrecordp/3` can be used to create records\nwhile `extract/2` and `extract_all/1` can be used to extract records from\nErlang files.\n\n## Types\n\nTypes can be defined for tuples with the `record/2` macro (only available in\ntypespecs). This macro will expand to a tuple as seen in the example below:\n\n    defmodule MyModule do\n      require Record\n      Record.defrecord(:user, name: \"john\", age: 25)\n\n      @type user :: record(:user, name: String.t(), age: integer)\n      # expands to: \"@type user :: {:user, String.t(), integer}\"\n    end\n\n## Reflection\n\nA list of all records in a module, if any, can be retrieved by reading the\n`@__records__` module attribute. It returns a list of maps with the record\nkind, name, tag, and fields. The attribute is only available inside the\nmodule definition.\n","title":"Record","type":"module"},{"doc":"Defines a set of macros to create, access, and pattern match on a record. The name of the generated macros will be name (which has to be an atom). tag is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if nil ), it's the same as name . kv is a keyword list of name: default_value fields for the new record. The following macros are generated: name/0 to create a new record with default values for all fields name/1 to create a new record with the given fields and values, to get the zero-based index of the given field in a record or to convert the given record to a keyword list name/2 to update an existing record with the given fields and values or to access a given field in a given record All these macros are public macros (as defined by defmacro ). See the &quot;Examples&quot; section for examples on how to use these macros. Examples defmodule User do require Record Record . defrecord ( :user , name : &quot;meg&quot; , age : &quot;25&quot; ) end In the example above, a set of macros named user but with different arities will be defined to manipulate the underlying record. # Import the module to make the user macros locally available import User # To create records record = user ( ) #=&gt; {:user, &quot;meg&quot;, 25} record = user ( age : 26 ) #=&gt; {:user, &quot;meg&quot;, 26} # To get a field from the record user ( record , :name ) #=&gt; &quot;meg&quot; # To update the record user ( record , age : 26 ) #=&gt; {:user, &quot;meg&quot;, 26} # To get the zero-based index of the field in record tuple # (index 0 is occupied by the record &quot;tag&quot;) user ( :name ) #=&gt; 1 # Convert a record to a keyword list user ( record ) #=&gt; [name: &quot;meg&quot;, age: 26] The generated macros can also be used in order to pattern match on records and to bind variables during the match: record = user ( ) #=&gt; {:user, &quot;meg&quot;, 25} user ( name : name ) = record name #=&gt; &quot;meg&quot; By default, Elixir uses the record name as the first element of the tuple (the &quot;tag&quot;). However, a different tag can be specified when defining a record, as in the following example, in which we use Customer as the second argument of defrecord/3 : defmodule User do require Record Record . defrecord ( :user , Customer , name : nil ) end require User User . user ( ) #=&gt; {Customer, nil} Defining extracted records with anonymous functions in the values If a record defines an anonymous function in the default values, an ArgumentError will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults. Record . defrecord ( :my_rec , Record . extract ( ... ) ) ** (ArgumentError) invalid value for record field fun_field, cannot escape #Function&lt;12.90072148/2 in :erl_eval.expr/5&gt;. To work around this error, redefine the field with your own &amp;M.f/a function, like so: defmodule MyRec do require Record Record . defrecord ( :my_rec , Record . extract ( ... ) |&gt; Keyword . merge ( fun_field : &amp; __MODULE__ . foo / 2 ) ) def foo ( bar , baz ) , do : IO . inspect ( { bar , baz } ) end","ref":"Record.html#defrecord/3","source_doc":"Defines a set of macros to create, access, and pattern match\non a record.\n\nThe name of the generated macros will be `name` (which has to be an\natom). `tag` is also an atom and is used as the \"tag\" for the record (i.e.,\nthe first element of the record tuple); by default (if `nil`), it's the same\nas `name`. `kv` is a keyword list of `name: default_value` fields for the\nnew record.\n\nThe following macros are generated:\n\n  * `name/0` to create a new record with default values for all fields\n  * `name/1` to create a new record with the given fields and values,\n    to get the zero-based index of the given field in a record or to\n    convert the given record to a keyword list\n  * `name/2` to update an existing record with the given fields and values\n    or to access a given field in a given record\n\nAll these macros are public macros (as defined by `defmacro`).\n\nSee the \"Examples\" section for examples on how to use these macros.\n\n## Examples\n\n    defmodule User do\n      require Record\n      Record.defrecord(:user, name: \"meg\", age: \"25\")\n    end\n\nIn the example above, a set of macros named `user` but with different\narities will be defined to manipulate the underlying record.\n\n    # Import the module to make the user macros locally available\n    import User\n\n    # To create records\n    record = user()        #=> {:user, \"meg\", 25}\n    record = user(age: 26) #=> {:user, \"meg\", 26}\n\n    # To get a field from the record\n    user(record, :name) #=> \"meg\"\n\n    # To update the record\n    user(record, age: 26) #=> {:user, \"meg\", 26}\n\n    # To get the zero-based index of the field in record tuple\n    # (index 0 is occupied by the record \"tag\")\n    user(:name) #=> 1\n\n    # Convert a record to a keyword list\n    user(record) #=> [name: \"meg\", age: 26]\n\nThe generated macros can also be used in order to pattern match on records and\nto bind variables during the match:\n\n    record = user() #=> {:user, \"meg\", 25}\n\n    user(name: name) = record\n    name #=> \"meg\"\n\nBy default, Elixir uses the record name as the first element of the tuple (the \"tag\").\nHowever, a different tag can be specified when defining a record,\nas in the following example, in which we use `Customer` as the second argument of `defrecord/3`:\n\n    defmodule User do\n      require Record\n      Record.defrecord(:user, Customer, name: nil)\n    end\n\n    require User\n    User.user() #=> {Customer, nil}\n\n## Defining extracted records with anonymous functions in the values\n\nIf a record defines an anonymous function in the default values, an\n`ArgumentError` will be raised. This can happen unintentionally when defining\na record after extracting it from an Erlang library that uses anonymous\nfunctions for defaults.\n\n    Record.defrecord(:my_rec, Record.extract(...))\n    ** (ArgumentError) invalid value for record field fun_field,\n        cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n\nTo work around this error, redefine the field with your own &M.f/a function,\nlike so:\n\n    defmodule MyRec do\n      require Record\n      Record.defrecord(:my_rec, Record.extract(...) |> Keyword.merge(fun_field: &__MODULE__.foo/2))\n      def foo(bar, baz), do: IO.inspect({bar, baz})\n    end\n\n","title":"Record.defrecord/3","type":"macro"},{"doc":"Same as defrecord/3 but generates private macros.","ref":"Record.html#defrecordp/3","source_doc":"Same as `defrecord/3` but generates private macros.\n","title":"Record.defrecordp/3","type":"macro"},{"doc":"Extracts record information from an Erlang file. Returns a quoted expression containing the fields as a list of tuples. name , which is the name of the extracted record, is expected to be an atom at compile time . Options This function requires one of the following options, which are exclusive to each other (i.e., only one of them can be used in the same call): :from - (binary representing a path to a file) path to the Erlang file that contains the record definition to extract; with this option, this function uses the same path lookup used by the -include attribute used in Erlang modules. :from_lib - (binary representing a path to a file) path to the Erlang file that contains the record definition to extract; with this option, this function uses the same path lookup used by the -include_lib attribute used in Erlang modules. It additionally accepts the following optional, non-exclusive options: :includes - (a list of directories as binaries) if the record being extracted depends on relative includes, this option allows developers to specify the directory where those relative includes exist. :macros - (keyword list of macro names and values) if the record being extracted depends on the values of macros, this option allows the value of those macros to be set. These options are expected to be literals (including the binary values) at compile time. Examples iex&gt; Record . extract ( :file_info , from_lib : &quot;kernel/include/file.hrl&quot; ) [ size : :undefined , type : :undefined , access : :undefined , atime : :undefined , mtime : :undefined , ctime : :undefined , mode : :undefined , links : :undefined , major_device : :undefined , minor_device : :undefined , inode : :undefined , uid : :undefined , gid : :undefined ]","ref":"Record.html#extract/2","source_doc":"Extracts record information from an Erlang file.\n\nReturns a quoted expression containing the fields as a list\nof tuples.\n\n`name`, which is the name of the extracted record, is expected to be an atom\n*at compile time*.\n\n## Options\n\nThis function requires one of the following options, which are exclusive to each\nother (i.e., only one of them can be used in the same call):\n\n  * `:from` - (binary representing a path to a file) path to the Erlang file\n    that contains the record definition to extract; with this option, this\n    function uses the same path lookup used by the `-include` attribute used in\n    Erlang modules.\n\n  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n    file that contains the record definition to extract; with this option,\n    this function uses the same path lookup used by the `-include_lib`\n    attribute used in Erlang modules.\n\nIt additionally accepts the following optional, non-exclusive options:\n\n  * `:includes` - (a list of directories as binaries) if the record being\n    extracted depends on relative includes, this option allows developers\n    to specify the directory where those relative includes exist.\n\n  * `:macros` - (keyword list of macro names and values) if the record\n    being extracted depends on the values of macros, this option allows\n    the value of those macros to be set.\n\nThese options are expected to be literals (including the binary values) at\ncompile time.\n\n## Examples\n\n    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n    [\n      size: :undefined,\n      type: :undefined,\n      access: :undefined,\n      atime: :undefined,\n      mtime: :undefined,\n      ctime: :undefined,\n      mode: :undefined,\n      links: :undefined,\n      major_device: :undefined,\n      minor_device: :undefined,\n      inode: :undefined,\n      uid: :undefined,\n      gid: :undefined\n    ]\n\n","title":"Record.extract/2","type":"function"},{"doc":"Extracts all records information from an Erlang file. Returns a keyword list of {record_name, fields} tuples where record_name is the name of an extracted record and fields is a list of {field, value} tuples representing the fields for that record. Options Accepts the same options as listed for Record.extract/2 .","ref":"Record.html#extract_all/1","source_doc":"Extracts all records information from an Erlang file.\n\nReturns a keyword list of `{record_name, fields}` tuples where `record_name`\nis the name of an extracted record and `fields` is a list of `{field, value}`\ntuples representing the fields for that record.\n\n## Options\n\nAccepts the same options as listed for `Record.extract/2`.\n\n","title":"Record.extract_all/1","type":"function"},{"doc":"Checks if the given data is a record. This is implemented as a macro so it can be used in guard clauses. Examples Record . is_record ( { User , &quot;john&quot; , 27 } ) #=&gt; true Record . is_record ( { } ) #=&gt; false","ref":"Record.html#is_record/1","source_doc":"Checks if the given `data` is a record.\n\nThis is implemented as a macro so it can be used in guard clauses.\n\n## Examples\n\n    Record.is_record({User, \"john\", 27})\n    #=> true\n\n    Record.is_record({})\n    #=> false\n\n","title":"Record.is_record/1","type":"macro"},{"doc":"Checks if the given data is a record of kind kind . This is implemented as a macro so it can be used in guard clauses. Examples iex&gt; record = { User , &quot;john&quot; , 27 } iex&gt; Record . is_record ( record , User ) true","ref":"Record.html#is_record/2","source_doc":"Checks if the given `data` is a record of kind `kind`.\n\nThis is implemented as a macro so it can be used in guard clauses.\n\n## Examples\n\n    iex> record = {User, \"john\", 27}\n    iex> Record.is_record(record, User)\n    true\n\n","title":"Record.is_record/2","type":"macro"},{"doc":"Provides regular expressions for Elixir. Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's :re module. More information can be found in the :re module documentation . Regular expressions in Elixir can be created using the sigils ~r (see sigil_r/2 ) or ~R (see sigil_R/2 ): # A simple regular expression that matches foo anywhere in the string ~r/foo/ # A regular expression with case insensitive and Unicode options ~r/foo/iu Regular expressions created via sigils are pre-compiled and stored in the .beam file. Note that this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information. A Regex is represented internally as the Regex struct. Therefore, %Regex{} can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. There is also not guarantee two regular expressions from the same source are equal, for example: ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ == ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ may return true or false depending on your machine, endianness, available optimizations and others. You can, however, retrieve the source of a compiled regular expression by accessing the source field, and then compare those directly: ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ . source == ~r/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/ . source Modifiers The modifiers available when creating a Regex are: :unicode (u) - enables Unicode specific patterns like \\p and causes character classes like \\w , \\W , \\s , and the like to also match on Unicode (see examples below in &quot;Character classes&quot;). It expects valid Unicode strings to be given on match :caseless (i) - adds case insensitivity :dotall (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting (*CR) or (*LF) or (*CRLF) or (*ANY) according to :re documentation :multiline (m) - causes ^ and $ to mark the beginning and end of each line; use \\A and \\z to match the end or beginning of the string :extended (x) - whitespace characters are ignored except when escaped and allow # to delimit comments :firstline (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline :ungreedy (U) - inverts the &quot;greediness&quot; of the regexp (the previous r option is deprecated in favor of U ) The options not available are: :anchored - not available, use ^ or \\A instead :dollar_endonly - not available, use \\z instead :no_auto_capture - not available, use ?: instead :newline - not available, use (*CR) or (*LF) or (*CRLF) or (*ANYCRLF) or (*ANY) at the beginning of the regexp according to the :re documentation Captures Many functions in this module handle what to capture in a regex match via the :capture option. The supported values are: :all - all captured subpatterns including the complete matching string (this is the default) :first - only the first captured subpattern, which is always the complete matching part of the string; all explicitly captured subpatterns are discarded :all_but_first - all but the first matching subpattern, i.e. all explicitly captured subpatterns, but not the complete matching part of the string :none - does not return matching subpatterns at all :all_names - captures all named subpattern matches in the Regex as a list ordered alphabetically by the names of the subpatterns list(binary) - a list of named captures to capture Character classes Regex supports several built in named character classes. These are used by enclosing the class name in [: :] inside a group. For example: iex&gt; String . match? ( &quot;123&quot; , ~r/^[[:alnum:]]+$/ ) true iex&gt; String . match? ( &quot;123 456&quot; , ~r/^[[:alnum:][:blank:]]+$/ ) true The supported class names are: alnum - Letters and digits alpha - Letters blank - Space or tab only cntrl - Control characters digit - Decimal digits (same as \\d) graph - Printing characters, excluding space lower - Lowercase letters print - Printing characters, including space punct - Printing characters, excluding letters, digits, and space space - Whitespace (the same as \\s from PCRE 8.34) upper - Uppercase letters word - &quot;Word&quot; characters (same as \\w) xdigit - Hexadecimal digits There is another character class, ascii , that erroneously matches Latin-1 characters instead of the 0-127 range specified by POSIX. This cannot be fixed without altering the behaviour of other classes, so we recommend matching the range with [\\\\0-\\x7f] instead. Note the behaviour of those classes may change according to the Unicode and other modifiers: iex&gt; String . match? ( &quot;josé&quot; , ~r/^[[:lower:]]+$/ ) false iex&gt; String . match? ( &quot;josé&quot; , ~r/^[[:lower:]]+$/u ) true iex&gt; Regex . replace ( ~r/ \\s / , &quot;Unicode \\u00A0 spaces&quot; , &quot;-&quot; ) &quot;Unicode spaces&quot; iex&gt; Regex . replace ( ~r/ \\s /u , &quot;Unicode \\u00A0 spaces&quot; , &quot;-&quot; ) &quot;Unicode-spaces&quot; Precompilation Regular expressions built with sigil are precompiled and stored in .beam files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via mix compile or similar) or released on the host (via mix releases or similar) with a matching OTP, operating system and architecture as the target. If you know you are running on a different system than the current one and you are doing multiple matches with the regex, you can manually invoke Regex.recompile/1 or Regex.recompile!/1 to perform a runtime version check and recompile the regex if necessary.","ref":"Regex.html","source_doc":"Provides regular expressions for Elixir.\n\nRegex is based on PCRE (Perl Compatible Regular Expressions) and\nbuilt on top of Erlang's `:re` module. More information can be found\nin the [`:re` module documentation](`:re`).\n\nRegular expressions in Elixir can be created using the sigils\n`~r` (see `sigil_r/2`) or `~R` (see `sigil_R/2`):\n\n    # A simple regular expression that matches foo anywhere in the string\n    ~r/foo/\n\n    # A regular expression with case insensitive and Unicode options\n    ~r/foo/iu\n\nRegular expressions created via sigils are pre-compiled and stored\nin the `.beam` file. Note that this may be a problem if you are precompiling\nElixir, see the \"Precompilation\" section for more information.\n\nA Regex is represented internally as the `Regex` struct. Therefore,\n`%Regex{}` can be used whenever there is a need to match on them.\nKeep in mind that all of the structs fields are private. There is\nalso not guarantee two regular expressions from the same source are\nequal, for example:\n\n    ~r/(?<foo>.)(?<bar>.)/ == ~r/(?<foo>.)(?<bar>.)/\n\nmay return `true` or `false` depending on your machine, endianness,\navailable optimizations and others. You can, however, retrieve the source\nof a compiled regular expression by accessing the `source` field, and then\ncompare those directly:\n\n    ~r/(?<foo>.)(?<bar>.)/.source == ~r/(?<foo>.)(?<bar>.)/.source\n\n## Modifiers\n\nThe modifiers available when creating a Regex are:\n\n  * `:unicode` (u) - enables Unicode specific patterns like `\\p` and causes\n    character classes like `\\w`, `\\W`, `\\s`, and the like to also match on Unicode\n    (see examples below in \"Character classes\"). It expects valid Unicode\n    strings to be given on match\n\n  * `:caseless` (i) - adds case insensitivity\n\n  * `:dotall` (s) - causes dot to match newlines and also set newline to\n    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n    `(*LF)` or `(*CRLF)` or `(*ANY)` according to `:re` documentation\n\n  * `:multiline` (m) - causes `^` and `$` to mark the beginning and end of\n    each line; use `\\A` and `\\z` to match the end or beginning of the string\n\n  * `:extended` (x) - whitespace characters are ignored except when escaped\n    and allow `#` to delimit comments\n\n  * `:firstline` (f) - forces the unanchored pattern to match before or at the\n    first newline, though the matched text may continue over the newline\n\n  * `:ungreedy` (U) - inverts the \"greediness\" of the regexp\n    (the previous `r` option is deprecated in favor of `U`)\n\nThe options not available are:\n\n  * `:anchored` - not available, use `^` or `\\A` instead\n  * `:dollar_endonly` - not available, use `\\z` instead\n  * `:no_auto_capture` - not available, use `?:` instead\n  * `:newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the\n    `:re` documentation\n\n## Captures\n\nMany functions in this module handle what to capture in a regex\nmatch via the `:capture` option. The supported values are:\n\n  * `:all` - all captured subpatterns including the complete matching string\n    (this is the default)\n\n  * `:first` - only the first captured subpattern, which is always the\n    complete matching part of the string; all explicitly captured subpatterns\n    are discarded\n\n  * `:all_but_first` - all but the first matching subpattern, i.e. all\n    explicitly captured subpatterns, but not the complete matching part of\n    the string\n\n  * `:none` - does not return matching subpatterns at all\n\n  * `:all_names` - captures all named subpattern matches in the Regex as a list\n    ordered **alphabetically** by the names of the subpatterns\n\n  * `list(binary)` - a list of named captures to capture\n\n## Character classes\n\nRegex supports several built in named character classes. These are used by\nenclosing the class name in `[: :]` inside a group. For example:\n\n    iex> String.match?(\"123\", ~r/^[[:alnum:]]+$/)\n    true\n    iex> String.match?(\"123 456\", ~r/^[[:alnum:][:blank:]]+$/)\n    true\n\nThe supported class names are:\n\n  * alnum - Letters and digits\n  * alpha - Letters\n  * blank - Space or tab only\n  * cntrl - Control characters\n  * digit - Decimal digits (same as \\\\d)\n  * graph - Printing characters, excluding space\n  * lower - Lowercase letters\n  * print - Printing characters, including space\n  * punct - Printing characters, excluding letters, digits, and space\n  * space - Whitespace (the same as \\s from PCRE 8.34)\n  * upper - Uppercase letters\n  * word  - \"Word\" characters (same as \\w)\n  * xdigit - Hexadecimal digits\n\nThere is another character class, `ascii`, that erroneously matches\nLatin-1 characters instead of the 0-127 range specified by POSIX. This\ncannot be fixed without altering the behaviour of other classes, so we\nrecommend matching the range with `[\\\\0-\\x7f]` instead.\n\nNote the behaviour of those classes may change according to the Unicode\nand other modifiers:\n\n    iex> String.match?(\"josé\", ~r/^[[:lower:]]+$/)\n    false\n    iex> String.match?(\"josé\", ~r/^[[:lower:]]+$/u)\n    true\n    iex> Regex.replace(~r/\\s/, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicode spaces\"\n    iex> Regex.replace(~r/\\s/u, \"Unicode\\u00A0spaces\", \"-\")\n    \"Unicode-spaces\"\n\n## Precompilation\n\nRegular expressions built with sigil are precompiled and stored in `.beam`\nfiles. Precompiled regexes will be checked in runtime and may work slower\nbetween operating systems and OTP releases. This is rarely a problem, as most Elixir code\nshared during development is compiled on the target (such as dependencies,\narchives, and escripts) and, when running in production, the code must either\nbe compiled on the target (via `mix compile` or similar) or released on the\nhost (via `mix releases` or similar) with a matching OTP, operating system\nand architecture as the target.\n\nIf you know you are running on a different system than the current one and\nyou are doing multiple matches with the regex, you can manually invoke\n`Regex.recompile/1` or `Regex.recompile!/1` to perform a runtime version\ncheck and recompile the regex if necessary.\n","title":"Regex","type":"module"},{"doc":"Compiles the regular expression. The given options can either be a binary with the characters representing the same regex options given to the ~r (see sigil_r/2 ) sigil, or a list of options, as expected by the Erlang's :re module. It returns {:ok, regex} in case of success, {:error, reason} otherwise. Examples iex&gt; Regex . compile ( &quot;foo&quot; ) { :ok , ~r/foo/ } iex&gt; Regex . compile ( &quot;*foo&quot; ) { :error , { &#39;nothing to repeat&#39; , 0 } } iex&gt; Regex . compile ( &quot;foo&quot; , &quot;i&quot; ) { :ok , ~r/foo/i } iex&gt; Regex . compile ( &quot;foo&quot; , [ :caseless ] ) { :ok , Regex . compile! ( &quot;foo&quot; , [ :caseless ] ) }","ref":"Regex.html#compile/2","source_doc":"Compiles the regular expression.\n\nThe given options can either be a binary with the characters\nrepresenting the same regex options given to the\n`~r` (see `sigil_r/2`) sigil, or a list of options, as\nexpected by the Erlang's [`:re`](`:re`) module.\n\nIt returns `{:ok, regex}` in case of success,\n`{:error, reason}` otherwise.\n\n## Examples\n\n    iex> Regex.compile(\"foo\")\n    {:ok, ~r/foo/}\n\n    iex> Regex.compile(\"*foo\")\n    {:error, {'nothing to repeat', 0}}\n\n    iex> Regex.compile(\"foo\", \"i\")\n    {:ok, ~r/foo/i}\n\n    iex> Regex.compile(\"foo\", [:caseless])\n    {:ok, Regex.compile!(\"foo\", [:caseless])}\n\n","title":"Regex.compile/2","type":"function"},{"doc":"Compiles the regular expression and raises Regex.CompileError in case of errors.","ref":"Regex.html#compile!/2","source_doc":"Compiles the regular expression and raises `Regex.CompileError` in case of errors.\n","title":"Regex.compile!/2","type":"function"},{"doc":"Escapes a string to be literally matched in a regex. Examples iex&gt; Regex . escape ( &quot;.&quot; ) &quot; \\\\ .&quot; iex&gt; Regex . escape ( &quot; \\\\ what if&quot; ) &quot; \\\\ \\\\ what \\\\ if&quot;","ref":"Regex.html#escape/1","source_doc":"Escapes a string to be literally matched in a regex.\n\n## Examples\n\n    iex> Regex.escape(\".\")\n    \"\\\\.\"\n\n    iex> Regex.escape(\"\\\\what if\")\n    \"\\\\\\\\what\\\\ if\"\n\n","title":"Regex.escape/1","type":"function"},{"doc":"Returns a boolean indicating whether there was a match or not. Examples iex&gt; Regex . match? ( ~r/foo/ , &quot;foo&quot; ) true iex&gt; Regex . match? ( ~r/foo/ , &quot;bar&quot; ) false Elixir also provides text-based match operator =~/2 and function String.match?/2 as an alternative to test strings against regular expressions and strings.","ref":"Regex.html#match?/2","source_doc":"Returns a boolean indicating whether there was a match or not.\n\n## Examples\n\n    iex> Regex.match?(~r/foo/, \"foo\")\n    true\n\n    iex> Regex.match?(~r/foo/, \"bar\")\n    false\n\nElixir also provides text-based match operator `=~/2` and function `String.match?/2` as\nan alternative to test strings against regular expressions and\nstrings.\n","title":"Regex.match?/2","type":"function"},{"doc":"Returns the given captures as a map or nil if no captures are found. Options :return - when set to :index , returns byte index and match length. Defaults to :binary . Examples iex&gt; Regex . named_captures ( ~r/c(?&lt;foo&gt;d)/ , &quot;abcd&quot; ) %{ &quot;foo&quot; =&gt; &quot;d&quot; } iex&gt; Regex . named_captures ( ~r/a(?&lt;foo&gt;b)c(?&lt;bar&gt;d)/ , &quot;abcd&quot; ) %{ &quot;bar&quot; =&gt; &quot;d&quot; , &quot;foo&quot; =&gt; &quot;b&quot; } iex&gt; Regex . named_captures ( ~r/a(?&lt;foo&gt;b)c(?&lt;bar&gt;d)/ , &quot;efgh&quot; ) nil","ref":"Regex.html#named_captures/3","source_doc":"Returns the given captures as a map or `nil` if no captures are found.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n\n## Examples\n\n    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n    %{\"foo\" => \"d\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n\n    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n    nil\n\n","title":"Regex.named_captures/3","type":"function"},{"doc":"Returns a list of names in the regex. Examples iex&gt; Regex . names ( ~r/(?&lt;foo&gt;bar)/ ) [ &quot;foo&quot; ]","ref":"Regex.html#names/1","source_doc":"Returns a list of names in the regex.\n\n## Examples\n\n    iex> Regex.names(~r/(?<foo>bar)/)\n    [\"foo\"]\n\n","title":"Regex.names/1","type":"function"},{"doc":"Returns the regex options, as a string or list depending on how it was compiled. See the documentation of Regex.compile/2 for more information. Examples iex&gt; Regex . opts ( ~r/foo/m ) &quot;m&quot; iex&gt; Regex . opts ( Regex . compile! ( &quot;foo&quot; , [ :caseless ] ) ) [ :caseless ]","ref":"Regex.html#opts/1","source_doc":"Returns the regex options, as a string or list depending on how\nit was compiled.\n\nSee the documentation of `Regex.compile/2` for more information.\n\n## Examples\n\n    iex> Regex.opts(~r/foo/m)\n    \"m\"\n\n    iex> Regex.opts(Regex.compile!(\"foo\", [:caseless]))\n    [:caseless]\n\n","title":"Regex.opts/1","type":"function"},{"doc":"Returns the underlying re_pattern in the regular expression.","ref":"Regex.html#re_pattern/1","source_doc":"Returns the underlying `re_pattern` in the regular expression.\n","title":"Regex.re_pattern/1","type":"function"},{"doc":"Recompiles the existing regular expression if necessary. This checks the version stored in the regular expression and recompiles the regex in case of version mismatch.","ref":"Regex.html#recompile/1","source_doc":"Recompiles the existing regular expression if necessary.\n\nThis checks the version stored in the regular expression\nand recompiles the regex in case of version mismatch.\n","title":"Regex.recompile/1","type":"function"},{"doc":"Recompiles the existing regular expression and raises Regex.CompileError in case of errors.","ref":"Regex.html#recompile!/1","source_doc":"Recompiles the existing regular expression and raises `Regex.CompileError` in case of errors.\n","title":"Regex.recompile!/1","type":"function"},{"doc":"Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement. The replacement can be either a string or a function that returns a string. The resulting string is used as a replacement for every match. When the replacement is a string, it allows specific captures of the match using brackets at the regex expression and accessing them in the replacement via \\N or \\g{N} , where N is the number of the capture. In case \\0 is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use \\\\N and \\\\g{N} . When the replacement is a function, it allows specific captures too. The function may have arity N where each argument maps to a capture, with the first argument being the whole match. If the function expects more arguments than captures found, the remaining arguments will receive &quot;&quot; . Options :global - when false , replaces only the first occurrence (defaults to true ) Examples iex&gt; Regex . replace ( ~r/d/ , &quot;abc&quot; , &quot;d&quot; ) &quot;abc&quot; iex&gt; Regex . replace ( ~r/b/ , &quot;abc&quot; , &quot;d&quot; ) &quot;adc&quot; iex&gt; Regex . replace ( ~r/b/ , &quot;abc&quot; , &quot;[ \\\\ 0]&quot; ) &quot;a[b]c&quot; iex&gt; Regex . replace ( ~r/a(b|d)c/ , &quot;abcadc&quot; , &quot;[ \\\\ 1]&quot; ) &quot;[b][d]&quot; iex&gt; Regex . replace ( ~r/ \\. ( \\d )$/ , &quot;500.5&quot; , &quot;. \\\\ g{1}0&quot; ) &quot;500.50&quot; iex&gt; Regex . replace ( ~r/a(b|d)c/ , &quot;abcadc&quot; , fn _ , x -&gt; &quot;[ \#{ x } ]&quot; end ) &quot;[b][d]&quot; iex&gt; Regex . replace ( ~r/( \\w +)@( \\w +).( \\w +)/ , &quot;abc@def.com&quot; , fn _full , _c1 , _c2 , c3 -&gt; &quot;TLD: \#{ c3 } &quot; end ) &quot;TLD: com&quot; iex&gt; Regex . replace ( ~r/a/ , &quot;abcadc&quot; , &quot;A&quot; , global : false ) &quot;Abcadc&quot;","ref":"Regex.html#replace/4","source_doc":"Receives a regex, a binary and a replacement, returns a new\nbinary where all matches are replaced by the replacement.\n\nThe replacement can be either a string or a function that returns a string.\nThe resulting string is used as a replacement for every match.\n\nWhen the replacement is a string, it allows specific captures of the match\nusing brackets at the regex expression and accessing them in the replacement\nvia `\\N` or `\\g{N}`, where `N` is the number of the capture. In case `\\0` is\nused, the whole match is inserted. Note that in regexes the backslash needs\nto be escaped, hence in practice you'll need to use `\\\\N` and `\\\\g{N}`.\n\nWhen the replacement is a function, it allows specific captures too.\nThe function may have arity N where each argument maps to a capture,\nwith the first argument being the whole match. If the function expects more\narguments than captures found, the remaining arguments will receive `\"\"`.\n\n## Options\n\n  * `:global` - when `false`, replaces only the first occurrence\n    (defaults to `true`)\n\n## Examples\n\n    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n    \"abc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n    \"adc\"\n\n    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n    \"a[b]c\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n    \"500.50\"\n\n    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[\#{x}]\" end)\n    \"[b][d]\"\n\n    iex> Regex.replace(~r/(\\w+)@(\\w+).(\\w+)/, \"abc@def.com\", fn _full, _c1, _c2, c3 -> \"TLD: \#{c3}\" end)\n    \"TLD: com\"\n\n    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n    \"Abcadc\"\n\n","title":"Regex.replace/4","type":"function"},{"doc":"Runs the regular expression against the given string until the first match. It returns a list with all captures or nil if no match occurred. Options :return - when set to :index , returns byte index and match length. Defaults to :binary . :capture - what to capture in the result. Check the moduledoc for Regex to see the possible capture values. :offset - (since v1.12.0) specifies the starting offset to match in the given string. Defaults to zero. Examples iex&gt; Regex . run ( ~r/c(d)/ , &quot;abcd&quot; ) [ &quot;cd&quot; , &quot;d&quot; ] iex&gt; Regex . run ( ~r/e/ , &quot;abcd&quot; ) nil iex&gt; Regex . run ( ~r/c(d)/ , &quot;abcd&quot; , return : :index ) [ { 2 , 2 } , { 3 , 1 } ]","ref":"Regex.html#run/3","source_doc":"Runs the regular expression against the given string until the first match.\nIt returns a list with all captures or `nil` if no match occurred.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.run(~r/c(d)/, \"abcd\")\n    [\"cd\", \"d\"]\n\n    iex> Regex.run(~r/e/, \"abcd\")\n    nil\n\n    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n    [{2, 2}, {3, 1}]\n\n","title":"Regex.run/3","type":"function"},{"doc":"Same as run/3 , but scans the target several times collecting all matches of the regular expression. A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents. Options :return - when set to :index , returns byte index and match length. Defaults to :binary . :capture - what to capture in the result. Check the moduledoc for Regex to see the possible capture values. :offset - (since v1.12.0) specifies the starting offset to match in the given string. Defaults to zero. Examples iex&gt; Regex . scan ( ~r/c(d|e)/ , &quot;abcd abce&quot; ) [ [ &quot;cd&quot; , &quot;d&quot; ] , [ &quot;ce&quot; , &quot;e&quot; ] ] iex&gt; Regex . scan ( ~r/c(?:d|e)/ , &quot;abcd abce&quot; ) [ [ &quot;cd&quot; ] , [ &quot;ce&quot; ] ] iex&gt; Regex . scan ( ~r/e/ , &quot;abcd&quot; ) [ ] iex&gt; Regex . scan ( ~r/ \\p {Sc}/u , &quot;$, £, and €&quot; ) [ [ &quot;$&quot; ] , [ &quot;£&quot; ] , [ &quot;€&quot; ] ] iex&gt; Regex . scan ( ~r/=+/ , &quot;=ü†ƒ8===&quot; , return : :index ) [ [ { 0 , 1 } ] , [ { 9 , 3 } ] ]","ref":"Regex.html#scan/3","source_doc":"Same as `run/3`, but scans the target several times collecting all\nmatches of the regular expression.\n\nA list of lists is returned, where each entry in the primary list represents a\nmatch and each entry in the secondary list represents the captured contents.\n\n## Options\n\n  * `:return` - when set to `:index`, returns byte index and match length.\n    Defaults to `:binary`.\n  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n    to see the possible capture values.\n  * `:offset` - (since v1.12.0) specifies the starting offset to match in the given string.\n    Defaults to zero.\n\n## Examples\n\n    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n\n    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n    [[\"cd\"], [\"ce\"]]\n\n    iex> Regex.scan(~r/e/, \"abcd\")\n    []\n\n    iex> Regex.scan(~r/\\p{Sc}/u, \"$, £, and €\")\n    [[\"$\"], [\"£\"], [\"€\"]]\n\n    iex> Regex.scan(~r/=+/, \"=ü†ƒ8===\", return: :index)\n    [[{0, 1}], [{9, 3}]]\n\n","title":"Regex.scan/3","type":"function"},{"doc":"Returns the regex source as a binary. Examples iex&gt; Regex . source ( ~r/foo/ ) &quot;foo&quot;","ref":"Regex.html#source/1","source_doc":"Returns the regex source as a binary.\n\n## Examples\n\n    iex> Regex.source(~r/foo/)\n    \"foo\"\n\n","title":"Regex.source/1","type":"function"},{"doc":"Splits the given target based on the given pattern and in the given number of parts. Options :parts - when specified, splits the string into the given number of parts. If not specified, :parts defaults to :infinity , which will split the string into the maximum number of parts possible based on the given pattern. :trim - when true , removes empty strings ( &quot;&quot; ) from the result. Defaults to false . :on - specifies which captures to split the string on, and in what order. Defaults to :first which means captures inside the regex do not affect the splitting process. :include_captures - when true , includes in the result the matches of the regular expression. The matches are not counted towards the maximum number of parts if combined with the :parts option. Defaults to false . Examples iex&gt; Regex . split ( ~r{-} , &quot;a-b-c&quot; ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; Regex . split ( ~r{-} , &quot;a-b-c&quot; , parts : 2 ) [ &quot;a&quot; , &quot;b-c&quot; ] iex&gt; Regex . split ( ~r{-} , &quot;abc&quot; ) [ &quot;abc&quot; ] iex&gt; Regex . split ( ~r{} , &quot;abc&quot; ) [ &quot;&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;&quot; ] iex&gt; Regex . split ( ~r{a(?&lt;second&gt;b)c} , &quot;abc&quot; ) [ &quot;&quot; , &quot;&quot; ] iex&gt; Regex . split ( ~r{a(?&lt;second&gt;b)c} , &quot;abc&quot; , on : [ :second ] ) [ &quot;a&quot; , &quot;c&quot; ] iex&gt; Regex . split ( ~r{(x)} , &quot;Elixir&quot; , include_captures : true ) [ &quot;Eli&quot; , &quot;x&quot; , &quot;ir&quot; ] iex&gt; Regex . split ( ~r{a(?&lt;second&gt;b)c} , &quot;abc&quot; , on : [ :second ] , include_captures : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ]","ref":"Regex.html#split/3","source_doc":"Splits the given target based on the given pattern and in the given number of\nparts.\n\n## Options\n\n  * `:parts` - when specified, splits the string into the given number of\n    parts. If not specified, `:parts` defaults to `:infinity`, which will\n    split the string into the maximum number of parts possible based on the\n    given pattern.\n\n  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n    Defaults to `false`.\n\n  * `:on` - specifies which captures to split the string on, and in what\n    order. Defaults to `:first` which means captures inside the regex do not\n    affect the splitting process.\n\n  * `:include_captures` - when `true`, includes in the result the matches of\n    the regular expression. The matches are not counted towards the maximum\n    number of parts if combined with the `:parts` option. Defaults to `false`.\n\n## Examples\n\n    iex> Regex.split(~r{-}, \"a-b-c\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> Regex.split(~r{-}, \"a-b-c\", parts: 2)\n    [\"a\", \"b-c\"]\n\n    iex> Regex.split(~r{-}, \"abc\")\n    [\"abc\"]\n\n    iex> Regex.split(~r{}, \"abc\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\")\n    [\"\", \"\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second])\n    [\"a\", \"c\"]\n\n    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n    [\"Eli\", \"x\", \"ir\"]\n\n    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second], include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\n","title":"Regex.split/3","type":"function"},{"doc":"Returns the version of the underlying Regex engine.","ref":"Regex.html#version/0","source_doc":"Returns the version of the underlying Regex engine.\n","title":"Regex.version/0","type":"function"},{"doc":"","ref":"Regex.html#t:t/0","source_doc":false,"title":"Regex.t/0","type":"type"},{"doc":"Strings in Elixir are UTF-8 encoded binaries. Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as &quot;hello&quot; and &quot;héllò&quot; . In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: &quot;this is a string with \\&quot;double quotes\\&quot;&quot; . You can concatenate two strings with the &lt;&gt;/2 operator: iex&gt; &quot;hello&quot; &lt;&gt; &quot; &quot; &lt;&gt; &quot;world&quot; &quot;hello world&quot; The functions in this module act according to The Unicode Standard, Version 15.0.0 . Interpolation Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the \#{} syntax: iex&gt; name = &quot;joe&quot; iex&gt; &quot;hello \#{ name } &quot; &quot;hello joe&quot; Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the String.Chars protocol. This allows, for example, to output an integer from the interpolation: iex&gt; &quot;2 + 2 = \#{ 2 + 2 } &quot; &quot;2 + 2 = 4&quot; In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised. Escape characters Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters: \\0 - Null byte \\a - Bell \\b - Backspace \\t - Horizontal tab \\n - Line feed (New lines) \\v - Vertical tab \\f - Form feed \\r - Carriage return \\e - Command Escape \\s - Space \\# - Returns the # character itself, skipping interpolation \\\\ - Single backslash \\xNN - A byte represented by the hexadecimal NN \\uNNNN - A Unicode code point represented by NNNN \\u{NNNNNN} - A Unicode code point represented by NNNNNN Note it is generally not advised to use \\xNN in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as \\uNNNN . In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next. Unicode and code points In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well. Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point. In Elixir you can use a ? in front of a character literal to reveal its code point: iex&gt; ?a 97 iex&gt; ?ł 322 Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. 97 translates to 0061 in hex, and we can represent any Unicode character in an Elixir string by using the \\u escape character followed by its code point number: iex&gt; &quot; \\u0061 &quot; === &quot;a&quot; true iex&gt; 0x0061 = 97 = ?a 97 The hex representation will also help you look up information about a code point, e.g. https://codepoints.net/U+0061 has a data sheet all about the lower case a , a.k.a. code point 97. Remember you can get the hex presentation of a number by calling Integer.to_string/2 : iex&gt; Integer . to_string ( ?a , 16 ) &quot;61&quot; UTF-8 encoded and encodings Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is what we store, an encoding deals with how we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, and such. Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a variable width character encoding that uses one to four bytes to store each code point. It is capable of encoding all valid Unicode code points. Let's see an example: iex&gt; string = &quot;héllo&quot; &quot;héllo&quot; iex&gt; String . length ( string ) 5 iex&gt; byte_size ( string ) 6 Although the string above has 5 characters, it uses 6 bytes, as two bytes are used to represent the character é . Grapheme clusters This module also works with the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;é&quot; can be represented either as a single &quot;e with acute&quot; code point, as seen above in the string &quot;héllo&quot; , or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points): iex&gt; string = &quot; \\u0065 \\u0301 &quot; &quot;é&quot; iex&gt; byte_size ( string ) 3 iex&gt; String . length ( string ) 1 iex&gt; String . codepoints ( string ) [ &quot;e&quot; , &quot;́&quot; ] iex&gt; String . graphemes ( string ) [ &quot;é&quot; ] Although it looks visually the same as before, the example above is made of two characters, it is perceived by users as one. Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module. In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour. More information about graphemes can be found in the Unicode Standard Annex #29 . For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's :unicode module. String and binary operations To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points. For example, String.length/1 will take longer as the input grows. On the other hand, Kernel.byte_size/1 always runs in constant time (i.e. regardless of the input size). This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries: Kernel.binary_part/3 - retrieves part of the binary Kernel.bit_size/1 and Kernel.byte_size/1 - size related functions Kernel.is_bitstring/1 and Kernel.is_binary/1 - type-check function Plus a number of functions for working with binaries (bytes) in the :binary module A utf8 modifier is also available inside the binary syntax &lt;&lt;&gt;&gt; . It can be used to match code points out of a binary/string: iex&gt; &lt;&lt; eacute :: utf8 &gt;&gt; = &quot;é&quot; iex&gt; eacute 233 You can also fully convert a string into a list of integer code points, known as &quot;charlists&quot; in Elixir, by calling String.to_charlist/1 : iex&gt; String . to_charlist ( &quot;héllo&quot; ) [ 104 , 233 , 108 , 108 , 111 ] If you would rather see the underlying bytes of a string, instead of its codepoints, a common trick is to concatenate the null byte &lt;&lt;0&gt;&gt; to it: iex&gt; &quot;héllo&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; &lt;&lt; 104 , 195 , 169 , 108 , 108 , 111 , 0 &gt;&gt; Alternatively, you can view a string's binary representation by passing an option to IO.inspect/2 : IO . inspect ( &quot;héllo&quot; , binaries : :as_binaries ) #=&gt; &lt;&lt;104, 195, 169, 108, 108, 111&gt;&gt; Self-synchronization The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected. This module relies on this behaviour to ignore such invalid characters. For example, length/1 will return a correct result even if an invalid code point is fed into it. In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. String.chunk/2 can be used for breaking a string into valid and invalid parts. Compile binary patterns Many functions in this module work with patterns. For example, String.split/3 can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern: iex&gt; String . split ( &quot;foo bar&quot; , &quot; &quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot;foo bar!&quot; , [ &quot; &quot; , &quot;!&quot; ] ) [ &quot;foo&quot; , &quot;bar&quot; , &quot;&quot; ] iex&gt; pattern = :binary . compile_pattern ( [ &quot; &quot; , &quot;!&quot; ] ) iex&gt; String . split ( &quot;foo bar!&quot; , pattern ) [ &quot;foo&quot; , &quot;bar&quot; , &quot;&quot; ] The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.","ref":"String.html","source_doc":"Strings in Elixir are UTF-8 encoded binaries.\n\nStrings in Elixir are a sequence of Unicode characters,\ntypically written between double quoted strings, such\nas `\"hello\"` and `\"héllò\"`.\n\nIn case a string must have a double-quote in itself,\nthe double quotes must be escaped with a backslash,\nfor example: `\"this is a string with \\\"double quotes\\\"\"`.\n\nYou can concatenate two strings with the `<>/2` operator:\n\n    iex> \"hello\" <> \" \" <> \"world\"\n    \"hello world\"\n\nThe functions in this module act according to\n[The Unicode Standard, Version 15.0.0](http://www.unicode.org/versions/Unicode15.0.0/).\n\n## Interpolation\n\nStrings in Elixir also support interpolation. This allows\nyou to place some value in the middle of a string by using\nthe `\#{}` syntax:\n\n    iex> name = \"joe\"\n    iex> \"hello \#{name}\"\n    \"hello joe\"\n\nAny Elixir expression is valid inside the interpolation.\nIf a string is given, the string is interpolated as is.\nIf any other value is given, Elixir will attempt to convert\nit to a string using the `String.Chars` protocol. This\nallows, for example, to output an integer from the interpolation:\n\n    iex> \"2 + 2 = \#{2 + 2}\"\n    \"2 + 2 = 4\"\n\nIn case the value you want to interpolate cannot be\nconverted to a string, because it doesn't have a human\ntextual representation, a protocol error will be raised.\n\n## Escape characters\n\nBesides allowing double-quotes to be escaped with a backslash,\nstrings also support the following escape characters:\n\n  * `\\0` - Null byte\n  * `\\a` - Bell\n  * `\\b` - Backspace\n  * `\\t` - Horizontal tab\n  * `\\n` - Line feed (New lines)\n  * `\\v` - Vertical tab\n  * `\\f` - Form feed\n  * `\\r` - Carriage return\n  * `\\e` - Command Escape\n  * `\\s` - Space\n  * `\\#` - Returns the `#` character itself, skipping interpolation\n  * `\\\\` - Single backslash\n  * `\\xNN` - A byte represented by the hexadecimal `NN`\n  * `\\uNNNN` - A Unicode code point represented by `NNNN`\n  * `\\u{NNNNNN}` - A Unicode code point represented by `NNNNNN`\n\nNote it is generally not advised to use `\\xNN` in Elixir\nstrings, as introducing an invalid byte sequence would\nmake the string invalid. If you have to introduce a\ncharacter by its hexadecimal representation, it is best\nto work with Unicode code points, such as `\\uNNNN`. In fact,\nunderstanding Unicode code points can be essential when doing\nlow-level manipulations of string, so let's explore them in\ndetail next.\n\n## Unicode and code points\n\nIn order to facilitate meaningful communication between computers\nacross multiple languages, a standard is required so that the ones\nand zeros on one machine mean the same thing when they are transmitted\nto another. The Unicode Standard acts as an official registry of\nvirtually all the characters we know: this includes characters from\nclassical and historical texts, emoji, and formatting and control\ncharacters as well.\n\nUnicode organizes all of the characters in its repertoire into code\ncharts, and each character is given a unique numerical index. This\nnumerical index is known as a Code Point.\n\nIn Elixir you can use a `?` in front of a character literal to reveal\nits code point:\n\n    iex> ?a\n    97\n    iex> ?ł\n    322\n\nNote that most Unicode code charts will refer to a code point by its\nhexadecimal (hex) representation, e.g. `97` translates to `0061` in hex,\nand we can represent any Unicode character in an Elixir string by\nusing the `\\u` escape character followed by its code point number:\n\n    iex> \"\\u0061\" === \"a\"\n    true\n    iex> 0x0061 = 97 = ?a\n    97\n\nThe hex representation will also help you look up information about a\ncode point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061)\nhas a data sheet all about the lower case `a`, a.k.a. code point 97.\nRemember you can get the hex presentation of a number by calling\n`Integer.to_string/2`:\n\n    iex> Integer.to_string(?a, 16)\n    \"61\"\n\n## UTF-8 encoded and encodings\n\nNow that we understand what the Unicode standard is and what code points\nare, we can finally talk about encodings. Whereas the code point is **what**\nwe store, an encoding deals with **how** we store it: encoding is an\nimplementation. In other words, we need a mechanism to convert the code\npoint numbers into bytes so they can be stored in memory, written to disk, and such.\n\nElixir uses UTF-8 to encode its strings, which means that code points are\nencoded as a series of 8-bit bytes. UTF-8 is a **variable width** character\nencoding that uses one to four bytes to store each code point. It is capable\nof encoding all valid Unicode code points. Let's see an example:\n\n    iex> string = \"héllo\"\n    \"héllo\"\n    iex> String.length(string)\n    5\n    iex> byte_size(string)\n    6\n\nAlthough the string above has 5 characters, it uses 6 bytes, as two bytes\nare used to represent the character `é`.\n\n## Grapheme clusters\n\nThis module also works with the concept of grapheme cluster\n(from now on referenced as graphemes). Graphemes can consist\nof multiple code points that may be perceived as a single character\nby readers. For example, \"é\" can be represented either as a single\n\"e with acute\" code point, as seen above in the string `\"héllo\"`,\nor as the letter \"e\" followed by a \"combining acute accent\"\n(two code points):\n\n    iex> string = \"\\u0065\\u0301\"\n    \"é\"\n    iex> byte_size(string)\n    3\n    iex> String.length(string)\n    1\n    iex> String.codepoints(string)\n    [\"e\", \"́\"]\n    iex> String.graphemes(string)\n    [\"é\"]\n\nAlthough it looks visually the same as before, the example above\nis made of two characters, it is perceived by users as one.\n\nGraphemes can also be two characters that are interpreted as one\nby some languages. For example, some languages may consider \"ch\"\nas a single character. However, since this information depends on\nthe locale, it is not taken into account by this module.\n\nIn general, the functions in this module rely on the Unicode\nStandard, but do not contain any of the locale specific behaviour.\nMore information about graphemes can be found in the [Unicode\nStandard Annex #29](https://www.unicode.org/reports/tr29/).\n\nFor converting a binary to a different encoding and for Unicode\nnormalization mechanisms, see Erlang's `:unicode` module.\n\n## String and binary operations\n\nTo act according to the Unicode Standard, many functions\nin this module run in linear time, as they need to traverse\nthe whole string considering the proper Unicode code points.\n\nFor example, `String.length/1` will take longer as\nthe input grows. On the other hand, `Kernel.byte_size/1` always runs\nin constant time (i.e. regardless of the input size).\n\nThis means often there are performance costs in using the\nfunctions in this module, compared to the more low-level\noperations that work directly with binaries:\n\n  * `Kernel.binary_part/3` - retrieves part of the binary\n  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type-check function\n  * Plus a number of functions for working with binaries (bytes)\n    in the [`:binary` module](`:binary`)\n\nA `utf8` modifier is also available inside the binary syntax `<<>>`.\nIt can be used to match code points out of a binary/string:\n\n    iex> <<eacute::utf8>> = \"é\"\n    iex> eacute\n    233\n\nYou can also fully convert a string into a list of integer code points,\nknown as \"charlists\" in Elixir, by calling `String.to_charlist/1`:\n\n    iex> String.to_charlist(\"héllo\")\n    [104, 233, 108, 108, 111]\n\nIf you would rather see the underlying bytes of a string, instead of\nits codepoints, a common trick is to concatenate the null byte `<<0>>`\nto it:\n\n    iex> \"héllo\" <> <<0>>\n    <<104, 195, 169, 108, 108, 111, 0>>\n\nAlternatively, you can view a string's binary representation by\npassing an option to `IO.inspect/2`:\n\n    IO.inspect(\"héllo\", binaries: :as_binaries)\n    #=> <<104, 195, 169, 108, 108, 111>>\n\n## Self-synchronization\n\nThe UTF-8 encoding is self-synchronizing. This means that\nif malformed data (i.e., data that is not possible according\nto the definition of the encoding) is encountered, only one\ncode point needs to be rejected.\n\nThis module relies on this behaviour to ignore such invalid\ncharacters. For example, `length/1` will return\na correct result even if an invalid code point is fed into it.\n\nIn other words, this module expects invalid data to be detected\nelsewhere, usually when retrieving data from the external source.\nFor example, a driver that reads strings from a database will be\nresponsible to check the validity of the encoding. `String.chunk/2`\ncan be used for breaking a string into valid and invalid parts.\n\n## Compile binary patterns\n\nMany functions in this module work with patterns. For example,\n`String.split/3` can split a string into multiple strings given\na pattern. This pattern can be a string, a list of strings or\na compiled pattern:\n\n    iex> String.split(\"foo bar\", \" \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n    [\"foo\", \"bar\", \"\"]\n\n    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n    iex> String.split(\"foo bar!\", pattern)\n    [\"foo\", \"bar\", \"\"]\n\nThe compiled pattern is useful when the same match will\nbe done over and over again. Note though that the compiled\npattern cannot be stored in a module attribute as the pattern\nis generated at runtime and does not survive compile time.\n","title":"String","type":"module"},{"doc":"Returns the grapheme at the position of the given UTF-8 string . If position is greater than string length, then it returns nil . Examples iex&gt; String . at ( &quot;elixir&quot; , 0 ) &quot;e&quot; iex&gt; String . at ( &quot;elixir&quot; , 1 ) &quot;l&quot; iex&gt; String . at ( &quot;elixir&quot; , 10 ) nil iex&gt; String . at ( &quot;elixir&quot; , - 1 ) &quot;r&quot; iex&gt; String . at ( &quot;elixir&quot; , - 10 ) nil","ref":"String.html#at/2","source_doc":"Returns the grapheme at the `position` of the given UTF-8 `string`.\nIf `position` is greater than `string` length, then it returns `nil`.\n\n## Examples\n\n    iex> String.at(\"elixir\", 0)\n    \"e\"\n\n    iex> String.at(\"elixir\", 1)\n    \"l\"\n\n    iex> String.at(\"elixir\", 10)\n    nil\n\n    iex> String.at(\"elixir\", -1)\n    \"r\"\n\n    iex> String.at(\"elixir\", -10)\n    nil\n\n","title":"String.at/2","type":"function"},{"doc":"Computes the bag distance between two strings. Returns a float value between 0 and 1 representing the bag distance between string1 and string2 . The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different. The algorithm is outlined in the &quot;String Matching with Metric Trees Using an Approximate Distance&quot; paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella. Examples iex&gt; String . bag_distance ( &quot;abc&quot; , &quot;&quot; ) 0.0 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;a&quot; ) 0.25 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;ab&quot; ) 0.5 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;abc&quot; ) 0.75 iex&gt; String . bag_distance ( &quot;abcd&quot; , &quot;abcd&quot; ) 1.0","ref":"String.html#bag_distance/2","source_doc":"Computes the bag distance between two strings.\n\nReturns a float value between 0 and 1 representing the bag\ndistance between `string1` and `string2`.\n\nThe bag distance is meant to be an efficient approximation\nof the distance between two strings to quickly rule out strings\nthat are largely different.\n\nThe algorithm is outlined in the \"String Matching with Metric\nTrees Using an Approximate Distance\" paper by Ilaria Bartolini,\nPaolo Ciaccia, and Marco Patella.\n\n## Examples\n\n    iex> String.bag_distance(\"abc\", \"\")\n    0.0\n    iex> String.bag_distance(\"abcd\", \"a\")\n    0.25\n    iex> String.bag_distance(\"abcd\", \"ab\")\n    0.5\n    iex> String.bag_distance(\"abcd\", \"abc\")\n    0.75\n    iex> String.bag_distance(\"abcd\", \"abcd\")\n    1.0\n\n","title":"String.bag_distance/2","type":"function"},{"doc":"Converts the first character in the given string to uppercase and the remainder to lowercase according to mode . mode may be :default , :ascii , :greek or :turkic . The :default mode considers all non-conditional transformations outlined in the Unicode standard. :ascii capitalizes only the letters A to Z. :greek includes the context sensitive mappings found in Greek. :turkic properly handles the letter i with the dotless variant. Examples iex&gt; String . capitalize ( &quot;abcd&quot; ) &quot;Abcd&quot; iex&gt; String . capitalize ( &quot;ﬁn&quot; ) &quot;Fin&quot; iex&gt; String . capitalize ( &quot;olá&quot; ) &quot;Olá&quot;","ref":"String.html#capitalize/2","source_doc":"Converts the first character in the given string to\nuppercase and the remainder to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\ncapitalizes only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.capitalize(\"abcd\")\n    \"Abcd\"\n\n    iex> String.capitalize(\"ﬁn\")\n    \"Fin\"\n\n    iex> String.capitalize(\"olá\")\n    \"Olá\"\n\n","title":"String.capitalize/2","type":"function"},{"doc":"Splits the string into chunks of characters that share a common trait. The trait can be one of two options: :valid - the string is split into chunks of valid and invalid character sequences :printable - the string is split into chunks of printable and non-printable character sequences Returns a list of binaries each of which contains only one kind of characters. If the given string is empty, an empty list is returned. Examples iex&gt; String . chunk ( &lt;&lt; ?a , ?b , ?c , 0 &gt;&gt; , :valid ) [ &quot;abc \\0 &quot; ] iex&gt; String . chunk ( &lt;&lt; ?a , ?b , ?c , 0 , 0xFFFF :: utf16 &gt;&gt; , :valid ) [ &quot;abc \\0 &quot; , &lt;&lt; 0xFFFF :: utf16 &gt;&gt; ] iex&gt; String . chunk ( &lt;&lt; ?a , ?b , ?c , 0 , 0x0FFFF :: utf8 &gt;&gt; , :printable ) [ &quot;abc&quot; , &lt;&lt; 0 , 0x0FFFF :: utf8 &gt;&gt; ]","ref":"String.html#chunk/2","source_doc":"Splits the string into chunks of characters that share a common trait.\n\nThe trait can be one of two options:\n\n  * `:valid` - the string is split into chunks of valid and invalid\n    character sequences\n\n  * `:printable` - the string is split into chunks of printable and\n    non-printable character sequences\n\nReturns a list of binaries each of which contains only one kind of\ncharacters.\n\nIf the given string is empty, an empty list is returned.\n\n## Examples\n\n    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n    [\"abc\\0\"]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0xFFFF::utf16>>, :valid)\n    [\"abc\\0\", <<0xFFFF::utf16>>]\n\n    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0FFFF::utf8>>, :printable)\n    [\"abc\", <<0, 0x0FFFF::utf8>>]\n\n","title":"String.chunk/2","type":"function"},{"doc":"Returns a list of code points encoded as strings. To retrieve code points in their natural integer representation, see to_charlist/1 . For details about code points and graphemes, see the String module documentation. Examples iex&gt; String . codepoints ( &quot;olá&quot; ) [ &quot;o&quot; , &quot;l&quot; , &quot;á&quot; ] iex&gt; String . codepoints ( &quot;оптими зации&quot; ) [ &quot;о&quot; , &quot;п&quot; , &quot;т&quot; , &quot;и&quot; , &quot;м&quot; , &quot;и&quot; , &quot; &quot; , &quot;з&quot; , &quot;а&quot; , &quot;ц&quot; , &quot;и&quot; , &quot;и&quot; ] iex&gt; String . codepoints ( &quot;ἅἪῼ&quot; ) [ &quot;ἅ&quot; , &quot;Ἢ&quot; , &quot;ῼ&quot; ] iex&gt; String . codepoints ( &quot; \\u00e9 &quot; ) [ &quot;é&quot; ] iex&gt; String . codepoints ( &quot; \\u0065 \\u0301 &quot; ) [ &quot;e&quot; , &quot;́&quot; ]","ref":"String.html#codepoints/1","source_doc":"Returns a list of code points encoded as strings.\n\nTo retrieve code points in their natural integer\nrepresentation, see `to_charlist/1`. For details about\ncode points and graphemes, see the `String` module\ndocumentation.\n\n## Examples\n\n    iex> String.codepoints(\"olá\")\n    [\"o\", \"l\", \"á\"]\n\n    iex> String.codepoints(\"оптими зации\")\n    [\"о\", \"п\", \"т\", \"и\", \"м\", \"и\", \" \", \"з\", \"а\", \"ц\", \"и\", \"и\"]\n\n    iex> String.codepoints(\"ἅἪῼ\")\n    [\"ἅ\", \"Ἢ\", \"ῼ\"]\n\n    iex> String.codepoints(\"\\u00e9\")\n    [\"é\"]\n\n    iex> String.codepoints(\"\\u0065\\u0301\")\n    [\"e\", \"́\"]\n\n","title":"String.codepoints/1","type":"function"},{"doc":"Searches if string contains any of the given contents . contents can be either a string, a list of strings, or a compiled pattern. If contents is a list, this function will search if any of the strings in contents are part of string . Searching for a string in a list If you want to check if string is listed in contents , where contents is a list, use Enum.member?(contents, string) instead. Examples iex&gt; String . contains? ( &quot;elixir of life&quot; , &quot;of&quot; ) true iex&gt; String . contains? ( &quot;elixir of life&quot; , [ &quot;life&quot; , &quot;death&quot; ] ) true iex&gt; String . contains? ( &quot;elixir of life&quot; , [ &quot;death&quot; , &quot;mercury&quot; ] ) false The argument can also be a compiled pattern: iex&gt; pattern = :binary . compile_pattern ( [ &quot;life&quot; , &quot;death&quot; ] ) iex&gt; String . contains? ( &quot;elixir of life&quot; , pattern ) true An empty string will always match: iex&gt; String . contains? ( &quot;elixir of life&quot; , &quot;&quot; ) true iex&gt; String . contains? ( &quot;elixir of life&quot; , [ &quot;&quot; , &quot;other&quot; ] ) true An empty list will never match: iex&gt; String . contains? ( &quot;elixir of life&quot; , [ ] ) false iex&gt; String . contains? ( &quot;&quot; , [ ] ) false Be aware that this function can match within or across grapheme boundaries. For example, take the grapheme &quot;é&quot; which is made of the characters &quot;e&quot; and the acute accent. The following returns true : iex&gt; String . contains? ( String . normalize ( &quot;é&quot; , :nfd ) , &quot;e&quot; ) true However, if &quot;é&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return false : iex&gt; String . contains? ( String . normalize ( &quot;é&quot; , :nfc ) , &quot;e&quot; ) false","ref":"String.html#contains?/2","source_doc":"Searches if `string` contains any of the given `contents`.\n\n`contents` can be either a string, a list of strings,\nor a compiled pattern. If `contents` is a list, this\nfunction will search if any of the strings in `contents`\nare part of `string`.\n\n> #### Searching for a string in a list {: .tip}\n>\n> If you want to check if `string` is listed in `contents`,\n> where `contents` is a list, use `Enum.member?(contents, string)`\n> instead.\n\n## Examples\n\n    iex> String.contains?(\"elixir of life\", \"of\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"life\", \"death\"])\n    true\n    iex> String.contains?(\"elixir of life\", [\"death\", \"mercury\"])\n    false\n\nThe argument can also be a compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n    iex> String.contains?(\"elixir of life\", pattern)\n    true\n\nAn empty string will always match:\n\n    iex> String.contains?(\"elixir of life\", \"\")\n    true\n    iex> String.contains?(\"elixir of life\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.contains?(\"elixir of life\", [])\n    false\n\n    iex> String.contains?(\"\", [])\n    false\n\nBe aware that this function can match within or across grapheme boundaries.\nFor example, take the grapheme \"é\" which is made of the characters\n\"e\" and the acute accent. The following returns `true`:\n\n    iex> String.contains?(String.normalize(\"é\", :nfd), \"e\")\n    true\n\nHowever, if \"é\" is represented by the single character \"e with acute\"\naccent, then it will return `false`:\n\n    iex> String.contains?(String.normalize(\"é\", :nfc), \"e\")\n    false\n\n","title":"String.contains?/2","type":"function"},{"doc":"Converts all characters in the given string to lowercase according to mode . mode may be :default , :ascii , :greek or :turkic . The :default mode considers all non-conditional transformations outlined in the Unicode standard. :ascii lowercases only the letters A to Z. :greek includes the context sensitive mappings found in Greek. :turkic properly handles the letter i with the dotless variant. Examples iex&gt; String . downcase ( &quot;ABCD&quot; ) &quot;abcd&quot; iex&gt; String . downcase ( &quot;AB 123 XPTO&quot; ) &quot;ab 123 xpto&quot; iex&gt; String . downcase ( &quot;OLÁ&quot; ) &quot;olá&quot; The :ascii mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters: iex&gt; String . downcase ( &quot;OLÁ&quot; , :ascii ) &quot;olÁ&quot; The :greek mode properly handles the context sensitive sigma in Greek: iex&gt; String . downcase ( &quot;ΣΣ&quot; ) &quot;σσ&quot; iex&gt; String . downcase ( &quot;ΣΣ&quot; , :greek ) &quot;σς&quot; And :turkic properly handles the letter i with the dotless variant: iex&gt; String . downcase ( &quot;Iİ&quot; ) &quot;ii̇&quot; iex&gt; String . downcase ( &quot;Iİ&quot; , :turkic ) &quot;ıi&quot;","ref":"String.html#downcase/2","source_doc":"Converts all characters in the given string to lowercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nlowercases only the letters A to Z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.downcase(\"ABCD\")\n    \"abcd\"\n\n    iex> String.downcase(\"AB 123 XPTO\")\n    \"ab 123 xpto\"\n\n    iex> String.downcase(\"OLÁ\")\n    \"olá\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.downcase(\"OLÁ\", :ascii)\n    \"olÁ\"\n\nThe `:greek` mode properly handles the context sensitive sigma in Greek:\n\n    iex> String.downcase(\"ΣΣ\")\n    \"σσ\"\n\n    iex> String.downcase(\"ΣΣ\", :greek)\n    \"σς\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.downcase(\"Iİ\")\n    \"ii̇\"\n\n    iex> String.downcase(\"Iİ\", :turkic)\n    \"ıi\"\n\n","title":"String.downcase/2","type":"function"},{"doc":"Returns a string subject repeated n times. Inlined by the compiler. Examples iex&gt; String . duplicate ( &quot;abc&quot; , 0 ) &quot;&quot; iex&gt; String . duplicate ( &quot;abc&quot; , 1 ) &quot;abc&quot; iex&gt; String . duplicate ( &quot;abc&quot; , 2 ) &quot;abcabc&quot;","ref":"String.html#duplicate/2","source_doc":"Returns a string `subject` repeated `n` times.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.duplicate(\"abc\", 0)\n    \"\"\n\n    iex> String.duplicate(\"abc\", 1)\n    \"abc\"\n\n    iex> String.duplicate(\"abc\", 2)\n    \"abcabc\"\n\n","title":"String.duplicate/2","type":"function"},{"doc":"Returns true if string ends with any of the suffixes given. suffixes can be either a single suffix or a list of suffixes. Examples iex&gt; String . ends_with? ( &quot;language&quot; , &quot;age&quot; ) true iex&gt; String . ends_with? ( &quot;language&quot; , [ &quot;youth&quot; , &quot;age&quot; ] ) true iex&gt; String . ends_with? ( &quot;language&quot; , [ &quot;youth&quot; , &quot;elixir&quot; ] ) false An empty suffix will always match: iex&gt; String . ends_with? ( &quot;language&quot; , &quot;&quot; ) true iex&gt; String . ends_with? ( &quot;language&quot; , [ &quot;&quot; , &quot;other&quot; ] ) true","ref":"String.html#ends_with?/2","source_doc":"Returns `true` if `string` ends with any of the suffixes given.\n\n`suffixes` can be either a single suffix or a list of suffixes.\n\n## Examples\n\n    iex> String.ends_with?(\"language\", \"age\")\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"age\"])\n    true\n    iex> String.ends_with?(\"language\", [\"youth\", \"elixir\"])\n    false\n\nAn empty suffix will always match:\n\n    iex> String.ends_with?(\"language\", \"\")\n    true\n    iex> String.ends_with?(\"language\", [\"\", \"other\"])\n    true\n\n","title":"String.ends_with?/2","type":"function"},{"doc":"Returns true if string1 is canonically equivalent to string2 . It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to: String . normalize ( string1 , :nfd ) == String . normalize ( string2 , :nfd ) If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes. Examples iex&gt; String . equivalent? ( &quot;abc&quot; , &quot;abc&quot; ) true iex&gt; String . equivalent? ( &quot;man \\u0303 ana&quot; , &quot;mañana&quot; ) true iex&gt; String . equivalent? ( &quot;abc&quot; , &quot;ABC&quot; ) false iex&gt; String . equivalent? ( &quot;nø&quot; , &quot;nó&quot; ) false","ref":"String.html#equivalent?/2","source_doc":"Returns `true` if `string1` is canonically equivalent to `string2`.\n\nIt performs Normalization Form Canonical Decomposition (NFD) on the\nstrings before comparing them. This function is equivalent to:\n\n    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n\nIf you plan to compare multiple strings, multiple times in a row, you\nmay normalize them upfront and compare them directly to avoid multiple\nnormalization passes.\n\n## Examples\n\n    iex> String.equivalent?(\"abc\", \"abc\")\n    true\n\n    iex> String.equivalent?(\"man\\u0303ana\", \"mañana\")\n    true\n\n    iex> String.equivalent?(\"abc\", \"ABC\")\n    false\n\n    iex> String.equivalent?(\"nø\", \"nó\")\n    false\n\n","title":"String.equivalent?/2","type":"function"},{"doc":"Returns the first grapheme from a UTF-8 string, nil if the string is empty. Examples iex&gt; String . first ( &quot;elixir&quot; ) &quot;e&quot; iex&gt; String . first ( &quot;եոգլի&quot; ) &quot;ե&quot; iex&gt; String . first ( &quot;&quot; ) nil","ref":"String.html#first/1","source_doc":"Returns the first grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\n## Examples\n\n    iex> String.first(\"elixir\")\n    \"e\"\n\n    iex> String.first(\"եոգլի\")\n    \"ե\"\n\n    iex> String.first(\"\")\n    nil\n\n","title":"String.first/1","type":"function"},{"doc":"Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm. The algorithm is outlined in the Unicode Standard Annex #29, Unicode Text Segmentation . For details about code points and graphemes, see the String module documentation. Examples iex&gt; String . graphemes ( &quot;Ńaïve&quot; ) [ &quot;Ń&quot; , &quot;a&quot; , &quot;ï&quot; , &quot;v&quot; , &quot;e&quot; ] iex&gt; String . graphemes ( &quot; \\u00e9 &quot; ) [ &quot;é&quot; ] iex&gt; String . graphemes ( &quot; \\u0065 \\u0301 &quot; ) [ &quot;é&quot; ]","ref":"String.html#graphemes/1","source_doc":"Returns Unicode graphemes in the string as per Extended Grapheme\nCluster algorithm.\n\nThe algorithm is outlined in the [Unicode Standard Annex #29,\nUnicode Text Segmentation](https://www.unicode.org/reports/tr29/).\n\nFor details about code points and graphemes, see the `String` module documentation.\n\n## Examples\n\n    iex> String.graphemes(\"Ńaïve\")\n    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n\n    iex> String.graphemes(\"\\u00e9\")\n    [\"é\"]\n\n    iex> String.graphemes(\"\\u0065\\u0301\")\n    [\"é\"]\n\n","title":"String.graphemes/1","type":"function"},{"doc":"Computes the Jaro distance (similarity) between two strings. Returns a float value between 0.0 (equates to no similarity) and 1.0 (is an exact match) representing Jaro distance between string1 and string2 . The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the &quot;did you mean?&quot; functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the jaro_distance/2 score. Examples iex&gt; String . jaro_distance ( &quot;Dwayne&quot; , &quot;Duane&quot; ) 0.8222222222222223 iex&gt; String . jaro_distance ( &quot;even&quot; , &quot;odd&quot; ) 0.0 iex&gt; String . jaro_distance ( &quot;same&quot; , &quot;same&quot; ) 1.0","ref":"String.html#jaro_distance/2","source_doc":"Computes the Jaro distance (similarity) between two strings.\n\nReturns a float value between `0.0` (equates to no similarity) and `1.0`\n(is an exact match) representing [Jaro](https://en.wikipedia.org/wiki/Jaro-Winkler_distance)\ndistance between `string1` and `string2`.\n\nThe Jaro distance metric is designed and best suited for short\nstrings such as person names. Elixir itself uses this function\nto provide the \"did you mean?\" functionality. For instance, when you\nare calling a function in a module and you have a typo in the\nfunction name, we attempt to suggest the most similar function\nname available, if any, based on the `jaro_distance/2` score.\n\n## Examples\n\n    iex> String.jaro_distance(\"Dwayne\", \"Duane\")\n    0.8222222222222223\n    iex> String.jaro_distance(\"even\", \"odd\")\n    0.0\n    iex> String.jaro_distance(\"same\", \"same\")\n    1.0\n\n","title":"String.jaro_distance/2","type":"function"},{"doc":"Returns the last grapheme from a UTF-8 string, nil if the string is empty. It traverses the whole string to find its last grapheme. Examples iex&gt; String . last ( &quot;&quot; ) nil iex&gt; String . last ( &quot;elixir&quot; ) &quot;r&quot; iex&gt; String . last ( &quot;եոգլի&quot; ) &quot;ի&quot;","ref":"String.html#last/1","source_doc":"Returns the last grapheme from a UTF-8 string,\n`nil` if the string is empty.\n\nIt traverses the whole string to find its last grapheme.\n\n## Examples\n\n    iex> String.last(\"\")\n    nil\n\n    iex> String.last(\"elixir\")\n    \"r\"\n\n    iex> String.last(\"եոգլի\")\n    \"ի\"\n\n","title":"String.last/1","type":"function"},{"doc":"Returns the number of Unicode graphemes in a UTF-8 string. Examples iex&gt; String . length ( &quot;elixir&quot; ) 6 iex&gt; String . length ( &quot;եոգլի&quot; ) 5","ref":"String.html#length/1","source_doc":"Returns the number of Unicode graphemes in a UTF-8 string.\n\n## Examples\n\n    iex> String.length(\"elixir\")\n    6\n\n    iex> String.length(\"եոգլի\")\n    5\n\n","title":"String.length/1","type":"function"},{"doc":"Checks if string matches the given regular expression. Examples iex&gt; String . match? ( &quot;foo&quot; , ~r/foo/ ) true iex&gt; String . match? ( &quot;bar&quot; , ~r/foo/ ) false Elixir also provides text-based match operator =~/2 and function Regex.match?/2 as alternatives to test strings against regular expressions.","ref":"String.html#match?/2","source_doc":"Checks if `string` matches the given regular expression.\n\n## Examples\n\n    iex> String.match?(\"foo\", ~r/foo/)\n    true\n\n    iex> String.match?(\"bar\", ~r/foo/)\n    false\n\nElixir also provides text-based match operator `=~/2` and function `Regex.match?/2` as\nalternatives to test strings against regular expressions.\n","title":"String.match?/2","type":"function"},{"doc":"Returns a keyword list that represents an edit script. Check List.myers_difference/2 for more information. Examples iex&gt; string1 = &quot;fox hops over the dog&quot; iex&gt; string2 = &quot;fox jumps over the lazy cat&quot; iex&gt; String . myers_difference ( string1 , string2 ) [ eq : &quot;fox &quot; , del : &quot;ho&quot; , ins : &quot;jum&quot; , eq : &quot;ps over the &quot; , del : &quot;dog&quot; , ins : &quot;lazy cat&quot; ]","ref":"String.html#myers_difference/2","source_doc":"Returns a keyword list that represents an edit script.\n\nCheck `List.myers_difference/2` for more information.\n\n## Examples\n\n    iex> string1 = \"fox hops over the dog\"\n    iex> string2 = \"fox jumps over the lazy cat\"\n    iex> String.myers_difference(string1, string2)\n    [eq: \"fox \", del: \"ho\", ins: \"jum\", eq: \"ps over the \", del: \"dog\", ins: \"lazy cat\"]\n\n","title":"String.myers_difference/2","type":"function"},{"doc":"Returns the next code point in a string. The result is a tuple with the code point and the remainder of the string or nil in case the string reached its end. As with other functions in the String module, next_codepoint/1 works with binaries that are invalid UTF-8. If the string starts with a sequence of bytes that is not valid in UTF-8 encoding, the first element of the returned tuple is a binary with the first byte. Examples iex&gt; String . next_codepoint ( &quot;olá&quot; ) { &quot;o&quot; , &quot;lá&quot; } iex&gt; invalid = &quot; \\x 80 \\x 80OK&quot; # first two bytes are invalid in UTF-8 iex&gt; { _ , rest } = String . next_codepoint ( invalid ) { &lt;&lt; 128 &gt;&gt; , &lt;&lt; 128 , 79 , 75 &gt;&gt; } iex&gt; String . next_codepoint ( rest ) { &lt;&lt; 128 &gt;&gt; , &quot;OK&quot; } Comparison with binary pattern matching Binary pattern matching provides a similar way to decompose a string: iex&gt; &lt;&lt; codepoint :: utf8 , rest :: binary &gt;&gt; = &quot;Elixir&quot; &quot;Elixir&quot; iex&gt; codepoint 69 iex&gt; rest &quot;lixir&quot; though not entirely equivalent because codepoint comes as an integer, and the pattern won't match invalid UTF-8. Binary pattern matching, however, is simpler and more efficient, so pick the option that better suits your use case.","ref":"String.html#next_codepoint/1","source_doc":"Returns the next code point in a string.\n\nThe result is a tuple with the code point and the\nremainder of the string or `nil` in case\nthe string reached its end.\n\nAs with other functions in the `String` module, `next_codepoint/1`\nworks with binaries that are invalid UTF-8. If the string starts\nwith a sequence of bytes that is not valid in UTF-8 encoding, the\nfirst element of the returned tuple is a binary with the first byte.\n\n## Examples\n\n    iex> String.next_codepoint(\"olá\")\n    {\"o\", \"lá\"}\n\n    iex> invalid = \"\\x80\\x80OK\" # first two bytes are invalid in UTF-8\n    iex> {_, rest} = String.next_codepoint(invalid)\n    {<<128>>, <<128, 79, 75>>}\n    iex> String.next_codepoint(rest)\n    {<<128>>, \"OK\"}\n\n## Comparison with binary pattern matching\n\nBinary pattern matching provides a similar way to decompose\na string:\n\n    iex> <<codepoint::utf8, rest::binary>> = \"Elixir\"\n    \"Elixir\"\n    iex> codepoint\n    69\n    iex> rest\n    \"lixir\"\n\nthough not entirely equivalent because `codepoint` comes as\nan integer, and the pattern won't match invalid UTF-8.\n\nBinary pattern matching, however, is simpler and more efficient,\nso pick the option that better suits your use case.\n","title":"String.next_codepoint/1","type":"function"},{"doc":"Returns the next grapheme in a string. The result is a tuple with the grapheme and the remainder of the string or nil in case the String reached its end. Examples iex&gt; String . next_grapheme ( &quot;olá&quot; ) { &quot;o&quot; , &quot;lá&quot; } iex&gt; String . next_grapheme ( &quot;&quot; ) nil","ref":"String.html#next_grapheme/1","source_doc":"Returns the next grapheme in a string.\n\nThe result is a tuple with the grapheme and the\nremainder of the string or `nil` in case\nthe String reached its end.\n\n## Examples\n\n    iex> String.next_grapheme(\"olá\")\n    {\"o\", \"lá\"}\n\n    iex> String.next_grapheme(\"\")\n    nil\n\n","title":"String.next_grapheme/1","type":"function"},{"doc":"Converts all characters in string to Unicode normalization form identified by form . Invalid Unicode codepoints are skipped and the remaining of the string is converted. If you want the algorithm to stop and return on invalid codepoint, use :unicode.characters_to_nfd_binary/1 , :unicode.characters_to_nfc_binary/1 , :unicode.characters_to_nfkd_binary/1 , and :unicode.characters_to_nfkc_binary/1 instead. Normalization forms :nfkc and :nfkd should not be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets. Forms The supported forms are: :nfd - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order. :nfc - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence. :nfkd - Normalization Form Compatibility Decomposition. Characters are decomposed by compatibility equivalence, and multiple combining characters are arranged in a specific order. :nfkc - Normalization Form Compatibility Composition. Characters are decomposed and then recomposed by compatibility equivalence. Examples iex&gt; String . normalize ( &quot;yêṩ&quot; , :nfd ) &quot;yêṩ&quot; iex&gt; String . normalize ( &quot;leña&quot; , :nfc ) &quot;leña&quot; iex&gt; String . normalize ( &quot;ﬁ&quot; , :nfkd ) &quot;fi&quot; iex&gt; String . normalize ( &quot;fi&quot; , :nfkc ) &quot;fi&quot;","ref":"String.html#normalize/2","source_doc":"Converts all characters in `string` to Unicode normalization\nform identified by `form`.\n\nInvalid Unicode codepoints are skipped and the remaining of\nthe string is converted. If you want the algorithm to stop\nand return on invalid codepoint, use `:unicode.characters_to_nfd_binary/1`,\n`:unicode.characters_to_nfc_binary/1`, `:unicode.characters_to_nfkd_binary/1`,\nand `:unicode.characters_to_nfkc_binary/1` instead.\n\nNormalization forms `:nfkc` and `:nfkd` should not be blindly applied\nto arbitrary text. Because they erase many formatting distinctions,\nthey will prevent round-trip conversion to and from many legacy\ncharacter sets.\n\n## Forms\n\nThe supported forms are:\n\n  * `:nfd` - Normalization Form Canonical Decomposition.\n    Characters are decomposed by canonical equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfc` - Normalization Form Canonical Composition.\n    Characters are decomposed and then recomposed by canonical equivalence.\n\n  * `:nfkd` - Normalization Form Compatibility Decomposition.\n    Characters are decomposed by compatibility equivalence, and\n    multiple combining characters are arranged in a specific\n    order.\n\n  * `:nfkc` - Normalization Form Compatibility Composition.\n    Characters are decomposed and then recomposed by compatibility equivalence.\n\n## Examples\n\n    iex> String.normalize(\"yêṩ\", :nfd)\n    \"yêṩ\"\n\n    iex> String.normalize(\"leña\", :nfc)\n    \"leña\"\n\n    iex> String.normalize(\"ﬁ\", :nfkd)\n    \"fi\"\n\n    iex> String.normalize(\"fi\", :nfkc)\n    \"fi\"\n\n","title":"String.normalize/2","type":"function"},{"doc":"Returns a new string padded with a leading filler which is made of elements from the padding . Passing a list of strings as padding will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string padding is equivalent to passing the list of graphemes in it. If no padding is given, it defaults to whitespace. When count is less than or equal to the length of string , given string is returned. Raises ArgumentError if the given padding contains a non-string element. Examples iex&gt; String . pad_leading ( &quot;abc&quot; , 5 ) &quot; abc&quot; iex&gt; String . pad_leading ( &quot;abc&quot; , 4 , &quot;12&quot; ) &quot;1abc&quot; iex&gt; String . pad_leading ( &quot;abc&quot; , 6 , &quot;12&quot; ) &quot;121abc&quot; iex&gt; String . pad_leading ( &quot;abc&quot; , 5 , [ &quot;1&quot; , &quot;23&quot; ] ) &quot;123abc&quot;","ref":"String.html#pad_leading/3","source_doc":"Returns a new string padded with a leading filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_leading(\"abc\", 5)\n    \"  abc\"\n\n    iex> String.pad_leading(\"abc\", 4, \"12\")\n    \"1abc\"\n\n    iex> String.pad_leading(\"abc\", 6, \"12\")\n    \"121abc\"\n\n    iex> String.pad_leading(\"abc\", 5, [\"1\", \"23\"])\n    \"123abc\"\n\n","title":"String.pad_leading/3","type":"function"},{"doc":"Returns a new string padded with a trailing filler which is made of elements from the padding . Passing a list of strings as padding will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string padding is equivalent to passing the list of graphemes in it. If no padding is given, it defaults to whitespace. When count is less than or equal to the length of string , given string is returned. Raises ArgumentError if the given padding contains a non-string element. Examples iex&gt; String . pad_trailing ( &quot;abc&quot; , 5 ) &quot;abc &quot; iex&gt; String . pad_trailing ( &quot;abc&quot; , 4 , &quot;12&quot; ) &quot;abc1&quot; iex&gt; String . pad_trailing ( &quot;abc&quot; , 6 , &quot;12&quot; ) &quot;abc121&quot; iex&gt; String . pad_trailing ( &quot;abc&quot; , 5 , [ &quot;1&quot; , &quot;23&quot; ] ) &quot;abc123&quot;","ref":"String.html#pad_trailing/3","source_doc":"Returns a new string padded with a trailing filler\nwhich is made of elements from the `padding`.\n\nPassing a list of strings as `padding` will take one element of the list\nfor every missing entry. If the list is shorter than the number of inserts,\nthe filling will start again from the beginning of the list.\nPassing a string `padding` is equivalent to passing the list of graphemes in it.\nIf no `padding` is given, it defaults to whitespace.\n\nWhen `count` is less than or equal to the length of `string`,\ngiven `string` is returned.\n\nRaises `ArgumentError` if the given `padding` contains a non-string element.\n\n## Examples\n\n    iex> String.pad_trailing(\"abc\", 5)\n    \"abc  \"\n\n    iex> String.pad_trailing(\"abc\", 4, \"12\")\n    \"abc1\"\n\n    iex> String.pad_trailing(\"abc\", 6, \"12\")\n    \"abc121\"\n\n    iex> String.pad_trailing(\"abc\", 5, [\"1\", \"23\"])\n    \"abc123\"\n\n","title":"String.pad_trailing/3","type":"function"},{"doc":"Checks if a string contains only printable characters up to character_limit . Takes an optional character_limit as a second argument. If character_limit is 0 , this function will return true . Examples iex&gt; String . printable? ( &quot;abc&quot; ) true iex&gt; String . printable? ( &quot;abc&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; ) false iex&gt; String . printable? ( &quot;abc&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; , 2 ) true iex&gt; String . printable? ( &quot;abc&quot; &lt;&gt; &lt;&lt; 0 &gt;&gt; , 0 ) true","ref":"String.html#printable?/2","source_doc":"Checks if a string contains only printable characters up to `character_limit`.\n\nTakes an optional `character_limit` as a second argument. If `character_limit` is `0`, this\nfunction will return `true`.\n\n## Examples\n\n    iex> String.printable?(\"abc\")\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>)\n    false\n\n    iex> String.printable?(\"abc\" <> <<0>>, 2)\n    true\n\n    iex> String.printable?(\"abc\" <> <<0>>, 0)\n    true\n\n","title":"String.printable?/2","type":"function"},{"doc":"Returns a new string created by replacing occurrences of pattern in subject with replacement . The subject is always a string. The pattern may be a string, a list of strings, a regular expression, or a compiled pattern. The replacement may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata. By default it replaces all occurrences but this behaviour can be controlled through the :global option; see the &quot;Options&quot; section below. Options :global - (boolean) if true , all occurrences of pattern are replaced with replacement , otherwise only the first occurrence is replaced. Defaults to true Examples iex&gt; String . replace ( &quot;a,b,c&quot; , &quot;,&quot; , &quot;-&quot; ) &quot;a-b-c&quot; iex&gt; String . replace ( &quot;a,b,c&quot; , &quot;,&quot; , &quot;-&quot; , global : false ) &quot;a-b,c&quot; The pattern may also be a list of strings and the replacement may also be a function that receives the matches: iex&gt; String . replace ( &quot;a,b,c&quot; , [ &quot;a&quot; , &quot;c&quot; ] , fn &lt;&lt; char &gt;&gt; -&gt; &lt;&lt; char + 1 &gt;&gt; end ) &quot;b,b,d&quot; When the pattern is a regular expression, one can give \\N or \\g{N} in the replacement string to access a specific capture in the regular expression: iex&gt; String . replace ( &quot;a,b,c&quot; , ~r/,(.)/ , &quot;, \\\\ 1 \\\\ g{1}&quot; ) &quot;a,bb,cc&quot; Note that we had to escape the backslash escape character (i.e., we used \\\\N instead of just \\N to escape the backslash; same thing for \\\\g{N} ). By giving \\0 , one can inject the whole match in the replacement string. A compiled pattern can also be given: iex&gt; pattern = :binary . compile_pattern ( &quot;,&quot; ) iex&gt; String . replace ( &quot;a,b,c&quot; , pattern , &quot;[]&quot; ) &quot;a[]b[]c&quot; When an empty string is provided as a pattern , the function will treat it as an implicit empty string between each grapheme and the string will be interspersed. If an empty string is provided as replacement the subject will be returned: iex&gt; String . replace ( &quot;ELIXIR&quot; , &quot;&quot; , &quot;.&quot; ) &quot;.E.L.I.X.I.R.&quot; iex&gt; String . replace ( &quot;ELIXIR&quot; , &quot;&quot; , &quot;&quot; ) &quot;ELIXIR&quot; Be aware that this function can replace within or across grapheme boundaries. For example, take the grapheme &quot;é&quot; which is made of the characters &quot;e&quot; and the acute accent. The following will replace only the letter &quot;e&quot;, moving the accent to the letter &quot;o&quot;: iex&gt; String . replace ( String . normalize ( &quot;é&quot; , :nfd ) , &quot;e&quot; , &quot;o&quot; ) &quot;ó&quot; However, if &quot;é&quot; is represented by the single character &quot;e with acute&quot; accent, then it won't be replaced at all: iex&gt; String . replace ( String . normalize ( &quot;é&quot; , :nfc ) , &quot;e&quot; , &quot;o&quot; ) &quot;é&quot;","ref":"String.html#replace/4","source_doc":"Returns a new string created by replacing occurrences of `pattern` in\n`subject` with `replacement`.\n\nThe `subject` is always a string.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe `replacement` may be a string or a function that receives the matched\npattern and must return the replacement as a string or iodata.\n\nBy default it replaces all occurrences but this behaviour can be controlled\nthrough the `:global` option; see the \"Options\" section below.\n\n## Options\n\n  * `:global` - (boolean) if `true`, all occurrences of `pattern` are replaced\n    with `replacement`, otherwise only the first occurrence is\n    replaced. Defaults to `true`\n\n## Examples\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\")\n    \"a-b-c\"\n\n    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n    \"a-b,c\"\n\nThe pattern may also be a list of strings and the replacement may also\nbe a function that receives the matches:\n\n    iex> String.replace(\"a,b,c\", [\"a\", \"c\"], fn <<char>> -> <<char + 1>> end)\n    \"b,b,d\"\n\nWhen the pattern is a regular expression, one can give `\\N` or\n`\\g{N}` in the `replacement` string to access a specific capture in the\nregular expression:\n\n    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n    \"a,bb,cc\"\n\nNote that we had to escape the backslash escape character (i.e., we used `\\\\N`\ninstead of just `\\N` to escape the backslash; same thing for `\\\\g{N}`). By\ngiving `\\0`, one can inject the whole match in the replacement string.\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern(\",\")\n    iex> String.replace(\"a,b,c\", pattern, \"[]\")\n    \"a[]b[]c\"\n\nWhen an empty string is provided as a `pattern`, the function will treat it as\nan implicit empty string between each grapheme and the string will be\ninterspersed. If an empty string is provided as `replacement` the `subject`\nwill be returned:\n\n    iex> String.replace(\"ELIXIR\", \"\", \".\")\n    \".E.L.I.X.I.R.\"\n\n    iex> String.replace(\"ELIXIR\", \"\", \"\")\n    \"ELIXIR\"\n\nBe aware that this function can replace within or across grapheme boundaries.\nFor example, take the grapheme \"é\" which is made of the characters\n\"e\" and the acute accent. The following will replace only the letter \"e\",\nmoving the accent to the letter \"o\":\n\n    iex> String.replace(String.normalize(\"é\", :nfd), \"e\", \"o\")\n    \"ó\"\n\nHowever, if \"é\" is represented by the single character \"e with acute\"\naccent, then it won't be replaced at all:\n\n    iex> String.replace(String.normalize(\"é\", :nfc), \"e\", \"o\")\n    \"é\"\n\n","title":"String.replace/4","type":"function"},{"doc":"Replaces all leading occurrences of match by replacement of match in string . Returns the string untouched if there are no occurrences. If match is &quot;&quot; , this function raises an ArgumentError exception: this happens because this function replaces all the occurrences of match at the beginning of string , and it's impossible to replace &quot;multiple&quot; occurrences of &quot;&quot; . Examples iex&gt; String . replace_leading ( &quot;hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_leading ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_leading ( &quot;hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola world&quot; iex&gt; String . replace_leading ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola ola world&quot; This function can replace across grapheme boundaries. See replace/3 for more information and examples.","ref":"String.html#replace_leading/3","source_doc":"Replaces all leading occurrences of `match` by `replacement` of `match` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe beginning of `string`, and it's impossible to replace \"multiple\"\noccurrences of `\"\"`.\n\n## Examples\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n    \"world\"\n\n    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola \")\n    \"ola ola world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n","title":"String.replace_leading/3","type":"function"},{"doc":"Replaces prefix in string by replacement if it matches match . Returns the string untouched if there is no match. If match is an empty string ( &quot;&quot; ), replacement is just prepended to string . Examples iex&gt; String . replace_prefix ( &quot;world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_prefix ( &quot;hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;world&quot; iex&gt; String . replace_prefix ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;&quot; ) &quot;hello world&quot; iex&gt; String . replace_prefix ( &quot;world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;world&quot; iex&gt; String . replace_prefix ( &quot;hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola world&quot; iex&gt; String . replace_prefix ( &quot;hello hello world&quot; , &quot;hello &quot; , &quot;ola &quot; ) &quot;ola hello world&quot; iex&gt; String . replace_prefix ( &quot;world&quot; , &quot;&quot; , &quot;hello &quot; ) &quot;hello world&quot; This function can replace across grapheme boundaries. See replace/3 for more information and examples.","ref":"String.html#replace_prefix/3","source_doc":"Replaces prefix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just prepended to `string`.\n\n## Examples\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n    \"world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n    \"hello world\"\n\n    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n    \"world\"\n    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n    \"ola world\"\n    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n    \"ola hello world\"\n\n    iex> String.replace_prefix(\"world\", \"\", \"hello \")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n","title":"String.replace_prefix/3","type":"function"},{"doc":"Replaces suffix in string by replacement if it matches match . Returns the string untouched if there is no match. If match is an empty string ( &quot;&quot; ), replacement is just appended to string . Examples iex&gt; String . replace_suffix ( &quot;hello&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_suffix ( &quot;hello world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_suffix ( &quot;hello world world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello world&quot; iex&gt; String . replace_suffix ( &quot;hello&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello&quot; iex&gt; String . replace_suffix ( &quot;hello world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello mundo&quot; iex&gt; String . replace_suffix ( &quot;hello world world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello world mundo&quot; iex&gt; String . replace_suffix ( &quot;hello&quot; , &quot;&quot; , &quot; world&quot; ) &quot;hello world&quot; This function can replace across grapheme boundaries. See replace/3 for more information and examples.","ref":"String.html#replace_suffix/3","source_doc":"Replaces suffix in `string` by `replacement` if it matches `match`.\n\nReturns the string untouched if there is no match. If `match` is an empty\nstring (`\"\"`), `replacement` is just appended to `string`.\n\n## Examples\n\n    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n    \"hello world\"\n\n    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n    \"hello\"\n    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo\")\n    \"hello world mundo\"\n\n    iex> String.replace_suffix(\"hello\", \"\", \" world\")\n    \"hello world\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n","title":"String.replace_suffix/3","type":"function"},{"doc":"Replaces all trailing occurrences of match by replacement in string . Returns the string untouched if there are no occurrences. If match is &quot;&quot; , this function raises an ArgumentError exception: this happens because this function replaces all the occurrences of match at the end of string , and it's impossible to replace &quot;multiple&quot; occurrences of &quot;&quot; . Examples iex&gt; String . replace_trailing ( &quot;hello world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_trailing ( &quot;hello world world&quot; , &quot; world&quot; , &quot;&quot; ) &quot;hello&quot; iex&gt; String . replace_trailing ( &quot;hello world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello mundo&quot; iex&gt; String . replace_trailing ( &quot;hello world world&quot; , &quot; world&quot; , &quot; mundo&quot; ) &quot;hello mundo mundo&quot; This function can replace across grapheme boundaries. See replace/3 for more information and examples.","ref":"String.html#replace_trailing/3","source_doc":"Replaces all trailing occurrences of `match` by `replacement` in `string`.\n\nReturns the string untouched if there are no occurrences.\n\nIf `match` is `\"\"`, this function raises an `ArgumentError` exception: this\nhappens because this function replaces **all** the occurrences of `match` at\nthe end of `string`, and it's impossible to replace \"multiple\" occurrences of\n`\"\"`.\n\n## Examples\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n    \"hello\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n    \"hello\"\n\n    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n    \"hello mundo\"\n    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo\")\n    \"hello mundo mundo\"\n\nThis function can replace across grapheme boundaries. See `replace/3`\nfor more information and examples.\n","title":"String.replace_trailing/3","type":"function"},{"doc":"Reverses the graphemes in given string. Examples iex&gt; String . reverse ( &quot;abcd&quot; ) &quot;dcba&quot; iex&gt; String . reverse ( &quot;hello world&quot; ) &quot;dlrow olleh&quot; iex&gt; String . reverse ( &quot;hello ∂og&quot; ) &quot;go∂ olleh&quot; Keep in mind reversing the same string twice does not necessarily yield the original string: iex&gt; &quot;̀e&quot; &quot;̀e&quot; iex&gt; String . reverse ( &quot;̀e&quot; ) &quot;è&quot; iex&gt; String . reverse ( String . reverse ( &quot;̀e&quot; ) ) &quot;è&quot; In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.","ref":"String.html#reverse/1","source_doc":"Reverses the graphemes in given string.\n\n## Examples\n\n    iex> String.reverse(\"abcd\")\n    \"dcba\"\n\n    iex> String.reverse(\"hello world\")\n    \"dlrow olleh\"\n\n    iex> String.reverse(\"hello ∂og\")\n    \"go∂ olleh\"\n\nKeep in mind reversing the same string twice does\nnot necessarily yield the original string:\n\n    iex> \"̀e\"\n    \"̀e\"\n    iex> String.reverse(\"̀e\")\n    \"è\"\n    iex> String.reverse(String.reverse(\"̀e\"))\n    \"è\"\n\nIn the first example the accent is before the vowel, so\nit is considered two graphemes. However, when you reverse\nit once, you have the vowel followed by the accent, which\nbecomes one grapheme. Reversing it again will keep it as\none single grapheme.\n","title":"String.reverse/1","type":"function"},{"doc":"Returns a substring from the offset given by the start of the range to the offset given by the end of the range. If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &quot;&quot; . If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones. Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check Kernel.binary_part/3 or Kernel.binary_slice/2 instead Examples iex&gt; String . slice ( &quot;elixir&quot; , 1 .. 3 ) &quot;lix&quot; iex&gt; String . slice ( &quot;elixir&quot; , 1 .. 10 ) &quot;lixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 4 .. - 1 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 4 .. 6 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 100 .. 100 ) &quot;elixir&quot; For ranges where start &gt; stop , you need to explicitly mark them as increasing: iex&gt; String . slice ( &quot;elixir&quot; , 2 .. - 1 // 1 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , 1 .. - 2 // 1 ) &quot;lixi&quot; You can use ../0 as a shortcut for 0..-1//1 , which returns the whole string as is: iex&gt; String . slice ( &quot;elixir&quot; , .. ) &quot;elixir&quot; The step can be any positive number. For example, to get every 2 characters of the string: iex&gt; String . slice ( &quot;elixir&quot; , 0 .. - 1 // 2 ) &quot;eii&quot; If the first position is after the string ends or after the last position of the range, it returns an empty string: iex&gt; String . slice ( &quot;elixir&quot; , 10 .. 3 ) &quot;&quot; iex&gt; String . slice ( &quot;a&quot; , 1 .. 1500 ) &quot;&quot;","ref":"String.html#slice/2","source_doc":"Returns a substring from the offset given by the start of the\nrange to the offset given by the end of the range.\n\nIf the start of the range is not a valid offset for the given\nstring or if the range is in reverse order, returns `\"\"`.\n\nIf the start or end of the range is negative, the whole string\nis traversed first in order to convert the negative indices into\npositive ones.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or\n`Kernel.binary_slice/2` instead\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1..3)\n    \"lix\"\n    iex> String.slice(\"elixir\", 1..10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", -4..-1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -4..6)\n    \"ixir\"\n    iex> String.slice(\"elixir\", -100..100)\n    \"elixir\"\n\nFor ranges where `start > stop`, you need to explicitly\nmark them as increasing:\n\n    iex> String.slice(\"elixir\", 2..-1//1)\n    \"ixir\"\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n\nYou can use `../0` as a shortcut for `0..-1//1`, which returns\nthe whole string as is:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n\nThe step can be any positive number. For example, to\nget every 2 characters of the string:\n\n    iex> String.slice(\"elixir\", 0..-1//2)\n    \"eii\"\n\nIf the first position is after the string ends or after\nthe last position of the range, it returns an empty string:\n\n    iex> String.slice(\"elixir\", 10..3)\n    \"\"\n    iex> String.slice(\"a\", 1..1500)\n    \"\"\n\n","title":"String.slice/2","type":"function"},{"doc":"Returns a substring starting at the offset start , and of the given length . If the offset is greater than string length, then it returns &quot;&quot; . Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check Kernel.binary_part/3 or Kernel.binary_slice/3 instead. Examples iex&gt; String . slice ( &quot;elixir&quot; , 1 , 3 ) &quot;lix&quot; iex&gt; String . slice ( &quot;elixir&quot; , 1 , 10 ) &quot;lixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , 10 , 3 ) &quot;&quot; If the start position is negative, it is normalized against the string length and clamped to 0: iex&gt; String . slice ( &quot;elixir&quot; , - 4 , 4 ) &quot;ixir&quot; iex&gt; String . slice ( &quot;elixir&quot; , - 10 , 3 ) &quot;eli&quot; If start is more than the string length, an empty string is returned: iex&gt; String . slice ( &quot;elixir&quot; , 10 , 1500 ) &quot;&quot;","ref":"String.html#slice/3","source_doc":"Returns a substring starting at the offset `start`, and of the given `length`.\n\nIf the offset is greater than string length, then it returns `\"\"`.\n\nRemember this function works with Unicode graphemes and considers\nthe slices to represent grapheme offsets. If you want to split\non raw bytes, check `Kernel.binary_part/3` or `Kernel.binary_slice/3`\ninstead.\n\n## Examples\n\n    iex> String.slice(\"elixir\", 1, 3)\n    \"lix\"\n\n    iex> String.slice(\"elixir\", 1, 10)\n    \"lixir\"\n\n    iex> String.slice(\"elixir\", 10, 3)\n    \"\"\n\nIf the start position is negative, it is normalized\nagainst the string length and clamped to 0:\n\n    iex> String.slice(\"elixir\", -4, 4)\n    \"ixir\"\n\n    iex> String.slice(\"elixir\", -10, 3)\n    \"eli\"\n\nIf start is more than the string length, an empty\nstring is returned:\n\n    iex> String.slice(\"elixir\", 10, 1500)\n    \"\"\n\n","title":"String.slice/3","type":"function"},{"doc":"Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace. Examples iex&gt; String . split ( &quot;foo bar&quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot;foo&quot; &lt;&gt; &lt;&lt; 194 , 133 &gt;&gt; &lt;&gt; &quot;bar&quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot; foo bar &quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; String . split ( &quot;no \\u00a0 break&quot; ) [ &quot;no \\u00a0 break&quot; ]","ref":"String.html#split/1","source_doc":"Divides a string into substrings at each Unicode whitespace\noccurrence with leading and trailing whitespace ignored. Groups\nof whitespace are treated as a single occurrence. Divisions do\nnot occur on non-breaking whitespace.\n\n## Examples\n\n    iex> String.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\" foo   bar \")\n    [\"foo\", \"bar\"]\n\n    iex> String.split(\"no\\u00a0break\")\n    [\"no\\u00a0break\"]\n\n","title":"String.split/1","type":"function"},{"doc":"Divides a string into parts based on a pattern. Returns a list of these parts. The pattern may be a string, a list of strings, a regular expression, or a compiled pattern. The string is split into as many parts as possible by default, but can be controlled via the :parts option. Empty strings are only removed from the result if the :trim option is set to true . When the pattern used is a regular expression, the string is split using Regex.split/3 . Options :parts (positive integer or :infinity ) - the string is split into at most as many parts as this option specifies. If :infinity , the string will be split into all possible parts. Defaults to :infinity . :trim (boolean) - if true , empty strings are removed from the resulting list. This function also accepts all options accepted by Regex.split/3 if pattern is a regular expression. Examples Splitting with a string pattern: iex&gt; String . split ( &quot;a,b,c&quot; , &quot;,&quot; ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;a,b,c&quot; , &quot;,&quot; , parts : 2 ) [ &quot;a&quot; , &quot;b,c&quot; ] iex&gt; String . split ( &quot; a b c &quot; , &quot; &quot; , trim : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] A list of patterns: iex&gt; String . split ( &quot;1,2 3,4&quot; , [ &quot; &quot; , &quot;,&quot; ] ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ] A regular expression: iex&gt; String . split ( &quot;a,b,c&quot; , ~r{,} ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;a,b,c&quot; , ~r{,} , parts : 2 ) [ &quot;a&quot; , &quot;b,c&quot; ] iex&gt; String . split ( &quot; a b c &quot; , ~r{ \\s } , trim : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;abc&quot; , ~r{b} , include_captures : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] A compiled pattern: iex&gt; pattern = :binary . compile_pattern ( [ &quot; &quot; , &quot;,&quot; ] ) iex&gt; String . split ( &quot;1,2 3,4&quot; , pattern ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ] Splitting on empty string returns graphemes: iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; ) [ &quot;&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;&quot; ] iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; , trim : true ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; , parts : 1 ) [ &quot;abc&quot; ] iex&gt; String . split ( &quot;abc&quot; , &quot;&quot; , parts : 3 ) [ &quot;&quot; , &quot;a&quot; , &quot;bc&quot; ] Be aware that this function can split within or across grapheme boundaries. For example, take the grapheme &quot;é&quot; which is made of the characters &quot;e&quot; and the acute accent. The following will split the string into two parts: iex&gt; String . split ( String . normalize ( &quot;é&quot; , :nfd ) , &quot;e&quot; ) [ &quot;&quot; , &quot;́&quot; ] However, if &quot;é&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part: iex&gt; String . split ( String . normalize ( &quot;é&quot; , :nfc ) , &quot;e&quot; ) [ &quot;é&quot; ]","ref":"String.html#split/3","source_doc":"Divides a string into parts based on a pattern.\n\nReturns a list of these parts.\n\nThe `pattern` may be a string, a list of strings, a regular expression, or a\ncompiled pattern.\n\nThe string is split into as many parts as possible by\ndefault, but can be controlled via the `:parts` option.\n\nEmpty strings are only removed from the result if the\n`:trim` option is set to `true`.\n\nWhen the pattern used is a regular expression, the string is\nsplit using `Regex.split/3`.\n\n## Options\n\n  * `:parts` (positive integer or `:infinity`) - the string\n    is split into at most as many parts as this option specifies.\n    If `:infinity`, the string will be split into all possible\n    parts. Defaults to `:infinity`.\n\n  * `:trim` (boolean) - if `true`, empty strings are removed from\n    the resulting list.\n\nThis function also accepts all options accepted by `Regex.split/3`\nif `pattern` is a regular expression.\n\n## Examples\n\nSplitting with a string pattern:\n\n    iex> String.split(\"a,b,c\", \",\")\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", \",\", parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", \" \", trim: true)\n    [\"a\", \"b\", \"c\"]\n\nA list of patterns:\n\n    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n    [\"1\", \"2\", \"3\", \"4\"]\n\nA regular expression:\n\n    iex> String.split(\"a,b,c\", ~r{,})\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n    [\"a\", \"b,c\"]\n\n    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", ~r{b}, include_captures: true)\n    [\"a\", \"b\", \"c\"]\n\nA compiled pattern:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.split(\"1,2 3,4\", pattern)\n    [\"1\", \"2\", \"3\", \"4\"]\n\nSplitting on empty string returns graphemes:\n\n    iex> String.split(\"abc\", \"\")\n    [\"\", \"a\", \"b\", \"c\", \"\"]\n\n    iex> String.split(\"abc\", \"\", trim: true)\n    [\"a\", \"b\", \"c\"]\n\n    iex> String.split(\"abc\", \"\", parts: 1)\n    [\"abc\"]\n\n    iex> String.split(\"abc\", \"\", parts: 3)\n    [\"\", \"a\", \"bc\"]\n\nBe aware that this function can split within or across grapheme boundaries.\nFor example, take the grapheme \"é\" which is made of the characters\n\"e\" and the acute accent. The following will split the string into two parts:\n\n    iex> String.split(String.normalize(\"é\", :nfd), \"e\")\n    [\"\", \"́\"]\n\nHowever, if \"é\" is represented by the single character \"e with acute\"\naccent, then it will split the string into just one part:\n\n    iex> String.split(String.normalize(\"é\", :nfc), \"e\")\n    [\"é\"]\n\n","title":"String.split/3","type":"function"},{"doc":"Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string. The offset is capped to the length of the string. Returns a tuple with two elements. Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use Kernel.binary_part/3 instead. Examples iex&gt; String . split_at ( &quot;sweetelixir&quot; , 5 ) { &quot;sweet&quot; , &quot;elixir&quot; } iex&gt; String . split_at ( &quot;sweetelixir&quot; , - 6 ) { &quot;sweet&quot; , &quot;elixir&quot; } iex&gt; String . split_at ( &quot;abc&quot; , 0 ) { &quot;&quot; , &quot;abc&quot; } iex&gt; String . split_at ( &quot;abc&quot; , 1000 ) { &quot;abc&quot; , &quot;&quot; } iex&gt; String . split_at ( &quot;abc&quot; , - 1000 ) { &quot;&quot; , &quot;abc&quot; }","ref":"String.html#split_at/2","source_doc":"Splits a string into two at the specified offset. When the offset given is\nnegative, location is counted from the end of the string.\n\nThe offset is capped to the length of the string. Returns a tuple with\ntwo elements.\n\nNote: keep in mind this function splits on graphemes and for such it\nhas to linearly traverse the string. If you want to split a string or\na binary based on the number of bytes, use `Kernel.binary_part/3`\ninstead.\n\n## Examples\n\n    iex> String.split_at(\"sweetelixir\", 5)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"sweetelixir\", -6)\n    {\"sweet\", \"elixir\"}\n\n    iex> String.split_at(\"abc\", 0)\n    {\"\", \"abc\"}\n\n    iex> String.split_at(\"abc\", 1000)\n    {\"abc\", \"\"}\n\n    iex> String.split_at(\"abc\", -1000)\n    {\"\", \"abc\"}\n\n","title":"String.split_at/2","type":"function"},{"doc":"Returns an enumerable that splits a string on demand. This is in contrast to split/3 which splits the entire string upfront. This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does. Options :trim - when true , does not emit empty patterns Examples iex&gt; String . splitter ( &quot;1,2 3,4 5,6 7,8,...,99999&quot; , [ &quot; &quot; , &quot;,&quot; ] ) |&gt; Enum . take ( 4 ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ] iex&gt; String . splitter ( &quot;abcd&quot; , &quot;&quot; ) |&gt; Enum . take ( 10 ) [ &quot;&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;&quot; ] iex&gt; String . splitter ( &quot;abcd&quot; , &quot;&quot; , trim : true ) |&gt; Enum . take ( 10 ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] A compiled pattern can also be given: iex&gt; pattern = :binary . compile_pattern ( [ &quot; &quot; , &quot;,&quot; ] ) iex&gt; String . splitter ( &quot;1,2 3,4 5,6 7,8,...,99999&quot; , pattern ) |&gt; Enum . take ( 4 ) [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot; ]","ref":"String.html#splitter/3","source_doc":"Returns an enumerable that splits a string on demand.\n\nThis is in contrast to `split/3` which splits the\nentire string upfront.\n\nThis function does not support regular expressions\nby design. When using regular expressions, it is often\nmore efficient to have the regular expressions traverse\nthe string at once than in parts, like this function does.\n\n## Options\n\n  * :trim - when `true`, does not emit empty patterns\n\n## Examples\n\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", [\" \", \",\"]) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n    iex> String.splitter(\"abcd\", \"\") |> Enum.take(10)\n    [\"\", \"a\", \"b\", \"c\", \"d\", \"\"]\n\n    iex> String.splitter(\"abcd\", \"\", trim: true) |> Enum.take(10)\n    [\"a\", \"b\", \"c\", \"d\"]\n\nA compiled pattern can also be given:\n\n    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n    iex> String.splitter(\"1,2 3,4 5,6 7,8,...,99999\", pattern) |> Enum.take(4)\n    [\"1\", \"2\", \"3\", \"4\"]\n\n","title":"String.splitter/3","type":"function"},{"doc":"Returns true if string starts with any of the prefixes given. prefix can be either a string, a list of strings, or a compiled pattern. Examples iex&gt; String . starts_with? ( &quot;elixir&quot; , &quot;eli&quot; ) true iex&gt; String . starts_with? ( &quot;elixir&quot; , [ &quot;erlang&quot; , &quot;elixir&quot; ] ) true iex&gt; String . starts_with? ( &quot;elixir&quot; , [ &quot;erlang&quot; , &quot;ruby&quot; ] ) false An empty string will always match: iex&gt; String . starts_with? ( &quot;elixir&quot; , &quot;&quot; ) true iex&gt; String . starts_with? ( &quot;elixir&quot; , [ &quot;&quot; , &quot;other&quot; ] ) true An empty list will never match: iex&gt; String . starts_with? ( &quot;elixir&quot; , [ ] ) false iex&gt; String . starts_with? ( &quot;&quot; , [ ] ) false","ref":"String.html#starts_with?/2","source_doc":"Returns `true` if `string` starts with any of the prefixes given.\n\n`prefix` can be either a string, a list of strings, or a compiled\npattern.\n\n## Examples\n\n    iex> String.starts_with?(\"elixir\", \"eli\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"elixir\"])\n    true\n    iex> String.starts_with?(\"elixir\", [\"erlang\", \"ruby\"])\n    false\n\nAn empty string will always match:\n\n    iex> String.starts_with?(\"elixir\", \"\")\n    true\n    iex> String.starts_with?(\"elixir\", [\"\", \"other\"])\n    true\n\nAn empty list will never match:\n\n    iex> String.starts_with?(\"elixir\", [])\n    false\n\n    iex> String.starts_with?(\"\", [])\n    false\n\n","title":"String.starts_with?/2","type":"function"},{"doc":"Converts a string to an existing atom or creates a new one. Warning: this function creates atoms dynamically and atoms are not garbage-collected. Therefore, string should not be an untrusted value, such as input received from a socket or during a web request. Consider using to_existing_atom/1 instead. By default, the maximum number of atoms is 1_048_576 . This limit can be raised or lowered using the VM option +t . The maximum atom size is of 255 Unicode code points. Inlined by the compiler. Examples iex&gt; String . to_atom ( &quot;my_atom&quot; ) :my_atom","ref":"String.html#to_atom/1","source_doc":"Converts a string to an existing atom or creates a new one.\n\nWarning: this function creates atoms dynamically and atoms are\nnot garbage-collected. Therefore, `string` should not be an\nuntrusted value, such as input received from a socket or during\na web request. Consider using `to_existing_atom/1` instead.\n\nBy default, the maximum number of atoms is `1_048_576`. This limit\ncan be raised or lowered using the VM option `+t`.\n\nThe maximum atom size is of 255 Unicode code points.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_atom(\"my_atom\")\n    :my_atom\n\n","title":"String.to_atom/1","type":"function"},{"doc":"Converts a string into a charlist. Specifically, this function takes a UTF-8 encoded binary and returns a list of its integer code points. It is similar to codepoints/1 except that the latter returns a list of code points as strings. In case you need to work with bytes, take a look at the :binary module . Examples iex&gt; String . to_charlist ( &quot;foo&quot; ) ~c&quot;foo&quot;","ref":"String.html#to_charlist/1","source_doc":"Converts a string into a charlist.\n\nSpecifically, this function takes a UTF-8 encoded binary and returns a list of its integer\ncode points. It is similar to `codepoints/1` except that the latter returns a list of code points as\nstrings.\n\nIn case you need to work with bytes, take a look at the\n[`:binary` module](`:binary`).\n\n## Examples\n\n    iex> String.to_charlist(\"foo\")\n    ~c\"foo\"\n\n","title":"String.to_charlist/1","type":"function"},{"doc":"Converts a string to an existing atom or raises if the atom does not exist. The maximum atom size is of 255 Unicode code points. Raises an ArgumentError if the atom does not exist. Inlined by the compiler. Atoms and modules Since Elixir is a compiled language, the atoms defined in a module will only exist after said module is loaded, which typically happens whenever a function in the module is executed. Therefore, it is generally recommended to call String.to_existing_atom/1 only to convert atoms defined within the module making the function call to to_existing_atom/1 . To create a module name itself from a string safely, it is recommended to use Module.safe_concat/1 . Examples iex&gt; _ = :my_atom iex&gt; String . to_existing_atom ( &quot;my_atom&quot; ) :my_atom","ref":"String.html#to_existing_atom/1","source_doc":"Converts a string to an existing atom or raises if\nthe atom does not exist.\n\nThe maximum atom size is of 255 Unicode code points.\nRaises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `String.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n>\n> To create a module name itself from a string safely,\n> it is recommended to use `Module.safe_concat/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> String.to_existing_atom(\"my_atom\")\n    :my_atom\n\n","title":"String.to_existing_atom/1","type":"function"},{"doc":"Returns a float whose text representation is string . string must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then Float.parse/1 should be used. Otherwise, an ArgumentError will be raised. Inlined by the compiler. Examples iex&gt; String . to_float ( &quot;2.2017764e+0&quot; ) 2.2017764 iex&gt; String . to_float ( &quot;3.0&quot; ) 3.0 String . to_float ( &quot;3&quot; ) ** (ArgumentError) argument error","ref":"String.html#to_float/1","source_doc":"Returns a float whose text representation is `string`.\n\n`string` must be the string representation of a float including a decimal point.\nIn order to parse a string without decimal point as a float then `Float.parse/1`\nshould be used. Otherwise, an `ArgumentError` will be raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_float(\"2.2017764e+0\")\n    2.2017764\n\n    iex> String.to_float(\"3.0\")\n    3.0\n\n    String.to_float(\"3\")\n    ** (ArgumentError) argument error\n\n","title":"String.to_float/1","type":"function"},{"doc":"Returns an integer whose text representation is string . string must be the string representation of an integer. Otherwise, an ArgumentError will be raised. If you want to parse a string that may contain an ill-formatted integer, use Integer.parse/1 . Inlined by the compiler. Examples iex&gt; String . to_integer ( &quot;123&quot; ) 123 Passing a string that does not represent an integer leads to an error: String . to_integer ( &quot;invalid data&quot; ) ** (ArgumentError) argument error","ref":"String.html#to_integer/1","source_doc":"Returns an integer whose text representation is `string`.\n\n`string` must be the string representation of an integer.\nOtherwise, an `ArgumentError` will be raised. If you want\nto parse a string that may contain an ill-formatted integer,\nuse `Integer.parse/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"123\")\n    123\n\nPassing a string that does not represent an integer leads to an error:\n\n    String.to_integer(\"invalid data\")\n    ** (ArgumentError) argument error\n\n","title":"String.to_integer/1","type":"function"},{"doc":"Returns an integer whose text representation is string in base base . Inlined by the compiler. Examples iex&gt; String . to_integer ( &quot;3FF&quot; , 16 ) 1023","ref":"String.html#to_integer/2","source_doc":"Returns an integer whose text representation is `string` in base `base`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> String.to_integer(\"3FF\", 16)\n    1023\n\n","title":"String.to_integer/2","type":"function"},{"doc":"Returns a string where all leading and trailing Unicode whitespaces have been removed. Examples iex&gt; String . trim ( &quot; \\n abc \\n &quot; ) &quot;abc&quot;","ref":"String.html#trim/1","source_doc":"Returns a string where all leading and trailing Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim(\"\\n  abc\\n  \")\n    \"abc\"\n\n","title":"String.trim/1","type":"function"},{"doc":"Returns a string where all leading and trailing to_trim characters have been removed. Examples iex&gt; String . trim ( &quot;a abc a&quot; , &quot;a&quot; ) &quot; abc &quot;","ref":"String.html#trim/2","source_doc":"Returns a string where all leading and trailing `to_trim` characters have been\nremoved.\n\n## Examples\n\n    iex> String.trim(\"a  abc  a\", \"a\")\n    \"  abc  \"\n\n","title":"String.trim/2","type":"function"},{"doc":"Returns a string where all leading Unicode whitespaces have been removed. Examples iex&gt; String . trim_leading ( &quot; \\n abc &quot; ) &quot;abc &quot;","ref":"String.html#trim_leading/1","source_doc":"Returns a string where all leading Unicode whitespaces\nhave been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"\\n  abc   \")\n    \"abc   \"\n\n","title":"String.trim_leading/1","type":"function"},{"doc":"Returns a string where all leading to_trim characters have been removed. Examples iex&gt; String . trim_leading ( &quot;__ abc _&quot; , &quot;_&quot; ) &quot; abc _&quot; iex&gt; String . trim_leading ( &quot;1 abc&quot; , &quot;11&quot; ) &quot;1 abc&quot;","ref":"String.html#trim_leading/2","source_doc":"Returns a string where all leading `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_leading(\"__ abc _\", \"_\")\n    \" abc _\"\n\n    iex> String.trim_leading(\"1 abc\", \"11\")\n    \"1 abc\"\n\n","title":"String.trim_leading/2","type":"function"},{"doc":"Returns a string where all trailing Unicode whitespaces has been removed. Examples iex&gt; String . trim_trailing ( &quot; abc \\n &quot; ) &quot; abc&quot;","ref":"String.html#trim_trailing/1","source_doc":"Returns a string where all trailing Unicode whitespaces\nhas been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"   abc\\n  \")\n    \"   abc\"\n\n","title":"String.trim_trailing/1","type":"function"},{"doc":"Returns a string where all trailing to_trim characters have been removed. Examples iex&gt; String . trim_trailing ( &quot;_ abc __&quot; , &quot;_&quot; ) &quot;_ abc &quot; iex&gt; String . trim_trailing ( &quot;abc 1&quot; , &quot;11&quot; ) &quot;abc 1&quot;","ref":"String.html#trim_trailing/2","source_doc":"Returns a string where all trailing `to_trim` characters have been removed.\n\n## Examples\n\n    iex> String.trim_trailing(\"_ abc __\", \"_\")\n    \"_ abc \"\n\n    iex> String.trim_trailing(\"abc 1\", \"11\")\n    \"abc 1\"\n\n","title":"String.trim_trailing/2","type":"function"},{"doc":"Converts all characters in the given string to uppercase according to mode . mode may be :default , :ascii , :greek or :turkic . The :default mode considers all non-conditional transformations outlined in the Unicode standard. :ascii uppercases only the letters a to z. :greek includes the context sensitive mappings found in Greek. :turkic properly handles the letter i with the dotless variant. Examples iex&gt; String . upcase ( &quot;abcd&quot; ) &quot;ABCD&quot; iex&gt; String . upcase ( &quot;ab 123 xpto&quot; ) &quot;AB 123 XPTO&quot; iex&gt; String . upcase ( &quot;olá&quot; ) &quot;OLÁ&quot; The :ascii mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters: iex&gt; String . upcase ( &quot;olá&quot; , :ascii ) &quot;OLá&quot; And :turkic properly handles the letter i with the dotless variant: iex&gt; String . upcase ( &quot;ıi&quot; ) &quot;II&quot; iex&gt; String . upcase ( &quot;ıi&quot; , :turkic ) &quot;Iİ&quot;","ref":"String.html#upcase/2","source_doc":"Converts all characters in the given string to uppercase according to `mode`.\n\n`mode` may be `:default`, `:ascii`, `:greek` or `:turkic`. The `:default` mode considers\nall non-conditional transformations outlined in the Unicode standard. `:ascii`\nuppercases only the letters a to z. `:greek` includes the context sensitive\nmappings found in Greek. `:turkic` properly handles the letter i with the dotless variant.\n\n## Examples\n\n    iex> String.upcase(\"abcd\")\n    \"ABCD\"\n\n    iex> String.upcase(\"ab 123 xpto\")\n    \"AB 123 XPTO\"\n\n    iex> String.upcase(\"olá\")\n    \"OLÁ\"\n\nThe `:ascii` mode ignores Unicode characters and provides a more\nperformant implementation when you know the string contains only\nASCII characters:\n\n    iex> String.upcase(\"olá\", :ascii)\n    \"OLá\"\n\nAnd `:turkic` properly handles the letter i with the dotless variant:\n\n    iex> String.upcase(\"ıi\")\n    \"II\"\n\n    iex> String.upcase(\"ıi\", :turkic)\n    \"Iİ\"\n\n","title":"String.upcase/2","type":"function"},{"doc":"Checks whether string contains only valid characters. algorithm may be :default or :fast_ascii . Both algorithms are equivalent from a validation perspective (they will always produce the same output), but :fast_ascii can yield significant performance benefits in specific scenarios. If all of the following conditions are true, you may want to experiment with the :fast_ascii algorithm to see if it yields performance benefits in your specific scenario: You are running Erlang/OTP 26 or newer on a 64 bit platform You expect most of your strings to be longer than ~64 bytes You expect most of your strings to contain mostly ASCII codepoints Note that the :fast_ascii algorithm does not affect correctness, you can expect the output of String.valid?/2 to be the same regardless of algorithm. The only difference to be expected is one of performance, which can be expected to improve roughly linearly in string length compared to the :default algorithm. Examples iex&gt; String . valid? ( &quot;a&quot; ) true iex&gt; String . valid? ( &quot;ø&quot; ) true iex&gt; String . valid? ( &lt;&lt; 0xFFFF :: 16 &gt;&gt; ) false iex&gt; String . valid? ( &lt;&lt; 0xEF , 0xB7 , 0x90 &gt;&gt; ) true iex&gt; String . valid? ( &quot;asd&quot; &lt;&gt; &lt;&lt; 0xFFFF :: 16 &gt;&gt; ) false iex&gt; String . valid? ( &quot;a&quot; , :fast_ascii ) true iex&gt; String . valid? ( 4 ) ** (FunctionClauseError) no function clause matching in String.valid?/2","ref":"String.html#valid?/2","source_doc":"Checks whether `string` contains only valid characters.\n\n`algorithm` may be `:default` or `:fast_ascii`. Both algorithms are equivalent\nfrom a validation perspective (they will always produce the same output), but\n`:fast_ascii` can yield significant performance benefits in specific scenarios.\n\nIf all of the following conditions are true, you may want to experiment with\nthe `:fast_ascii` algorithm to see if it yields performance benefits in your\nspecific scenario:\n\n* You are running Erlang/OTP 26 or newer on a 64 bit platform\n* You expect most of your strings to be longer than ~64 bytes\n* You expect most of your strings to contain mostly ASCII codepoints\n\nNote that the `:fast_ascii` algorithm does not affect correctness, you can\nexpect the output of `String.valid?/2` to be the same regardless of algorithm.\nThe only difference to be expected is one of performance, which can be\nexpected to improve roughly linearly in string length compared to the\n`:default` algorithm.\n\n## Examples\n\n    iex> String.valid?(\"a\")\n    true\n\n    iex> String.valid?(\"ø\")\n    true\n\n    iex> String.valid?(<<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(<<0xEF, 0xB7, 0x90>>)\n    true\n\n    iex> String.valid?(\"asd\" <> <<0xFFFF::16>>)\n    false\n\n    iex> String.valid?(\"a\", :fast_ascii)\n    true\n\n    iex> String.valid?(4)\n    ** (FunctionClauseError) no function clause matching in String.valid?/2\n\n","title":"String.valid?/2","type":"function"},{"doc":"A single Unicode code point encoded in UTF-8. It may be one or more bytes.","ref":"String.html#t:codepoint/0","source_doc":"A single Unicode code point encoded in UTF-8. It may be one or more bytes.","title":"String.codepoint/0","type":"type"},{"doc":"Multiple code points that may be perceived as a single character by readers","ref":"String.html#t:grapheme/0","source_doc":"Multiple code points that may be perceived as a single character by readers","title":"String.grapheme/0","type":"type"},{"doc":"Pattern used in functions like replace/4 and split/3 . It must be one of: a string an empty list a list containing non-empty strings a compiled search pattern created by :binary.compile_pattern/1","ref":"String.html#t:pattern/0","source_doc":"Pattern used in functions like `replace/4` and `split/3`.\n\nIt must be one of:\n\n  * a string\n  * an empty list\n  * a list containing non-empty strings\n  * a compiled search pattern created by `:binary.compile_pattern/1`\n\n","title":"String.pattern/0","type":"type"},{"doc":"A UTF-8 encoded binary. The types String.t() and binary() are equivalent to analysis tools. Although, for those reading the documentation, String.t() implies it is a UTF-8 encoded binary.","ref":"String.html#t:t/0","source_doc":"A UTF-8 encoded binary.\n\nThe types `String.t()` and `binary()` are equivalent to analysis tools.\nAlthough, for those reading the documentation, `String.t()` implies\nit is a UTF-8 encoded binary.\n","title":"String.t/0","type":"type"},{"doc":"A Time struct and functions. The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the new/4 function or using the ~T (see sigil_T/2 ) sigil: iex&gt; ~T[23:00:07.001] ~T[23:00:07.001] Both new/4 and sigil return a struct where the time fields can be accessed directly: iex&gt; time = ~T[23:00:07.001] iex&gt; time . hour 23 iex&gt; time . microsecond { 1000 , 3 } The functions on this module work with the Time struct as well as any struct that contains the same fields as the Time struct, such as NaiveDateTime and DateTime . Such functions expect Calendar.time/0 in their typespecs (instead of t/0 ). Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries. Comparing times Comparisons in Elixir using ==/2 , &gt;/2 , &lt;/2 and similar are structural and based on the Time struct fields. For proper comparison between times, use the compare/2 function. The existence of the compare/2 function in this module also allows using Enum.min/2 and Enum.max/2 functions to get the minimum and maximum time of an Enum . For example: iex&gt; Enum . min ( [ ~T[23:00:07.001] , ~T[10:00:07.001] ] , Time ) ~T[10:00:07.001]","ref":"Time.html","source_doc":"A Time struct and functions.\n\nThe Time struct contains the fields hour, minute, second and microseconds.\nNew times can be built with the `new/4` function or using the\n`~T` (see `sigil_T/2`) sigil:\n\n    iex> ~T[23:00:07.001]\n    ~T[23:00:07.001]\n\nBoth `new/4` and sigil return a struct where the time fields can\nbe accessed directly:\n\n    iex> time = ~T[23:00:07.001]\n    iex> time.hour\n    23\n    iex> time.microsecond\n    {1000, 3}\n\nThe functions on this module work with the `Time` struct as well\nas any struct that contains the same fields as the `Time` struct,\nsuch as `NaiveDateTime` and `DateTime`. Such functions expect\n`t:Calendar.time/0` in their typespecs (instead of `t:t/0`).\n\nDevelopers should avoid creating the Time structs directly\nand instead rely on the functions provided by this module as well\nas the ones in third-party calendar libraries.\n\n## Comparing times\n\nComparisons in Elixir using `==/2`, `>/2`, `</2` and similar are structural\nand based on the `Time` struct fields. For proper comparison between\ntimes, use the `compare/2` function. The existence of the `compare/2`\nfunction in this module also allows using `Enum.min/2` and `Enum.max/2`\nfunctions to get the minimum and maximum time of an `Enum`. For example:\n\n    iex> Enum.min([~T[23:00:07.001], ~T[10:00:07.001]], Time)\n    ~T[10:00:07.001]\n","title":"Time","type":"module"},{"doc":"Adds the amount_to_add of unit s to the given time . Accepts an amount_to_add in any unit . unit can be :hour , :minute , :second or any subsecond precision from System.time_unit/0 . It defaults to :second . Negative values will move backwards in time. This function always consider the unit to be computed according to the Calendar.ISO . Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar. Examples iex&gt; Time . add ( ~T[10:00:00] , 27000 ) ~T[17:30:00] iex&gt; Time . add ( ~T[11:00:00.005] , 2400 ) ~T[11:40:00.005] iex&gt; Time . add ( ~T[00:00:00.000] , 86_399_999 , :millisecond ) ~T[23:59:59.999] Negative values are allowed: iex&gt; Time . add ( ~T[23:00:00] , - 60 ) ~T[22:59:00] Note that the time is cyclic: iex&gt; Time . add ( ~T[17:10:05] , 86400 ) ~T[17:10:05] Hours and minutes are also supported: iex&gt; Time . add ( ~T[17:10:05] , 2 , :hour ) ~T[19:10:05] iex&gt; Time . add ( ~T[17:10:05] , 30 , :minute ) ~T[17:40:05] This operation merges the precision of the time with the given unit: iex&gt; result = Time . add ( ~T[00:29:10] , 21 , :millisecond ) ~T[00:29:10.021] iex&gt; result . microsecond { 21000 , 3 }","ref":"Time.html#add/3","source_doc":"Adds the `amount_to_add` of `unit`s to the given `time`.\n\nAccepts an `amount_to_add` in any `unit`. `unit` can be\n`:hour`, `:minute`, `:second` or any subsecond precision from\n`t:System.time_unit/0`. It defaults to `:second`. Negative values\nwill move backwards in time.\n\nThis function always consider the unit to be computed according\nto the `Calendar.ISO`.\n\nNote the result value represents the time of day, meaning that it is cyclic,\nfor instance, it will never go over 24 hours for the ISO calendar.\n\n## Examples\n\n    iex> Time.add(~T[10:00:00], 27000)\n    ~T[17:30:00]\n    iex> Time.add(~T[11:00:00.005], 2400)\n    ~T[11:40:00.005]\n    iex> Time.add(~T[00:00:00.000], 86_399_999, :millisecond)\n    ~T[23:59:59.999]\n\nNegative values are allowed:\n\n    iex> Time.add(~T[23:00:00], -60)\n    ~T[22:59:00]\n\nNote that the time is cyclic:\n\n    iex> Time.add(~T[17:10:05], 86400)\n    ~T[17:10:05]\n\nHours and minutes are also supported:\n\n    iex> Time.add(~T[17:10:05], 2, :hour)\n    ~T[19:10:05]\n    iex> Time.add(~T[17:10:05], 30, :minute)\n    ~T[17:40:05]\n\nThis operation merges the precision of the time with the given unit:\n\n    iex> result = Time.add(~T[00:29:10], 21, :millisecond)\n    ~T[00:29:10.021]\n    iex> result.microsecond\n    {21000, 3}\n\n","title":"Time.add/3","type":"function"},{"doc":"Returns true if the first time is strictly later than the second. Examples iex&gt; Time . after? ( ~T[16:04:28] , ~T[16:04:16] ) true iex&gt; Time . after? ( ~T[16:04:16] , ~T[16:04:16] ) false iex&gt; Time . after? ( ~T[16:04:16.001] , ~T[16:04:16.01] ) false","ref":"Time.html#after?/2","source_doc":"Returns true if the first time is strictly later than the second.\n\n## Examples\n\n    iex> Time.after?(~T[16:04:28], ~T[16:04:16])\n    true\n    iex> Time.after?(~T[16:04:16], ~T[16:04:16])\n    false\n    iex> Time.after?(~T[16:04:16.001], ~T[16:04:16.01])\n    false\n\n","title":"Time.after?/2","type":"function"},{"doc":"Returns true if the first time is strictly earlier than the second. Examples iex&gt; Time . before? ( ~T[16:04:16] , ~T[16:04:28] ) true iex&gt; Time . before? ( ~T[16:04:16] , ~T[16:04:16] ) false iex&gt; Time . before? ( ~T[16:04:16.01] , ~T[16:04:16.001] ) false","ref":"Time.html#before?/2","source_doc":"Returns true if the first time is strictly earlier than the second.\n\n## Examples\n\n    iex> Time.before?(~T[16:04:16], ~T[16:04:28])\n    true\n    iex> Time.before?(~T[16:04:16], ~T[16:04:16])\n    false\n    iex> Time.before?(~T[16:04:16.01], ~T[16:04:16.001])\n    false\n\n","title":"Time.before?/2","type":"function"},{"doc":"Compares two time structs. Returns :gt if first time is later than the second and :lt for vice versa. If the two times are equal :eq is returned. Examples iex&gt; Time . compare ( ~T[16:04:16] , ~T[16:04:28] ) :lt iex&gt; Time . compare ( ~T[16:04:16] , ~T[16:04:16] ) :eq iex&gt; Time . compare ( ~T[16:04:16.01] , ~T[16:04:16.001] ) :gt This function can also be used to compare across more complex calendar types by considering only the time fields: iex&gt; Time . compare ( ~N[1900-01-01 16:04:16] , ~N[2015-01-01 16:04:16] ) :eq iex&gt; Time . compare ( ~N[2015-01-01 16:04:16] , ~N[2015-01-01 16:04:28] ) :lt iex&gt; Time . compare ( ~N[2015-01-01 16:04:16.01] , ~N[2000-01-01 16:04:16.001] ) :gt","ref":"Time.html#compare/2","source_doc":"Compares two time structs.\n\nReturns `:gt` if first time is later than the second\nand `:lt` for vice versa. If the two times are equal\n`:eq` is returned.\n\n## Examples\n\n    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n    :lt\n    iex> Time.compare(~T[16:04:16], ~T[16:04:16])\n    :eq\n    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n    :gt\n\nThis function can also be used to compare across more\ncomplex calendar types by considering only the time fields:\n\n    iex> Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])\n    :eq\n    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n    :lt\n    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n    :gt\n\n","title":"Time.compare/2","type":"function"},{"doc":"Converts given time to a different calendar. Returns {:ok, time} if the conversion was successful, or {:error, reason} if it was not, for some reason. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Time . convert ( ~T[13:30:15] , Calendar.Holocene ) { :ok , % Time { calendar : Calendar.Holocene , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } } }","ref":"Time.html#convert/2","source_doc":"Converts given `time` to a different calendar.\n\nReturns `{:ok, time}` if the conversion was successful,\nor `{:error, reason}` if it was not, for some reason.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert(~T[13:30:15], Calendar.Holocene)\n    {:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}\n\n","title":"Time.convert/2","type":"function"},{"doc":"Similar to Time.convert/2 , but raises an ArgumentError if the conversion between the two calendars is not possible. Examples Imagine someone implements Calendar.Holocene , a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year: iex&gt; Time . convert! ( ~T[13:30:15] , Calendar.Holocene ) % Time { calendar : Calendar.Holocene , hour : 13 , minute : 30 , second : 15 , microsecond : { 0 , 0 } }","ref":"Time.html#convert!/2","source_doc":"Similar to `Time.convert/2`, but raises an `ArgumentError`\nif the conversion between the two calendars is not possible.\n\n## Examples\n\nImagine someone implements `Calendar.Holocene`, a calendar based on the\nGregorian calendar that adds exactly 10,000 years to the current Gregorian\nyear:\n\n    iex> Time.convert!(~T[13:30:15], Calendar.Holocene)\n    %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}\n\n","title":"Time.convert!/2","type":"function"},{"doc":"Returns the difference between two times, considering only the hour, minute, second and microsecond. As with the compare/2 function both Time structs and other structures containing time can be used. If for instance a NaiveDateTime or DateTime is passed, only the hour, minute, second, and microsecond is considered. Any additional information about a date or time zone is ignored when calculating the difference. The answer can be returned in any :hour , :minute , :second or any subsecond unit available from System.time_unit/0 . If the first time value is earlier than the second, a negative number is returned. The unit is measured according to Calendar.ISO and defaults to :second . Fractional results are not supported and are truncated. Examples iex&gt; Time . diff ( ~T[00:29:12] , ~T[00:29:10] ) 2 # When passing a `NaiveDateTime` the date part is ignored. iex&gt; Time . diff ( ~N[2017-01-01 00:29:12] , ~T[00:29:10] ) 2 # Two `NaiveDateTime` structs could have big differences in the date # but only the time part is considered. iex&gt; Time . diff ( ~N[2017-01-01 00:29:12] , ~N[1900-02-03 00:29:10] ) 2 iex&gt; Time . diff ( ~T[00:29:12] , ~T[00:29:10] , :microsecond ) 2_000_000 iex&gt; Time . diff ( ~T[00:29:10] , ~T[00:29:12] , :microsecond ) - 2_000_000 iex&gt; Time . diff ( ~T[02:29:10] , ~T[00:29:10] , :hour ) 2 iex&gt; Time . diff ( ~T[02:29:10] , ~T[00:29:11] , :hour ) 1","ref":"Time.html#diff/3","source_doc":"Returns the difference between two times, considering only the hour, minute,\nsecond and microsecond.\n\nAs with the `compare/2` function both `Time` structs and other structures\ncontaining time can be used. If for instance a `NaiveDateTime` or `DateTime`\nis passed, only the hour, minute, second, and microsecond is considered. Any\nadditional information about a date or time zone is ignored when calculating\nthe difference.\n\nThe answer can be returned in any `:hour`, `:minute`, `:second` or any\nsubsecond `unit` available from `t:System.time_unit/0`. If the first time\nvalue is earlier than the second, a negative number is returned.\n\nThe unit is measured according to `Calendar.ISO` and defaults to `:second`.\nFractional results are not supported and are truncated.\n\n## Examples\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10])\n    2\n\n    # When passing a `NaiveDateTime` the date part is ignored.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])\n    2\n\n    # Two `NaiveDateTime` structs could have big differences in the date\n    # but only the time part is considered.\n    iex> Time.diff(~N[2017-01-01 00:29:12], ~N[1900-02-03 00:29:10])\n    2\n\n    iex> Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)\n    2_000_000\n    iex> Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)\n    -2_000_000\n\n    iex> Time.diff(~T[02:29:10], ~T[00:29:10], :hour)\n    2\n    iex> Time.diff(~T[02:29:10], ~T[00:29:11], :hour)\n    1\n\n","title":"Time.diff/3","type":"function"},{"doc":"Converts an Erlang time tuple to a Time struct. Examples iex&gt; Time . from_erl ( { 23 , 30 , 15 } , { 5000 , 3 } ) { :ok , ~T[23:30:15.005] } iex&gt; Time . from_erl ( { 24 , 30 , 15 } ) { :error , :invalid_time }","ref":"Time.html#from_erl/3","source_doc":"Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n    {:ok, ~T[23:30:15.005]}\n    iex> Time.from_erl({24, 30, 15})\n    {:error, :invalid_time}\n\n","title":"Time.from_erl/3","type":"function"},{"doc":"Converts an Erlang time tuple to a Time struct. Examples iex&gt; Time . from_erl! ( { 23 , 30 , 15 } ) ~T[23:30:15] iex&gt; Time . from_erl! ( { 23 , 30 , 15 } , { 5000 , 3 } ) ~T[23:30:15.005] iex&gt; Time . from_erl! ( { 24 , 30 , 15 } ) ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time","ref":"Time.html#from_erl!/3","source_doc":"Converts an Erlang time tuple to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_erl!({23, 30, 15})\n    ~T[23:30:15]\n    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n    ~T[23:30:15.005]\n    iex> Time.from_erl!({24, 30, 15})\n    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time\n\n","title":"Time.from_erl!/3","type":"function"},{"doc":"Parses the extended &quot;Local time&quot; format described by ISO 8601:2019 . Time zone offset may be included in the string but they will be simply discarded as such information is not included in times. As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function. Examples iex&gt; Time . from_iso8601 ( &quot;23:50:07&quot; ) { :ok , ~T[23:50:07] } iex&gt; Time . from_iso8601 ( &quot;23:50:07Z&quot; ) { :ok , ~T[23:50:07] } iex&gt; Time . from_iso8601 ( &quot;T23:50:07Z&quot; ) { :ok , ~T[23:50:07] } iex&gt; Time . from_iso8601 ( &quot;23:50:07,0123456&quot; ) { :ok , ~T[23:50:07.012345] } iex&gt; Time . from_iso8601 ( &quot;23:50:07.0123456&quot; ) { :ok , ~T[23:50:07.012345] } iex&gt; Time . from_iso8601 ( &quot;23:50:07.123Z&quot; ) { :ok , ~T[23:50:07.123] } iex&gt; Time . from_iso8601 ( &quot;2015:01:23 23-50-07&quot; ) { :error , :invalid_format } iex&gt; Time . from_iso8601 ( &quot;23:50:07A&quot; ) { :error , :invalid_format } iex&gt; Time . from_iso8601 ( &quot;23:50:07.&quot; ) { :error , :invalid_format } iex&gt; Time . from_iso8601 ( &quot;23:50:61&quot; ) { :error , :invalid_time }","ref":"Time.html#from_iso8601/2","source_doc":"Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nTime zone offset may be included in the string but they will be\nsimply discarded as such information is not included in times.\n\nAs specified in the standard, the separator \"T\" may be omitted if\ndesired as there is no ambiguity within this function.\n\n## Examples\n\n    iex> Time.from_iso8601(\"23:50:07\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n    iex> Time.from_iso8601(\"T23:50:07Z\")\n    {:ok, ~T[23:50:07]}\n\n    iex> Time.from_iso8601(\"23:50:07,0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.0123456\")\n    {:ok, ~T[23:50:07.012345]}\n    iex> Time.from_iso8601(\"23:50:07.123Z\")\n    {:ok, ~T[23:50:07.123]}\n\n    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07A\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:07.\")\n    {:error, :invalid_format}\n    iex> Time.from_iso8601(\"23:50:61\")\n    {:error, :invalid_time}\n\n","title":"Time.from_iso8601/2","type":"function"},{"doc":"Parses the extended &quot;Local time&quot; format described by ISO 8601:2019 . Raises if the format is invalid. Examples iex&gt; Time . from_iso8601! ( &quot;23:50:07,123Z&quot; ) ~T[23:50:07.123] iex&gt; Time . from_iso8601! ( &quot;23:50:07.123Z&quot; ) ~T[23:50:07.123] iex&gt; Time . from_iso8601! ( &quot;2015:01:23 23-50-07&quot; ) ** (ArgumentError) cannot parse &quot;2015:01:23 23-50-07&quot; as time, reason: :invalid_format","ref":"Time.html#from_iso8601!/2","source_doc":"Parses the extended \"Local time\" format described by\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nRaises if the format is invalid.\n\n## Examples\n\n    iex> Time.from_iso8601!(\"23:50:07,123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n    ~T[23:50:07.123]\n    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format\n\n","title":"Time.from_iso8601!/2","type":"function"},{"doc":"Converts a number of seconds after midnight to a Time struct. Examples iex&gt; Time . from_seconds_after_midnight ( 10_000 ) ~T[02:46:40] iex&gt; Time . from_seconds_after_midnight ( 30_000 , { 5000 , 3 } ) ~T[08:20:00.005] iex&gt; Time . from_seconds_after_midnight ( - 1 ) ~T[23:59:59] iex&gt; Time . from_seconds_after_midnight ( 100_000 ) ~T[03:46:40]","ref":"Time.html#from_seconds_after_midnight/3","source_doc":"Converts a number of seconds after midnight to a `Time` struct.\n\n## Examples\n\n    iex> Time.from_seconds_after_midnight(10_000)\n    ~T[02:46:40]\n    iex> Time.from_seconds_after_midnight(30_000, {5000, 3})\n    ~T[08:20:00.005]\n    iex> Time.from_seconds_after_midnight(-1)\n    ~T[23:59:59]\n    iex> Time.from_seconds_after_midnight(100_000)\n    ~T[03:46:40]\n\n","title":"Time.from_seconds_after_midnight/3","type":"function"},{"doc":"Builds a new time. Expects all values to be integers. Returns {:ok, time} if each entry fits its appropriate range, returns {:error, reason} otherwise. Microseconds can also be given with a precision, which must be an integer between 0 and 6. The built-in calendar does not support leap seconds. Examples iex&gt; Time . new ( 0 , 0 , 0 , 0 ) { :ok , ~T[00:00:00.000000] } iex&gt; Time . new ( 23 , 59 , 59 , 999_999 ) { :ok , ~T[23:59:59.999999] } iex&gt; Time . new ( 24 , 59 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; Time . new ( 23 , 60 , 59 , 999_999 ) { :error , :invalid_time } iex&gt; Time . new ( 23 , 59 , 60 , 999_999 ) { :error , :invalid_time } iex&gt; Time . new ( 23 , 59 , 59 , 1_000_000 ) { :error , :invalid_time } # Invalid precision Time . new ( 23 , 59 , 59 , { 999_999 , 10 } ) { :error , :invalid_time }","ref":"Time.html#new/5","source_doc":"Builds a new time.\n\nExpects all values to be integers. Returns `{:ok, time}` if each\nentry fits its appropriate range, returns `{:error, reason}` otherwise.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new(0, 0, 0, 0)\n    {:ok, ~T[00:00:00.000000]}\n    iex> Time.new(23, 59, 59, 999_999)\n    {:ok, ~T[23:59:59.999999]}\n\n    iex> Time.new(24, 59, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 60, 59, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 60, 999_999)\n    {:error, :invalid_time}\n    iex> Time.new(23, 59, 59, 1_000_000)\n    {:error, :invalid_time}\n\n    # Invalid precision\n    Time.new(23, 59, 59, {999_999, 10})\n    {:error, :invalid_time}\n\n","title":"Time.new/5","type":"function"},{"doc":"Builds a new time. Expects all values to be integers. Returns time if each entry fits its appropriate range, raises if the time is invalid. Microseconds can also be given with a precision, which must be an integer between 0 and 6. The built-in calendar does not support leap seconds. Examples iex&gt; Time . new! ( 0 , 0 , 0 , 0 ) ~T[00:00:00.000000] iex&gt; Time . new! ( 23 , 59 , 59 , 999_999 ) ~T[23:59:59.999999] iex&gt; Time . new! ( 24 , 59 , 59 , 999_999 ) ** (ArgumentError) cannot build time, reason: :invalid_time","ref":"Time.html#new!/5","source_doc":"Builds a new time.\n\nExpects all values to be integers. Returns `time` if each\nentry fits its appropriate range, raises if the time is invalid.\n\nMicroseconds can also be given with a precision, which must be an\ninteger between 0 and 6.\n\nThe built-in calendar does not support leap seconds.\n\n## Examples\n\n    iex> Time.new!(0, 0, 0, 0)\n    ~T[00:00:00.000000]\n    iex> Time.new!(23, 59, 59, 999_999)\n    ~T[23:59:59.999999]\n    iex> Time.new!(24, 59, 59, 999_999)\n    ** (ArgumentError) cannot build time, reason: :invalid_time\n","title":"Time.new!/5","type":"function"},{"doc":"Converts given time to an Erlang time tuple. WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds. Examples iex&gt; Time . to_erl ( ~T[23:30:15.999] ) { 23 , 30 , 15 } iex&gt; Time . to_erl ( ~N[2010-04-17 23:30:15.999] ) { 23 , 30 , 15 }","ref":"Time.html#to_erl/1","source_doc":"Converts given `time` to an Erlang time tuple.\n\nWARNING: Loss of precision may occur, as Erlang time tuples\nonly contain hours/minutes/seconds.\n\n## Examples\n\n    iex> Time.to_erl(~T[23:30:15.999])\n    {23, 30, 15}\n\n    iex> Time.to_erl(~N[2010-04-17 23:30:15.999])\n    {23, 30, 15}\n\n","title":"Time.to_erl/1","type":"function"},{"doc":"Converts the given time to ISO 8601:2019 . By default, Time.to_iso8601/2 returns times formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the :basic option. Examples iex&gt; Time . to_iso8601 ( ~T[23:00:13] ) &quot;23:00:13&quot; iex&gt; Time . to_iso8601 ( ~T[23:00:13.001] ) &quot;23:00:13.001&quot; iex&gt; Time . to_iso8601 ( ~T[23:00:13.001] , :basic ) &quot;230013.001&quot; iex&gt; Time . to_iso8601 ( ~N[2010-04-17 23:00:13] ) &quot;23:00:13&quot;","ref":"Time.html#to_iso8601/2","source_doc":"Converts the given time to\n[ISO 8601:2019](https://en.wikipedia.org/wiki/ISO_8601).\n\nBy default, `Time.to_iso8601/2` returns times formatted in the \"extended\"\nformat, for human readability. It also supports the \"basic\" format through\npassing the `:basic` option.\n\n### Examples\n\n    iex> Time.to_iso8601(~T[23:00:13])\n    \"23:00:13\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001])\n    \"23:00:13.001\"\n\n    iex> Time.to_iso8601(~T[23:00:13.001], :basic)\n    \"230013.001\"\n\n    iex> Time.to_iso8601(~N[2010-04-17 23:00:13])\n    \"23:00:13\"\n\n","title":"Time.to_iso8601/2","type":"function"},{"doc":"Converts a Time struct to a number of seconds after midnight. The returned value is a two-element tuple with the number of seconds and microseconds. Examples iex&gt; Time . to_seconds_after_midnight ( ~T[23:30:15] ) { 84615 , 0 } iex&gt; Time . to_seconds_after_midnight ( ~N[2010-04-17 23:30:15.999] ) { 84615 , 999000 }","ref":"Time.html#to_seconds_after_midnight/1","source_doc":"Converts a `Time` struct to a number of seconds after midnight.\n\nThe returned value is a two-element tuple with the number of seconds and microseconds.\n\n## Examples\n\n    iex> Time.to_seconds_after_midnight(~T[23:30:15])\n    {84615, 0}\n    iex> Time.to_seconds_after_midnight(~N[2010-04-17 23:30:15.999])\n    {84615, 999000}\n\n","title":"Time.to_seconds_after_midnight/1","type":"function"},{"doc":"Converts the given time to a string. Examples iex&gt; Time . to_string ( ~T[23:00:00] ) &quot;23:00:00&quot; iex&gt; Time . to_string ( ~T[23:00:00.001] ) &quot;23:00:00.001&quot; iex&gt; Time . to_string ( ~T[23:00:00.123456] ) &quot;23:00:00.123456&quot; iex&gt; Time . to_string ( ~N[2015-01-01 23:00:00.001] ) &quot;23:00:00.001&quot; iex&gt; Time . to_string ( ~N[2015-01-01 23:00:00.123456] ) &quot;23:00:00.123456&quot;","ref":"Time.html#to_string/1","source_doc":"Converts the given `time` to a string.\n\n### Examples\n\n    iex> Time.to_string(~T[23:00:00])\n    \"23:00:00\"\n    iex> Time.to_string(~T[23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~T[23:00:00.123456])\n    \"23:00:00.123456\"\n\n    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n    \"23:00:00.001\"\n    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n    \"23:00:00.123456\"\n\n","title":"Time.to_string/1","type":"function"},{"doc":"Returns the given time with the microsecond field truncated to the given precision ( :microsecond , millisecond or :second ). The given time is returned unchanged if it already has lower precision than the given precision. Examples iex&gt; Time . truncate ( ~T[01:01:01.123456] , :microsecond ) ~T[01:01:01.123456] iex&gt; Time . truncate ( ~T[01:01:01.123456] , :millisecond ) ~T[01:01:01.123] iex&gt; Time . truncate ( ~T[01:01:01.123456] , :second ) ~T[01:01:01]","ref":"Time.html#truncate/2","source_doc":"Returns the given time with the microsecond field truncated to the given\nprecision (`:microsecond`, `millisecond` or `:second`).\n\nThe given time is returned unchanged if it already has lower precision than\nthe given precision.\n\n## Examples\n\n    iex> Time.truncate(~T[01:01:01.123456], :microsecond)\n    ~T[01:01:01.123456]\n\n    iex> Time.truncate(~T[01:01:01.123456], :millisecond)\n    ~T[01:01:01.123]\n\n    iex> Time.truncate(~T[01:01:01.123456], :second)\n    ~T[01:01:01]\n\n","title":"Time.truncate/2","type":"function"},{"doc":"Returns the current time in UTC. Examples iex&gt; time = Time . utc_now ( ) iex&gt; time . hour &gt;= 0 true","ref":"Time.html#utc_now/1","source_doc":"Returns the current time in UTC.\n\n## Examples\n\n    iex> time = Time.utc_now()\n    iex> time.hour >= 0\n    true\n\n","title":"Time.utc_now/1","type":"function"},{"doc":"","ref":"Time.html#t:t/0","source_doc":false,"title":"Time.t/0","type":"type"},{"doc":"Functions for working with tuples. Please note the following functions for tuples are found in Kernel : elem/2 - accesses a tuple by index put_elem/3 - inserts a value into a tuple by index tuple_size/1 - gets the number of elements in a tuple Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. Enum functions do not work on tuples. Tuples are denoted with curly braces: iex&gt; { } { } iex&gt; { 1 , :two , &quot;three&quot; } { 1 , :two , &quot;three&quot; } A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals. Tuples are typically used either when a function has multiple return values or for error handling. File.read/1 returns {:ok, contents} if reading the given file is successful, or else {:error, reason} such as when the file does not exist. The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple: tuple = { :ok , :example } # Avoid result = Tuple . insert_at ( tuple , 2 , %{ } ) # Prefer { :ok , atom } = tuple result = { :ok , atom , %{ } }","ref":"Tuple.html","source_doc":"Functions for working with tuples.\n\nPlease note the following functions for tuples are found in `Kernel`:\n\n  * `elem/2` - accesses a tuple by index\n  * `put_elem/3` - inserts a value into a tuple by index\n  * `tuple_size/1` - gets the number of elements in a tuple\n\nTuples are intended as fixed-size containers for multiple elements.\nTo manipulate a collection of elements, use a list instead. `Enum`\nfunctions do not work on tuples.\n\nTuples are denoted with curly braces:\n\n    iex> {}\n    {}\n    iex> {1, :two, \"three\"}\n    {1, :two, \"three\"}\n\nA tuple may contain elements of different types, which are stored\ncontiguously in memory. Accessing any element takes constant time,\nbut modifying a tuple, which produces a shallow copy, takes linear time.\nTuples are good for reading data while lists are better for traversals.\n\nTuples are typically used either when a function has multiple return values\nor for error handling. `File.read/1` returns `{:ok, contents}` if reading\nthe given file is successful, or else `{:error, reason}` such as when\nthe file does not exist.\n\nThe functions in this module that add and remove elements from tuples are\nrarely used in practice, as they typically imply tuples are being used as\ncollections. To append to a tuple, it is preferable to extract the elements\nfrom the old tuple with pattern matching, and then create a new tuple:\n\n    tuple = {:ok, :example}\n\n    # Avoid\n    result = Tuple.insert_at(tuple, 2, %{})\n\n    # Prefer\n    {:ok, atom} = tuple\n    result = {:ok, atom, %{}}\n\n","title":"Tuple","type":"module"},{"doc":"Inserts an element at the end of a tuple. Returns a new tuple with the element appended at the end, and contains the elements in tuple followed by value as the last element. Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar } iex&gt; Tuple . append ( tuple , :baz ) { :foo , :bar , :baz }","ref":"Tuple.html#append/2","source_doc":"Inserts an element at the end of a tuple.\n\nReturns a new tuple with the element appended at the end, and contains\nthe elements in `tuple` followed by `value` as the last element.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar}\n    iex> Tuple.append(tuple, :baz)\n    {:foo, :bar, :baz}\n\n","title":"Tuple.append/2","type":"function"},{"doc":"Removes an element from a tuple. Deletes the element at the given index from tuple . Raises an ArgumentError if index is negative or greater than or equal to the length of tuple . Index is zero-based. Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar , :baz } iex&gt; Tuple . delete_at ( tuple , 0 ) { :bar , :baz }","ref":"Tuple.html#delete_at/2","source_doc":"Removes an element from a tuple.\n\nDeletes the element at the given `index` from `tuple`.\nRaises an `ArgumentError` if `index` is negative or greater than\nor equal to the length of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.delete_at(tuple, 0)\n    {:bar, :baz}\n\n","title":"Tuple.delete_at/2","type":"function"},{"doc":"Creates a new tuple. Creates a tuple of size containing the given data at every position. Inlined by the compiler. Examples iex&gt; Tuple . duplicate ( :hello , 3 ) { :hello , :hello , :hello }","ref":"Tuple.html#duplicate/2","source_doc":"Creates a new tuple.\n\nCreates a tuple of `size` containing the\ngiven `data` at every position.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Tuple.duplicate(:hello, 3)\n    {:hello, :hello, :hello}\n\n","title":"Tuple.duplicate/2","type":"function"},{"doc":"Inserts an element into a tuple. Inserts value into tuple at the given index . Raises an ArgumentError if index is negative or greater than the length of tuple . Index is zero-based. Inlined by the compiler. Examples iex&gt; tuple = { :bar , :baz } iex&gt; Tuple . insert_at ( tuple , 0 , :foo ) { :foo , :bar , :baz } iex&gt; Tuple . insert_at ( tuple , 2 , :bong ) { :bar , :baz , :bong }","ref":"Tuple.html#insert_at/3","source_doc":"Inserts an element into a tuple.\n\nInserts `value` into `tuple` at the given `index`.\nRaises an `ArgumentError` if `index` is negative or greater than the\nlength of `tuple`. Index is zero-based.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:bar, :baz}\n    iex> Tuple.insert_at(tuple, 0, :foo)\n    {:foo, :bar, :baz}\n    iex> Tuple.insert_at(tuple, 2, :bong)\n    {:bar, :baz, :bong}\n\n","title":"Tuple.insert_at/3","type":"function"},{"doc":"Computes a product of tuple elements. Examples iex&gt; Tuple . product ( { 255 , 255 } ) 65025 iex&gt; Tuple . product ( { 255 , 1.0 } ) 255.0 iex&gt; Tuple . product ( { } ) 1","ref":"Tuple.html#product/1","source_doc":"Computes a product of tuple elements.\n\n## Examples\n\n    iex> Tuple.product({255, 255})\n    65025\n    iex> Tuple.product({255, 1.0})\n    255.0\n    iex> Tuple.product({})\n    1\n","title":"Tuple.product/1","type":"function"},{"doc":"Computes a sum of tuple elements. Examples iex&gt; Tuple . sum ( { 255 , 255 } ) 510 iex&gt; Tuple . sum ( { 255 , 0.0 } ) 255.0 iex&gt; Tuple . sum ( { } ) 0","ref":"Tuple.html#sum/1","source_doc":"Computes a sum of tuple elements.\n\n## Examples\n\n    iex> Tuple.sum({255, 255})\n    510\n    iex> Tuple.sum({255, 0.0})\n    255.0\n    iex> Tuple.sum({})\n    0\n","title":"Tuple.sum/1","type":"function"},{"doc":"Converts a tuple to a list. Returns a new list with all the tuple elements. Inlined by the compiler. Examples iex&gt; tuple = { :foo , :bar , :baz } iex&gt; Tuple . to_list ( tuple ) [ :foo , :bar , :baz ]","ref":"Tuple.html#to_list/1","source_doc":"Converts a tuple to a list.\n\nReturns a new list with all the tuple elements.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> tuple = {:foo, :bar, :baz}\n    iex> Tuple.to_list(tuple)\n    [:foo, :bar, :baz]\n\n","title":"Tuple.to_list/1","type":"function"},{"doc":"Utilities for working with URIs. This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to RFC 3986 .","ref":"URI.html","source_doc":"Utilities for working with URIs.\n\nThis module provides functions for working with URIs (for example, parsing\nURIs or encoding query strings). The functions in this module are implemented\naccording to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n","title":"URI","type":"module"},{"doc":"The URI struct. The fields are defined to match the following URI representation (with field names between brackets): [ scheme ] :// [ userinfo ] @ [ host ] : [ port ] [ path ] ?[ query ] #[fragment] Note the authority field is deprecated. parse/1 will still populate it for backwards compatibility but you should generally avoid setting or getting it.","ref":"URI.html#__struct__/0","source_doc":"The URI struct.\n\nThe fields are defined to match the following URI representation\n(with field names between brackets):\n\n    [scheme]://[userinfo]@[host]:[port][path]?[query]#[fragment]\n\n\nNote the `authority` field is deprecated. `parse/1` will still\npopulate it for backwards compatibility but you should generally\navoid setting or getting it.\n","title":"URI.__struct__/0","type":"function"},{"doc":"Appends path to the given uri . Path must start with / and cannot contain additional URL components like fragments or query strings. This function further assumes the path is valid and it does not contain a query string or fragment parts. Examples iex&gt; URI . append_path ( URI . parse ( &quot;http://example.com/foo/?x=1&quot; ) , &quot;/my-path&quot; ) |&gt; URI . to_string ( ) &quot;http://example.com/foo/my-path?x=1&quot; iex&gt; URI . append_path ( URI . parse ( &quot;http://example.com&quot; ) , &quot;my-path&quot; ) ** (ArgumentError) path must start with &quot;/&quot;, got: &quot;my-path&quot;","ref":"URI.html#append_path/2","source_doc":"Appends `path` to the given `uri`.\n\nPath must start with `/` and cannot contain additional URL components like\nfragments or query strings. This function further assumes the path is valid and\nit does not contain a query string or fragment parts.\n\n## Examples\n\n    iex> URI.append_path(URI.parse(\"http://example.com/foo/?x=1\"), \"/my-path\") |> URI.to_string()\n    \"http://example.com/foo/my-path?x=1\"\n\n    iex> URI.append_path(URI.parse(\"http://example.com\"), \"my-path\")\n    ** (ArgumentError) path must start with \"/\", got: \"my-path\"\n\n","title":"URI.append_path/2","type":"function"},{"doc":"Appends query to the given uri . The given query is not automatically encoded, use encode/2 or encode_www_form/1 . Examples iex&gt; URI . append_query ( URI . parse ( &quot;http://example.com/&quot; ) , &quot;x=1&quot; ) |&gt; URI . to_string ( ) &quot;http://example.com/?x=1&quot; iex&gt; URI . append_query ( URI . parse ( &quot;http://example.com/?x=1&quot; ) , &quot;y=2&quot; ) |&gt; URI . to_string ( ) &quot;http://example.com/?x=1&amp;y=2&quot; iex&gt; URI . append_query ( URI . parse ( &quot;http://example.com/?x=1&quot; ) , &quot;x=2&quot; ) |&gt; URI . to_string ( ) &quot;http://example.com/?x=1&amp;x=2&quot;","ref":"URI.html#append_query/2","source_doc":"Appends `query` to the given `uri`.\n\nThe given `query` is not automatically encoded, use `encode/2` or `encode_www_form/1`.\n\n## Examples\n\n    iex> URI.append_query(URI.parse(\"http://example.com/\"), \"x=1\") |> URI.to_string()\n    \"http://example.com/?x=1\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"y=2\") |> URI.to_string()\n    \"http://example.com/?x=1&y=2\"\n\n    iex> URI.append_query(URI.parse(\"http://example.com/?x=1\"), \"x=2\") |> URI.to_string()\n    \"http://example.com/?x=1&x=2\"\n","title":"URI.append_query/2","type":"function"},{"doc":"Checks if character is a reserved one in a URI. As specified in RFC 3986, section 2.2 , the following characters are reserved: : , / , ? , # , [ , ] , @ , ! , $ , &amp; , ' , ( , ) , * , + , , , ; , = Examples iex&gt; URI . char_reserved? ( ?+ ) true","ref":"URI.html#char_reserved?/1","source_doc":"Checks if `character` is a reserved one in a URI.\n\nAs specified in [RFC 3986, section 2.2](https://tools.ietf.org/html/rfc3986#section-2.2),\nthe following characters are reserved: `:`, `/`, `?`, `#`, `[`, `]`, `@`, `!`, `$`, `&`, `'`, `(`, `)`, `*`, `+`, `,`, `;`, `=`\n\n## Examples\n\n    iex> URI.char_reserved?(?+)\n    true\n\n","title":"URI.char_reserved?/1","type":"function"},{"doc":"Checks if character is allowed unescaped in a URI. This is the default used by URI.encode/2 where both reserved and unreserved characters are kept unescaped. Examples iex&gt; URI . char_unescaped? ( ?{ ) false","ref":"URI.html#char_unescaped?/1","source_doc":"Checks if `character` is allowed unescaped in a URI.\n\nThis is the default used by `URI.encode/2` where both\n[reserved](`char_reserved?/1`) and [unreserved characters](`char_unreserved?/1`)\nare kept unescaped.\n\n## Examples\n\n    iex> URI.char_unescaped?(?{)\n    false\n\n","title":"URI.char_unescaped?/1","type":"function"},{"doc":"Checks if character is an unreserved one in a URI. As specified in RFC 3986, section 2.3 , the following characters are unreserved: Alphanumeric characters: A-Z , a-z , 0-9 ~ , _ , - , . Examples iex&gt; URI . char_unreserved? ( ?_ ) true","ref":"URI.html#char_unreserved?/1","source_doc":"Checks if `character` is an unreserved one in a URI.\n\nAs specified in [RFC 3986, section 2.3](https://tools.ietf.org/html/rfc3986#section-2.3),\nthe following characters are unreserved:\n\n  * Alphanumeric characters: `A-Z`, `a-z`, `0-9`\n  * `~`, `_`, `-`, `.`\n\n## Examples\n\n    iex> URI.char_unreserved?(?_)\n    true\n\n","title":"URI.char_unreserved?/1","type":"function"},{"doc":"Percent-unescapes a URI. Examples iex&gt; URI . decode ( &quot;https%3A%2F%2Felixir-lang.org&quot; ) &quot;https://elixir-lang.org&quot;","ref":"URI.html#decode/1","source_doc":"Percent-unescapes a URI.\n\n## Examples\n\n    iex> URI.decode(\"https%3A%2F%2Felixir-lang.org\")\n    \"https://elixir-lang.org\"\n\n","title":"URI.decode/1","type":"function"},{"doc":"Decodes query into a map. Given a query string in the form of key1=value1&amp;key2=value2... , this function inserts each key-value pair in the query string as one entry in the given map . Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped. You can specify one of the following encoding options: :www_form - (default, since v1.12.0) keys and values are decoded as per decode_www_form/1 . This is the format typically used by browsers on query strings and form data. It decodes &quot;+&quot; as &quot; &quot;. :rfc3986 - (since v1.12.0) keys and values are decoded as per decode/1 . The result is the same as :www_form except for leaving &quot;+&quot; as is in line with RFC 3986 . Encoding defaults to :www_form for backward compatibility. Use query_decoder/1 if you want to iterate over each value manually. Examples iex&gt; URI . decode_query ( &quot;foo=1&amp;bar=2&quot; ) %{ &quot;bar&quot; =&gt; &quot;2&quot; , &quot;foo&quot; =&gt; &quot;1&quot; } iex&gt; URI . decode_query ( &quot;percent=oh+yes%21&quot; , %{ &quot;starting&quot; =&gt; &quot;map&quot; } ) %{ &quot;percent&quot; =&gt; &quot;oh yes!&quot; , &quot;starting&quot; =&gt; &quot;map&quot; } iex&gt; URI . decode_query ( &quot;percent=oh+yes%21&quot; , %{ } , :rfc3986 ) %{ &quot;percent&quot; =&gt; &quot;oh+yes!&quot; }","ref":"URI.html#decode_query/3","source_doc":"Decodes `query` into a map.\n\nGiven a query string in the form of `key1=value1&key2=value2...`, this\nfunction inserts each key-value pair in the query string as one entry in the\ngiven `map`. Keys and values in the resulting map will be binaries. Keys and\nvalues will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\nUse `query_decoder/1` if you want to iterate over each value manually.\n\n## Examples\n\n    iex> URI.decode_query(\"foo=1&bar=2\")\n    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n\n    iex> URI.decode_query(\"percent=oh+yes%21\", %{}, :rfc3986)\n    %{\"percent\" => \"oh+yes!\"}\n\n","title":"URI.decode_query/3","type":"function"},{"doc":"Decodes string as &quot;x-www-form-urlencoded&quot;. Note &quot;x-www-form-urlencoded&quot; is not specified as part of RFC 3986. However, it is a commonly used format to encode query strings and form data by browsers. Examples iex&gt; URI . decode_www_form ( &quot;%3Call+in%2F&quot; ) &quot;&lt;all in/&quot;","ref":"URI.html#decode_www_form/1","source_doc":"Decodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Examples\n\n    iex> URI.decode_www_form(\"%3Call+in%2F\")\n    \"<all in/\"\n\n","title":"URI.decode_www_form/1","type":"function"},{"doc":"Returns the default port for a given scheme . If the scheme is unknown to the URI module, this function returns nil . The default port for any scheme can be configured globally via default_port/2 . Examples iex&gt; URI . default_port ( &quot;ftp&quot; ) 21 iex&gt; URI . default_port ( &quot;ponzi&quot; ) nil","ref":"URI.html#default_port/1","source_doc":"Returns the default port for a given `scheme`.\n\nIf the scheme is unknown to the `URI` module, this function returns\n`nil`. The default port for any scheme can be configured globally\nvia `default_port/2`.\n\n## Examples\n\n    iex> URI.default_port(\"ftp\")\n    21\n\n    iex> URI.default_port(\"ponzi\")\n    nil\n\n","title":"URI.default_port/1","type":"function"},{"doc":"Registers the default port for the given scheme . After this function is called, port will be returned by default_port/1 for the given scheme scheme . Note that this function changes the default port for the given scheme globally , meaning for every application. It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.","ref":"URI.html#default_port/2","source_doc":"Registers the default `port` for the given `scheme`.\n\nAfter this function is called, `port` will be returned by\n`default_port/1` for the given scheme `scheme`. Note that this function\nchanges the default port for the given `scheme` *globally*, meaning for\nevery application.\n\nIt is recommended for this function to be invoked in your\napplication's start callback in case you want to register\nnew URIs.\n","title":"URI.default_port/2","type":"function"},{"doc":"Percent-escapes all characters that require escaping in string . This means reserved characters, such as : and / , and the so-called unreserved characters, which have the same meaning both escaped and unescaped, won't be escaped by default. See encode_www_form/1 if you are interested in escaping reserved characters too. This function also accepts a predicate function as an optional argument. If passed, this function will be called with each byte in string as its argument and should return a truthy value (anything other than false or nil ) if the given byte should be left as is, or return a falsy value ( false or nil ) if the character should be escaped. Defaults to URI.char_unescaped?/1 . Examples iex&gt; URI . encode ( &quot;ftp://s-ite.tld/?value=put it+й&quot; ) &quot;ftp://s-ite.tld/?value=put%20it+%D0%B9&quot; iex&gt; URI . encode ( &quot;a string&quot; , &amp; ( &amp;1 != ?i ) ) &quot;a str%69ng&quot;","ref":"URI.html#encode/2","source_doc":"Percent-escapes all characters that require escaping in `string`.\n\nThis means reserved characters, such as `:` and `/`, and the\nso-called unreserved characters, which have the same meaning both\nescaped and unescaped, won't be escaped by default.\n\nSee `encode_www_form/1` if you are interested in escaping reserved\ncharacters too.\n\nThis function also accepts a `predicate` function as an optional\nargument. If passed, this function will be called with each byte\nin `string` as its argument and should return a truthy value (anything other\nthan `false` or `nil`) if the given byte should be left as is, or return a\nfalsy value (`false` or `nil`) if the character should be escaped. Defaults\nto `URI.char_unescaped?/1`.\n\n## Examples\n\n    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n\n    iex> URI.encode(\"a string\", &(&1 != ?i))\n    \"a str%69ng\"\n\n","title":"URI.encode/2","type":"function"},{"doc":"Encodes enumerable into a query string using encoding . Takes an enumerable that enumerates as a list of two-element tuples (for instance, a map or a keyword list) and returns a string in the form of key1=value1&amp;key2=value2... . Keys and values can be any term that implements the String.Chars protocol with the exception of lists, which are explicitly forbidden. You can specify one of the following encoding strategies: :www_form - (default, since v1.12.0) keys and values are URL encoded as per encode_www_form/1 . This is the format typically used by browsers on query strings and form data. It encodes &quot; &quot; as &quot;+&quot;. :rfc3986 - (since v1.12.0) the same as :www_form except it encodes &quot; &quot; as &quot;%20&quot; according RFC 3986 . This is the best option if you are encoding in a non-browser situation, since encoding spaces as &quot;+&quot; can be ambiguous to URI parsers. This can inadvertently lead to spaces being interpreted as literal plus signs. Encoding defaults to :www_form for backward compatibility. Examples iex&gt; query = %{ &quot;foo&quot; =&gt; 1 , &quot;bar&quot; =&gt; 2 } iex&gt; URI . encode_query ( query ) &quot;bar=2&amp;foo=1&quot; iex&gt; query = %{ &quot;key&quot; =&gt; &quot;value with spaces&quot; } iex&gt; URI . encode_query ( query ) &quot;key=value+with+spaces&quot; iex&gt; query = %{ &quot;key&quot; =&gt; &quot;value with spaces&quot; } iex&gt; URI . encode_query ( query , :rfc3986 ) &quot;key=value%20with%20spaces&quot; iex&gt; URI . encode_query ( %{ key : [ :a , :list ] } ) ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]","ref":"URI.html#encode_query/2","source_doc":"Encodes `enumerable` into a query string using `encoding`.\n\nTakes an enumerable that enumerates as a list of two-element\ntuples (for instance, a map or a keyword list) and returns a string\nin the form of `key1=value1&key2=value2...`.\n\nKeys and values can be any term that implements the `String.Chars`\nprotocol with the exception of lists, which are explicitly forbidden.\n\nYou can specify one of the following `encoding` strategies:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are URL encoded as\n    per `encode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It encodes \" \" as \"+\".\n\n  * `:rfc3986` - (since v1.12.0) the same as `:www_form` except it encodes\n    \" \" as \"%20\" according [RFC 3986](https://tools.ietf.org/html/rfc3986).\n    This is the best option if you are encoding in a non-browser situation,\n    since encoding spaces as \"+\" can be ambiguous to URI parsers. This can\n    inadvertently lead to spaces being interpreted as literal plus signs.\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> query = %{\"foo\" => 1, \"bar\" => 2}\n    iex> URI.encode_query(query)\n    \"bar=2&foo=1\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query)\n    \"key=value+with+spaces\"\n\n    iex> query = %{\"key\" => \"value with spaces\"}\n    iex> URI.encode_query(query, :rfc3986)\n    \"key=value%20with%20spaces\"\n\n    iex> URI.encode_query(%{key: [:a, :list]})\n    ** (ArgumentError) encode_query/2 values cannot be lists, got: [:a, :list]\n\n","title":"URI.encode_query/2","type":"function"},{"doc":"Encodes string as &quot;x-www-form-urlencoded&quot;. Note &quot;x-www-form-urlencoded&quot; is not specified as part of RFC 3986. However, it is a commonly used format to encode query strings and form data by browsers. Example iex&gt; URI . encode_www_form ( &quot;put: it+й&quot; ) &quot;put%3A+it%2B%D0%B9&quot;","ref":"URI.html#encode_www_form/1","source_doc":"Encodes `string` as \"x-www-form-urlencoded\".\n\nNote \"x-www-form-urlencoded\" is not specified as part of\nRFC 3986. However, it is a commonly used format to encode\nquery strings and form data by browsers.\n\n## Example\n\n    iex> URI.encode_www_form(\"put: it+й\")\n    \"put%3A+it%2B%D0%B9\"\n\n","title":"URI.encode_www_form/1","type":"function"},{"doc":"Merges two URIs. This function merges two URIs as per RFC 3986, section 5.2 . Examples iex&gt; URI . merge ( URI . parse ( &quot;http://google.com&quot; ) , &quot;/query&quot; ) |&gt; to_string ( ) &quot;http://google.com/query&quot; iex&gt; URI . merge ( &quot;http://example.com&quot; , &quot;http://google.com&quot; ) |&gt; to_string ( ) &quot;http://google.com&quot;","ref":"URI.html#merge/2","source_doc":"Merges two URIs.\n\nThis function merges two URIs as per\n[RFC 3986, section 5.2](https://tools.ietf.org/html/rfc3986#section-5.2).\n\n## Examples\n\n    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string()\n    \"http://google.com/query\"\n\n    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string()\n    \"http://google.com\"\n\n","title":"URI.merge/2","type":"function"},{"doc":"Creates a new URI struct from a URI or a string. If a %URI{} struct is given, it returns {:ok, uri} . If a string is given, it will parse and validate it. If the string is valid, it returns {:ok, uri} , otherwise it returns {:error, part} with the invalid part of the URI. For parsing URIs without further validation, see parse/1 . This function can parse both absolute and relative URLs. You can check if a URI is absolute or relative by checking if the scheme field is nil or not. When a URI is given without a port, the value returned by URI.default_port/1 for the URI's scheme is used for the :port field. The scheme is also normalized to lowercase. Examples iex&gt; URI . new ( &quot;https://elixir-lang.org/&quot; ) { :ok , % URI { fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : 443 , query : nil , scheme : &quot;https&quot; , userinfo : nil } } iex&gt; URI . new ( &quot;//elixir-lang.org/&quot; ) { :ok , % URI { fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } } iex&gt; URI . new ( &quot;/foo/bar&quot; ) { :ok , % URI { fragment : nil , host : nil , path : &quot;/foo/bar&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } } iex&gt; URI . new ( &quot;foo/bar&quot; ) { :ok , % URI { fragment : nil , host : nil , path : &quot;foo/bar&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } } iex&gt; URI . new ( &quot;//[fe80::]/&quot; ) { :ok , % URI { fragment : nil , host : &quot;fe80::&quot; , path : &quot;/&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } } iex&gt; URI . new ( &quot;https:?query&quot; ) { :ok , % URI { fragment : nil , host : nil , path : nil , port : 443 , query : &quot;query&quot; , scheme : &quot;https&quot; , userinfo : nil } } iex&gt; URI . new ( &quot;/invalid_greater_than_in_path/&gt;&quot; ) { :error , &quot;&gt;&quot; } Giving an existing URI simply returns it wrapped in a tuple: iex&gt; { :ok , uri } = URI . new ( &quot;https://elixir-lang.org/&quot; ) iex&gt; URI . new ( uri ) { :ok , % URI { fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : 443 , query : nil , scheme : &quot;https&quot; , userinfo : nil } }","ref":"URI.html#new/1","source_doc":"Creates a new URI struct from a URI or a string.\n\nIf a `%URI{}` struct is given, it returns `{:ok, uri}`. If a string is\ngiven, it will parse and validate it. If the string is valid, it returns\n`{:ok, uri}`, otherwise it returns `{:error, part}` with the invalid part\nof the URI. For parsing URIs without further validation, see `parse/1`.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\n`nil` or not.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\n## Examples\n\n    iex> URI.new(\"https://elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//elixir-lang.org/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"foo/bar\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"//[fe80::]/\")\n    {:ok, %URI{\n      fragment: nil,\n      host: \"fe80::\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"https:?query\")\n    {:ok, %URI{\n      fragment: nil,\n      host: nil,\n      path: nil,\n      port: 443,\n      query: \"query\",\n      scheme: \"https\",\n      userinfo: nil\n    }}\n\n    iex> URI.new(\"/invalid_greater_than_in_path/>\")\n    {:error, \">\"}\n\nGiving an existing URI simply returns it wrapped in a tuple:\n\n    iex> {:ok, uri} = URI.new(\"https://elixir-lang.org/\")\n    iex> URI.new(uri)\n    {:ok, %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }}\n","title":"URI.new/1","type":"function"},{"doc":"Similar to new/1 but raises URI.Error if an invalid string is given. Examples iex&gt; URI . new! ( &quot;https://elixir-lang.org/&quot; ) % URI { fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : 443 , query : nil , scheme : &quot;https&quot; , userinfo : nil } iex&gt; URI . new! ( &quot;/invalid_greater_than_in_path/&gt;&quot; ) ** (URI.Error) cannot parse due to reason invalid_uri: &quot;&gt;&quot; Giving an existing URI simply returns it: iex&gt; uri = URI . new! ( &quot;https://elixir-lang.org/&quot; ) iex&gt; URI . new! ( uri ) % URI { fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : 443 , query : nil , scheme : &quot;https&quot; , userinfo : nil }","ref":"URI.html#new!/1","source_doc":"Similar to `new/1` but raises `URI.Error` if an invalid string is given.\n\n## Examples\n\n    iex> URI.new!(\"https://elixir-lang.org/\")\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.new!(\"/invalid_greater_than_in_path/>\")\n    ** (URI.Error) cannot parse due to reason invalid_uri: \">\"\n\nGiving an existing URI simply returns it:\n\n    iex> uri = URI.new!(\"https://elixir-lang.org/\")\n    iex> URI.new!(uri)\n    %URI{\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n","title":"URI.new!/1","type":"function"},{"doc":"Parses a URI into its components, without further validation. This function can parse both absolute and relative URLs. You can check if a URI is absolute or relative by checking if the scheme field is nil or not. Furthermore, this function expects both absolute and relative URIs to be well-formed and does not perform any validation. See the &quot;Examples&quot; section below. Use new/1 if you want to validate the URI fields after parsing. When a URI is given without a port, the value returned by URI.default_port/1 for the URI's scheme is used for the :port field. The scheme is also normalized to lowercase. If a %URI{} struct is given to this function, this function returns it unmodified. :authority field This function sets the field :authority for backwards-compatibility reasons but it is deprecated. Examples iex&gt; URI . parse ( &quot;https://elixir-lang.org/&quot; ) % URI { authority : &quot;elixir-lang.org&quot; , fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : 443 , query : nil , scheme : &quot;https&quot; , userinfo : nil } iex&gt; URI . parse ( &quot;//elixir-lang.org/&quot; ) % URI { authority : &quot;elixir-lang.org&quot; , fragment : nil , host : &quot;elixir-lang.org&quot; , path : &quot;/&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } iex&gt; URI . parse ( &quot;/foo/bar&quot; ) % URI { fragment : nil , host : nil , path : &quot;/foo/bar&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } iex&gt; URI . parse ( &quot;foo/bar&quot; ) % URI { fragment : nil , host : nil , path : &quot;foo/bar&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } In contrast to URI.new/1 , this function will parse poorly-formed URIs, for example: iex&gt; URI . parse ( &quot;/invalid_greater_than_in_path/&gt;&quot; ) % URI { fragment : nil , host : nil , path : &quot;/invalid_greater_than_in_path/&gt;&quot; , port : nil , query : nil , scheme : nil , userinfo : nil } Another example is a URI with brackets in query strings. It is accepted by parse/1 , it is commonly accepted by browsers, but it will be refused by new/1 : iex&gt; URI . parse ( &quot;/?foo[bar]=baz&quot; ) % URI { fragment : nil , host : nil , path : &quot;/&quot; , port : nil , query : &quot;foo[bar]=baz&quot; , scheme : nil , userinfo : nil }","ref":"URI.html#parse/1","source_doc":"Parses a URI into its components, without further validation.\n\nThis function can parse both absolute and relative URLs. You can check\nif a URI is absolute or relative by checking if the `scheme` field is\nnil or not. Furthermore, this function expects both absolute and\nrelative URIs to be well-formed and does not perform any validation.\nSee the \"Examples\" section below. Use `new/1` if you want to validate\nthe URI fields after parsing.\n\nWhen a URI is given without a port, the value returned by `URI.default_port/1`\nfor the URI's scheme is used for the `:port` field. The scheme is also\nnormalized to lowercase.\n\nIf a `%URI{}` struct is given to this function, this function returns it\nunmodified.\n\n> #### `:authority` field {: .info}\n>\n> This function sets the field `:authority` for backwards-compatibility reasons\n> but it is deprecated.\n\n## Examples\n\n    iex> URI.parse(\"https://elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: 443,\n      query: nil,\n      scheme: \"https\",\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"//elixir-lang.org/\")\n    %URI{\n      authority: \"elixir-lang.org\",\n      fragment: nil,\n      host: \"elixir-lang.org\",\n      path: \"/\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"/foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\n    iex> URI.parse(\"foo/bar\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"foo/bar\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nIn contrast to `URI.new/1`, this function will parse poorly-formed\nURIs, for example:\n\n    iex> URI.parse(\"/invalid_greater_than_in_path/>\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/invalid_greater_than_in_path/>\",\n      port: nil,\n      query: nil,\n      scheme: nil,\n      userinfo: nil\n    }\n\nAnother example is a URI with brackets in query strings. It is accepted\nby `parse/1`, it is commonly accepted by browsers, but it will be refused\nby `new/1`:\n\n    iex> URI.parse(\"/?foo[bar]=baz\")\n    %URI{\n      fragment: nil,\n      host: nil,\n      path: \"/\",\n      port: nil,\n      query: \"foo[bar]=baz\",\n      scheme: nil,\n      userinfo: nil\n    }\n\n","title":"URI.parse/1","type":"function"},{"doc":"Returns a stream of two-element tuples representing key-value pairs in the given query . Key and value in each tuple will be binaries and will be percent-unescaped. You can specify one of the following encoding options: :www_form - (default, since v1.12.0) keys and values are decoded as per decode_www_form/1 . This is the format typically used by browsers on query strings and form data. It decodes &quot;+&quot; as &quot; &quot;. :rfc3986 - (since v1.12.0) keys and values are decoded as per decode/1 . The result is the same as :www_form except for leaving &quot;+&quot; as is in line with RFC 3986 . Encoding defaults to :www_form for backward compatibility. Examples iex&gt; URI . query_decoder ( &quot;foo=1&amp;bar=2&quot; ) |&gt; Enum . to_list ( ) [ { &quot;foo&quot; , &quot;1&quot; } , { &quot;bar&quot; , &quot;2&quot; } ] iex&gt; URI . query_decoder ( &quot;food=bread%26butter&amp;drinks=tap%20water+please&quot; ) |&gt; Enum . to_list ( ) [ { &quot;food&quot; , &quot;bread&amp;butter&quot; } , { &quot;drinks&quot; , &quot;tap water please&quot; } ] iex&gt; URI . query_decoder ( &quot;food=bread%26butter&amp;drinks=tap%20water+please&quot; , :rfc3986 ) |&gt; Enum . to_list ( ) [ { &quot;food&quot; , &quot;bread&amp;butter&quot; } , { &quot;drinks&quot; , &quot;tap water+please&quot; } ]","ref":"URI.html#query_decoder/2","source_doc":"Returns a stream of two-element tuples representing key-value pairs in the\ngiven `query`.\n\nKey and value in each tuple will be binaries and will be percent-unescaped.\n\nYou can specify one of the following `encoding` options:\n\n  * `:www_form` - (default, since v1.12.0) keys and values are decoded as per\n    `decode_www_form/1`. This is the format typically used by browsers on\n    query strings and form data. It decodes \"+\" as \" \".\n\n  * `:rfc3986` - (since v1.12.0) keys and values are decoded as per\n    `decode/1`. The result is the same as `:www_form` except for leaving \"+\"\n    as is in line with [RFC 3986](https://tools.ietf.org/html/rfc3986).\n\nEncoding defaults to `:www_form` for backward compatibility.\n\n## Examples\n\n    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\") |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water please\"}]\n\n    iex> URI.query_decoder(\"food=bread%26butter&drinks=tap%20water+please\", :rfc3986) |> Enum.to_list()\n    [{\"food\", \"bread&butter\"}, {\"drinks\", \"tap water+please\"}]\n\n","title":"URI.query_decoder/2","type":"function"},{"doc":"Returns the string representation of the given URI struct . Examples iex&gt; uri = URI . parse ( &quot;http://google.com&quot; ) iex&gt; URI . to_string ( uri ) &quot;http://google.com&quot; iex&gt; uri = URI . parse ( &quot;foo://bar.baz&quot; ) iex&gt; URI . to_string ( uri ) &quot;foo://bar.baz&quot;","ref":"URI.html#to_string/1","source_doc":"Returns the string representation of the given [URI struct](`t:t/0`).\n\n## Examples\n\n    iex> uri = URI.parse(\"http://google.com\")\n    iex> URI.to_string(uri)\n    \"http://google.com\"\n\n    iex> uri = URI.parse(\"foo://bar.baz\")\n    iex> URI.to_string(uri)\n    \"foo://bar.baz\"\n\n","title":"URI.to_string/1","type":"function"},{"doc":"","ref":"URI.html#t:authority/0","source_doc":false,"title":"URI.authority/0","type":"opaque"},{"doc":"","ref":"URI.html#t:t/0","source_doc":false,"title":"URI.t/0","type":"type"},{"doc":"Functions for parsing and matching versions against requirements. A version is a string in a specific format or a Version generated after parsing via Version.parse/1 . Although Elixir projects are not required to follow SemVer, they must follow the format outlined on SemVer 2.0 schema . Versions In a nutshell, a version is represented by three numbers: MAJOR.MINOR.PATCH Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens ( [0-9A-Za-z-] ): &quot;1.0.0-alpha.3&quot; Build information can be added by appending a plus sign and a series of dot-separated identifiers immediately following the patch or pre-release version. Identifiers consist of only ASCII alphanumeric characters and hyphens ( [0-9A-Za-z-] ): &quot;1.0.0-alpha.3+20130417140000.amd64&quot; Requirements Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as &gt; , &gt;= , &lt; , &lt;= , and == that work as one would expect, and additionally the special operator ~&gt; described in detail further below. # Only version 2.0.0 &quot;== 2.0.0&quot; # Anything later than 2.0.0 &quot;&gt; 2.0.0&quot; Requirements also support and and or for complex conditions: # 2.0.0 and later until 2.1.0 &quot;&gt;= 2.0.0 and &lt; 2.1.0&quot; Since the example above is such a common requirement, it can be expressed as: &quot;~&gt; 2.0.0&quot; ~&gt; will never include pre-release versions of its upper bound, regardless of the usage of the :allow_pre option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for ~&gt; requirements and their corresponding translations. ~&gt; Translation ~&gt; 2.0.0 &gt;= 2.0.0 and &lt; 2.1.0 ~&gt; 2.1.2 &gt;= 2.1.2 and &lt; 2.2.0 ~&gt; 2.1.3-dev &gt;= 2.1.3-dev and &lt; 2.2.0 ~&gt; 2.0 &gt;= 2.0.0 and &lt; 3.0.0 ~&gt; 2.1 &gt;= 2.1.0 and &lt; 3.0.0 The requirement operand after the ~&gt; is allowed to omit the patch version, allowing us to express ~&gt; 2.1 or ~&gt; 2.1-dev , something that wouldn't be allowed when using the common comparison operators. When the :allow_pre option is set false in Version.match?/3 , the requirement will not match a pre-release version unless the operand is a pre-release version. The default is to always allow pre-releases but note that in Hex :allow_pre is set to false . See the table below for examples. Requirement Version :allow_pre Matches ~&gt; 2.0 2.1.0 true or false true ~&gt; 2.0 3.0.0 true or false false ~&gt; 2.0.0 2.0.5 true or false true ~&gt; 2.0.0 2.1.0 true or false false ~&gt; 2.1.2 2.1.6-dev true true ~&gt; 2.1.2 2.1.6-dev false false ~&gt; 2.1-dev 2.2.0-dev true or false true ~&gt; 2.1.2-dev 2.1.6-dev true or false true &gt;= 2.1.0 2.2.0-dev true true &gt;= 2.1.0 2.2.0-dev false false &gt;= 2.1.0-dev 2.2.6-dev true or false true","ref":"Version.html","source_doc":"Functions for parsing and matching versions against requirements.\n\nA version is a string in a specific format or a `Version`\ngenerated after parsing via `Version.parse/1`.\n\nAlthough Elixir projects are not required to follow SemVer,\nthey must follow the format outlined on [SemVer 2.0 schema](https://semver.org/).\n\n## Versions\n\nIn a nutshell, a version is represented by three numbers:\n\n    MAJOR.MINOR.PATCH\n\nPre-releases are supported by optionally appending a hyphen and a series of\nperiod-separated identifiers immediately following the patch version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3\"\n\nBuild information can be added by appending a plus sign and a series of\ndot-separated identifiers immediately following the patch or pre-release version.\nIdentifiers consist of only ASCII alphanumeric characters and hyphens (`[0-9A-Za-z-]`):\n\n    \"1.0.0-alpha.3+20130417140000.amd64\"\n\n## Requirements\n\nRequirements allow you to specify which versions of a given\ndependency you are willing to work against. Requirements support the common\ncomparison operators such as `>`, `>=`, `<`, `<=`, and `==` that work as one\nwould expect, and additionally the special operator `~>` described in detail\nfurther below.\n\n    # Only version 2.0.0\n    \"== 2.0.0\"\n\n    # Anything later than 2.0.0\n    \"> 2.0.0\"\n\nRequirements also support `and` and `or` for complex conditions:\n\n    # 2.0.0 and later until 2.1.0\n    \">= 2.0.0 and < 2.1.0\"\n\nSince the example above is such a common requirement, it can\nbe expressed as:\n\n    \"~> 2.0.0\"\n\n`~>` will never include pre-release versions of its upper bound,\nregardless of the usage of the `:allow_pre` option, or whether the operand\nis a pre-release version. It can also be used to set an upper bound on only the major\nversion part. See the table below for `~>` requirements and\ntheir corresponding translations.\n\n`~>`           | Translation\n:------------- | :---------------------\n`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n\nThe requirement operand after the `~>` is allowed to omit the patch version,\nallowing us to express `~> 2.1` or `~> 2.1-dev`, something that wouldn't be allowed\nwhen using the common comparison operators.\n\nWhen the `:allow_pre` option is set `false` in `Version.match?/3`, the requirement\nwill not match a pre-release version unless the operand is a pre-release version.\nThe default is to always allow pre-releases but note that in\nHex `:allow_pre` is set to `false`. See the table below for examples.\n\nRequirement    | Version     | `:allow_pre`      | Matches\n:------------- | :---------- | :---------------- | :------\n`~> 2.0`       | `2.1.0`     | `true` or `false` | `true`\n`~> 2.0`       | `3.0.0`     | `true` or `false` | `false`\n`~> 2.0.0`     | `2.0.5`     | `true` or `false` | `true`\n`~> 2.0.0`     | `2.1.0`     | `true` or `false` | `false`\n`~> 2.1.2`     | `2.1.6-dev` | `true`            | `true`\n`~> 2.1.2`     | `2.1.6-dev` | `false`           | `false`\n`~> 2.1-dev`   | `2.2.0-dev` | `true` or `false` | `true`\n`~> 2.1.2-dev` | `2.1.6-dev` | `true` or `false` | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `true`            | `true`\n`>= 2.1.0`     | `2.2.0-dev` | `false`           | `false`\n`>= 2.1.0-dev` | `2.2.6-dev` | `true` or `false` | `true`\n\n","title":"Version","type":"module"},{"doc":"The Version struct. It contains the fields :major , :minor , :patch , :pre , and :build according to SemVer 2.0, where :pre is a list. You can read those fields but you should not create a new Version directly via the struct syntax. Instead use the functions in this module.","ref":"Version.html#__struct__/0","source_doc":"The Version struct.\n\nIt contains the fields `:major`, `:minor`, `:patch`, `:pre`, and\n`:build` according to SemVer 2.0, where `:pre` is a list.\n\nYou can read those fields but you should not create a new `Version`\ndirectly via the struct syntax. Instead use the functions in this\nmodule.\n","title":"Version.__struct__/0","type":"function"},{"doc":"Compares two versions. Returns :gt if the first version is greater than the second one, and :lt for vice versa. If the two versions are equal, :eq is returned. Pre-releases are strictly less than their corresponding release versions. Patch segments are compared lexicographically if they are alphanumeric, and numerically otherwise. Build segments are ignored: if two versions differ only in their build segment they are considered to be equal. Raises a Version.InvalidVersionError exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise. Examples iex&gt; Version . compare ( &quot;2.0.1-alpha1&quot; , &quot;2.0.0&quot; ) :gt iex&gt; Version . compare ( &quot;1.0.0-beta&quot; , &quot;1.0.0-rc1&quot; ) :lt iex&gt; Version . compare ( &quot;1.0.0-10&quot; , &quot;1.0.0-2&quot; ) :gt iex&gt; Version . compare ( &quot;2.0.1+build0&quot; , &quot;2.0.1&quot; ) :eq iex&gt; Version . compare ( &quot;invalid&quot; , &quot;2.0.1&quot; ) ** (Version.InvalidVersionError) invalid version: &quot;invalid&quot;","ref":"Version.html#compare/2","source_doc":"Compares two versions.\n\nReturns `:gt` if the first version is greater than the second one, and `:lt`\nfor vice versa. If the two versions are equal, `:eq` is returned.\n\nPre-releases are strictly less than their corresponding release versions.\n\nPatch segments are compared lexicographically if they are alphanumeric, and\nnumerically otherwise.\n\nBuild segments are ignored: if two versions differ only in their build segment\nthey are considered to be equal.\n\nRaises a `Version.InvalidVersionError` exception if any of the two given\nversions are not parsable. If given an already parsed version this function\nwon't raise.\n\n## Examples\n\n    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n    :gt\n\n    iex> Version.compare(\"1.0.0-beta\", \"1.0.0-rc1\")\n    :lt\n\n    iex> Version.compare(\"1.0.0-10\", \"1.0.0-2\")\n    :gt\n\n    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n    :eq\n\n    iex> Version.compare(\"invalid\", \"2.0.1\")\n    ** (Version.InvalidVersionError) invalid version: \"invalid\"\n\n","title":"Version.compare/2","type":"function"},{"doc":"Compiles a requirement to an internal representation that may optimize matching. The internal representation is opaque.","ref":"Version.html#compile_requirement/1","source_doc":"Compiles a requirement to an internal representation that may optimize matching.\n\nThe internal representation is opaque.\n","title":"Version.compile_requirement/1","type":"function"},{"doc":"Checks if the given version matches the specification. Returns true if version satisfies requirement , false otherwise. Raises a Version.InvalidRequirementError exception if requirement is not parsable, or a Version.InvalidVersionError exception if version is not parsable. If given an already parsed version and requirement this function won't raise. Options :allow_pre (boolean) - when false , pre-release versions will not match unless the operand is a pre-release version. Defaults to true . For examples, please refer to the table above under the &quot;Requirements&quot; section. Examples iex&gt; Version . match? ( &quot;2.0.0&quot; , &quot;&gt; 1.0.0&quot; ) true iex&gt; Version . match? ( &quot;2.0.0&quot; , &quot;== 1.0.0&quot; ) false iex&gt; Version . match? ( &quot;2.1.6-dev&quot; , &quot;~&gt; 2.1.2&quot; ) true iex&gt; Version . match? ( &quot;2.1.6-dev&quot; , &quot;~&gt; 2.1.2&quot; , allow_pre : false ) false iex&gt; Version . match? ( &quot;foo&quot; , &quot;== 1.0.0&quot; ) ** (Version.InvalidVersionError) invalid version: &quot;foo&quot; iex&gt; Version . match? ( &quot;2.0.0&quot; , &quot;== == 1.0.0&quot; ) ** (Version.InvalidRequirementError) invalid requirement: &quot;== == 1.0.0&quot;","ref":"Version.html#match?/3","source_doc":"Checks if the given version matches the specification.\n\nReturns `true` if `version` satisfies `requirement`, `false` otherwise.\nRaises a `Version.InvalidRequirementError` exception if `requirement` is not\nparsable, or a `Version.InvalidVersionError` exception if `version` is not parsable.\nIf given an already parsed version and requirement this function won't\nraise.\n\n## Options\n\n  * `:allow_pre` (boolean) - when `false`, pre-release versions will not match\n    unless the operand is a pre-release version. Defaults to `true`.\n    For examples, please refer to the table above under the \"Requirements\" section.\n\n## Examples\n\n    iex> Version.match?(\"2.0.0\", \"> 1.0.0\")\n    true\n\n    iex> Version.match?(\"2.0.0\", \"== 1.0.0\")\n    false\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\")\n    true\n\n    iex> Version.match?(\"2.1.6-dev\", \"~> 2.1.2\", allow_pre: false)\n    false\n\n    iex> Version.match?(\"foo\", \"== 1.0.0\")\n    ** (Version.InvalidVersionError) invalid version: \"foo\"\n\n    iex> Version.match?(\"2.0.0\", \"== == 1.0.0\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 1.0.0\"\n\n","title":"Version.match?/3","type":"function"},{"doc":"Parses a version string into a Version struct. Examples iex&gt; Version . parse ( &quot;2.0.1-alpha1&quot; ) { :ok , % Version { major : 2 , minor : 0 , patch : 1 , pre : [ &quot;alpha1&quot; ] } } iex&gt; Version . parse ( &quot;2.0-alpha1&quot; ) :error","ref":"Version.html#parse/1","source_doc":"Parses a version string into a `Version` struct.\n\n## Examples\n\n    iex> Version.parse(\"2.0.1-alpha1\")\n    {:ok, %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}}\n\n    iex> Version.parse(\"2.0-alpha1\")\n    :error\n\n","title":"Version.parse/1","type":"function"},{"doc":"Parses a version string into a Version . If string is an invalid version, a Version.InvalidVersionError is raised. Examples iex&gt; Version . parse! ( &quot;2.0.1-alpha1&quot; ) % Version { major : 2 , minor : 0 , patch : 1 , pre : [ &quot;alpha1&quot; ] } iex&gt; Version . parse! ( &quot;2.0-alpha1&quot; ) ** (Version.InvalidVersionError) invalid version: &quot;2.0-alpha1&quot;","ref":"Version.html#parse!/1","source_doc":"Parses a version string into a `Version`.\n\nIf `string` is an invalid version, a `Version.InvalidVersionError` is raised.\n\n## Examples\n\n    iex> Version.parse!(\"2.0.1-alpha1\")\n    %Version{major: 2, minor: 0, patch: 1, pre: [\"alpha1\"]}\n\n    iex> Version.parse!(\"2.0-alpha1\")\n    ** (Version.InvalidVersionError) invalid version: \"2.0-alpha1\"\n\n","title":"Version.parse!/1","type":"function"},{"doc":"Parses a version requirement string into a Version.Requirement struct. Examples iex&gt; { :ok , requirement } = Version . parse_requirement ( &quot;== 2.0.1&quot; ) iex&gt; requirement Version . parse_requirement! ( &quot;== 2.0.1&quot; ) iex&gt; Version . parse_requirement ( &quot;== == 2.0.1&quot; ) :error","ref":"Version.html#parse_requirement/1","source_doc":"Parses a version requirement string into a `Version.Requirement` struct.\n\n## Examples\n\n    iex> {:ok, requirement} = Version.parse_requirement(\"== 2.0.1\")\n    iex> requirement\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement(\"== == 2.0.1\")\n    :error\n\n","title":"Version.parse_requirement/1","type":"function"},{"doc":"Parses a version requirement string into a Version.Requirement struct. If string is an invalid requirement, a Version.InvalidRequirementError is raised. Examples iex&gt; Version . parse_requirement! ( &quot;== 2.0.1&quot; ) Version . parse_requirement! ( &quot;== 2.0.1&quot; ) iex&gt; Version . parse_requirement! ( &quot;== == 2.0.1&quot; ) ** (Version.InvalidRequirementError) invalid requirement: &quot;== == 2.0.1&quot;","ref":"Version.html#parse_requirement!/1","source_doc":"Parses a version requirement string into a `Version.Requirement` struct.\n\nIf `string` is an invalid requirement, a `Version.InvalidRequirementError` is raised.\n\n# Examples\n\n    iex> Version.parse_requirement!(\"== 2.0.1\")\n    Version.parse_requirement!(\"== 2.0.1\")\n\n    iex> Version.parse_requirement!(\"== == 2.0.1\")\n    ** (Version.InvalidRequirementError) invalid requirement: \"== == 2.0.1\"\n\n","title":"Version.parse_requirement!/1","type":"function"},{"doc":"Converts the given version to a string. Examples iex&gt; Version . to_string ( % Version { major : 1 , minor : 2 , patch : 3 } ) &quot;1.2.3&quot; iex&gt; Version . to_string ( Version . parse! ( &quot;1.14.0-rc.0+build0&quot; ) ) &quot;1.14.0-rc.0+build0&quot;","ref":"Version.html#to_string/1","source_doc":"Converts the given version to a string.\n\n### Examples\n\n    iex> Version.to_string(%Version{major: 1, minor: 2, patch: 3})\n    \"1.2.3\"\n    iex> Version.to_string(Version.parse!(\"1.14.0-rc.0+build0\"))\n    \"1.14.0-rc.0+build0\"\n","title":"Version.to_string/1","type":"function"},{"doc":"","ref":"Version.html#t:build/0","source_doc":false,"title":"Version.build/0","type":"type"},{"doc":"","ref":"Version.html#t:major/0","source_doc":false,"title":"Version.major/0","type":"type"},{"doc":"","ref":"Version.html#t:minor/0","source_doc":false,"title":"Version.minor/0","type":"type"},{"doc":"","ref":"Version.html#t:patch/0","source_doc":false,"title":"Version.patch/0","type":"type"},{"doc":"","ref":"Version.html#t:pre/0","source_doc":false,"title":"Version.pre/0","type":"type"},{"doc":"","ref":"Version.html#t:requirement/0","source_doc":false,"title":"Version.requirement/0","type":"type"},{"doc":"","ref":"Version.html#t:t/0","source_doc":false,"title":"Version.t/0","type":"type"},{"doc":"","ref":"Version.html#t:version/0","source_doc":false,"title":"Version.version/0","type":"type"},{"doc":"A struct that holds version requirement information. The struct fields are private and should not be accessed. See the &quot;Requirements&quot; section in the Version module for more information.","ref":"Version.Requirement.html","source_doc":"A struct that holds version requirement information.\n\nThe struct fields are private and should not be accessed.\n\nSee the \"Requirements\" section in the `Version` module\nfor more information.\n","title":"Version.Requirement","type":"module"},{"doc":"","ref":"Version.Requirement.html#t:t/0","source_doc":false,"title":"Version.Requirement.t/0","type":"opaque"},{"doc":"Key-based access to data structures. The Access module defines a behaviour for dynamically accessing keys of any type in a data structure via the data[key] syntax. Access supports keyword lists ( Keyword ) and maps ( Map ) out of the box. Keywords supports only atoms keys, keys for maps can be of any type. Both return nil if the key does not exist: iex&gt; keywords = [ a : 1 , b : 2 ] iex&gt; keywords [ :a ] 1 iex&gt; keywords [ :c ] nil iex&gt; map = %{ a : 1 , b : 2 } iex&gt; map [ :a ] 1 iex&gt; star_ratings = %{ 1.0 =&gt; &quot;★&quot; , 1.5 =&gt; &quot;★☆&quot; , 2.0 =&gt; &quot;★★&quot; } iex&gt; star_ratings [ 1.5 ] &quot;★☆&quot; This syntax is very convenient as it can be nested arbitrarily: iex&gt; keywords = [ a : 1 , b : 2 ] iex&gt; keywords [ :c ] [ :unknown ] nil This works because accessing anything on a nil value, returns nil itself: iex&gt; nil [ :a ] nil The access syntax can also be used with the Kernel.put_in/2 , Kernel.update_in/2 and Kernel.get_and_update_in/2 macros to allow values to be set in nested data structures: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] [ :age ] , 28 ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } Maps and structs While the access syntax is allowed in maps via map[key] , if your map is made of predefined atom keys, you should prefer to access those atom keys with map.key instead of map[key] , as map.key will raise if the key is missing (which is not supposed to happen if the keys are predefined). Similarly, since structs are maps and structs have predefined keys, they only allow the struct.key syntax and they do not allow the struct[key] access syntax. Access.key/1 can also be used to construct dynamic access to structs and maps. In a nutshell, when using put_in/2 and friends: put_in ( struct_or_map . key , :value ) put_in ( keyword_or_map [ :key ] , :value ) When using put_in/3 and friends: put_in ( struct_or_map , [ Access . key! ( :key ) ] , :value ) put_in ( keyword_or_map , [ :key ] , :value ) This covers the dual nature of maps in Elixir, as they can be either for structured data or as a key-value store. See the Map module for more information. Nested data structures Both key-based access syntaxes can be used with the nested update functions and macros in Kernel , such as Kernel.get_in/2 , Kernel.put_in/3 , Kernel.update_in/3 , Kernel.pop_in/2 , and Kernel.get_and_update_in/3 . For example, to update a map inside another map: iex&gt; users = %{ &quot;john&quot; =&gt; %{ age : 27 } , &quot;meg&quot; =&gt; %{ age : 23 } } iex&gt; put_in ( users [ &quot;john&quot; ] . age , 28 ) %{ &quot;john&quot; =&gt; %{ age : 28 } , &quot;meg&quot; =&gt; %{ age : 23 } } This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the Access -related functions and macros in Kernel . For instance, given a user map with the :name and :languages keys, here is how to deeply traverse the map and convert all language names to uppercase: iex&gt; languages = [ ...&gt; %{ name : &quot;elixir&quot; , type : :functional } , ...&gt; %{ name : &quot;c&quot; , type : :procedural } ...&gt; ] iex&gt; user = %{ name : &quot;john&quot; , languages : languages } iex&gt; update_in ( user , [ :languages , Access . all ( ) , :name ] , &amp; String . upcase / 1 ) %{ name : &quot;john&quot; , languages : [ %{ name : &quot;ELIXIR&quot; , type : :functional } , %{ name : &quot;C&quot; , type : :procedural } ] } See the functions key/1 , key!/1 , elem/1 , and all/0 for some of the available accessors.","ref":"Access.html","source_doc":"Key-based access to data structures.\n\nThe `Access` module defines a behaviour for dynamically accessing\nkeys of any type in a data structure via the `data[key]` syntax.\n\n`Access` supports keyword lists (`Keyword`) and maps (`Map`) out\nof the box. Keywords supports only atoms keys, keys for maps can\nbe of any type. Both return `nil` if the key does not exist:\n\n    iex> keywords = [a: 1, b: 2]\n    iex> keywords[:a]\n    1\n    iex> keywords[:c]\n    nil\n\n    iex> map = %{a: 1, b: 2}\n    iex> map[:a]\n    1\n\n    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n    iex> star_ratings[1.5]\n    \"★☆\"\n\nThis syntax is very convenient as it can be nested arbitrarily:\n\n    iex> keywords = [a: 1, b: 2]\n    iex> keywords[:c][:unknown]\n    nil\n\nThis works because accessing anything on a `nil` value, returns\n`nil` itself:\n\n    iex> nil[:a]\n    nil\n\nThe access syntax can also be used with the `Kernel.put_in/2`,\n`Kernel.update_in/2` and `Kernel.get_and_update_in/2` macros\nto allow values to be set in nested data structures:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"][:age], 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\n## Maps and structs\n\nWhile the access syntax is allowed in maps via `map[key]`,\nif your map is made of predefined atom keys, you should prefer\nto access those atom keys with `map.key` instead of `map[key]`,\nas `map.key` will raise if the key is missing (which is not\nsupposed to happen if the keys are predefined).\n\nSimilarly, since structs are maps and structs have predefined\nkeys, they only allow the `struct.key` syntax and they do not\nallow the `struct[key]` access syntax. `Access.key/1` can also\nbe used to construct dynamic access to structs and maps.\n\nIn a nutshell, when using `put_in/2` and friends:\n\n    put_in(struct_or_map.key, :value)\n    put_in(keyword_or_map[:key], :value)\n\nWhen using `put_in/3` and friends:\n\n    put_in(struct_or_map, [Access.key!(:key)], :value)\n    put_in(keyword_or_map, [:key], :value)\n\nThis covers the dual nature of maps in Elixir, as they can be\neither for structured data or as a key-value store. See the `Map`\nmodule for more information.\n\n## Nested data structures\n\nBoth key-based access syntaxes can be used with the nested update\nfunctions and macros in `Kernel`, such as `Kernel.get_in/2`,\n`Kernel.put_in/3`, `Kernel.update_in/3`, `Kernel.pop_in/2`, and\n`Kernel.get_and_update_in/3`.\n\nFor example, to update a map inside another map:\n\n    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n    iex> put_in(users[\"john\"].age, 28)\n    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n\nThis module provides convenience functions for traversing other\nstructures, like tuples and lists. These functions can be used\nin all the `Access`-related functions and macros in `Kernel`.\n\nFor instance, given a user map with the `:name` and `:languages`\nkeys, here is how to deeply traverse the map and convert all\nlanguage names to uppercase:\n\n    iex> languages = [\n    ...>   %{name: \"elixir\", type: :functional},\n    ...>   %{name: \"c\", type: :procedural}\n    ...> ]\n    iex> user = %{name: \"john\", languages: languages}\n    iex> update_in(user, [:languages, Access.all(), :name], &String.upcase/1)\n    %{\n      name: \"john\",\n      languages: [\n        %{name: \"ELIXIR\", type: :functional},\n        %{name: \"C\", type: :procedural}\n      ]\n    }\n\nSee the functions `key/1`, `key!/1`, `elem/1`, and `all/0` for\nsome of the available accessors.\n","title":"Access","type":"behaviour"},{"doc":"Returns a function that accesses all the elements in a list. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; get_in ( list , [ Access . all ( ) , :name ] ) [ &quot;john&quot; , &quot;mary&quot; ] iex&gt; get_and_update_in ( list , [ Access . all ( ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ &quot;john&quot; , &quot;mary&quot; ] , [ %{ name : &quot;JOHN&quot; } , %{ name : &quot;MARY&quot; } ] } iex&gt; pop_in ( list , [ Access . all ( ) , :name ] ) { [ &quot;john&quot; , &quot;mary&quot; ] , [ %{ } , %{ } ] } Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2: iex&gt; require Integer iex&gt; get_and_update_in ( [ 1 , 2 , 3 , 4 , 5 ] , [ Access . all ( ) ] , fn num -&gt; ...&gt; if Integer . is_even ( num ) , do : :pop , else : { num , num * 2 } ...&gt; end ) { [ 1 , 2 , 3 , 4 , 5 ] , [ 2 , 6 , 10 ] } An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . all ( ) ] ) ** (RuntimeError) Access.all/0 expected a list, got: %{}","ref":"Access.html#all/0","source_doc":"Returns a function that accesses all the elements in a list.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.all(), :name])\n    [\"john\", \"mary\"]\n    iex> get_and_update_in(list, [Access.all(), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n    iex> pop_in(list, [Access.all(), :name])\n    {[\"john\", \"mary\"], [%{}, %{}]}\n\nHere is an example that traverses the list dropping even\nnumbers and multiplying odd numbers by 2:\n\n    iex> require Integer\n    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all()], fn num ->\n    ...>   if Integer.is_even(num), do: :pop, else: {num, num * 2}\n    ...> end)\n    {[1, 2, 3, 4, 5], [2, 6, 10]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.all()])\n    ** (RuntimeError) Access.all/0 expected a list, got: %{}\n\n","title":"Access.all/0","type":"function"},{"doc":"Returns a function that accesses the element at index (zero based) of a list. Keep in mind that index lookups in lists take linear time: the larger the list, the longer it will take to access its index. Therefore index-based operations are generally avoided in favor of other functions in the Enum module. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; get_in ( list , [ Access . at ( 1 ) , :name ] ) &quot;mary&quot; iex&gt; get_in ( list , [ Access . at ( - 1 ) , :name ] ) &quot;mary&quot; iex&gt; get_and_update_in ( list , [ Access . at ( 0 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , [ %{ name : &quot;JOHN&quot; } , %{ name : &quot;mary&quot; } ] } iex&gt; get_and_update_in ( list , [ Access . at ( - 1 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;mary&quot; , [ %{ name : &quot;john&quot; } , %{ name : &quot;MARY&quot; } ] } at/1 can also be used to pop elements out of a list or a key inside of a list: iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; pop_in ( list , [ Access . at ( 0 ) ] ) { %{ name : &quot;john&quot; } , [ %{ name : &quot;mary&quot; } ] } iex&gt; pop_in ( list , [ Access . at ( 0 ) , :name ] ) { &quot;john&quot; , [ %{ } , %{ name : &quot;mary&quot; } ] } When the index is out of bounds, nil is returned and the update function is never called: iex&gt; list = [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] iex&gt; get_in ( list , [ Access . at ( 10 ) , :name ] ) nil iex&gt; get_and_update_in ( list , [ Access . at ( 10 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { nil , [ %{ name : &quot;john&quot; } , %{ name : &quot;mary&quot; } ] } An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . at ( 1 ) ] ) ** (RuntimeError) Access.at/1 expected a list, got: %{}","ref":"Access.html#at/1","source_doc":"Returns a function that accesses the element at `index` (zero based) of a list.\n\nKeep in mind that index lookups in lists take linear time: the larger the list,\nthe longer it will take to access its index. Therefore index-based operations\nare generally avoided in favor of other functions in the `Enum` module.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(1), :name])\n    \"mary\"\n    iex> get_in(list, [Access.at(-1), :name])\n    \"mary\"\n    iex> get_and_update_in(list, [Access.at(0), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n    iex> get_and_update_in(list, [Access.at(-1), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"mary\", [%{name: \"john\"}, %{name: \"MARY\"}]}\n\n`at/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> pop_in(list, [Access.at(0)])\n    {%{name: \"john\"}, [%{name: \"mary\"}]}\n    iex> pop_in(list, [Access.at(0), :name])\n    {\"john\", [%{}, %{name: \"mary\"}]}\n\nWhen the index is out of bounds, `nil` is returned and the update function is never called:\n\n    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n    iex> get_in(list, [Access.at(10), :name])\n    nil\n    iex> get_and_update_in(list, [Access.at(10), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.at(1)])\n    ** (RuntimeError) Access.at/1 expected a list, got: %{}\n\n","title":"Access.at/1","type":"function"},{"doc":"Same as at/1 except that it raises Enum.OutOfBoundsError if the given index is out of bounds. Examples iex&gt; get_in ( [ :a , :b , :c ] , [ Access . at! ( 2 ) ] ) :c iex&gt; get_in ( [ :a , :b , :c ] , [ Access . at! ( 3 ) ] ) ** (Enum.OutOfBoundsError) out of bounds error","ref":"Access.html#at!/1","source_doc":"Same as `at/1` except that it raises `Enum.OutOfBoundsError`\nif the given index is out of bounds.\n\n## Examples\n\n    iex> get_in([:a, :b, :c], [Access.at!(2)])\n    :c\n    iex> get_in([:a, :b, :c], [Access.at!(3)])\n    ** (Enum.OutOfBoundsError) out of bounds error\n\n","title":"Access.at!/1","type":"function"},{"doc":"Returns a function that accesses the element at the given index in a tuple. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. The returned function raises if index is out of bounds. Note that popping elements out of tuples is not possible and raises an error. Examples iex&gt; map = %{ user : { &quot;john&quot; , 27 } } iex&gt; get_in ( map , [ :user , Access . elem ( 0 ) ] ) &quot;john&quot; iex&gt; get_and_update_in ( map , [ :user , Access . elem ( 0 ) ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , %{ user : { &quot;JOHN&quot; , 27 } } } iex&gt; pop_in ( map , [ :user , Access . elem ( 0 ) ] ) ** (RuntimeError) cannot pop data from a tuple An error is raised if the accessed structure is not a tuple: iex&gt; get_in ( %{ } , [ Access . elem ( 0 ) ] ) ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}","ref":"Access.html#elem/1","source_doc":"Returns a function that accesses the element at the given index in a tuple.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function raises if `index` is out of bounds.\n\nNote that popping elements out of tuples is not possible and raises an\nerror.\n\n## Examples\n\n    iex> map = %{user: {\"john\", 27}}\n    iex> get_in(map, [:user, Access.elem(0)])\n    \"john\"\n    iex> get_and_update_in(map, [:user, Access.elem(0)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: {\"JOHN\", 27}}}\n    iex> pop_in(map, [:user, Access.elem(0)])\n    ** (RuntimeError) cannot pop data from a tuple\n\nAn error is raised if the accessed structure is not a tuple:\n\n    iex> get_in(%{}, [Access.elem(0)])\n    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}\n\n","title":"Access.elem/1","type":"function"},{"doc":"Fetches the value for the given key in a container (a map, keyword list, or struct that implements the Access behaviour). Returns {:ok, value} where value is the value under key if there is such a key, or :error if key is not found. Examples iex&gt; Access . fetch ( %{ name : &quot;meg&quot; , age : 26 } , :name ) { :ok , &quot;meg&quot; } iex&gt; Access . fetch ( [ ordered : true , on_timeout : :exit ] , :timeout ) :error","ref":"Access.html#fetch/2","source_doc":"Fetches the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns `{:ok, value}` where `value` is the value under `key` if there is such\na key, or `:error` if `key` is not found.\n\n## Examples\n\n    iex> Access.fetch(%{name: \"meg\", age: 26}, :name)\n    {:ok, \"meg\"}\n\n    iex> Access.fetch([ordered: true, on_timeout: :exit], :timeout)\n    :error\n\n","title":"Access.fetch/2","type":"function"},{"doc":"Invoked in order to access the value stored under key in the given term term . This function should return {:ok, value} where value is the value under key if the key exists in the term, or :error if the key does not exist in the term. Many of the functions defined in the Access module internally call this function. This function is also used when the square-brackets access syntax ( structure[key] ) is used: the fetch/2 callback implemented by the module that defines the structure struct is invoked and if it returns {:ok, value} then value is returned, or if it returns :error then nil is returned. See the Map.fetch/2 and Keyword.fetch/2 implementations for examples of how to implement this callback.","ref":"Access.html#c:fetch/2","source_doc":"Invoked in order to access the value stored under `key` in the given term `term`.\n\nThis function should return `{:ok, value}` where `value` is the value under\n`key` if the key exists in the term, or `:error` if the key does not exist in\nthe term.\n\nMany of the functions defined in the `Access` module internally call this\nfunction. This function is also used when the square-brackets access syntax\n(`structure[key]`) is used: the `fetch/2` callback implemented by the module\nthat defines the `structure` struct is invoked and if it returns `{:ok,\nvalue}` then `value` is returned, or if it returns `:error` then `nil` is\nreturned.\n\nSee the `Map.fetch/2` and `Keyword.fetch/2` implementations for examples of\nhow to implement this callback.\n","title":"Access.fetch/2","type":"callback"},{"doc":"Same as fetch/2 but returns the value directly, or raises a KeyError exception if key is not found. Examples iex&gt; Access . fetch! ( %{ name : &quot;meg&quot; , age : 26 } , :name ) &quot;meg&quot;","ref":"Access.html#fetch!/2","source_doc":"Same as `fetch/2` but returns the value directly,\nor raises a `KeyError` exception if `key` is not found.\n\n## Examples\n\n    iex> Access.fetch!(%{name: \"meg\", age: 26}, :name)\n    \"meg\"\n\n","title":"Access.fetch!/2","type":"function"},{"doc":"Returns a function that accesses all elements of a list that match the provided predicate. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] iex&gt; get_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt; 20 ) ) , :name ] ) [ &quot;francine&quot; ] iex&gt; get_and_update_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &lt;= 20 ) ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ &quot;john&quot; ] , [ %{ name : &quot;JOHN&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] } filter/1 can also be used to pop elements out of a list or a key inside of a list: iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] iex&gt; pop_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 20 ) ) ] ) { [ %{ name : &quot;francine&quot; , salary : 30 } ] , [ %{ name : &quot;john&quot; , salary : 10 } ] } iex&gt; pop_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 20 ) ) , :name ] ) { [ &quot;francine&quot; ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ salary : 30 } ] } When no match is found, an empty list is returned and the update function is never called iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] iex&gt; get_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 50 ) ) , :name ] ) [ ] iex&gt; get_and_update_in ( list , [ Access . filter ( &amp; ( &amp;1 . salary &gt;= 50 ) ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } ] } An error is raised if the predicate is not a function or is of the incorrect arity: iex&gt; get_in ( [ ] , [ Access . filter ( 5 ) ] ) ** (FunctionClauseError) no function clause matching in Access.filter/1 An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . filter ( fn a -&gt; a == 10 end ) ] ) ** (RuntimeError) Access.filter/1 expected a list, got: %{}","ref":"Access.html#filter/1","source_doc":"Returns a function that accesses all elements of a list that match the provided predicate.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary > 20)), :name])\n    [\"francine\"]\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary <= 20)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"john\"], [%{name: \"JOHN\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\n`filter/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20))])\n    {[%{name: \"francine\", salary: 30}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.filter(&(&1.salary >= 20)), :name])\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{salary: 30}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]\n    iex> get_in(list, [Access.filter(&(&1.salary >= 50)), :name])\n    []\n    iex> get_and_update_in(list, [Access.filter(&(&1.salary >= 50)), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}]}\n\nAn error is raised if the predicate is not a function or is of the incorrect arity:\n\n    iex> get_in([], [Access.filter(5)])\n    ** (FunctionClauseError) no function clause matching in Access.filter/1\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.filter(fn a -> a == 10 end)])\n    ** (RuntimeError) Access.filter/1 expected a list, got: %{}\n\n","title":"Access.filter/1","type":"function"},{"doc":"Gets the value for the given key in a container (a map, keyword list, or struct that implements the Access behaviour). Returns the value under key if there is such a key, or default if key is not found. Examples iex&gt; Access . get ( %{ name : &quot;john&quot; } , :name , &quot;default name&quot; ) &quot;john&quot; iex&gt; Access . get ( %{ name : &quot;john&quot; } , :age , 25 ) 25 iex&gt; Access . get ( [ ordered : true ] , :timeout ) nil","ref":"Access.html#get/3","source_doc":"Gets the value for the given key in a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns the value under `key` if there is such a key, or `default` if `key` is\nnot found.\n\n## Examples\n\n    iex> Access.get(%{name: \"john\"}, :name, \"default name\")\n    \"john\"\n    iex> Access.get(%{name: \"john\"}, :age, 25)\n    25\n\n    iex> Access.get([ordered: true], :timeout)\n    nil\n\n","title":"Access.get/3","type":"function"},{"doc":"Gets and updates the given key in a container (a map, a keyword list, a struct that implements the Access behaviour). The fun argument receives the value of key (or nil if key is not present in container ) and must return a two-element tuple {current_value, new_value} : the &quot;get&quot; value current_value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key ( new_value ). fun may also return :pop , which means the current value should be removed from the container and returned. The returned value is a two-element tuple with the &quot;get&quot; value returned by fun and a new container with the updated value under key . Examples iex&gt; Access . get_and_update ( [ a : 1 ] , :a , fn current_value -&gt; ...&gt; { current_value , current_value + 1 } ...&gt; end ) { 1 , [ a : 2 ] }","ref":"Access.html#get_and_update/3","source_doc":"Gets and updates the given key in a `container` (a map, a keyword list,\na struct that implements the `Access` behaviour).\n\nThe `fun` argument receives the value of `key` (or `nil` if `key` is not\npresent in `container`) and must return a two-element tuple `{current_value, new_value}`:\nthe \"get\" value `current_value` (the retrieved value, which can be operated on before\nbeing returned) and the new value to be stored under `key` (`new_value`).\n`fun` may also return `:pop`, which means the current value\nshould be removed from the container and returned.\n\nThe returned value is a two-element tuple with the \"get\" value returned by\n`fun` and a new container with the updated value under `key`.\n\n## Examples\n\n    iex> Access.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, current_value + 1}\n    ...> end)\n    {1, [a: 2]}\n\n","title":"Access.get_and_update/3","type":"function"},{"doc":"Invoked in order to access the value under key and update it at the same time. The implementation of this callback should invoke fun with the value under key in the passed structure data , or with nil if key is not present in it. This function must return either {current_value, new_value} or :pop . If the passed function returns {current_value, new_value} , the return value of this callback should be {current_value, new_data} , where: current_value is the retrieved value (which can be operated on before being returned) new_value is the new value to be stored under key new_data is data after updating the value of key with new_value . If the passed function returns :pop , the return value of this callback must be {value, new_data} where value is the value under key (or nil if not present) and new_data is data without key . See the implementations of Map.get_and_update/3 or Keyword.get_and_update/3 for more examples.","ref":"Access.html#c:get_and_update/3","source_doc":"Invoked in order to access the value under `key` and update it at the same time.\n\nThe implementation of this callback should invoke `fun` with the value under\n`key` in the passed structure `data`, or with `nil` if `key` is not present in it.\nThis function must return either `{current_value, new_value}` or `:pop`.\n\nIf the passed function returns `{current_value, new_value}`,\nthe return value of this callback should be `{current_value, new_data}`, where:\n\n  * `current_value` is the retrieved value (which can be operated on before being returned)\n\n  * `new_value` is the new value to be stored under `key`\n\n  * `new_data` is `data` after updating the value of `key` with `new_value`.\n\nIf the passed function returns `:pop`, the return value of this callback\nmust be `{value, new_data}` where `value` is the value under `key`\n(or `nil` if not present) and `new_data` is `data` without `key`.\n\nSee the implementations of `Map.get_and_update/3` or `Keyword.get_and_update/3`\nfor more examples.\n","title":"Access.get_and_update/3","type":"callback"},{"doc":"Returns a function that accesses the given key in a map/struct. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys: iex&gt; get_in ( %{ } , [ Access . key ( :user , %{ } ) , Access . key ( :name , &quot;meg&quot; ) ] ) &quot;meg&quot; Such is also useful when using update functions, allowing us to introduce values as we traverse the data structure for updates: iex&gt; put_in ( %{ } , [ Access . key ( :user , %{ } ) , Access . key ( :name ) ] , &quot;Mary&quot; ) %{ user : %{ name : &quot;Mary&quot; } } Examples iex&gt; map = %{ user : %{ name : &quot;john&quot; } } iex&gt; get_in ( map , [ Access . key ( :unknown , %{ } ) , Access . key ( :name , &quot;john&quot; ) ] ) &quot;john&quot; iex&gt; get_and_update_in ( map , [ Access . key ( :user ) , Access . key ( :name ) ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , %{ user : %{ name : &quot;JOHN&quot; } } } iex&gt; pop_in ( map , [ Access . key ( :user ) , Access . key ( :name ) ] ) { &quot;john&quot; , %{ user : %{ } } } An error is raised if the accessed structure is not a map or a struct: iex&gt; get_in ( [ ] , [ Access . key ( :foo ) ] ) ** (BadMapError) expected a map, got: []","ref":"Access.html#key/2","source_doc":"Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nThe returned function uses the default value if the key does not exist.\nThis can be used to specify defaults and safely traverse missing keys:\n\n    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, \"meg\")])\n    \"meg\"\n\nSuch is also useful when using update functions, allowing us to introduce\nvalues as we traverse the data structure for updates:\n\n    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name)], \"Mary\")\n    %{user: %{name: \"Mary\"}}\n\n## Examples\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john\")])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key(:user), Access.key(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key(:user), Access.key(:name)])\n    {\"john\", %{user: %{}}}\n\nAn error is raised if the accessed structure is not a map or a struct:\n\n    iex> get_in([], [Access.key(:foo)])\n    ** (BadMapError) expected a map, got: []\n\n","title":"Access.key/2","type":"function"},{"doc":"Returns a function that accesses the given key in a map/struct. The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Similar to key/2 , but the returned function raises if the key does not exist. Examples iex&gt; map = %{ user : %{ name : &quot;john&quot; } } iex&gt; get_in ( map , [ Access . key! ( :user ) , Access . key! ( :name ) ] ) &quot;john&quot; iex&gt; get_and_update_in ( map , [ Access . key! ( :user ) , Access . key! ( :name ) ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { &quot;john&quot; , %{ user : %{ name : &quot;JOHN&quot; } } } iex&gt; pop_in ( map , [ Access . key! ( :user ) , Access . key! ( :name ) ] ) { &quot;john&quot; , %{ user : %{ } } } iex&gt; get_in ( map , [ Access . key! ( :user ) , Access . key! ( :unknown ) ] ) ** (KeyError) key :unknown not found in: %{name: &quot;john&quot;} An error is raised if the accessed structure is not a map/struct: iex&gt; get_in ( [ ] , [ Access . key! ( :foo ) ] ) ** (RuntimeError) Access.key!/1 expected a map/struct, got: []","ref":"Access.html#key!/1","source_doc":"Returns a function that accesses the given key in a map/struct.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\nSimilar to `key/2`, but the returned function raises if the key does not exist.\n\n## Examples\n\n    iex> map = %{user: %{name: \"john\"}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n    \"john\"\n    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {\"john\", %{user: %{name: \"JOHN\"}}}\n    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n    {\"john\", %{user: %{}}}\n    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n\nAn error is raised if the accessed structure is not a map/struct:\n\n    iex> get_in([], [Access.key!(:foo)])\n    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []\n\n","title":"Access.key!/1","type":"function"},{"doc":"Removes the entry with a given key from a container (a map, keyword list, or struct that implements the Access behaviour). Returns a tuple containing the value associated with the key and the updated container. nil is returned for the value if the key isn't in the container. Examples With a map: iex&gt; Access . pop ( %{ name : &quot;Elixir&quot; , creator : &quot;Valim&quot; } , :name ) { &quot;Elixir&quot; , %{ creator : &quot;Valim&quot; } } A keyword list: iex&gt; Access . pop ( [ name : &quot;Elixir&quot; , creator : &quot;Valim&quot; ] , :name ) { &quot;Elixir&quot; , [ creator : &quot;Valim&quot; ] } An unknown key: iex&gt; Access . pop ( %{ name : &quot;Elixir&quot; , creator : &quot;Valim&quot; } , :year ) { nil , %{ creator : &quot;Valim&quot; , name : &quot;Elixir&quot; } }","ref":"Access.html#pop/2","source_doc":"Removes the entry with a given key from a container (a map, keyword\nlist, or struct that implements the `Access` behaviour).\n\nReturns a tuple containing the value associated with the key and the\nupdated container. `nil` is returned for the value if the key isn't\nin the container.\n\n## Examples\n\nWith a map:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n    {\"Elixir\", %{creator: \"Valim\"}}\n\nA keyword list:\n\n    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n    {\"Elixir\", [creator: \"Valim\"]}\n\nAn unknown key:\n\n    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n    {nil, %{creator: \"Valim\", name: \"Elixir\"}}\n\n","title":"Access.pop/2","type":"function"},{"doc":"Invoked to &quot;pop&quot; the value under key out of the given data structure. When key exists in the given structure data , the implementation should return a {value, new_data} tuple where value is the value that was under key and new_data is term without key . When key is not present in the given structure, a tuple {value, data} should be returned, where value is implementation-defined. See the implementations for Map.pop/3 or Keyword.pop/3 for more examples.","ref":"Access.html#c:pop/2","source_doc":"Invoked to \"pop\" the value under `key` out of the given data structure.\n\nWhen `key` exists in the given structure `data`, the implementation should\nreturn a `{value, new_data}` tuple where `value` is the value that was under\n`key` and `new_data` is `term` without `key`.\n\nWhen `key` is not present in the given structure, a tuple `{value, data}`\nshould be returned, where `value` is implementation-defined.\n\nSee the implementations for `Map.pop/3` or `Keyword.pop/3` for more examples.\n","title":"Access.pop/2","type":"callback"},{"doc":"Returns a function that accesses all items of a list that are within the provided range. The range will be normalized following the same rules from Enum.slice/2 . The returned function is typically passed as an accessor to Kernel.get_in/2 , Kernel.get_and_update_in/3 , and friends. Examples iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } , %{ name : &quot;vitor&quot; , salary : 25 } ] iex&gt; get_in ( list , [ Access . slice ( 1 .. 2 ) , :name ] ) [ &quot;francine&quot; , &quot;vitor&quot; ] iex&gt; get_and_update_in ( list , [ Access . slice ( 1 .. 3 // 2 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ &quot;francine&quot; ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;FRANCINE&quot; , salary : 30 } , %{ name : &quot;vitor&quot; , salary : 25 } ] } slice/1 can also be used to pop elements out of a list or a key inside of a list: iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } , %{ name : &quot;vitor&quot; , salary : 25 } ] iex&gt; pop_in ( list , [ Access . slice ( - 2 .. - 1 ) ] ) { [ %{ name : &quot;francine&quot; , salary : 30 } , %{ name : &quot;vitor&quot; , salary : 25 } ] , [ %{ name : &quot;john&quot; , salary : 10 } ] } iex&gt; pop_in ( list , [ Access . slice ( - 2 .. - 1 ) , :name ] ) { [ &quot;francine&quot; , &quot;vitor&quot; ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ salary : 30 } , %{ salary : 25 } ] } When no match is found, an empty list is returned and the update function is never called iex&gt; list = [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } , %{ name : &quot;vitor&quot; , salary : 25 } ] iex&gt; get_in ( list , [ Access . slice ( 5 .. 10 // 2 ) , :name ] ) [ ] iex&gt; get_and_update_in ( list , [ Access . slice ( 5 .. 10 // 2 ) , :name ] , fn prev -&gt; ...&gt; { prev , String . upcase ( prev ) } ...&gt; end ) { [ ] , [ %{ name : &quot;john&quot; , salary : 10 } , %{ name : &quot;francine&quot; , salary : 30 } , %{ name : &quot;vitor&quot; , salary : 25 } ] } An error is raised if the accessed structure is not a list: iex&gt; get_in ( %{ } , [ Access . slice ( 2 .. 10 // 3 ) ] ) ** (ArgumentError) Access.slice/1 expected a list, got: %{} An error is raised if the step of the range is negative: iex&gt; get_in ( [ ] , [ Access . slice ( 2 .. 10 // - 1 ) ] ) ** (ArgumentError) Access.slice/1 does not accept ranges with negative steps, got: 2..10//-1","ref":"Access.html#slice/1","source_doc":"Returns a function that accesses all items of a list that are within the provided range.\n\nThe range will be normalized following the same rules from `Enum.slice/2`.\n\nThe returned function is typically passed as an accessor to `Kernel.get_in/2`,\n`Kernel.get_and_update_in/3`, and friends.\n\n## Examples\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(1..2), :name])\n    [\"francine\", \"vitor\"]\n    iex> get_and_update_in(list, [Access.slice(1..3//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[\"francine\"], [%{name: \"john\", salary: 10}, %{name: \"FRANCINE\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\n`slice/1` can also be used to pop elements out of a list or\na key inside of a list:\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> pop_in(list, [Access.slice(-2..-1)])\n    {[%{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}], [%{name: \"john\", salary: 10}]}\n    iex> pop_in(list, [Access.slice(-2..-1), :name])\n    {[\"francine\", \"vitor\"], [%{name: \"john\", salary: 10}, %{salary: 30}, %{salary: 25}]}\n\nWhen no match is found, an empty list is returned and the update function is never called\n\n    iex> list = [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]\n    iex> get_in(list, [Access.slice(5..10//2), :name])\n    []\n    iex> get_and_update_in(list, [Access.slice(5..10//2), :name], fn prev ->\n    ...>   {prev, String.upcase(prev)}\n    ...> end)\n    {[], [%{name: \"john\", salary: 10}, %{name: \"francine\", salary: 30}, %{name: \"vitor\", salary: 25}]}\n\nAn error is raised if the accessed structure is not a list:\n\n    iex> get_in(%{}, [Access.slice(2..10//3)])\n    ** (ArgumentError) Access.slice/1 expected a list, got: %{}\n\nAn error is raised if the step of the range is negative:\n\n    iex> get_in([], [Access.slice(2..10//-1)])\n    ** (ArgumentError) Access.slice/1 does not accept ranges with negative steps, got: 2..10//-1\n\n","title":"Access.slice/1","type":"function"},{"doc":"","ref":"Access.html#t:access_fun/2","source_doc":false,"title":"Access.access_fun/2","type":"type"},{"doc":"","ref":"Access.html#t:container/0","source_doc":false,"title":"Access.container/0","type":"type"},{"doc":"","ref":"Access.html#t:get_and_update_fun/2","source_doc":false,"title":"Access.get_and_update_fun/2","type":"type"},{"doc":"","ref":"Access.html#t:get_fun/1","source_doc":false,"title":"Access.get_fun/1","type":"type"},{"doc":"","ref":"Access.html#t:key/0","source_doc":false,"title":"Access.key/0","type":"type"},{"doc":"","ref":"Access.html#t:nil_container/0","source_doc":false,"title":"Access.nil_container/0","type":"type"},{"doc":"","ref":"Access.html#t:t/0","source_doc":false,"title":"Access.t/0","type":"type"},{"doc":"","ref":"Access.html#t:value/0","source_doc":false,"title":"Access.value/0","type":"type"},{"doc":"Returns an inclusive range between dates. Ranges must be created with the Date.range/2 or Date.range/3 function. The following fields are public: :first - the initial date on the range :last - the last date on the range :step - (since v1.12.0) the step The remaining fields are private and should not be accessed.","ref":"Date.Range.html","source_doc":"Returns an inclusive range between dates.\n\nRanges must be created with the `Date.range/2` or `Date.range/3` function.\n\nThe following fields are public:\n\n  * `:first` - the initial date on the range\n  * `:last` - the last date on the range\n  * `:step` - (since v1.12.0) the step\n\nThe remaining fields are private and should not be accessed.\n","title":"Date.Range","type":"module"},{"doc":"","ref":"Date.Range.html#t:t/0","source_doc":false,"title":"Date.Range.t/0","type":"type"},{"doc":"Functions for working with collections (known as enumerables). In Elixir, an enumerable is any data type that implements the Enumerable protocol. List s ( [1, 2, 3] ), Map s ( %{foo: 1, bar: 2} ) and Range s ( 1..3 ) are common data types used as enumerables: iex&gt; Enum . map ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] iex&gt; Enum . sum ( [ 1 , 2 , 3 ] ) 6 iex&gt; Enum . map ( 1 .. 3 , fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] iex&gt; Enum . sum ( 1 .. 3 ) 6 iex&gt; map = %{ &quot;a&quot; =&gt; 1 , &quot;b&quot; =&gt; 2 } iex&gt; Enum . map ( map , fn { k , v } -&gt; { k , v * 2 } end ) [ { &quot;a&quot; , 2 } , { &quot;b&quot; , 4 } ] However, many other enumerables exist in the language, such as MapSet s and the data type returned by File.stream!/3 which allows a file to be traversed as if it was an enumerable. The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as Enum.map/2 . After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take. This linear behaviour should also be expected on operations like count/1 , member?/2 , at/2 and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the Enum module is meant to work with a large variety of data types and not all data types can provide optimized behaviour. Finally, note the functions in the Enum module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the Stream module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the Stream module for examples and documentation.","ref":"Enum.html","source_doc":"Functions for working with collections (known as enumerables).\n\nIn Elixir, an enumerable is any data type that implements the\n`Enumerable` protocol. `List`s (`[1, 2, 3]`), `Map`s (`%{foo: 1, bar: 2}`)\nand `Range`s (`1..3`) are common data types used as enumerables:\n\n    iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.map(1..3, fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.sum(1..3)\n    6\n\n    iex> map = %{\"a\" => 1, \"b\" => 2}\n    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n    [{\"a\", 2}, {\"b\", 4}]\n\nHowever, many other enumerables exist in the language, such as `MapSet`s\nand the data type returned by `File.stream!/3` which allows a file to be\ntraversed as if it was an enumerable.\n\nThe functions in this module work in linear time. This means that, the\ntime it takes to perform an operation grows at the same rate as the length\nof the enumerable. This is expected on operations such as `Enum.map/2`.\nAfter all, if we want to traverse every element on a list, the longer the\nlist, the more elements we need to traverse, and the longer it will take.\n\nThis linear behaviour should also be expected on operations like `count/1`,\n`member?/2`, `at/2` and similar. While Elixir does allow data types to\nprovide performant variants for such operations, you should not expect it\nto always be available, since the `Enum` module is meant to work with a\nlarge variety of data types and not all data types can provide optimized\nbehaviour.\n\nFinally, note the functions in the `Enum` module are eager: they will\ntraverse the enumerable as soon as they are invoked. This is particularly\ndangerous when working with infinite enumerables. In such cases, you should\nuse the `Stream` module, which allows you to lazily express computations,\nwithout traversing collections, and work with possibly infinite collections.\nSee the `Stream` module for examples and documentation.\n","title":"Enum","type":"module"},{"doc":"Returns true if all elements in enumerable are truthy. When an element has a falsy value ( false or nil ) iteration stops immediately and false is returned. In all other cases true is returned. Examples iex&gt; Enum . all? ( [ 1 , 2 , 3 ] ) true iex&gt; Enum . all? ( [ 1 , nil , 3 ] ) false iex&gt; Enum . all? ( [ ] ) true","ref":"Enum.html#all?/1","source_doc":"Returns `true` if all elements in `enumerable` are truthy.\n\nWhen an element has a falsy value (`false` or `nil`) iteration stops immediately\nand `false` is returned. In all other cases `true` is returned.\n\n## Examples\n\n    iex> Enum.all?([1, 2, 3])\n    true\n\n    iex> Enum.all?([1, nil, 3])\n    false\n\n    iex> Enum.all?([])\n    true\n\n","title":"Enum.all?/1","type":"function"},{"doc":"Returns true if fun.(element) is truthy for all elements in enumerable . Iterates over enumerable and invokes fun on each element. If fun ever returns a falsy value ( false or nil ), iteration stops immediately and false is returned. Otherwise, true is returned. Examples iex&gt; Enum . all? ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) true iex&gt; Enum . all? ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) false iex&gt; Enum . all? ( [ ] , fn _ -&gt; nil end ) true As the last example shows, Enum.all?/2 returns true if enumerable is empty, regardless of fun . In an empty enumerable there is no element for which fun returns a falsy value, so the result must be true . This is a well-defined logical argument for empty collections.","ref":"Enum.html#all?/2","source_doc":"Returns `true` if `fun.(element)` is truthy for all elements in `enumerable`.\n\nIterates over `enumerable` and invokes `fun` on each element. If `fun` ever\nreturns a falsy value (`false` or `nil`), iteration stops immediately and\n`false` is returned. Otherwise, `true` is returned.\n\n## Examples\n\n    iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)\n    true\n\n    iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)\n    false\n\n    iex> Enum.all?([], fn _ -> nil end)\n    true\n\nAs the last example shows, `Enum.all?/2` returns `true` if `enumerable` is\nempty, regardless of `fun`. In an empty enumerable there is no element for\nwhich `fun` returns a falsy value, so the result must be `true`. This is a\nwell-defined logical argument for empty collections.\n\n","title":"Enum.all?/2","type":"function"},{"doc":"Returns true if at least one element in enumerable is truthy. When an element has a truthy value (neither false nor nil ) iteration stops immediately and true is returned. In all other cases false is returned. Examples iex&gt; Enum . any? ( [ false , false , false ] ) false iex&gt; Enum . any? ( [ false , true , false ] ) true iex&gt; Enum . any? ( [ ] ) false","ref":"Enum.html#any?/1","source_doc":"Returns `true` if at least one element in `enumerable` is truthy.\n\nWhen an element has a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.\n\n## Examples\n\n    iex> Enum.any?([false, false, false])\n    false\n\n    iex> Enum.any?([false, true, false])\n    true\n\n    iex> Enum.any?([])\n    false\n\n","title":"Enum.any?/1","type":"function"},{"doc":"Returns true if fun.(element) is truthy for at least one element in enumerable . Iterates over the enumerable and invokes fun on each element. When an invocation of fun returns a truthy value (neither false nor nil ) iteration stops immediately and true is returned. In all other cases false is returned. Examples iex&gt; Enum . any? ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) false iex&gt; Enum . any? ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) true iex&gt; Enum . any? ( [ ] , fn x -&gt; x &gt; 0 end ) false","ref":"Enum.html#any?/2","source_doc":"Returns `true` if `fun.(element)` is truthy for at least one element in `enumerable`.\n\nIterates over the `enumerable` and invokes `fun` on each element. When an invocation\nof `fun` returns a truthy value (neither `false` nor `nil`) iteration stops\nimmediately and `true` is returned. In all other cases `false` is returned.\n\n## Examples\n\n    iex> Enum.any?([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    false\n\n    iex> Enum.any?([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.any?([], fn x -> x > 0 end)\n    false\n\n","title":"Enum.any?/2","type":"function"},{"doc":"Finds the element at the given index (zero-based). Returns default if index is out of bounds. A negative index can be passed, which means the enumerable is enumerated once and the index is counted from the end (for example, -1 finds the last element). Examples iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 0 ) 2 iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 2 ) 6 iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 4 ) nil iex&gt; Enum . at ( [ 2 , 4 , 6 ] , 4 , :none ) :none","ref":"Enum.html#at/3","source_doc":"Finds the element at the given `index` (zero-based).\n\nReturns `default` if `index` is out of bounds.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` finds the last element).\n\n## Examples\n\n    iex> Enum.at([2, 4, 6], 0)\n    2\n\n    iex> Enum.at([2, 4, 6], 2)\n    6\n\n    iex> Enum.at([2, 4, 6], 4)\n    nil\n\n    iex> Enum.at([2, 4, 6], 4, :none)\n    :none\n\n","title":"Enum.at/3","type":"function"},{"doc":"Splits enumerable on every element for which fun returns a new value. Returns a list of lists. Examples iex&gt; Enum . chunk_by ( [ 1 , 2 , 2 , 3 , 4 , 4 , 6 , 7 , 7 ] , &amp; ( rem ( &amp;1 , 2 ) == 1 ) ) [ [ 1 ] , [ 2 , 2 ] , [ 3 ] , [ 4 , 4 , 6 ] , [ 7 , 7 ] ]","ref":"Enum.html#chunk_by/2","source_doc":"Splits enumerable on every element for which `fun` returns a new\nvalue.\n\nReturns a list of lists.\n\n## Examples\n\n    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n\n","title":"Enum.chunk_by/2","type":"function"},{"doc":"Shortcut to chunk_every(enumerable, count, count) .","ref":"Enum.html#chunk_every/2","source_doc":"Shortcut to `chunk_every(enumerable, count, count)`.\n","title":"Enum.chunk_every/2","type":"function"},{"doc":"Returns list of lists containing count elements each, where each new chunk starts step elements into the enumerable . step is optional and, if not passed, defaults to count , i.e. chunks do not overlap. Chunking will stop as soon as the collection ends or when we emit an incomplete chunk. If the last chunk does not have count elements to fill the chunk, elements are taken from leftover to fill in the chunk. If leftover does not have enough elements to fill the chunk, then a partial chunk is returned with less than count elements. If :discard is given in leftover , the last chunk is discarded unless it has exactly count elements. Examples iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 2 ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , :discard ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , [ 7 ] ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] , [ 5 , 6 , 7 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 ] , 3 , 3 , [ ] ) [ [ 1 , 2 , 3 ] , [ 4 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 ] , 10 ) [ [ 1 , 2 , 3 , 4 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 , 5 ] , 2 , 3 , [ ] ) [ [ 1 , 2 ] , [ 4 , 5 ] ] iex&gt; Enum . chunk_every ( [ 1 , 2 , 3 , 4 ] , 3 , 3 , Stream . cycle ( [ 0 ] ) ) [ [ 1 , 2 , 3 ] , [ 4 , 0 , 0 ] ]","ref":"Enum.html#chunk_every/4","source_doc":"Returns list of lists containing `count` elements each, where\neach new chunk starts `step` elements into the `enumerable`.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap. Chunking will stop as soon as the collection\nends or when we emit an incomplete chunk.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, [])\n    [[1, 2, 3], [4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 10)\n    [[1, 2, 3, 4]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])\n    [[1, 2], [4, 5]]\n\n    iex> Enum.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0]))\n    [[1, 2, 3], [4, 0, 0]]\n\n","title":"Enum.chunk_every/4","type":"function"},{"doc":"Chunks the enumerable with fine grained control when every chunk is emitted. chunk_fun receives the current element and the accumulator and must return: {:cont, chunk, acc} to emit a chunk and continue with the accumulator {:cont, acc} to not emit any chunk and continue with the accumulator {:halt, acc} to halt chunking over the enumerable . after_fun is invoked with the final accumulator when iteration is finished (or halt ed) to handle any trailing elements that were returned as part of an accumulator, but were not emitted as a chunk by chunk_fun . It must return: {:cont, chunk, acc} to emit a chunk. The chunk will be appended to the list of already emitted chunks. {:cont, acc} to not emit a chunk The acc in after_fun is required in order to mirror the tuple format from chunk_fun but it will be discarded since the traversal is complete. Returns a list of emitted chunks. Examples iex&gt; chunk_fun = fn element , acc -&gt; ...&gt; if rem ( element , 2 ) == 0 do ...&gt; { :cont , Enum . reverse ( [ element | acc ] ) , [ ] } ...&gt; else ...&gt; { :cont , [ element | acc ] } ...&gt; end ...&gt; end iex&gt; after_fun = fn ...&gt; [ ] -&gt; { :cont , [ ] } ...&gt; acc -&gt; { :cont , Enum . reverse ( acc ) , [ ] } ...&gt; end iex&gt; Enum . chunk_while ( 1 .. 10 , [ ] , chunk_fun , after_fun ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] , [ 7 , 8 ] , [ 9 , 10 ] ] iex&gt; Enum . chunk_while ( [ 1 , 2 , 3 , 5 , 7 ] , [ ] , chunk_fun , after_fun ) [ [ 1 , 2 ] , [ 3 , 5 , 7 ] ]","ref":"Enum.html#chunk_while/4","source_doc":"Chunks the `enumerable` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk and continue with the accumulator\n  * `{:cont, acc}` to not emit any chunk and continue with the accumulator\n  * `{:halt, acc}` to halt chunking over the `enumerable`.\n\n`after_fun` is invoked with the final accumulator when iteration is\nfinished (or `halt`ed) to handle any trailing elements that were returned\nas part of an accumulator, but were not emitted as a chunk by `chunk_fun`.\nIt must return:\n\n  * `{:cont, chunk, acc}` to emit a chunk. The chunk will be appended to the\n    list of already emitted chunks.\n  * `{:cont, acc}` to not emit a chunk\n\nThe `acc` in `after_fun` is required in order to mirror the tuple format\nfrom `chunk_fun` but it will be discarded since the traversal is complete.\n\nReturns a list of emitted chunks.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> Enum.chunk_while(1..10, [], chunk_fun, after_fun)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n    iex> Enum.chunk_while([1, 2, 3, 5, 7], [], chunk_fun, after_fun)\n    [[1, 2], [3, 5, 7]]\n\n","title":"Enum.chunk_while/4","type":"function"},{"doc":"Given an enumerable of enumerables, concatenates the enumerables into a single list. Examples iex&gt; Enum . concat ( [ 1 .. 3 , 4 .. 6 , 7 .. 9 ] ) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] iex&gt; Enum . concat ( [ [ 1 , [ 2 ] , 3 ] , [ 4 ] , [ 5 , 6 ] ] ) [ 1 , [ 2 ] , 3 , 4 , 5 , 6 ]","ref":"Enum.html#concat/1","source_doc":"Given an enumerable of enumerables, concatenates the `enumerables` into\na single list.\n\n## Examples\n\n    iex> Enum.concat([1..3, 4..6, 7..9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n    [1, [2], 3, 4, 5, 6]\n\n","title":"Enum.concat/1","type":"function"},{"doc":"Concatenates the enumerable on the right with the enumerable on the left . This function produces the same result as the ++/2 operator for lists. Examples iex&gt; Enum . concat ( 1 .. 3 , 4 .. 6 ) [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; Enum . concat ( [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) [ 1 , 2 , 3 , 4 , 5 , 6 ]","ref":"Enum.html#concat/2","source_doc":"Concatenates the enumerable on the `right` with the enumerable on the\n`left`.\n\nThis function produces the same result as the `++/2` operator\nfor lists.\n\n## Examples\n\n    iex> Enum.concat(1..3, 4..6)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n\n","title":"Enum.concat/2","type":"function"},{"doc":"Returns the size of the enumerable . Examples iex&gt; Enum . count ( [ 1 , 2 , 3 ] ) 3","ref":"Enum.html#count/1","source_doc":"Returns the size of the `enumerable`.\n\n## Examples\n\n    iex> Enum.count([1, 2, 3])\n    3\n\n","title":"Enum.count/1","type":"function"},{"doc":"Returns the count of elements in the enumerable for which fun returns a truthy value. Examples iex&gt; Enum . count ( [ 1 , 2 , 3 , 4 , 5 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) 2","ref":"Enum.html#count/2","source_doc":"Returns the count of elements in the `enumerable` for which `fun` returns\na truthy value.\n\n## Examples\n\n    iex> Enum.count([1, 2, 3, 4, 5], fn x -> rem(x, 2) == 0 end)\n    2\n\n","title":"Enum.count/2","type":"function"},{"doc":"Counts the enumerable stopping at limit . This is useful for checking certain properties of the count of an enumerable without having to actually count the entire enumerable. For example, if you wanted to check that the count was exactly, at least, or more than a value. If the enumerable implements Enumerable.count/1 , the enumerable is not traversed and we return the lower of the two numbers. To force enumeration, use count_until/3 with fn _ -&gt; true end as the second argument. Examples iex&gt; Enum . count_until ( 1 .. 20 , 5 ) 5 iex&gt; Enum . count_until ( 1 .. 20 , 50 ) 20 iex&gt; Enum . count_until ( 1 .. 10 , 10 ) == 10 # At least 10 true iex&gt; Enum . count_until ( 1 .. 11 , 10 + 1 ) &gt; 10 # More than 10 true iex&gt; Enum . count_until ( 1 .. 5 , 10 ) &lt; 10 # Less than 10 true iex&gt; Enum . count_until ( 1 .. 10 , 10 + 1 ) == 10 # Exactly ten true","ref":"Enum.html#count_until/2","source_doc":"Counts the enumerable stopping at `limit`.\n\nThis is useful for checking certain properties of the count of an enumerable\nwithout having to actually count the entire enumerable. For example, if you\nwanted to check that the count was exactly, at least, or more than a value.\n\nIf the enumerable implements `c:Enumerable.count/1`, the enumerable is\nnot traversed and we return the lower of the two numbers. To force\nenumeration, use `count_until/3` with `fn _ -> true end` as the second\nargument.\n\n## Examples\n\n    iex> Enum.count_until(1..20, 5)\n    5\n    iex> Enum.count_until(1..20, 50)\n    20\n    iex> Enum.count_until(1..10, 10) == 10 # At least 10\n    true\n    iex> Enum.count_until(1..11, 10 + 1) > 10 # More than 10\n    true\n    iex> Enum.count_until(1..5, 10) < 10 # Less than 10\n    true\n    iex> Enum.count_until(1..10, 10 + 1) == 10 # Exactly ten\n    true\n\n","title":"Enum.count_until/2","type":"function"},{"doc":"Counts the elements in the enumerable for which fun returns a truthy value, stopping at limit . See count/2 and count_until/2 for more information. Examples iex&gt; Enum . count_until ( 1 .. 20 , fn x -&gt; rem ( x , 2 ) == 0 end , 7 ) 7 iex&gt; Enum . count_until ( 1 .. 20 , fn x -&gt; rem ( x , 2 ) == 0 end , 11 ) 10","ref":"Enum.html#count_until/3","source_doc":"Counts the elements in the enumerable for which `fun` returns a truthy value, stopping at `limit`.\n\nSee `count/2` and `count_until/2` for more information.\n\n## Examples\n\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 7)\n    7\n    iex> Enum.count_until(1..20, fn x -> rem(x, 2) == 0 end, 11)\n    10\n","title":"Enum.count_until/3","type":"function"},{"doc":"Enumerates the enumerable , returning a list where all consecutive duplicated elements are collapsed to a single element. Elements are compared using ===/2 . If you want to remove all duplicated elements, regardless of order, see uniq/1 . Examples iex&gt; Enum . dedup ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) [ 1 , 2 , 3 , 2 , 1 ] iex&gt; Enum . dedup ( [ 1 , 1 , 2 , 2.0 , :three , :three ] ) [ 1 , 2 , 2.0 , :three ]","ref":"Enum.html#dedup/1","source_doc":"Enumerates the `enumerable`, returning a list where all consecutive\nduplicated elements are collapsed to a single element.\n\nElements are compared using `===/2`.\n\nIf you want to remove all duplicated elements, regardless of order,\nsee `uniq/1`.\n\n## Examples\n\n    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n    [1, 2, 3, 2, 1]\n\n    iex> Enum.dedup([1, 1, 2, 2.0, :three, :three])\n    [1, 2, 2.0, :three]\n\n","title":"Enum.dedup/1","type":"function"},{"doc":"Enumerates the enumerable , returning a list where all consecutive duplicated elements are collapsed to a single element. The function fun maps every element to a term which is used to determine if two elements are duplicates. Examples iex&gt; Enum . dedup_by ( [ { 1 , :a } , { 2 , :b } , { 2 , :c } , { 1 , :a } ] , fn { x , _ } -&gt; x end ) [ { 1 , :a } , { 2 , :b } , { 1 , :a } ] iex&gt; Enum . dedup_by ( [ 5 , 1 , 2 , 3 , 2 , 1 ] , fn x -&gt; x &gt; 2 end ) [ 5 , 1 , 3 , 2 ]","ref":"Enum.html#dedup_by/2","source_doc":"Enumerates the `enumerable`, returning a list where all consecutive\nduplicated elements are collapsed to a single element.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\n## Examples\n\n    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)\n    [{1, :a}, {2, :b}, {1, :a}]\n\n    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n    [5, 1, 3, 2]\n\n","title":"Enum.dedup_by/2","type":"function"},{"doc":"Drops the amount of elements from the enumerable . If a negative amount is given, the amount of last values will be dropped. The enumerable will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end. Examples iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , 2 ) [ 3 ] iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , 10 ) [ ] iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , 0 ) [ 1 , 2 , 3 ] iex&gt; Enum . drop ( [ 1 , 2 , 3 ] , - 1 ) [ 1 , 2 ]","ref":"Enum.html#drop/2","source_doc":"Drops the `amount` of elements from the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of last values will be dropped.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\n## Examples\n\n    iex> Enum.drop([1, 2, 3], 2)\n    [3]\n\n    iex> Enum.drop([1, 2, 3], 10)\n    []\n\n    iex> Enum.drop([1, 2, 3], 0)\n    [1, 2, 3]\n\n    iex> Enum.drop([1, 2, 3], -1)\n    [1, 2]\n\n","title":"Enum.drop/2","type":"function"},{"doc":"Returns a list of every nth element in the enumerable dropped, starting with the first element. The first element is always dropped, unless nth is 0. The second argument specifying every nth element must be a non-negative integer. Examples iex&gt; Enum . drop_every ( 1 .. 10 , 2 ) [ 2 , 4 , 6 , 8 , 10 ] iex&gt; Enum . drop_every ( 1 .. 10 , 0 ) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] iex&gt; Enum . drop_every ( [ 1 , 2 , 3 ] , 1 ) [ ]","ref":"Enum.html#drop_every/2","source_doc":"Returns a list of every `nth` element in the `enumerable` dropped,\nstarting with the first element.\n\nThe first element is always dropped, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\n## Examples\n\n    iex> Enum.drop_every(1..10, 2)\n    [2, 4, 6, 8, 10]\n\n    iex> Enum.drop_every(1..10, 0)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n    iex> Enum.drop_every([1, 2, 3], 1)\n    []\n\n","title":"Enum.drop_every/2","type":"function"},{"doc":"Drops elements at the beginning of the enumerable while fun returns a truthy value. Examples iex&gt; Enum . drop_while ( [ 1 , 2 , 3 , 2 , 1 ] , fn x -&gt; x &lt; 3 end ) [ 3 , 2 , 1 ]","ref":"Enum.html#drop_while/2","source_doc":"Drops elements at the beginning of the `enumerable` while `fun` returns a\ntruthy value.\n\n## Examples\n\n    iex> Enum.drop_while([1, 2, 3, 2, 1], fn x -> x < 3 end)\n    [3, 2, 1]\n\n","title":"Enum.drop_while/2","type":"function"},{"doc":"Invokes the given fun for each element in the enumerable . Returns :ok . Examples Enum . each ( [ &quot;some&quot; , &quot;example&quot; ] , fn x -&gt; IO . puts ( x ) end ) &quot;some&quot; &quot;example&quot; #=&gt; :ok","ref":"Enum.html#each/2","source_doc":"Invokes the given `fun` for each element in the `enumerable`.\n\nReturns `:ok`.\n\n## Examples\n\n    Enum.each([\"some\", \"example\"], fn x -> IO.puts(x) end)\n    \"some\"\n    \"example\"\n    #=> :ok\n\n","title":"Enum.each/2","type":"function"},{"doc":"Determines if the enumerable is empty. Returns true if enumerable is empty, otherwise false . Examples iex&gt; Enum . empty? ( [ ] ) true iex&gt; Enum . empty? ( [ 1 , 2 , 3 ] ) false","ref":"Enum.html#empty?/1","source_doc":"Determines if the `enumerable` is empty.\n\nReturns `true` if `enumerable` is empty, otherwise `false`.\n\n## Examples\n\n    iex> Enum.empty?([])\n    true\n\n    iex> Enum.empty?([1, 2, 3])\n    false\n\n","title":"Enum.empty?/1","type":"function"},{"doc":"Finds the element at the given index (zero-based). Returns {:ok, element} if found, otherwise :error . A negative index can be passed, which means the enumerable is enumerated once and the index is counted from the end (for example, -1 fetches the last element). Examples iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , 0 ) { :ok , 2 } iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , - 3 ) { :ok , 2 } iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , 2 ) { :ok , 6 } iex&gt; Enum . fetch ( [ 2 , 4 , 6 ] , 4 ) :error","ref":"Enum.html#fetch/2","source_doc":"Finds the element at the given `index` (zero-based).\n\nReturns `{:ok, element}` if found, otherwise `:error`.\n\nA negative `index` can be passed, which means the `enumerable` is\nenumerated once and the `index` is counted from the end (for example,\n`-1` fetches the last element).\n\n## Examples\n\n    iex> Enum.fetch([2, 4, 6], 0)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], -3)\n    {:ok, 2}\n\n    iex> Enum.fetch([2, 4, 6], 2)\n    {:ok, 6}\n\n    iex> Enum.fetch([2, 4, 6], 4)\n    :error\n\n","title":"Enum.fetch/2","type":"function"},{"doc":"Finds the element at the given index (zero-based). Raises OutOfBoundsError if the given index is outside the range of the enumerable . Examples iex&gt; Enum . fetch! ( [ 2 , 4 , 6 ] , 0 ) 2 iex&gt; Enum . fetch! ( [ 2 , 4 , 6 ] , 2 ) 6 iex&gt; Enum . fetch! ( [ 2 , 4 , 6 ] , 4 ) ** (Enum.OutOfBoundsError) out of bounds error","ref":"Enum.html#fetch!/2","source_doc":"Finds the element at the given `index` (zero-based).\n\nRaises `OutOfBoundsError` if the given `index` is outside the range of\nthe `enumerable`.\n\n## Examples\n\n    iex> Enum.fetch!([2, 4, 6], 0)\n    2\n\n    iex> Enum.fetch!([2, 4, 6], 2)\n    6\n\n    iex> Enum.fetch!([2, 4, 6], 4)\n    ** (Enum.OutOfBoundsError) out of bounds error\n\n","title":"Enum.fetch!/2","type":"function"},{"doc":"Filters the enumerable , i.e. returns only those elements for which fun returns a truthy value. See also reject/2 which discards all elements where the function returns a truthy value. Examples iex&gt; Enum . filter ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) [ 2 ] Keep in mind that filter is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using flat_map/2 . For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass: strings = [ &quot;1234&quot; , &quot;abc&quot; , &quot;12ab&quot; ] Enum . flat_map ( strings , fn string -&gt; case Integer . parse ( string ) do # transform to integer { int , _rest } -&gt; [ int ] # skip the value :error -&gt; [ ] end end )","ref":"Enum.html#filter/2","source_doc":"Filters the `enumerable`, i.e. returns only those elements\nfor which `fun` returns a truthy value.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n## Examples\n\n    iex> Enum.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [2]\n\nKeep in mind that `filter` is not capable of filtering and\ntransforming an element at the same time. If you would like\nto do so, consider using `flat_map/2`. For example, if you\nwant to convert all strings that represent an integer and\ndiscard the invalid one in one pass:\n\n    strings = [\"1234\", \"abc\", \"12ab\"]\n\n    Enum.flat_map(strings, fn string ->\n      case Integer.parse(string) do\n        # transform to integer\n        {int, _rest} -> [int]\n        # skip the value\n        :error -> []\n      end\n    end)\n\n","title":"Enum.filter/2","type":"function"},{"doc":"Returns the first element for which fun returns a truthy value. If no such element is found, returns default . Examples iex&gt; Enum . find ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) 3 iex&gt; Enum . find ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) nil iex&gt; Enum . find ( [ 2 , 4 , 6 ] , 0 , fn x -&gt; rem ( x , 2 ) == 1 end ) 0","ref":"Enum.html#find/3","source_doc":"Returns the first element for which `fun` returns a truthy value.\nIf no such element is found, returns `default`.\n\n## Examples\n\n    iex> Enum.find([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    3\n\n    iex> Enum.find([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n    iex> Enum.find([2, 4, 6], 0, fn x -> rem(x, 2) == 1 end)\n    0\n\n","title":"Enum.find/3","type":"function"},{"doc":"Similar to find/3 , but returns the index (zero-based) of the element instead of the element itself. Examples iex&gt; Enum . find_index ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) nil iex&gt; Enum . find_index ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) 1","ref":"Enum.html#find_index/2","source_doc":"Similar to `find/3`, but returns the index (zero-based)\nof the element instead of the element itself.\n\n## Examples\n\n    iex> Enum.find_index([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_index([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    1\n\n","title":"Enum.find_index/2","type":"function"},{"doc":"Similar to find/3 , but returns the value of the function invocation instead of the element itself. The return value is considered to be found when the result is truthy (neither nil nor false ). Examples iex&gt; Enum . find_value ( [ 2 , 3 , 4 ] , fn x -&gt; ...&gt; if x &gt; 2 , do : x * x ...&gt; end ) 9 iex&gt; Enum . find_value ( [ 2 , 4 , 6 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) nil iex&gt; Enum . find_value ( [ 2 , 3 , 4 ] , fn x -&gt; rem ( x , 2 ) == 1 end ) true iex&gt; Enum . find_value ( [ 1 , 2 , 3 ] , &quot;no bools!&quot; , &amp; is_boolean / 1 ) &quot;no bools!&quot;","ref":"Enum.html#find_value/3","source_doc":"Similar to `find/3`, but returns the value of the function\ninvocation instead of the element itself.\n\nThe return value is considered to be found when the result is truthy\n(neither `nil` nor `false`).\n\n## Examples\n\n    iex> Enum.find_value([2, 3, 4], fn x ->\n    ...>   if x > 2, do: x * x\n    ...> end)\n    9\n\n    iex> Enum.find_value([2, 4, 6], fn x -> rem(x, 2) == 1 end)\n    nil\n\n    iex> Enum.find_value([2, 3, 4], fn x -> rem(x, 2) == 1 end)\n    true\n\n    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n    \"no bools!\"\n\n","title":"Enum.find_value/3","type":"function"},{"doc":"Maps the given fun over enumerable and flattens the result. This function returns a new enumerable built by appending the result of invoking fun on each element of enumerable together; conceptually, this is similar to a combination of map/2 and concat/1 . Examples iex&gt; Enum . flat_map ( [ :a , :b , :c ] , fn x -&gt; [ x , x ] end ) [ :a , :a , :b , :b , :c , :c ] iex&gt; Enum . flat_map ( [ { 1 , 3 } , { 4 , 6 } ] , fn { x , y } -&gt; x .. y end ) [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; Enum . flat_map ( [ :a , :b , :c ] , fn x -&gt; [ [ x ] ] end ) [ [ :a ] , [ :b ] , [ :c ] ]","ref":"Enum.html#flat_map/2","source_doc":"Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new enumerable built by appending the result of invoking `fun`\non each element of `enumerable` together; conceptually, this is similar to a\ncombination of `map/2` and `concat/1`.\n\n## Examples\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [x, x] end)\n    [:a, :a, :b, :b, :c, :c]\n\n    iex> Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -> x..y end)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> Enum.flat_map([:a, :b, :c], fn x -> [[x]] end)\n    [[:a], [:b], [:c]]\n\n","title":"Enum.flat_map/2","type":"function"},{"doc":"Maps and reduces an enumerable , flattening the given results (only one level deep). It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with :halt as first element and the accumulator as second. Examples iex&gt; enumerable = 1 .. 100 iex&gt; n = 3 iex&gt; Enum . flat_map_reduce ( enumerable , 0 , fn x , acc -&gt; ...&gt; if acc &lt; n , do : { [ x ] , acc + 1 } , else : { :halt , acc } ...&gt; end ) { [ 1 , 2 , 3 ] , 3 } iex&gt; Enum . flat_map_reduce ( 1 .. 5 , 0 , fn x , acc -&gt; { [ [ x ] ] , acc + x } end ) { [ [ 1 ] , [ 2 ] , [ 3 ] , [ 4 ] , [ 5 ] ] , 15 }","ref":"Enum.html#flat_map_reduce/3","source_doc":"Maps and reduces an `enumerable`, flattening the given results (only one level deep).\n\nIt expects an accumulator and a function that receives each enumerable\nelement, and must return a tuple containing a new enumerable (often a list)\nwith the new accumulator or a tuple with `:halt` as first element and\nthe accumulator as second.\n\n## Examples\n\n    iex> enumerable = 1..100\n    iex> n = 3\n    iex> Enum.flat_map_reduce(enumerable, 0, fn x, acc ->\n    ...>   if acc < n, do: {[x], acc + 1}, else: {:halt, acc}\n    ...> end)\n    {[1, 2, 3], 3}\n\n    iex> Enum.flat_map_reduce(1..5, 0, fn x, acc -> {[[x]], acc + x} end)\n    {[[1], [2], [3], [4], [5]], 15}\n\n","title":"Enum.flat_map_reduce/3","type":"function"},{"doc":"Returns a map with keys as unique elements of enumerable and values as the count of every element. Examples iex&gt; Enum . frequencies ( ~w{ant buffalo ant ant buffalo dingo} ) %{ &quot;ant&quot; =&gt; 3 , &quot;buffalo&quot; =&gt; 2 , &quot;dingo&quot; =&gt; 1 }","ref":"Enum.html#frequencies/1","source_doc":"Returns a map with keys as unique elements of `enumerable` and values\nas the count of every element.\n\n## Examples\n\n    iex> Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})\n    %{\"ant\" => 3, \"buffalo\" => 2, \"dingo\" => 1}\n\n","title":"Enum.frequencies/1","type":"function"},{"doc":"Returns a map with keys as unique elements given by key_fun and values as the count of every element. Examples iex&gt; Enum . frequencies_by ( ~w{aa aA bb cc} , &amp; String . downcase / 1 ) %{ &quot;aa&quot; =&gt; 2 , &quot;bb&quot; =&gt; 1 , &quot;cc&quot; =&gt; 1 } iex&gt; Enum . frequencies_by ( ~w{aaa aA bbb cc c} , &amp; String . length / 1 ) %{ 3 =&gt; 2 , 2 =&gt; 2 , 1 =&gt; 1 }","ref":"Enum.html#frequencies_by/2","source_doc":"Returns a map with keys as unique elements given by `key_fun` and values\nas the count of every element.\n\n## Examples\n\n    iex> Enum.frequencies_by(~w{aa aA bb cc}, &String.downcase/1)\n    %{\"aa\" => 2, \"bb\" => 1, \"cc\" => 1}\n\n    iex> Enum.frequencies_by(~w{aaa aA bbb cc c}, &String.length/1)\n    %{3 => 2, 2 => 2, 1 => 1}\n\n","title":"Enum.frequencies_by/2","type":"function"},{"doc":"Splits the enumerable into groups based on key_fun . The result is a map where each key is given by key_fun and each value is a list of elements given by value_fun . The order of elements within each list is preserved from the enumerable . However, like all maps, the resulting map is unordered. Examples iex&gt; Enum . group_by ( ~w{ant buffalo cat dingo} , &amp; String . length / 1 ) %{ 3 =&gt; [ &quot;ant&quot; , &quot;cat&quot; ] , 5 =&gt; [ &quot;dingo&quot; ] , 7 =&gt; [ &quot;buffalo&quot; ] } iex&gt; Enum . group_by ( ~w{ant buffalo cat dingo} , &amp; String . length / 1 , &amp; String . first / 1 ) %{ 3 =&gt; [ &quot;a&quot; , &quot;c&quot; ] , 5 =&gt; [ &quot;d&quot; ] , 7 =&gt; [ &quot;b&quot; ] } The key can be any Elixir value. For example, you may use a tuple to group by multiple keys: iex&gt; collection = [ ...&gt; %{ id : 1 , lang : &quot;Elixir&quot; , seq : 1 } , ...&gt; %{ id : 1 , lang : &quot;Java&quot; , seq : 1 } , ...&gt; %{ id : 1 , lang : &quot;Ruby&quot; , seq : 2 } , ...&gt; %{ id : 2 , lang : &quot;Python&quot; , seq : 1 } , ...&gt; %{ id : 2 , lang : &quot;C#&quot; , seq : 2 } , ...&gt; %{ id : 2 , lang : &quot;Haskell&quot; , seq : 2 } , ...&gt; ] iex&gt; Enum . group_by ( collection , &amp; { &amp;1 . id , &amp;1 . seq } ) %{ { 1 , 1 } =&gt; [ %{ id : 1 , lang : &quot;Elixir&quot; , seq : 1 } , %{ id : 1 , lang : &quot;Java&quot; , seq : 1 } ] , { 1 , 2 } =&gt; [ %{ id : 1 , lang : &quot;Ruby&quot; , seq : 2 } ] , { 2 , 1 } =&gt; [ %{ id : 2 , lang : &quot;Python&quot; , seq : 1 } ] , { 2 , 2 } =&gt; [ %{ id : 2 , lang : &quot;C#&quot; , seq : 2 } , %{ id : 2 , lang : &quot;Haskell&quot; , seq : 2 } ] } iex&gt; Enum . group_by ( collection , &amp; { &amp;1 . id , &amp;1 . seq } , &amp; { &amp;1 . id , &amp;1 . lang } ) %{ { 1 , 1 } =&gt; [ { 1 , &quot;Elixir&quot; } , { 1 , &quot;Java&quot; } ] , { 1 , 2 } =&gt; [ { 1 , &quot;Ruby&quot; } ] , { 2 , 1 } =&gt; [ { 2 , &quot;Python&quot; } ] , { 2 , 2 } =&gt; [ { 2 , &quot;C#&quot; } , { 2 , &quot;Haskell&quot; } ] }","ref":"Enum.html#group_by/3","source_doc":"Splits the `enumerable` into groups based on `key_fun`.\n\nThe result is a map where each key is given by `key_fun`\nand each value is a list of elements given by `value_fun`.\nThe order of elements within each list is preserved from the `enumerable`.\nHowever, like all maps, the resulting map is unordered.\n\n## Examples\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n    %{3 => [\"ant\", \"cat\"], 5 => [\"dingo\"], 7 => [\"buffalo\"]}\n\n    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String.first/1)\n    %{3 => [\"a\", \"c\"], 5 => [\"d\"], 7 => [\"b\"]}\n\nThe key can be any Elixir value. For example, you may use a tuple\nto group by multiple keys:\n\n    iex> collection = [\n    ...>   %{id: 1, lang: \"Elixir\", seq: 1},\n    ...>   %{id: 1, lang: \"Java\", seq: 1},\n    ...>   %{id: 1, lang: \"Ruby\", seq: 2},\n    ...>   %{id: 2, lang: \"Python\", seq: 1},\n    ...>   %{id: 2, lang: \"C#\", seq: 2},\n    ...>   %{id: 2, lang: \"Haskell\", seq: 2},\n    ...> ]\n    iex> Enum.group_by(collection, &{&1.id, &1.seq})\n    %{\n      {1, 1} => [%{id: 1, lang: \"Elixir\", seq: 1}, %{id: 1, lang: \"Java\", seq: 1}],\n      {1, 2} => [%{id: 1, lang: \"Ruby\", seq: 2}],\n      {2, 1} => [%{id: 2, lang: \"Python\", seq: 1}],\n      {2, 2} => [%{id: 2, lang: \"C#\", seq: 2}, %{id: 2, lang: \"Haskell\", seq: 2}]\n    }\n    iex> Enum.group_by(collection, &{&1.id, &1.seq}, &{&1.id, &1.lang})\n    %{\n      {1, 1} => [{1, \"Elixir\"}, {1, \"Java\"}],\n      {1, 2} => [{1, \"Ruby\"}],\n      {2, 1} => [{2, \"Python\"}],\n      {2, 2} => [{2, \"C#\"}, {2, \"Haskell\"}]\n    }\n\n","title":"Enum.group_by/3","type":"function"},{"doc":"Intersperses separator between each element of the enumeration. Examples iex&gt; Enum . intersperse ( [ 1 , 2 , 3 ] , 0 ) [ 1 , 0 , 2 , 0 , 3 ] iex&gt; Enum . intersperse ( [ 1 ] , 0 ) [ 1 ] iex&gt; Enum . intersperse ( [ ] , 0 ) [ ]","ref":"Enum.html#intersperse/2","source_doc":"Intersperses `separator` between each element of the enumeration.\n\n## Examples\n\n    iex> Enum.intersperse([1, 2, 3], 0)\n    [1, 0, 2, 0, 3]\n\n    iex> Enum.intersperse([1], 0)\n    [1]\n\n    iex> Enum.intersperse([], 0)\n    []\n\n","title":"Enum.intersperse/2","type":"function"},{"doc":"Inserts the given enumerable into a collectable . Note that passing a non-empty list as the collectable is deprecated. If you're collecting into a non-empty keyword list, consider using Keyword.merge(collectable, Enum.to_list(enumerable)) . If you're collecting into a non-empty list, consider something like Enum.to_list(enumerable) ++ collectable . Examples iex&gt; Enum . into ( [ 1 , 2 ] , [ ] ) [ 1 , 2 ] iex&gt; Enum . into ( [ a : 1 , b : 2 ] , %{ } ) %{ a : 1 , b : 2 } iex&gt; Enum . into ( %{ a : 1 } , %{ b : 2 } ) %{ a : 1 , b : 2 } iex&gt; Enum . into ( [ a : 1 , a : 2 ] , %{ } ) %{ a : 2 }","ref":"Enum.html#into/2","source_doc":"Inserts the given `enumerable` into a `collectable`.\n\nNote that passing a non-empty list as the `collectable` is deprecated.\nIf you're collecting into a non-empty keyword list, consider using\n`Keyword.merge(collectable, Enum.to_list(enumerable))`. If you're collecting\ninto a non-empty list, consider something like `Enum.to_list(enumerable) ++ collectable`.\n\n## Examples\n\n    iex> Enum.into([1, 2], [])\n    [1, 2]\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}\n\n    iex> Enum.into(%{a: 1}, %{b: 2})\n    %{a: 1, b: 2}\n\n    iex> Enum.into([a: 1, a: 2], %{})\n    %{a: 2}\n\n","title":"Enum.into/2","type":"function"},{"doc":"Inserts the given enumerable into a collectable according to the transformation function. Examples iex&gt; Enum . into ( [ 1 , 2 , 3 ] , [ ] , fn x -&gt; x * 3 end ) [ 3 , 6 , 9 ] iex&gt; Enum . into ( %{ a : 1 , b : 2 } , %{ c : 3 } , fn { k , v } -&gt; { k , v * 2 } end ) %{ a : 2 , b : 4 , c : 3 }","ref":"Enum.html#into/3","source_doc":"Inserts the given `enumerable` into a `collectable` according to the\ntransformation function.\n\n## Examples\n\n    iex> Enum.into([1, 2, 3], [], fn x -> x * 3 end)\n    [3, 6, 9]\n\n    iex> Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -> {k, v * 2} end)\n    %{a: 2, b: 4, c: 3}\n\n","title":"Enum.into/3","type":"function"},{"doc":"Joins the given enumerable into a string using joiner as a separator. If joiner is not passed at all, it defaults to an empty string. All elements in the enumerable must be convertible to a string, otherwise an error is raised. Examples iex&gt; Enum . join ( [ 1 , 2 , 3 ] ) &quot;123&quot; iex&gt; Enum . join ( [ 1 , 2 , 3 ] , &quot; = &quot; ) &quot;1 = 2 = 3&quot; iex&gt; Enum . join ( [ [ &quot;a&quot; , &quot;b&quot; ] , [ &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , [ &quot;f&quot; , &quot;g&quot; ] ] , &quot;h&quot; , &quot;i&quot; ] , &quot; &quot; ) &quot;ab cdefg h i&quot;","ref":"Enum.html#join/2","source_doc":"Joins the given `enumerable` into a string using `joiner` as a\nseparator.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements in the `enumerable` must be convertible to a string,\notherwise an error is raised.\n\n## Examples\n\n    iex> Enum.join([1, 2, 3])\n    \"123\"\n\n    iex> Enum.join([1, 2, 3], \" = \")\n    \"1 = 2 = 3\"\n\n    iex> Enum.join([[\"a\", \"b\"], [\"c\", \"d\", \"e\", [\"f\", \"g\"]], \"h\", \"i\"], \" \")\n    \"ab cdefg h i\"\n\n","title":"Enum.join/2","type":"function"},{"doc":"Returns a list where each element is the result of invoking fun on each corresponding element of enumerable . For maps, the function expects a key-value tuple. Examples iex&gt; Enum . map ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) [ 2 , 4 , 6 ] iex&gt; Enum . map ( [ a : 1 , b : 2 ] , fn { k , v } -&gt; { k , - v } end ) [ a : - 1 , b : - 2 ]","ref":"Enum.html#map/2","source_doc":"Returns a list where each element is the result of invoking\n`fun` on each corresponding element of `enumerable`.\n\nFor maps, the function expects a key-value tuple.\n\n## Examples\n\n    iex> Enum.map([1, 2, 3], fn x -> x * 2 end)\n    [2, 4, 6]\n\n    iex> Enum.map([a: 1, b: 2], fn {k, v} -> {k, -v} end)\n    [a: -1, b: -2]\n\n","title":"Enum.map/2","type":"function"},{"doc":"Returns a list of results of invoking fun on every nth element of enumerable , starting with the first element. The first element is always passed to the given function, unless nth is 0 . The second argument specifying every nth element must be a non-negative integer. If nth is 0 , then enumerable is directly converted to a list, without fun being ever applied. Examples iex&gt; Enum . map_every ( 1 .. 10 , 2 , fn x -&gt; x + 1000 end ) [ 1001 , 2 , 1003 , 4 , 1005 , 6 , 1007 , 8 , 1009 , 10 ] iex&gt; Enum . map_every ( 1 .. 10 , 3 , fn x -&gt; x + 1000 end ) [ 1001 , 2 , 3 , 1004 , 5 , 6 , 1007 , 8 , 9 , 1010 ] iex&gt; Enum . map_every ( 1 .. 5 , 0 , fn x -&gt; x + 1000 end ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; Enum . map_every ( [ 1 , 2 , 3 ] , 1 , fn x -&gt; x + 1000 end ) [ 1001 , 1002 , 1003 ]","ref":"Enum.html#map_every/3","source_doc":"Returns a list of results of invoking `fun` on every `nth`\nelement of `enumerable`, starting with the first element.\n\nThe first element is always passed to the given function, unless `nth` is `0`.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\nIf `nth` is `0`, then `enumerable` is directly converted to a list,\nwithout `fun` being ever applied.\n\n## Examples\n\n    iex> Enum.map_every(1..10, 2, fn x -> x + 1000 end)\n    [1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]\n\n    iex> Enum.map_every(1..10, 3, fn x -> x + 1000 end)\n    [1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]\n\n    iex> Enum.map_every(1..5, 0, fn x -> x + 1000 end)\n    [1, 2, 3, 4, 5]\n\n    iex> Enum.map_every([1, 2, 3], 1, fn x -> x + 1000 end)\n    [1001, 1002, 1003]\n\n","title":"Enum.map_every/3","type":"function"},{"doc":"Maps and intersperses the given enumerable in one pass. Examples iex&gt; Enum . map_intersperse ( [ 1 , 2 , 3 ] , :a , &amp; ( &amp;1 * 2 ) ) [ 2 , :a , 4 , :a , 6 ]","ref":"Enum.html#map_intersperse/3","source_doc":"Maps and intersperses the given enumerable in one pass.\n\n## Examples\n\n    iex> Enum.map_intersperse([1, 2, 3], :a, &(&1 * 2))\n    [2, :a, 4, :a, 6]\n","title":"Enum.map_intersperse/3","type":"function"},{"doc":"Maps and joins the given enumerable in one pass. If joiner is not passed at all, it defaults to an empty string. All elements returned from invoking the mapper must be convertible to a string, otherwise an error is raised. Examples iex&gt; Enum . map_join ( [ 1 , 2 , 3 ] , &amp; ( &amp;1 * 2 ) ) &quot;246&quot; iex&gt; Enum . map_join ( [ 1 , 2 , 3 ] , &quot; = &quot; , &amp; ( &amp;1 * 2 ) ) &quot;2 = 4 = 6&quot;","ref":"Enum.html#map_join/3","source_doc":"Maps and joins the given `enumerable` in one pass.\n\nIf `joiner` is not passed at all, it defaults to an empty string.\n\nAll elements returned from invoking the `mapper` must be convertible to\na string, otherwise an error is raised.\n\n## Examples\n\n    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n    \"246\"\n\n    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n    \"2 = 4 = 6\"\n\n","title":"Enum.map_join/3","type":"function"},{"doc":"Invokes the given function to each element in the enumerable to reduce it to a single element, while keeping an accumulator. Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator. The function, fun , receives two arguments: the first one is the element, and the second one is the accumulator. fun must return a tuple with two elements in the form of {result, accumulator} . For maps, the first tuple element must be a {key, value} tuple. Examples iex&gt; Enum . map_reduce ( [ 1 , 2 , 3 ] , 0 , fn x , acc -&gt; { x * 2 , x + acc } end ) { [ 2 , 4 , 6 ] , 6 }","ref":"Enum.html#map_reduce/3","source_doc":"Invokes the given function to each element in the `enumerable` to reduce\nit to a single element, while keeping an accumulator.\n\nReturns a tuple where the first element is the mapped enumerable and\nthe second one is the final accumulator.\n\nThe function, `fun`, receives two arguments: the first one is the\nelement, and the second one is the accumulator. `fun` must return\na tuple with two elements in the form of `{result, accumulator}`.\n\nFor maps, the first tuple element must be a `{key, value}` tuple.\n\n## Examples\n\n    iex> Enum.map_reduce([1, 2, 3], 0, fn x, acc -> {x * 2, x + acc} end)\n    {[2, 4, 6], 6}\n\n","title":"Enum.map_reduce/3","type":"function"},{"doc":"Returns the maximal element in the enumerable according to Erlang's term ordering. By default, the comparison is done with the &gt;= sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements. If the enumerable is empty, the provided empty_fallback is called. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . max ( [ 1 , 2 , 3 ] ) 3 The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example: iex&gt; Enum . max ( [ ~D[2017-03-31] , ~D[2017-04-01] ] ) ~D[2017-03-31] In the example above, max/2 returned March 31st instead of April 1st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; Enum . max ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-04-01] Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . max ( [ ] , &amp; &gt;= / 2 , fn -&gt; 0 end ) 0","ref":"Enum.html#max/3","source_doc":"Returns the maximal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.max([1, 2, 3])\n    3\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-03-31]\n\nIn the example above, `max/2` returned March 31st instead of April 1st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-04-01]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max([], &>=/2, fn -> 0 end)\n    0\n\n","title":"Enum.max/3","type":"function"},{"doc":"Returns the maximal element in the enumerable as calculated by the given fun . By default, the comparison is done with the &gt;= sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements. Calls the provided empty_fallback function and returns its value if enumerable is empty. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . max_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; ] , fn x -&gt; String . length ( x ) end ) &quot;aaa&quot; iex&gt; Enum . max_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; , &quot;b&quot; , &quot;bbb&quot; ] , &amp; String . length / 1 ) &quot;aaa&quot; The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . max_by ( users , &amp; ( &amp;1 . birthday ) , Date ) %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . max_by ( [ ] , &amp; String . length / 1 , fn -&gt; nil end ) nil","ref":"Enum.html#max_by/4","source_doc":"Returns the maximal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `>=` sorter function.\nIf multiple elements are considered maximal, the first one that\nwas found is returned. If you want the last element considered\nmaximal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"aaa\"\n\n    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"aaa\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.max_by(users, &(&1.birthday), Date)\n    %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n    nil\n\n","title":"Enum.max_by/4","type":"function"},{"doc":"Checks if element exists within the enumerable . Membership is tested with the match ( ===/2 ) operator. Examples iex&gt; Enum . member? ( 1 .. 10 , 5 ) true iex&gt; Enum . member? ( 1 .. 10 , 5.0 ) false iex&gt; Enum . member? ( [ 1.0 , 2.0 , 3.0 ] , 2 ) false iex&gt; Enum . member? ( [ 1.0 , 2.0 , 3.0 ] , 2.000 ) true iex&gt; Enum . member? ( [ :a , :b , :c ] , :d ) false When called outside guards, the in and not in operators work by using this function.","ref":"Enum.html#member?/2","source_doc":"Checks if `element` exists within the `enumerable`.\n\nMembership is tested with the match (`===/2`) operator.\n\n## Examples\n\n    iex> Enum.member?(1..10, 5)\n    true\n    iex> Enum.member?(1..10, 5.0)\n    false\n\n    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n    false\n    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n    true\n\n    iex> Enum.member?([:a, :b, :c], :d)\n    false\n\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.\n","title":"Enum.member?/2","type":"function"},{"doc":"Returns the minimal element in the enumerable according to Erlang's term ordering. By default, the comparison is done with the &lt;= sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements. If the enumerable is empty, the provided empty_fallback is called. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . min ( [ 1 , 2 , 3 ] ) 1 The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example: iex&gt; Enum . min ( [ ~D[2017-03-31] , ~D[2017-04-01] ] ) ~D[2017-04-01] In the example above, min/2 returned April 1st instead of March 31st because the structural comparison compares the day before the year. For this reason, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; Enum . min ( [ ~D[2017-03-31] , ~D[2017-04-01] ] , Date ) ~D[2017-03-31] Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . min ( [ ] , fn -&gt; 0 end ) 0","ref":"Enum.html#min/3","source_doc":"Returns the minimal element in the `enumerable` according\nto Erlang's term ordering.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nIf the enumerable is empty, the provided `empty_fallback` is called.\nThe default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min([1, 2, 3])\n    1\n\nThe fact this function uses Erlang's term ordering means that the comparison\nis structural and not semantic. For example:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]])\n    ~D[2017-04-01]\n\nIn the example above, `min/2` returned April 1st instead of March 31st\nbecause the structural comparison compares the day before the year.\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)\n    ~D[2017-03-31]\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min([], fn -> 0 end)\n    0\n\n","title":"Enum.min/3","type":"function"},{"doc":"Returns the minimal element in the enumerable as calculated by the given fun . By default, the comparison is done with the &lt;= sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements. Calls the provided empty_fallback function and returns its value if enumerable is empty. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . min_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; ] , fn x -&gt; String . length ( x ) end ) &quot;a&quot; iex&gt; Enum . min_by ( [ &quot;a&quot; , &quot;aa&quot; , &quot;aaa&quot; , &quot;b&quot; , &quot;bbb&quot; ] , &amp; String . length / 1 ) &quot;a&quot; The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . min_by ( users , &amp; ( &amp;1 . birthday ) , Date ) %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . min_by ( [ ] , &amp; String . length / 1 , fn -&gt; nil end ) nil","ref":"Enum.html#min_by/4","source_doc":"Returns the minimal element in the `enumerable` as calculated\nby the given `fun`.\n\nBy default, the comparison is done with the `<=` sorter function.\nIf multiple elements are considered minimal, the first one that\nwas found is returned. If you want the last element considered\nminimal to be returned, the sorter function should not return true\nfor equal elements.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn x -> String.length(x) end)\n    \"a\"\n\n    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n    \"a\"\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_by(users, &(&1.birthday), Date)\n    %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n    nil\n\n","title":"Enum.min_by/4","type":"function"},{"doc":"Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering. If multiple elements are considered maximal or minimal, the first one that was found is returned. Calls the provided empty_fallback function and returns its value if enumerable is empty. The default empty_fallback raises Enum.EmptyError . Examples iex&gt; Enum . min_max ( [ 2 , 3 , 1 ] ) { 1 , 3 } iex&gt; Enum . min_max ( [ ] , fn -&gt; { nil , nil } end ) { nil , nil }","ref":"Enum.html#min_max/2","source_doc":"Returns a tuple with the minimal and the maximal elements in the\nenumerable according to Erlang's term ordering.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\nCalls the provided `empty_fallback` function and returns its value if\n`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n\n## Examples\n\n    iex> Enum.min_max([2, 3, 1])\n    {1, 3}\n\n    iex> Enum.min_max([], fn -> {nil, nil} end)\n    {nil, nil}\n\n","title":"Enum.min_max/2","type":"function"},{"doc":"Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function. If multiple elements are considered maximal or minimal, the first one that was found is returned. Examples iex&gt; Enum . min_max_by ( [ &quot;aaa&quot; , &quot;bb&quot; , &quot;c&quot; ] , fn x -&gt; String . length ( x ) end ) { &quot;c&quot; , &quot;aaa&quot; } iex&gt; Enum . min_max_by ( [ &quot;aaa&quot; , &quot;a&quot; , &quot;bb&quot; , &quot;c&quot; , &quot;ccc&quot; ] , &amp; String . length / 1 ) { &quot;a&quot; , &quot;aaa&quot; } iex&gt; Enum . min_max_by ( [ ] , &amp; String . length / 1 , fn -&gt; { nil , nil } end ) { nil , nil } The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . min_max_by ( users , &amp; ( &amp;1 . birthday ) , Date ) { %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } } Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback: iex&gt; Enum . min_max_by ( [ ] , &amp; String . length / 1 , fn -&gt; nil end ) nil","ref":"Enum.html#min_max_by/4","source_doc":"Returns a tuple with the minimal and the maximal elements in the\nenumerable as calculated by the given function.\n\nIf multiple elements are considered maximal or minimal, the first one\nthat was found is returned.\n\n## Examples\n\n    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn x -> String.length(x) end)\n    {\"c\", \"aaa\"}\n\n    iex> Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &String.length/1)\n    {\"a\", \"aaa\"}\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> {nil, nil} end)\n    {nil, nil}\n\nThe fact this function uses Erlang's term ordering means that the\ncomparison is structural and not semantic. Therefore, if you want\nto compare structs, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.min_max_by(users, &(&1.birthday), Date)\n    {\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    }\n\nFinally, if you don't want to raise on empty enumerables, you can pass\nthe empty fallback:\n\n    iex> Enum.min_max_by([], &String.length/1, fn -> nil end)\n    nil\n\n","title":"Enum.min_max_by/4","type":"function"},{"doc":"Returns the product of all elements. Raises ArithmeticError if enumerable contains a non-numeric value. Examples iex&gt; Enum . product ( [ ] ) 1 iex&gt; Enum . product ( [ 2 , 3 , 4 ] ) 24 iex&gt; Enum . product ( [ 2.0 , 3.0 , 4.0 ] ) 24.0","ref":"Enum.html#product/1","source_doc":"Returns the product of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.\n\n## Examples\n\n    iex> Enum.product([])\n    1\n    iex> Enum.product([2, 3, 4])\n    24\n    iex> Enum.product([2.0, 3.0, 4.0])\n    24.0\n\n","title":"Enum.product/1","type":"function"},{"doc":"Returns a random element of an enumerable . Raises Enum.EmptyError if enumerable is empty. This function uses Erlang's :rand module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed. The implementation is based on the reservoir sampling algorithm. It assumes that the sample being returned can fit into memory; the input enumerable doesn't have to, as it is traversed just once. If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory). Examples The examples below use the :exsss pseudorandom algorithm since it's the default from Erlang/OTP 22: # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exsss , { 100 , 101 , 102 } ) iex&gt; Enum . random ( [ 1 , 2 , 3 ] ) 2 iex&gt; Enum . random ( [ 1 , 2 , 3 ] ) 1 iex&gt; Enum . random ( 1 .. 1_000 ) 309","ref":"Enum.html#random/1","source_doc":"Returns a random element of an `enumerable`.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\nThe implementation is based on the\n[reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\nalgorithm.\nIt assumes that the sample being returned can fit into memory;\nthe input `enumerable` doesn't have to, as it is traversed just once.\n\nIf a range is passed into the function, this function will pick a\nrandom value between the range limits, without traversing the whole\nrange (thus executing in constant time and constant memory).\n\n## Examples\n\nThe examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {100, 101, 102})\n    iex> Enum.random([1, 2, 3])\n    2\n    iex> Enum.random([1, 2, 3])\n    1\n    iex> Enum.random(1..1_000)\n    309\n\n","title":"Enum.random/1","type":"function"},{"doc":"Invokes fun for each element in the enumerable with the accumulator. Raises Enum.EmptyError if enumerable is empty. The first element of the enumerable is used as the initial value of the accumulator. Then, the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the enumerable is done, the last accumulator is returned. Since the first element of the enumerable is used as the initial value of the accumulator, fun will only be executed n - 1 times where n is the length of the enumerable. This function won't call the specified function for enumerables that are one-element long. If you wish to use another value for the accumulator, use Enum.reduce/3 . Examples iex&gt; Enum . reduce ( [ 1 , 2 , 3 , 4 ] , fn x , acc -&gt; x * acc end ) 24","ref":"Enum.html#reduce/2","source_doc":"Invokes `fun` for each element in the `enumerable` with the\naccumulator.\n\nRaises `Enum.EmptyError` if `enumerable` is empty.\n\nThe first element of the `enumerable` is used as the initial value\nof the accumulator. Then, the function is invoked with the next\nelement and the accumulator. The result returned by the function\nis used as the accumulator for the next iteration, recursively.\nWhen the `enumerable` is done, the last accumulator is returned.\n\nSince the first element of the enumerable is used as the initial\nvalue of the accumulator, `fun` will only be executed `n - 1` times\nwhere `n` is the length of the enumerable. This function won't call\nthe specified function for enumerables that are one-element long.\n\nIf you wish to use another value for the accumulator, use\n`Enum.reduce/3`.\n\n## Examples\n\n    iex> Enum.reduce([1, 2, 3, 4], fn x, acc -> x * acc end)\n    24\n\n","title":"Enum.reduce/2","type":"function"},{"doc":"Invokes fun for each element in the enumerable with the accumulator. The initial value of the accumulator is acc . The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator. Examples iex&gt; Enum . reduce ( [ 1 , 2 , 3 ] , 0 , fn x , acc -&gt; x + acc end ) 6 iex&gt; Enum . reduce ( %{ a : 2 , b : 3 , c : 4 } , 0 , fn { _key , val } , acc -&gt; acc + val end ) 9 Reduce as a building block Reduce (sometimes called fold ) is a basic building block in functional programming. Almost all of the functions in the Enum module can be implemented on top of reduce. Those functions often rely on other operations, such as Enum.reverse/1 , which are optimized by the runtime. For example, we could implement map/2 in terms of reduce/3 as follows: def my_map ( enumerable , fun ) do enumerable |&gt; Enum . reduce ( [ ] , fn x , acc -&gt; [ fun . ( x ) | acc ] end ) |&gt; Enum . reverse ( ) end In the example above, Enum.reduce/3 accumulates the result of each call to fun into a list in reverse order, which is correctly ordered at the end by calling Enum.reverse/1 . Implementing functions like map/2 , filter/2 and others are a good exercise for understanding the power behind Enum.reduce/3 . When an operation cannot be expressed by any of the functions in the Enum module, developers will most likely resort to reduce/3 .","ref":"Enum.html#reduce/3","source_doc":"Invokes `fun` for each element in the `enumerable` with the accumulator.\n\nThe initial value of the accumulator is `acc`. The function is invoked for\neach element in the enumerable with the accumulator. The result returned\nby the function is used as the accumulator for the next iteration.\nThe function returns the last accumulator.\n\n## Examples\n\n    iex> Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)\n    6\n\n    iex> Enum.reduce(%{a: 2, b: 3, c: 4}, 0, fn {_key, val}, acc -> acc + val end)\n    9\n\n## Reduce as a building block\n\nReduce (sometimes called `fold`) is a basic building block in functional\nprogramming. Almost all of the functions in the `Enum` module can be\nimplemented on top of reduce. Those functions often rely on other operations,\nsuch as `Enum.reverse/1`, which are optimized by the runtime.\n\nFor example, we could implement `map/2` in terms of `reduce/3` as follows:\n\n    def my_map(enumerable, fun) do\n      enumerable\n      |> Enum.reduce([], fn x, acc -> [fun.(x) | acc] end)\n      |> Enum.reverse()\n    end\n\nIn the example above, `Enum.reduce/3` accumulates the result of each call\nto `fun` into a list in reverse order, which is correctly ordered at the\nend by calling `Enum.reverse/1`.\n\nImplementing functions like `map/2`, `filter/2` and others are a good\nexercise for understanding the power behind `Enum.reduce/3`. When an\noperation cannot be expressed by any of the functions in the `Enum`\nmodule, developers will most likely resort to `reduce/3`.\n","title":"Enum.reduce/3","type":"function"},{"doc":"Reduces enumerable until fun returns {:halt, term} . The return value for fun is expected to be {:cont, acc} to continue the reduction with acc as the new accumulator or {:halt, acc} to halt the reduction If fun returns {:halt, acc} the reduction is halted and the function returns acc . Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last {:cont, acc} . Examples iex&gt; Enum . reduce_while ( 1 .. 100 , 0 , fn x , acc -&gt; ...&gt; if x &lt; 5 do ...&gt; { :cont , acc + x } ...&gt; else ...&gt; { :halt , acc } ...&gt; end ...&gt; end ) 10 iex&gt; Enum . reduce_while ( 1 .. 100 , 0 , fn x , acc -&gt; ...&gt; if x &gt; 0 do ...&gt; { :cont , acc + x } ...&gt; else ...&gt; { :halt , acc } ...&gt; end ...&gt; end ) 5050","ref":"Enum.html#reduce_while/3","source_doc":"Reduces `enumerable` until `fun` returns `{:halt, term}`.\n\nThe return value for `fun` is expected to be\n\n  * `{:cont, acc}` to continue the reduction with `acc` as the new\n    accumulator or\n  * `{:halt, acc}` to halt the reduction\n\nIf `fun` returns `{:halt, acc}` the reduction is halted and the function\nreturns `acc`. Otherwise, if the enumerable is exhausted, the function returns\nthe accumulator of the last `{:cont, acc}`.\n\n## Examples\n\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x < 5 do\n    ...>     {:cont, acc + x}\n    ...>   else\n    ...>     {:halt, acc}\n    ...>   end\n    ...> end)\n    10\n    iex> Enum.reduce_while(1..100, 0, fn x, acc ->\n    ...>   if x > 0 do\n    ...>     {:cont, acc + x}\n    ...>   else\n    ...>     {:halt, acc}\n    ...>   end\n    ...> end)\n    5050\n\n","title":"Enum.reduce_while/3","type":"function"},{"doc":"Returns a list of elements in enumerable excluding those for which the function fun returns a truthy value. See also filter/2 . Examples iex&gt; Enum . reject ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) [ 1 , 3 ]","ref":"Enum.html#reject/2","source_doc":"Returns a list of elements in `enumerable` excluding those for which the function `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Enum.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    [1, 3]\n\n","title":"Enum.reject/2","type":"function"},{"doc":"Returns a list of elements in enumerable in reverse order. Examples iex&gt; Enum . reverse ( [ 1 , 2 , 3 ] ) [ 3 , 2 , 1 ]","ref":"Enum.html#reverse/1","source_doc":"Returns a list of elements in `enumerable` in reverse order.\n\n## Examples\n\n    iex> Enum.reverse([1, 2, 3])\n    [3, 2, 1]\n\n","title":"Enum.reverse/1","type":"function"},{"doc":"Reverses the elements in enumerable , appends the tail , and returns it as a list. This is an optimization for enumerable |&gt; Enum.reverse() |&gt; Enum.concat(tail) . Examples iex&gt; Enum . reverse ( [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ) [ 3 , 2 , 1 , 4 , 5 , 6 ]","ref":"Enum.html#reverse/2","source_doc":"Reverses the elements in `enumerable`, appends the `tail`, and returns\nit as a list.\n\nThis is an optimization for\n`enumerable |> Enum.reverse() |> Enum.concat(tail)`.\n\n## Examples\n\n    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n    [3, 2, 1, 4, 5, 6]\n\n","title":"Enum.reverse/2","type":"function"},{"doc":"Reverses the enumerable in the range from initial start_index through count elements. If count is greater than the size of the rest of the enumerable , then this function will reverse the rest of the enumerable. Examples iex&gt; Enum . reverse_slice ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 2 , 4 ) [ 1 , 2 , 6 , 5 , 4 , 3 ]","ref":"Enum.html#reverse_slice/3","source_doc":"Reverses the `enumerable` in the range from initial `start_index`\nthrough `count` elements.\n\nIf `count` is greater than the size of the rest of the `enumerable`,\nthen this function will reverse the rest of the enumerable.\n\n## Examples\n\n    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n    [1, 2, 6, 5, 4, 3]\n\n","title":"Enum.reverse_slice/3","type":"function"},{"doc":"Applies the given function to each element in the enumerable , storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the enumerable as the starting value. Examples iex&gt; Enum . scan ( 1 .. 5 , &amp; ( &amp;1 + &amp;2 ) ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Enum.html#scan/2","source_doc":"Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the first element in the `enumerable`\nas the starting value.\n\n## Examples\n\n    iex> Enum.scan(1..5, &(&1 + &2))\n    [1, 3, 6, 10, 15]\n\n","title":"Enum.scan/2","type":"function"},{"doc":"Applies the given function to each element in the enumerable , storing the result in a list and passing it as the accumulator for the next computation. Uses the given acc as the starting value. Examples iex&gt; Enum . scan ( 1 .. 5 , 0 , &amp; ( &amp;1 + &amp;2 ) ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Enum.html#scan/3","source_doc":"Applies the given function to each element in the `enumerable`,\nstoring the result in a list and passing it as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> Enum.scan(1..5, 0, &(&1 + &2))\n    [1, 3, 6, 10, 15]\n\n","title":"Enum.scan/3","type":"function"},{"doc":"Returns a list with the elements of enumerable shuffled. This function uses Erlang's :rand module to calculate the random value. Check its documentation for setting a different random algorithm or a different seed. Examples The examples below use the :exsss pseudorandom algorithm since it's the default from Erlang/OTP 22: # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exsss , { 1 , 2 , 3 } ) iex&gt; Enum . shuffle ( [ 1 , 2 , 3 ] ) [ 3 , 2 , 1 ] iex&gt; Enum . shuffle ( [ 1 , 2 , 3 ] ) [ 2 , 1 , 3 ]","ref":"Enum.html#shuffle/1","source_doc":"Returns a list with the elements of `enumerable` shuffled.\n\nThis function uses Erlang's [`:rand` module](`:rand`) to calculate\nthe random value. Check its documentation for setting a\ndifferent random algorithm or a different seed.\n\n## Examples\n\nThe examples below use the `:exsss` pseudorandom algorithm since it's\nthe default from Erlang/OTP 22:\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.shuffle([1, 2, 3])\n    [3, 2, 1]\n    iex> Enum.shuffle([1, 2, 3])\n    [2, 1, 3]\n\n","title":"Enum.shuffle/1","type":"function"},{"doc":"Returns a subset list of the given enumerable by index_range . index_range must be a Range . Given an enumerable , it drops elements before index_range.first (zero-base), then it takes elements until element index_range.last (inclusively). Indexes are normalized, meaning that negative indexes will be counted from the end (for example, -1 means the last element of the enumerable ). If index_range.last is out of bounds, then it is assigned as the index of the last element. If the normalized index_range.first is out of bounds of the given enumerable , or this one is greater than the normalized index_range.last , then [] is returned. If a step n (other than 1 ) is used in index_range , then it takes every n th element from index_range.first to index_range.last (according to the same rules described above). Examples iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , 1 .. 3 ) [ 2 , 3 , 4 ] iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , 3 .. 10 ) [ 4 , 5 ] # Last three elements (negative indexes) iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , - 3 .. - 1 ) [ 3 , 4 , 5 ] For ranges where start &gt; stop , you need to explicit mark them as increasing: iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , 1 .. - 2 // 1 ) [ 2 , 3 , 4 ] The step can be any positive number. For example, to get every 2 elements of the collection: iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , 0 .. - 1 // 2 ) [ 1 , 3 , 5 ] To get every third element of the first ten elements: iex&gt; integers = Enum . to_list ( 1 .. 20 ) iex&gt; Enum . slice ( integers , 0 .. 9 // 3 ) [ 1 , 4 , 7 , 10 ] If the first position is after the end of the enumerable or after the last position of the range, it returns an empty list: iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , 6 .. 10 ) [ ] # first is greater than last iex&gt; Enum . slice ( [ 1 , 2 , 3 , 4 , 5 ] , 6 .. 5 ) [ ]","ref":"Enum.html#slice/2","source_doc":"Returns a subset list of the given `enumerable` by `index_range`.\n\n`index_range` must be a `Range`. Given an `enumerable`, it drops\nelements before `index_range.first` (zero-base), then it takes elements\nuntil element `index_range.last` (inclusively).\n\nIndexes are normalized, meaning that negative indexes will be counted\nfrom the end (for example, `-1` means the last element of the `enumerable`).\n\nIf `index_range.last` is out of bounds, then it is assigned as the index\nof the last element.\n\nIf the normalized `index_range.first` is out of bounds of the given\n`enumerable`, or this one is greater than the normalized `index_range.last`,\nthen `[]` is returned.\n\nIf a step `n` (other than `1`) is used in `index_range`, then it takes\nevery `n`th element from `index_range.first` to `index_range.last`\n(according to the same rules described above).\n\n## Examples\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..3)\n    [2, 3, 4]\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 3..10)\n    [4, 5]\n\n    # Last three elements (negative indexes)\n    iex> Enum.slice([1, 2, 3, 4, 5], -3..-1)\n    [3, 4, 5]\n\nFor ranges where `start > stop`, you need to explicit\nmark them as increasing:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 1..-2//1)\n    [2, 3, 4]\n\nThe step can be any positive number. For example, to\nget every 2 elements of the collection:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 0..-1//2)\n    [1, 3, 5]\n\nTo get every third element of the first ten elements:\n\n    iex> integers = Enum.to_list(1..20)\n    iex> Enum.slice(integers, 0..9//3)\n    [1, 4, 7, 10]\n\nIf the first position is after the end of the enumerable\nor after the last position of the range, it returns an\nempty list:\n\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..10)\n    []\n\n    # first is greater than last\n    iex> Enum.slice([1, 2, 3, 4, 5], 6..5)\n    []\n\n","title":"Enum.slice/2","type":"function"},{"doc":"Returns a subset list of the given enumerable , from start_index (zero-based) with amount number of elements if available. Given an enumerable , it drops elements right before element start_index ; then, it takes amount of elements, returning as many elements as possible if there are not enough elements. A negative start_index can be passed, which means the enumerable is enumerated once and the index is counted from the end (for example, -1 starts slicing from the last element). It returns [] if amount is 0 or if start_index is out of bounds. Examples iex&gt; Enum . slice ( 1 .. 100 , 5 , 10 ) [ 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ] # amount to take is greater than the number of elements iex&gt; Enum . slice ( 1 .. 10 , 5 , 100 ) [ 6 , 7 , 8 , 9 , 10 ] iex&gt; Enum . slice ( 1 .. 10 , 5 , 0 ) [ ] # using a negative start index iex&gt; Enum . slice ( 1 .. 10 , - 6 , 3 ) [ 5 , 6 , 7 ] iex&gt; Enum . slice ( 1 .. 10 , - 11 , 5 ) [ 1 , 2 , 3 , 4 , 5 ] # out of bound start index iex&gt; Enum . slice ( 1 .. 10 , 10 , 5 ) [ ]","ref":"Enum.html#slice/3","source_doc":"Returns a subset list of the given `enumerable`, from `start_index` (zero-based)\nwith `amount` number of elements if available.\n\nGiven an `enumerable`, it drops elements right before element `start_index`;\nthen, it takes `amount` of elements, returning as many elements as possible if\nthere are not enough elements.\n\nA negative `start_index` can be passed, which means the `enumerable` is\nenumerated once and the index is counted from the end (for example,\n`-1` starts slicing from the last element).\n\nIt returns `[]` if `amount` is `0` or if `start_index` is out of bounds.\n\n## Examples\n\n    iex> Enum.slice(1..100, 5, 10)\n    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n    # amount to take is greater than the number of elements\n    iex> Enum.slice(1..10, 5, 100)\n    [6, 7, 8, 9, 10]\n\n    iex> Enum.slice(1..10, 5, 0)\n    []\n\n    # using a negative start index\n    iex> Enum.slice(1..10, -6, 3)\n    [5, 6, 7]\n    iex> Enum.slice(1..10, -11, 5)\n    [1, 2, 3, 4, 5]\n\n    # out of bound start index\n    iex> Enum.slice(1..10, 10, 5)\n    []\n\n","title":"Enum.slice/3","type":"function"},{"doc":"Slides a single or multiple elements given by range_or_single_index from enumerable to insertion_index . The semantics of the range to be moved match the semantics of Enum.slice/2 . Specifically, that means: Indices are normalized, meaning that negative indexes will be counted from the end (for example, -1 means the last element of the enumerable). This will result in two traversals of your enumerable on types like lists that don't provide a constant-time count. If the normalized index range's last is out of bounds, the range is truncated to the last element. If the normalized index range's first is out of bounds, the selected range for sliding will be empty, so you'll get back your input list. Decreasing ranges (such as 5..0//1 ) also select an empty range to be moved, so you'll get back your input list. Ranges with any step but 1 will raise an error. Examples # Slide a single element iex&gt; Enum . slide ( [ :a , :b , :c , :d , :e , :f , :g ] , 5 , 1 ) [ :a , :f , :b , :c , :d , :e , :g ] # Slide a range of elements backward iex&gt; Enum . slide ( [ :a , :b , :c , :d , :e , :f , :g ] , 3 .. 5 , 1 ) [ :a , :d , :e , :f , :b , :c , :g ] # Slide a range of elements forward iex&gt; Enum . slide ( [ :a , :b , :c , :d , :e , :f , :g ] , 1 .. 3 , 5 ) [ :a , :e , :f , :b , :c , :d , :g ] # Slide with negative indices (counting from the end) iex&gt; Enum . slide ( [ :a , :b , :c , :d , :e , :f , :g ] , 3 .. - 1 // 1 , 2 ) [ :a , :b , :d , :e , :f , :g , :c ] iex&gt; Enum . slide ( [ :a , :b , :c , :d , :e , :f , :g ] , - 4 .. - 2 , 1 ) [ :a , :d , :e , :f , :b , :c , :g ] # Insert at negative indices (counting from the end) iex&gt; Enum . slide ( [ :a , :b , :c , :d , :e , :f , :g ] , 3 , - 1 ) [ :a , :b , :c , :e , :f , :g , :d ]","ref":"Enum.html#slide/3","source_doc":"Slides a single or multiple elements given by `range_or_single_index` from `enumerable`\nto `insertion_index`.\n\nThe semantics of the range to be moved match the semantics of `Enum.slice/2`.\nSpecifically, that means:\n\n * Indices are normalized, meaning that negative indexes will be counted from the end\n    (for example, -1 means the last element of the enumerable). This will result in *two*\n    traversals of your enumerable on types like lists that don't provide a constant-time count.\n\n  * If the normalized index range's `last` is out of bounds, the range is truncated to the last element.\n\n  * If the normalized index range's `first` is out of bounds, the selected range for sliding\n    will be empty, so you'll get back your input list.\n\n  * Decreasing ranges (such as `5..0//1`) also select an empty range to be moved,\n    so you'll get back your input list.\n\n  * Ranges with any step but 1 will raise an error.\n\n## Examples\n\n    # Slide a single element\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 5, 1)\n    [:a, :f, :b, :c, :d, :e, :g]\n\n    # Slide a range of elements backward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..5, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Slide a range of elements forward\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 1..3, 5)\n    [:a, :e, :f, :b, :c, :d, :g]\n\n    # Slide with negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..-1//1, 2)\n    [:a, :b, :d, :e, :f, :g, :c]\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], -4..-2, 1)\n    [:a, :d, :e, :f, :b, :c, :g]\n\n    # Insert at negative indices (counting from the end)\n    iex> Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3, -1)\n    [:a, :b, :c, :e, :f, :g, :d]\n\n","title":"Enum.slide/3","type":"function"},{"doc":"Sorts the enumerable according to Erlang's term ordering. This function uses the merge sort algorithm. Do not use this function to sort structs, see sort/2 for more information. Examples iex&gt; Enum . sort ( [ 3 , 2 , 1 ] ) [ 1 , 2 , 3 ]","ref":"Enum.html#sort/1","source_doc":"Sorts the `enumerable` according to Erlang's term ordering.\n\nThis function uses the merge sort algorithm. Do not use this\nfunction to sort structs, see `sort/2` for more information.\n\n## Examples\n\n    iex> Enum.sort([3, 2, 1])\n    [1, 2, 3]\n\n","title":"Enum.sort/1","type":"function"},{"doc":"Sorts the enumerable by the given function. This function uses the merge sort algorithm. The given function should compare two arguments, and return true if the first argument precedes or is in the same place as the second one. Examples iex&gt; Enum . sort ( [ 1 , 2 , 3 ] , &amp; ( &amp;1 &gt;= &amp;2 ) ) [ 3 , 2 , 1 ] The sorting algorithm will be stable as long as the given function returns true for values considered equal: iex&gt; Enum . sort ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; ( byte_size ( &amp;1 ) &lt;= byte_size ( &amp;2 ) ) ) [ &quot;of&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;monster&quot; ] If the function does not return true for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example: iex&gt; Enum . sort ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; ( byte_size ( &amp;1 ) &lt; byte_size ( &amp;2 ) ) ) [ &quot;of&quot; , &quot;kind&quot; , &quot;some&quot; , &quot;monster&quot; ] Ascending and descending (since v1.10.0) sort/2 allows a developer to pass :asc or :desc as the sorter, which is a convenience for &amp;&lt;=/2 and &amp;&gt;=/2 respectively. iex&gt; Enum . sort ( [ 2 , 3 , 1 ] , :asc ) [ 1 , 2 , 3 ] iex&gt; Enum . sort ( [ 2 , 3 , 1 ] , :desc ) [ 3 , 2 , 1 ] Sorting structs Do not use &lt;/2 , &lt;=/2 , &gt;/2 , &gt;=/2 and friends when sorting structs. That's because the built-in operators above perform structural comparison and not a semantic one. Imagine we sort the following list of dates: iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates ) [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] Note that the returned result is incorrect, because sort/1 by default uses &lt;=/2 , which will compare their structure. When comparing structures, the fields are compared in alphabetical order, which means the dates above will be compared by day , month and then year , which is the opposite of what we want. For this reason, most structs provide a &quot;compare&quot; function, such as Date.compare/2 , which receives two structs and returns :lt (less-than), :eq (equal to), and :gt (greater-than). If you pass a module as the sorting function, Elixir will automatically use the compare/2 function of said module: iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates , Date ) [ ~D[2019-01-01] , ~D[2019-06-06] , ~D[2020-03-02] ] To retrieve all dates in descending order, you can wrap the module in a tuple with :asc or :desc as first element: iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates , { :asc , Date } ) [ ~D[2019-01-01] , ~D[2019-06-06] , ~D[2020-03-02] ] iex&gt; dates = [ ~D[2019-01-01] , ~D[2020-03-02] , ~D[2019-06-06] ] iex&gt; Enum . sort ( dates , { :desc , Date } ) [ ~D[2020-03-02] , ~D[2019-06-06] , ~D[2019-01-01] ]","ref":"Enum.html#sort/2","source_doc":"Sorts the `enumerable` by the given function.\n\nThis function uses the merge sort algorithm. The given function should compare\ntwo arguments, and return `true` if the first argument precedes or is in the\nsame place as the second one.\n\n## Examples\n\n    iex> Enum.sort([1, 2, 3], &(&1 >= &2))\n    [3, 2, 1]\n\nThe sorting algorithm will be stable as long as the given function\nreturns `true` for values considered equal:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2)))\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nIf the function does not return `true` for equal values, the sorting\nis not stable and the order of equal terms may be shuffled.\nFor example:\n\n    iex> Enum.sort([\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2)))\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\n## Ascending and descending (since v1.10.0)\n\n`sort/2` allows a developer to pass `:asc` or `:desc` as the sorter, which is a convenience for\n[`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively.\n\n    iex> Enum.sort([2, 3, 1], :asc)\n    [1, 2, 3]\n    iex> Enum.sort([2, 3, 1], :desc)\n    [3, 2, 1]\n\n## Sorting structs\n\nDo not use `</2`, `<=/2`, `>/2`, `>=/2` and friends when sorting structs.\nThat's because the built-in operators above perform structural comparison\nand not a semantic one. Imagine we sort the following list of dates:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates)\n    [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n\nNote that the returned result is incorrect, because `sort/1` by default uses\n`<=/2`, which will compare their structure. When comparing structures, the\nfields are compared in alphabetical order, which means the dates above will\nbe compared by `day`, `month` and then `year`, which is the opposite of what\nwe want.\n\nFor this reason, most structs provide a \"compare\" function, such as\n`Date.compare/2`, which receives two structs and returns `:lt` (less-than),\n`:eq` (equal to), and `:gt` (greater-than). If you pass a module as the\nsorting function, Elixir will automatically use the `compare/2` function\nof said module:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, Date)\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n\nTo retrieve all dates in descending order, you can wrap the module in\na tuple with `:asc` or `:desc` as first element:\n\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:asc, Date})\n    [~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]\n    iex> dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]\n    iex> Enum.sort(dates, {:desc, Date})\n    [~D[2020-03-02], ~D[2019-06-06], ~D[2019-01-01]]\n\n","title":"Enum.sort/2","type":"function"},{"doc":"Sorts the mapped results of the enumerable according to the provided sorter function. This function maps each element of the enumerable using the provided mapper function. The enumerable is then sorted by the mapped elements using the sorter , which defaults to :asc and sorts the elements ascendingly. sort_by/3 differs from sort/2 in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both elements, it's more efficient to use sort_by/3 . Ascending and descending (since v1.10.0) sort_by/3 allows a developer to pass :asc or :desc as the sorter, which is a convenience for &amp;&lt;=/2 and &amp;&gt;=/2 respectively: iex&gt; Enum . sort_by ( [ 2 , 3 , 1 ] , &amp; ( &amp;1 ) , :asc ) [ 1 , 2 , 3 ] iex&gt; Enum . sort_by ( [ 2 , 3 , 1 ] , &amp; ( &amp;1 ) , :desc ) [ 3 , 2 , 1 ] Examples Using the default sorter of :asc : iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; byte_size / 1 ) [ &quot;of&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;monster&quot; ] Sorting by multiple properties - first by size, then by first letter (this takes advantage of the fact that tuples are compared element-by-element): iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; { byte_size ( &amp;1 ) , String . first ( &amp;1 ) } ) [ &quot;of&quot; , &quot;kind&quot; , &quot;some&quot; , &quot;monster&quot; ] Similar to sort/2 , you can pass a custom sorter: iex&gt; Enum . sort_by ( [ &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; , &quot;monster&quot; ] , &amp; byte_size / 1 , :desc ) [ &quot;monster&quot; , &quot;some&quot; , &quot;kind&quot; , &quot;of&quot; ] As in sort/2 , avoid using the default sorting function to sort structs, as by default it performs structural comparison instead of a semantic one. In such cases, you shall pass a sorting function as third element or any module that implements a compare/2 function. For example, to sort users by their birthday in both ascending and descending order respectively: iex&gt; users = [ ...&gt; %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , ...&gt; %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , ...&gt; %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } ...&gt; ] iex&gt; Enum . sort_by ( users , &amp; ( &amp;1 . birthday ) , Date ) [ %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } , %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } , %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } ] iex&gt; Enum . sort_by ( users , &amp; ( &amp;1 . birthday ) , { :desc , Date } ) [ %{ name : &quot;Ellis&quot; , birthday : ~D[1943-05-11] } , %{ name : &quot;Turing&quot; , birthday : ~D[1912-06-23] } , %{ name : &quot;Lovelace&quot; , birthday : ~D[1815-12-10] } ] Performance characteristics As detailed in the initial section, sort_by/3 calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. This implies sort_by/3 must do an initial pass on the data to compute those values. However, if those values are cheap to compute, for example, you have already extracted the field you want to sort by into a tuple, then those extra passes become overhead. In such cases, consider using List.keysort/3 instead. Let's see an example. Imagine you have a list of products and you have a list of IDs. You want to keep all products that are in the given IDs and return their names sorted by their price. You could write it like this: for ( product &lt;- products , product . id in ids , do : product ) |&gt; Enum . sort_by ( &amp; &amp;1 . price ) |&gt; Enum . map ( &amp; &amp;1 . name ) However, you could also write it like this: for ( product &lt;- products , product . id in ids , do : { product . name , product . price } ) |&gt; List . keysort ( 1 ) |&gt; Enum . map ( &amp; elem ( &amp;1 , 0 ) ) Using List.keysort/3 will be a better choice for performance sensitive code as it avoids additional traversals.","ref":"Enum.html#sort_by/3","source_doc":"Sorts the mapped results of the `enumerable` according to the provided `sorter`\nfunction.\n\nThis function maps each element of the `enumerable` using the\nprovided `mapper` function. The enumerable is then sorted by\nthe mapped elements using the `sorter`, which defaults to `:asc`\nand sorts the elements ascendingly.\n\n`sort_by/3` differs from `sort/2` in that it only calculates the\ncomparison value for each element in the enumerable once instead of\nonce for each element in each comparison. If the same function is\nbeing called on both elements, it's more efficient to use `sort_by/3`.\n\n## Ascending and descending (since v1.10.0)\n\n`sort_by/3` allows a developer to pass `:asc` or `:desc` as the sorter,\nwhich is a convenience for [`&<=/2`](`<=/2`) and [`&>=/2`](`>=/2`) respectively:\n    iex> Enum.sort_by([2, 3, 1], &(&1), :asc)\n    [1, 2, 3]\n\n    iex> Enum.sort_by([2, 3, 1], &(&1), :desc)\n    [3, 2, 1]\n\n## Examples\n\nUsing the default `sorter` of `:asc` :\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1)\n    [\"of\", \"some\", \"kind\", \"monster\"]\n\nSorting by multiple properties - first by size, then by first letter\n(this takes advantage of the fact that tuples are compared element-by-element):\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &{byte_size(&1), String.first(&1)})\n    [\"of\", \"kind\", \"some\", \"monster\"]\n\nSimilar to `sort/2`, you can pass a custom sorter:\n\n    iex> Enum.sort_by([\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, :desc)\n    [\"monster\", \"some\", \"kind\", \"of\"]\n\nAs in `sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of\na semantic one. In such cases, you shall pass a sorting function as\nthird element or any module that implements a `compare/2` function.\nFor example, to sort users by their birthday in both ascending and\ndescending order respectively:\n\n    iex> users = [\n    ...>   %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n    ...>   %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n    ...>   %{name: \"Turing\", birthday: ~D[1912-06-23]}\n    ...> ]\n    iex> Enum.sort_by(users, &(&1.birthday), Date)\n    [\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]}\n    ]\n    iex> Enum.sort_by(users, &(&1.birthday), {:desc, Date})\n    [\n      %{name: \"Ellis\", birthday: ~D[1943-05-11]},\n      %{name: \"Turing\", birthday: ~D[1912-06-23]},\n      %{name: \"Lovelace\", birthday: ~D[1815-12-10]}\n    ]\n\n## Performance characteristics\n\nAs detailed in the initial section, `sort_by/3` calculates the comparison\nvalue for each element in the enumerable once instead of once for each\nelement in each comparison. This implies `sort_by/3` must do an initial\npass on the data to compute those values.\n\nHowever, if those values are cheap to compute, for example, you have\nalready extracted the field you want to sort by into a tuple, then those\nextra passes become overhead. In such cases, consider using `List.keysort/3`\ninstead.\n\nLet's see an example. Imagine you have a list of products and you have a\nlist of IDs. You want to keep all products that are in the given IDs and\nreturn their names sorted by their price. You could write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: product\n    )\n    |> Enum.sort_by(& &1.price)\n    |> Enum.map(& &1.name)\n\nHowever, you could also write it like this:\n\n    for(\n      product <- products,\n      product.id in ids,\n      do: {product.name, product.price}\n    )\n    |> List.keysort(1)\n    |> Enum.map(&elem(&1, 0))\n\nUsing `List.keysort/3` will be a better choice for performance sensitive\ncode as it avoids additional traversals.\n","title":"Enum.sort_by/3","type":"function"},{"doc":"Splits the enumerable into two enumerables, leaving count elements in the first one. If count is a negative number, it starts counting from the back to the beginning of the enumerable . Be aware that a negative count implies the enumerable will be enumerated twice: once to calculate the position, and a second time to do the actual splitting. Examples iex&gt; Enum . split ( [ 1 , 2 , 3 ] , 2 ) { [ 1 , 2 ] , [ 3 ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , 10 ) { [ 1 , 2 , 3 ] , [ ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , 0 ) { [ ] , [ 1 , 2 , 3 ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , - 1 ) { [ 1 , 2 ] , [ 3 ] } iex&gt; Enum . split ( [ 1 , 2 , 3 ] , - 5 ) { [ ] , [ 1 , 2 , 3 ] }","ref":"Enum.html#split/2","source_doc":"Splits the `enumerable` into two enumerables, leaving `count`\nelements in the first one.\n\nIf `count` is a negative number, it starts counting from the\nback to the beginning of the `enumerable`.\n\nBe aware that a negative `count` implies the `enumerable`\nwill be enumerated twice: once to calculate the position, and\na second time to do the actual splitting.\n\n## Examples\n\n    iex> Enum.split([1, 2, 3], 2)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], 10)\n    {[1, 2, 3], []}\n\n    iex> Enum.split([1, 2, 3], 0)\n    {[], [1, 2, 3]}\n\n    iex> Enum.split([1, 2, 3], -1)\n    {[1, 2], [3]}\n\n    iex> Enum.split([1, 2, 3], -5)\n    {[], [1, 2, 3]}\n\n","title":"Enum.split/2","type":"function"},{"doc":"Splits enumerable in two at the position of the element for which fun returns a falsy value ( false or nil ) for the first time. It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list. Examples iex&gt; Enum . split_while ( [ 1 , 2 , 3 , 4 ] , fn x -&gt; x &lt; 3 end ) { [ 1 , 2 ] , [ 3 , 4 ] } iex&gt; Enum . split_while ( [ 1 , 2 , 3 , 4 ] , fn x -&gt; x &lt; 0 end ) { [ ] , [ 1 , 2 , 3 , 4 ] } iex&gt; Enum . split_while ( [ 1 , 2 , 3 , 4 ] , fn x -&gt; x &gt; 0 end ) { [ 1 , 2 , 3 , 4 ] , [ ] }","ref":"Enum.html#split_while/2","source_doc":"Splits enumerable in two at the position of the element for which\n`fun` returns a falsy value (`false` or `nil`) for the first time.\n\nIt returns a two-element tuple with two lists of elements.\nThe element that triggered the split is part of the second list.\n\n## Examples\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 3 end)\n    {[1, 2], [3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x < 0 end)\n    {[], [1, 2, 3, 4]}\n\n    iex> Enum.split_while([1, 2, 3, 4], fn x -> x > 0 end)\n    {[1, 2, 3, 4], []}\n\n","title":"Enum.split_while/2","type":"function"},{"doc":"Splits the enumerable in two lists according to the given function fun . Splits the given enumerable in two lists by calling fun with each element in the enumerable as its only argument. Returns a tuple with the first list containing all the elements in enumerable for which applying fun returned a truthy value, and a second list with all the elements for which applying fun returned a falsy value ( false or nil ). The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below. Examples iex&gt; Enum . split_with ( [ 5 , 4 , 3 , 2 , 1 , 0 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) { [ 4 , 2 , 0 ] , [ 5 , 3 , 1 ] } iex&gt; Enum . split_with ( [ a : 1 , b : - 2 , c : 1 , d : - 3 ] , fn { _k , v } -&gt; v &lt; 0 end ) { [ b : - 2 , d : - 3 ] , [ a : 1 , c : 1 ] } iex&gt; Enum . split_with ( [ a : 1 , b : - 2 , c : 1 , d : - 3 ] , fn { _k , v } -&gt; v &gt; 50 end ) { [ ] , [ a : 1 , b : - 2 , c : 1 , d : - 3 ] } iex&gt; Enum . split_with ( [ ] , fn { _k , v } -&gt; v &gt; 50 end ) { [ ] , [ ] }","ref":"Enum.html#split_with/2","source_doc":"Splits the `enumerable` in two lists according to the given function `fun`.\n\nSplits the given `enumerable` in two lists by calling `fun` with each element\nin the `enumerable` as its only argument. Returns a tuple with the first list\ncontaining all the elements in `enumerable` for which applying `fun` returned\na truthy value, and a second list with all the elements for which applying\n`fun` returned a falsy value (`false` or `nil`).\n\nThe elements in both the returned lists are in the same relative order as they\nwere in the original enumerable (if such enumerable was ordered, like a\nlist). See the examples below.\n\n## Examples\n\n    iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn x -> rem(x, 2) == 0 end)\n    {[4, 2, 0], [5, 3, 1]}\n\n    iex> Enum.split_with([a: 1, b: -2, c: 1, d: -3], fn {_k, v} -> v < 0 end)\n    {[b: -2, d: -3], [a: 1, c: 1]}\n\n    iex> Enum.split_with([a: 1, b: -2, c: 1, d: -3], fn {_k, v} -> v > 50 end)\n    {[], [a: 1, b: -2, c: 1, d: -3]}\n\n    iex> Enum.split_with([], fn {_k, v} -> v > 50 end)\n    {[], []}\n\n","title":"Enum.split_with/2","type":"function"},{"doc":"Returns the sum of all elements. Raises ArithmeticError if enumerable contains a non-numeric value. Examples iex&gt; Enum . sum ( [ 1 , 2 , 3 ] ) 6 iex&gt; Enum . sum ( 1 .. 10 ) 55 iex&gt; Enum . sum ( 1 .. 10 // 2 ) 25","ref":"Enum.html#sum/1","source_doc":"Returns the sum of all elements.\n\nRaises `ArithmeticError` if `enumerable` contains a non-numeric value.\n\n## Examples\n\n    iex> Enum.sum([1, 2, 3])\n    6\n\n    iex> Enum.sum(1..10)\n    55\n\n    iex> Enum.sum(1..10//2)\n    25\n\n","title":"Enum.sum/1","type":"function"},{"doc":"Takes an amount of elements from the beginning or the end of the enumerable . If a positive amount is given, it takes the amount elements from the beginning of the enumerable . If a negative amount is given, the amount of elements will be taken from the end. The enumerable will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end. If amount is 0 , it returns [] . Examples iex&gt; Enum . take ( [ 1 , 2 , 3 ] , 2 ) [ 1 , 2 ] iex&gt; Enum . take ( [ 1 , 2 , 3 ] , 10 ) [ 1 , 2 , 3 ] iex&gt; Enum . take ( [ 1 , 2 , 3 ] , 0 ) [ ] iex&gt; Enum . take ( [ 1 , 2 , 3 ] , - 1 ) [ 3 ]","ref":"Enum.html#take/2","source_doc":"Takes an `amount` of elements from the beginning or the end of the `enumerable`.\n\nIf a positive `amount` is given, it takes the `amount` elements from the\nbeginning of the `enumerable`.\n\nIf a negative `amount` is given, the `amount` of elements will be taken from the end.\nThe `enumerable` will be enumerated once to retrieve the proper index and\nthe remaining calculation is performed from the end.\n\nIf amount is `0`, it returns `[]`.\n\n## Examples\n\n    iex> Enum.take([1, 2, 3], 2)\n    [1, 2]\n\n    iex> Enum.take([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> Enum.take([1, 2, 3], 0)\n    []\n\n    iex> Enum.take([1, 2, 3], -1)\n    [3]\n\n","title":"Enum.take/2","type":"function"},{"doc":"Returns a list of every nth element in the enumerable , starting with the first element. The first element is always included, unless nth is 0. The second argument specifying every nth element must be a non-negative integer. Examples iex&gt; Enum . take_every ( 1 .. 10 , 2 ) [ 1 , 3 , 5 , 7 , 9 ] iex&gt; Enum . take_every ( 1 .. 10 , 0 ) [ ] iex&gt; Enum . take_every ( [ 1 , 2 , 3 ] , 1 ) [ 1 , 2 , 3 ]","ref":"Enum.html#take_every/2","source_doc":"Returns a list of every `nth` element in the `enumerable`,\nstarting with the first element.\n\nThe first element is always included, unless `nth` is 0.\n\nThe second argument specifying every `nth` element must be a non-negative\ninteger.\n\n## Examples\n\n    iex> Enum.take_every(1..10, 2)\n    [1, 3, 5, 7, 9]\n\n    iex> Enum.take_every(1..10, 0)\n    []\n\n    iex> Enum.take_every([1, 2, 3], 1)\n    [1, 2, 3]\n\n","title":"Enum.take_every/2","type":"function"},{"doc":"Takes count random elements from enumerable . Note that this function will traverse the whole enumerable to get the random sublist. See random/1 for notes on implementation and random seed. Examples # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exsss , { 1 , 2 , 3 } ) iex&gt; Enum . take_random ( 1 .. 10 , 2 ) [ 3 , 1 ] iex&gt; Enum . take_random ( ?a .. ?z , 5 ) &#39;mikel&#39;","ref":"Enum.html#take_random/2","source_doc":"Takes `count` random elements from `enumerable`.\n\nNote that this function will traverse the whole `enumerable` to\nget the random sublist.\n\nSee `random/1` for notes on implementation and random seed.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Enum.take_random(1..10, 2)\n    [3, 1]\n    iex> Enum.take_random(?a..?z, 5)\n    'mikel'\n\n","title":"Enum.take_random/2","type":"function"},{"doc":"Takes the elements from the beginning of the enumerable while fun returns a truthy value. Examples iex&gt; Enum . take_while ( [ 1 , 2 , 3 ] , fn x -&gt; x &lt; 3 end ) [ 1 , 2 ]","ref":"Enum.html#take_while/2","source_doc":"Takes the elements from the beginning of the `enumerable` while `fun` returns\na truthy value.\n\n## Examples\n\n    iex> Enum.take_while([1, 2, 3], fn x -> x < 3 end)\n    [1, 2]\n\n","title":"Enum.take_while/2","type":"function"},{"doc":"Converts enumerable to a list. Examples iex&gt; Enum . to_list ( 1 .. 3 ) [ 1 , 2 , 3 ]","ref":"Enum.html#to_list/1","source_doc":"Converts `enumerable` to a list.\n\n## Examples\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n\n","title":"Enum.to_list/1","type":"function"},{"doc":"Enumerates the enumerable , removing all duplicated elements. Examples iex&gt; Enum . uniq ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) [ 1 , 2 , 3 ]","ref":"Enum.html#uniq/1","source_doc":"Enumerates the `enumerable`, removing all duplicated elements.\n\n## Examples\n\n    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n    [1, 2, 3]\n\n","title":"Enum.uniq/1","type":"function"},{"doc":"Enumerates the enumerable , by removing the elements for which function fun returned duplicate elements. The function fun maps every element to a term. Two elements are considered duplicates if the return value of fun is equal for both of them. The first occurrence of each element is kept. Example iex&gt; Enum . uniq_by ( [ { 1 , :x } , { 2 , :y } , { 1 , :z } ] , fn { x , _ } -&gt; x end ) [ { 1 , :x } , { 2 , :y } ] iex&gt; Enum . uniq_by ( [ a : { :tea , 2 } , b : { :tea , 2 } , c : { :coffee , 1 } ] , fn { _ , y } -&gt; y end ) [ a : { :tea , 2 } , c : { :coffee , 1 } ]","ref":"Enum.html#uniq_by/2","source_doc":"Enumerates the `enumerable`, by removing the elements for which\nfunction `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term. Two elements are\nconsidered duplicates if the return value of `fun` is equal for\nboth of them.\n\nThe first occurrence of each element is kept.\n\n## Example\n\n    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n    [{1, :x}, {2, :y}]\n\n    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)\n    [a: {:tea, 2}, c: {:coffee, 1}]\n\n","title":"Enum.uniq_by/2","type":"function"},{"doc":"Opposite of zip/2 . Extracts two-element tuples from the given enumerable and groups them together. It takes an enumerable with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively. This function fails unless enumerable is or can be converted into a list of tuples with exactly two elements in each tuple. Examples iex&gt; Enum . unzip ( [ { :a , 1 } , { :b , 2 } , { :c , 3 } ] ) { [ :a , :b , :c ] , [ 1 , 2 , 3 ] } iex&gt; Enum . unzip ( %{ a : 1 , b : 2 } ) { [ :a , :b ] , [ 1 , 2 ] }","ref":"Enum.html#unzip/1","source_doc":"Opposite of `zip/2`. Extracts two-element tuples from the\ngiven `enumerable` and groups them together.\n\nIt takes an `enumerable` with elements being two-element tuples and returns\na tuple with two lists, each of which is formed by the first and\nsecond element of each tuple, respectively.\n\nThis function fails unless `enumerable` is or can be converted into a\nlist of tuples with *exactly* two elements in each tuple.\n\n## Examples\n\n    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n    {[:a, :b, :c], [1, 2, 3]}\n\n    iex> Enum.unzip(%{a: 1, b: 2})\n    {[:a, :b], [1, 2]}\n\n","title":"Enum.unzip/1","type":"function"},{"doc":"Returns the enumerable with each element wrapped in a tuple alongside its index. May receive a function or an integer offset. If an offset is given, it will index from the given offset instead of from zero. If a function is given, it will index by invoking the function for each element and index (zero-based) of the enumerable. Examples iex&gt; Enum . with_index ( [ :a , :b , :c ] ) [ a : 0 , b : 1 , c : 2 ] iex&gt; Enum . with_index ( [ :a , :b , :c ] , 3 ) [ a : 3 , b : 4 , c : 5 ] iex&gt; Enum . with_index ( [ :a , :b , :c ] , fn element , index -&gt; { index , element } end ) [ { 0 , :a } , { 1 , :b } , { 2 , :c } ]","ref":"Enum.html#with_index/2","source_doc":"Returns the `enumerable` with each element wrapped in a tuple\nalongside its index.\n\nMay receive a function or an integer offset.\n\nIf an `offset` is given, it will index from the given offset instead of from\nzero.\n\nIf a `function` is given, it will index by invoking the function for each\nelement and index (zero-based) of the enumerable.\n\n## Examples\n\n    iex> Enum.with_index([:a, :b, :c])\n    [a: 0, b: 1, c: 2]\n\n    iex> Enum.with_index([:a, :b, :c], 3)\n    [a: 3, b: 4, c: 5]\n\n    iex> Enum.with_index([:a, :b, :c], fn element, index -> {index, element} end)\n    [{0, :a}, {1, :b}, {2, :c}]\n\n","title":"Enum.with_index/2","type":"function"},{"doc":"Zips corresponding elements from a finite collection of enumerables into a list of tuples. The zipping finishes as soon as any enumerable in the given collection completes. Examples iex&gt; Enum . zip ( [ [ 1 , 2 , 3 ] , [ :a , :b , :c ] , [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] ] ) [ { 1 , :a , &quot;foo&quot; } , { 2 , :b , &quot;bar&quot; } , { 3 , :c , &quot;baz&quot; } ] iex&gt; Enum . zip ( [ [ 1 , 2 , 3 , 4 , 5 ] , [ :a , :b , :c ] ] ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } ]","ref":"Enum.html#zip/1","source_doc":"Zips corresponding elements from a finite collection of enumerables\ninto a list of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n\n    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n","title":"Enum.zip/1","type":"function"},{"doc":"Zips corresponding elements from two enumerables into a list of tuples. The zipping finishes as soon as either enumerable completes. Examples iex&gt; Enum . zip ( [ 1 , 2 , 3 ] , [ :a , :b , :c ] ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } ] iex&gt; Enum . zip ( [ 1 , 2 , 3 , 4 , 5 ] , [ :a , :b , :c ] ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } ]","ref":"Enum.html#zip/2","source_doc":"Zips corresponding elements from two enumerables into a list\nof tuples.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n    [{1, :a}, {2, :b}, {3, :c}]\n\n","title":"Enum.zip/2","type":"function"},{"doc":"Reduces over all of the given enumerables, halting as soon as any enumerable is empty. The reducer will receive 2 args: a list of elements (one from each enum) and the accumulator. In practice, the behaviour provided by this function can be achieved with: Enum . reduce ( Stream . zip ( enums ) , acc , reducer ) But zip_reduce/3 exists for convenience purposes. Examples iex&gt; enums = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ] ...&gt; Enum . zip_reduce ( enums , [ ] , fn elements , acc -&gt; ...&gt; [ List . to_tuple ( elements ) | acc ] ...&gt; end ) [ { 1 , 2 , 3 } , { 1 , 2 , 3 } ] iex&gt; enums = [ [ 1 , 2 ] , %{ a : 3 , b : 4 } , [ 5 , 6 ] ] ...&gt; Enum . zip_reduce ( enums , [ ] , fn elements , acc -&gt; ...&gt; [ List . to_tuple ( elements ) | acc ] ...&gt; end ) [ { 2 , { :b , 4 } , 6 } , { 1 , { :a , 3 } , 5 } ]","ref":"Enum.html#zip_reduce/3","source_doc":"Reduces over all of the given enumerables, halting as soon as any enumerable is\nempty.\n\nThe reducer will receive 2 args: a list of elements (one from each enum) and the\naccumulator.\n\nIn practice, the behaviour provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(enums), acc, reducer)\n\nBut `zip_reduce/3` exists for convenience purposes.\n\n## Examples\n\n    iex> enums = [[1, 1], [2, 2], [3, 3]]\n    ...>  Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>    [List.to_tuple(elements) | acc]\n    ...> end)\n    [{1, 2, 3}, {1, 2, 3}]\n\n    iex> enums = [[1, 2], %{a: 3, b: 4}, [5, 6]]\n    ...> Enum.zip_reduce(enums, [], fn elements, acc ->\n    ...>   [List.to_tuple(elements) | acc]\n    ...> end)\n    [{2, {:b, 4}, 6}, {1, {:a, 3}, 5}]\n","title":"Enum.zip_reduce/3","type":"function"},{"doc":"Reduces over two enumerables halting as soon as either enumerable is empty. In practice, the behaviour provided by this function can be achieved with: Enum . reduce ( Stream . zip ( left , right ) , acc , reducer ) But zip_reduce/4 exists for convenience purposes. Examples iex&gt; Enum . zip_reduce ( [ 1 , 2 ] , [ 3 , 4 ] , 0 , fn x , y , acc -&gt; x + y + acc end ) 10 iex&gt; Enum . zip_reduce ( [ 1 , 2 ] , [ 3 , 4 ] , [ ] , fn x , y , acc -&gt; [ x + y | acc ] end ) [ 6 , 4 ]","ref":"Enum.html#zip_reduce/4","source_doc":"Reduces over two enumerables halting as soon as either enumerable is empty.\n\nIn practice, the behaviour provided by this function can be achieved with:\n\n    Enum.reduce(Stream.zip(left, right), acc, reducer)\n\nBut `zip_reduce/4` exists for convenience purposes.\n\n## Examples\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], 0, fn x, y, acc -> x + y + acc end)\n    10\n\n    iex> Enum.zip_reduce([1, 2], [3, 4], [], fn x, y, acc -> [x + y | acc] end)\n    [6, 4]\n","title":"Enum.zip_reduce/4","type":"function"},{"doc":"Zips corresponding elements from a finite collection of enumerables into list, transforming them with the zip_fun function as it goes. The first element from each of the enums in enumerables will be put into a list which is then passed to the one-arity zip_fun function. Then, the second elements from each of the enums are put into a list and passed to zip_fun , and so on until any one of the enums in enumerables runs out of elements. Returns a list with all the results of calling zip_fun . Examples iex&gt; Enum . zip_with ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] , fn [ x , y , z ] -&gt; x + y + z end ) [ 9 , 12 ] iex&gt; Enum . zip_with ( [ [ 1 , 2 ] , [ 3 , 4 ] ] , fn [ x , y ] -&gt; x + y end ) [ 4 , 6 ]","ref":"Enum.html#zip_with/2","source_doc":"Zips corresponding elements from a finite collection of enumerables\ninto list, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put\ninto a list which is then passed to the one-arity `zip_fun` function.\nThen, the second elements from each of the enums are put into a list\nand passed to `zip_fun`, and so on until any one of the enums in\n`enumerables` runs out of elements.\n\nReturns a list with all the results of calling `zip_fun`.\n\n## Examples\n\n    iex> Enum.zip_with([[1, 2], [3, 4], [5, 6]], fn [x, y, z] -> x + y + z end)\n    [9, 12]\n\n    iex> Enum.zip_with([[1, 2], [3, 4]], fn [x, y] -> x + y end)\n    [4, 6]\n\n","title":"Enum.zip_with/2","type":"function"},{"doc":"Zips corresponding elements from two enumerables into a list, transforming them with the zip_fun function as it goes. The corresponding elements from each collection are passed to the provided two-arity zip_fun function in turn. Returns a list that contains the result of calling zip_fun for each pair of elements. The zipping finishes as soon as either enumerable runs out of elements. Zipping Maps It's important to remember that zipping inherently relies on order. If you zip two lists you get the element at the index from each list in turn. If we zip two maps together it's tempting to think that you will get the given key in the left map and the matching key in the right map, but there is no such guarantee because map keys are not ordered! Consider the following: left = %{ :a =&gt; 1 , 1 =&gt; 3 } right = %{ :a =&gt; 1 , :b =&gt; :c } Enum . zip ( left , right ) # [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}] As you can see :a does not get paired with :a . If this is what you want, you should use Map.merge/3 . Examples iex&gt; Enum . zip_with ( [ 1 , 2 ] , [ 3 , 4 ] , fn x , y -&gt; x + y end ) [ 4 , 6 ] iex&gt; Enum . zip_with ( [ 1 , 2 ] , [ 3 , 4 , 5 , 6 ] , fn x , y -&gt; x + y end ) [ 4 , 6 ] iex&gt; Enum . zip_with ( [ 1 , 2 , 5 , 6 ] , [ 3 , 4 ] , fn x , y -&gt; x + y end ) [ 4 , 6 ]","ref":"Enum.html#zip_with/3","source_doc":"Zips corresponding elements from two enumerables into a list, transforming them with\nthe `zip_fun` function as it goes.\n\nThe corresponding elements from each collection are passed to the provided two-arity `zip_fun`\nfunction in turn. Returns a list that contains the result of calling `zip_fun` for each pair of\nelements.\n\nThe zipping finishes as soon as either enumerable runs out of elements.\n\n## Zipping Maps\n\nIt's important to remember that zipping inherently relies on order.\nIf you zip two lists you get the element at the index from each list in turn.\nIf we zip two maps together it's tempting to think that you will get the given\nkey in the left map and the matching key in the right map, but there is no such\nguarantee because map keys are not ordered! Consider the following:\n\n    left =  %{:a => 1, 1 => 3}\n    right = %{:a => 1, :b => :c}\n    Enum.zip(left, right)\n    # [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}]\n\nAs you can see `:a` does not get paired with `:a`. If this is what you want,\nyou should use `Map.merge/3`.\n\n## Examples\n\n    iex> Enum.zip_with([1, 2], [3, 4], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2], [3, 4, 5, 6], fn x, y -> x + y end)\n    [4, 6]\n\n    iex> Enum.zip_with([1, 2, 5, 6], [3, 4], fn x, y -> x + y end)\n    [4, 6]\n\n","title":"Enum.zip_with/3","type":"function"},{"doc":"","ref":"Enum.html#t:acc/0","source_doc":false,"title":"Enum.acc/0","type":"type"},{"doc":"","ref":"Enum.html#t:default/0","source_doc":false,"title":"Enum.default/0","type":"type"},{"doc":"","ref":"Enum.html#t:element/0","source_doc":false,"title":"Enum.element/0","type":"type"},{"doc":"Zero-based index. It can also be a negative integer.","ref":"Enum.html#t:index/0","source_doc":"Zero-based index. It can also be a negative integer.","title":"Enum.index/0","type":"type"},{"doc":"","ref":"Enum.html#t:t/0","source_doc":false,"title":"Enum.t/0","type":"type"},{"doc":"A keyword list is a list that consists exclusively of two-element tuples. The first element of these tuples is known as the key , and it must be an atom. The second element, known as the value , can be any term. Keywords are mostly used to work with optional values. Examples For example, the following is a keyword list: [ { :exit_on_close , true } , { :active , :once } , { :packet_size , 1024 } ] Elixir provides a special and more concise syntax for keyword lists: [ exit_on_close : true , active : :once , packet_size : 1024 ] The two syntaxes return the exact same value. A key can be any atom, consisting of Unicode letters, numbers, an underscore or the @ sign. If the key should have any other characters, such as spaces, you can wrap it in quotes: iex&gt; [ &quot;exit on close&quot; : true ] [ &quot;exit on close&quot; : true ] Wrapping an atom in quotes does not make it a string. Keyword list keys are always atoms. Quotes should only be used when necessary or Elixir will issue a warning. Duplicate keys and ordering A keyword may have duplicate keys so it is not strictly a key-value data type. However, most of the functions in this module work on a key-value structure and behave similar to the functions you would find in the Map module. For example, Keyword.get/3 will get the first entry matching the given key, regardless if duplicate entries exist. Similarly, Keyword.put/3 and Keyword.delete/2 ensure all duplicate entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts. A handful of functions exist to handle duplicate keys, for example, get_values/2 returns all values for a given key and delete_first/2 deletes just the first entry of the existing ones. Even though lists preserve the existing order, the functions in Keyword do not guarantee any ordering. For example, if you invoke Keyword.put(opts, new_key, new_value) , there is no guarantee for where new_key will be added to (the front, the end or anywhere else). Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as: def my_function ( [ some_key : value , another_key : another_value ] ) will match my_function ( [ some_key : :foo , another_key : :bar ] ) but it won't match my_function ( [ another_key : :bar , some_key : :foo ] ) Most of the functions in this module work in linear time. This means that the time it takes to perform an operation grows at the same rate as the length of the list. Call syntax When keyword lists are passed as the last argument to a function, the square brackets around the keyword list can be omitted. For example, the keyword list syntax: String . split ( &quot;1-0&quot; , &quot;-&quot; , [ trim : true , parts : 2 ] ) can be written without the enclosing brackets whenever it is the last argument of a function call: String . split ( &quot;1-0&quot; , &quot;-&quot; , trim : true , parts : 2 ) Since tuples, lists and maps are treated similarly to function arguments in Elixir syntax, this property is also available to them: iex&gt; { 1 , 2 , foo : :bar } { 1 , 2 , [ { :foo , :bar } ] } iex&gt; [ 1 , 2 , foo : :bar ] [ 1 , 2 , { :foo , :bar } ] iex&gt; %{ 1 =&gt; 2 , foo : :bar } %{ 1 =&gt; 2 , :foo =&gt; :bar }","ref":"Keyword.html","source_doc":"A keyword list is a list that consists exclusively of two-element tuples.\n\nThe first element of these tuples is known as the *key*, and it must be an atom.\nThe second element, known as the *value*, can be any term.\n\nKeywords are mostly used to work with optional values.\n\n## Examples\n\nFor example, the following is a keyword list:\n\n    [{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]\n\nElixir provides a special and more concise syntax for keyword lists:\n\n    [exit_on_close: true, active: :once, packet_size: 1024]\n\nThe two syntaxes return the exact same value.\n\nA *key* can be any atom, consisting of Unicode letters, numbers,\nan underscore or the `@` sign. If the *key* should have any other\ncharacters, such as spaces, you can wrap it in quotes:\n\n    iex> [\"exit on close\": true]\n    [\"exit on close\": true]\n\nWrapping an atom in quotes does not make it a string. Keyword list\n*keys* are always atoms. Quotes should only be used when necessary\nor Elixir will issue a warning.\n\n## Duplicate keys and ordering\n\nA keyword may have duplicate keys so it is not strictly a key-value\ndata type. However, most of the functions in this module work on a\nkey-value structure and behave similar to the functions you would\nfind in the `Map` module. For example, `Keyword.get/3` will get the first\nentry matching the given key, regardless if duplicate entries exist.\nSimilarly, `Keyword.put/3` and `Keyword.delete/2` ensure all duplicate\nentries for a given key are removed when invoked. Note, however, that\nkeyword list operations need to traverse the whole list in order to find\nkeys, so these operations are slower than their map counterparts.\n\nA handful of functions exist to handle duplicate keys, for example,\n`get_values/2` returns all values for a given key and `delete_first/2`\ndeletes just the first entry of the existing ones.\n\nEven though lists preserve the existing order, the functions in\n`Keyword` do not guarantee any ordering. For example, if you invoke\n`Keyword.put(opts, new_key, new_value)`, there is no guarantee for\nwhere `new_key` will be added to (the front, the end or anywhere else).\n\nGiven ordering is not guaranteed, it is not recommended to pattern\nmatch on keyword lists either. For example, a function such as:\n\n    def my_function([some_key: value, another_key: another_value])\n\nwill match\n\n    my_function([some_key: :foo, another_key: :bar])\n\nbut it won't match\n\n    my_function([another_key: :bar, some_key: :foo])\n\nMost of the functions in this module work in linear time. This means\nthat the time it takes to perform an operation grows at the same\nrate as the length of the list.\n\n## Call syntax\n\nWhen keyword lists are passed as the last argument to a function,\nthe square brackets around the keyword list can be omitted. For\nexample, the keyword list syntax:\n\n    String.split(\"1-0\", \"-\", [trim: true, parts: 2])\n\ncan be written without the enclosing brackets whenever it is the last\nargument of a function call:\n\n    String.split(\"1-0\", \"-\", trim: true, parts: 2)\n\nSince tuples, lists and maps are treated similarly to function\narguments in Elixir syntax, this property is also available to them:\n\n    iex> {1, 2, foo: :bar}\n    {1, 2, [{:foo, :bar}]}\n\n    iex> [1, 2, foo: :bar]\n    [1, 2, {:foo, :bar}]\n\n    iex> %{1 => 2, foo: :bar}\n    %{1 => 2, :foo => :bar}\n\n","title":"Keyword","type":"module"},{"doc":"Deletes the entries in the keyword list under a specific key . If the key does not exist, it returns the keyword list unchanged. Use delete_first/2 to delete just the first entry in case of duplicate keys. Examples iex&gt; Keyword . delete ( [ a : 1 , b : 2 ] , :a ) [ b : 2 ] iex&gt; Keyword . delete ( [ a : 1 , b : 2 , a : 3 ] , :a ) [ b : 2 ] iex&gt; Keyword . delete ( [ b : 2 ] , :a ) [ b : 2 ]","ref":"Keyword.html#delete/2","source_doc":"Deletes the entries in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\nUse `delete_first/2` to delete just the first entry in case of\nduplicate keys.\n\n## Examples\n\n    iex> Keyword.delete([a: 1, b: 2], :a)\n    [b: 2]\n    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n    [b: 2]\n    iex> Keyword.delete([b: 2], :a)\n    [b: 2]\n\n","title":"Keyword.delete/2","type":"function"},{"doc":"Deletes the first entry in the keyword list under a specific key . If the key does not exist, it returns the keyword list unchanged. Examples iex&gt; Keyword . delete_first ( [ a : 1 , b : 2 , a : 3 ] , :a ) [ b : 2 , a : 3 ] iex&gt; Keyword . delete_first ( [ b : 2 ] , :a ) [ b : 2 ]","ref":"Keyword.html#delete_first/2","source_doc":"Deletes the first entry in the keyword list under a specific `key`.\n\nIf the `key` does not exist, it returns the keyword list unchanged.\n\n## Examples\n\n    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n    [b: 2, a: 3]\n    iex> Keyword.delete_first([b: 2], :a)\n    [b: 2]\n\n","title":"Keyword.delete_first/2","type":"function"},{"doc":"Drops the given keys from the keyword list. Removes duplicate keys from the new keyword list. Examples iex&gt; Keyword . drop ( [ a : 1 , a : 2 ] , [ :a ] ) [ ] iex&gt; Keyword . drop ( [ a : 1 , b : 2 , c : 3 ] , [ :b , :d ] ) [ a : 1 , c : 3 ] iex&gt; Keyword . drop ( [ a : 1 , b : 2 , b : 3 , c : 3 , a : 5 ] , [ :b , :d ] ) [ a : 1 , c : 3 , a : 5 ]","ref":"Keyword.html#drop/2","source_doc":"Drops the given `keys` from the keyword list.\n\nRemoves duplicate keys from the new keyword list.\n\n## Examples\n\n    iex> Keyword.drop([a: 1, a: 2], [:a])\n    []\n    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n    [a: 1, c: 3]\n    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n    [a: 1, c: 3, a: 5]\n\n","title":"Keyword.drop/2","type":"function"},{"doc":"Checks if two keywords are equal. Considers two keywords to be equal if they contain the same keys and those keys contain the same values. Examples iex&gt; Keyword . equal? ( [ a : 1 , b : 2 ] , [ b : 2 , a : 1 ] ) true iex&gt; Keyword . equal? ( [ a : 1 , b : 2 ] , [ b : 1 , a : 2 ] ) false iex&gt; Keyword . equal? ( [ a : 1 , b : 2 , a : 3 ] , [ b : 2 , a : 3 , a : 1 ] ) true Comparison between values is done with ===/3 , which means integers are not equivalent to floats: iex&gt; Keyword . equal? ( [ a : 1.0 ] , [ a : 1 ] ) false","ref":"Keyword.html#equal?/2","source_doc":"Checks if two keywords are equal.\n\nConsiders two keywords to be equal if they contain\nthe same keys and those keys contain the same values.\n\n## Examples\n\n    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n    true\n    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n    false\n    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n    true\n\nComparison between values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Keyword.equal?([a: 1.0], [a: 1])\n    false\n\n","title":"Keyword.equal?/2","type":"function"},{"doc":"Fetches the value for a specific key and returns it in a tuple. If the key does not exist, it returns :error . Examples iex&gt; Keyword . fetch ( [ a : 1 ] , :a ) { :ok , 1 } iex&gt; Keyword . fetch ( [ a : 1 ] , :b ) :error","ref":"Keyword.html#fetch/2","source_doc":"Fetches the value for a specific `key` and returns it in a tuple.\n\nIf the `key` does not exist, it returns `:error`.\n\n## Examples\n\n    iex> Keyword.fetch([a: 1], :a)\n    {:ok, 1}\n    iex> Keyword.fetch([a: 1], :b)\n    :error\n\n","title":"Keyword.fetch/2","type":"function"},{"doc":"Fetches the value for specific key . If the key does not exist, it raises a KeyError . Examples iex&gt; Keyword . fetch! ( [ a : 1 ] , :a ) 1 iex&gt; Keyword . fetch! ( [ a : 1 ] , :b ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#fetch!/2","source_doc":"Fetches the value for specific `key`.\n\nIf the `key` does not exist, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.fetch!([a: 1], :a)\n    1\n    iex> Keyword.fetch!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]\n\n","title":"Keyword.fetch!/2","type":"function"},{"doc":"Returns a keyword list containing only the entries from keywords for which the function fun returns a truthy value. See also reject/2 which discards all entries where the function returns a truthy value. Examples iex&gt; Keyword . filter ( [ one : 1 , two : 2 , three : 3 ] , fn { _key , val } -&gt; rem ( val , 2 ) == 1 end ) [ one : 1 , three : 3 ]","ref":"Keyword.html#filter/2","source_doc":"Returns a keyword list containing only the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `reject/2` which discards all entries where the function\nreturns a truthy value.\n\n## Examples\n\n    iex> Keyword.filter([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [one: 1, three: 3]\n\n","title":"Keyword.filter/2","type":"function"},{"doc":"Builds a keyword from the given keys and the fixed value . Examples iex&gt; Keyword . from_keys ( [ :foo , :bar , :baz ] , :atom ) [ foo : :atom , bar : :atom , baz : :atom ]","ref":"Keyword.html#from_keys/2","source_doc":"Builds a keyword from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Keyword.from_keys([:foo, :bar, :baz], :atom)\n    [foo: :atom, bar: :atom, baz: :atom]\n\n","title":"Keyword.from_keys/2","type":"function"},{"doc":"Gets the value under the given key . Returns the default value if key does not exist ( nil if no default value is provided). If duplicate entries exist, it returns the first one. Use get_values/2 to retrieve all entries. Examples iex&gt; Keyword . get ( [ ] , :a ) nil iex&gt; Keyword . get ( [ a : 1 ] , :a ) 1 iex&gt; Keyword . get ( [ a : 1 ] , :b ) nil iex&gt; Keyword . get ( [ a : 1 ] , :b , 3 ) 3 With duplicate keys: iex&gt; Keyword . get ( [ a : 1 , a : 2 ] , :a , 3 ) 1 iex&gt; Keyword . get ( [ a : 1 , a : 2 ] , :b , 3 ) 3","ref":"Keyword.html#get/3","source_doc":"Gets the value under the given `key`.\n\nReturns the default value if `key` does not exist\n(`nil` if no default value is provided).\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> Keyword.get([], :a)\n    nil\n    iex> Keyword.get([a: 1], :a)\n    1\n    iex> Keyword.get([a: 1], :b)\n    nil\n    iex> Keyword.get([a: 1], :b, 3)\n    3\n\nWith duplicate keys:\n\n    iex> Keyword.get([a: 1, a: 2], :a, 3)\n    1\n    iex> Keyword.get([a: 1, a: 2], :b, 3)\n    3\n\n","title":"Keyword.get/3","type":"function"},{"doc":"Gets the value from key and updates it, all in one pass. The fun argument receives the value of key (or nil if key is not present) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key . The fun may also return :pop , implying the current value shall be removed from the keyword list and returned. Returns a tuple that contains the current value returned by fun and a new keyword list with the updated value under key . Examples iex&gt; Keyword . get_and_update ( [ a : 1 ] , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , [ a : &quot;new value!&quot; ] } iex&gt; Keyword . get_and_update ( [ a : 1 ] , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { nil , [ b : &quot;new value!&quot; , a : 1 ] } iex&gt; Keyword . get_and_update ( [ a : 2 ] , :a , fn number -&gt; ...&gt; { 2 * number , 3 * number } ...&gt; end ) { 4 , [ a : 6 ] } iex&gt; Keyword . get_and_update ( [ a : 1 ] , :a , fn _ -&gt; :pop end ) { 1 , [ ] } iex&gt; Keyword . get_and_update ( [ a : 1 ] , :b , fn _ -&gt; :pop end ) { nil , [ a : 1 ] }","ref":"Keyword.html#get_and_update/3","source_doc":"Gets the value from `key` and updates it, all in one pass.\n\nThe `fun` argument receives the value of `key` (or `nil` if `key`\nis not present) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned)\nand the new value to be stored under `key`. The `fun` may also\nreturn `:pop`, implying the current value shall be removed from the\nkeyword list and returned.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, [b: \"new value!\", a: 1]}\n\n    iex> Keyword.get_and_update([a: 2], :a, fn number ->\n    ...>   {2 * number, 3 * number}\n    ...> end)\n    {4, [a: 6]}\n\n    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n    {1, []}\n\n    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n    {nil, [a: 1]}\n\n","title":"Keyword.get_and_update/3","type":"function"},{"doc":"Gets the value under key and updates it. Raises if there is no key . The fun argument receives the value under key and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key . Returns a tuple that contains the current value returned by fun and a new keyword list with the updated value under key . Examples iex&gt; Keyword . get_and_update! ( [ a : 1 ] , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , [ a : &quot;new value!&quot; ] } iex&gt; Keyword . get_and_update! ( [ a : 1 ] , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) ** (KeyError) key :b not found in: [a: 1] iex&gt; Keyword . get_and_update! ( [ a : 1 ] , :a , fn _ -&gt; ...&gt; :pop ...&gt; end ) { 1 , [ ] }","ref":"Keyword.html#get_and_update!/3","source_doc":"Gets the value under `key` and updates it. Raises if there is no `key`.\n\nThe `fun` argument receives the value under `key` and must return a\ntwo-element tuple: the current value (the retrieved value, which can be\noperated on before being returned) and the new value to be stored under\n`key`.\n\nReturns a tuple that contains the current value returned by\n`fun` and a new keyword list with the updated value under `key`.\n\n## Examples\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, [a: \"new value!\"]}\n\n    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: [a: 1]\n\n    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, []}\n\n","title":"Keyword.get_and_update!/3","type":"function"},{"doc":"Gets the value under the given key . If key does not exist, lazily evaluates fun and returns its result. This is useful if the default value is very expensive to calculate or generally difficult to set up and tear down again. If duplicate entries exist, it returns the first one. Use get_values/2 to retrieve all entries. Examples iex&gt; keyword = [ a : 1 ] iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Keyword . get_lazy ( keyword , :a , fun ) 1 iex&gt; Keyword . get_lazy ( keyword , :b , fun ) 13","ref":"Keyword.html#get_lazy/3","source_doc":"Gets the value under the given `key`.\n\nIf `key` does not exist, lazily evaluates `fun` and returns its result.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nIf duplicate entries exist, it returns the first one.\nUse `get_values/2` to retrieve all entries.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.get_lazy(keyword, :a, fun)\n    1\n    iex> Keyword.get_lazy(keyword, :b, fun)\n    13\n\n","title":"Keyword.get_lazy/3","type":"function"},{"doc":"Gets all values under a specific key . Examples iex&gt; Keyword . get_values ( [ ] , :a ) [ ] iex&gt; Keyword . get_values ( [ a : 1 ] , :a ) [ 1 ] iex&gt; Keyword . get_values ( [ a : 1 , a : 2 ] , :a ) [ 1 , 2 ]","ref":"Keyword.html#get_values/2","source_doc":"Gets all values under a specific `key`.\n\n## Examples\n\n    iex> Keyword.get_values([], :a)\n    []\n    iex> Keyword.get_values([a: 1], :a)\n    [1]\n    iex> Keyword.get_values([a: 1, a: 2], :a)\n    [1, 2]\n\n","title":"Keyword.get_values/2","type":"function"},{"doc":"Returns whether a given key exists in the given keywords . Examples iex&gt; Keyword . has_key? ( [ a : 1 ] , :a ) true iex&gt; Keyword . has_key? ( [ a : 1 ] , :b ) false","ref":"Keyword.html#has_key?/2","source_doc":"Returns whether a given `key` exists in the given `keywords`.\n\n## Examples\n\n    iex> Keyword.has_key?([a: 1], :a)\n    true\n    iex> Keyword.has_key?([a: 1], :b)\n    false\n\n","title":"Keyword.has_key?/2","type":"function"},{"doc":"Returns all keys from the keyword list. Keeps duplicate keys in the resulting list of keys. Examples iex&gt; Keyword . keys ( a : 1 , b : 2 ) [ :a , :b ] iex&gt; Keyword . keys ( a : 1 , b : 2 , a : 3 ) [ :a , :b , :a ] iex&gt; Keyword . keys ( [ { :a , 1 } , { &quot;b&quot; , 2 } , { :c , 3 } ] ) ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {&quot;b&quot;, 2}","ref":"Keyword.html#keys/1","source_doc":"Returns all keys from the keyword list.\n\nKeeps duplicate keys in the resulting list of keys.\n\n## Examples\n\n    iex> Keyword.keys(a: 1, b: 2)\n    [:a, :b]\n\n    iex> Keyword.keys(a: 1, b: 2, a: 3)\n    [:a, :b, :a]\n\n    iex> Keyword.keys([{:a, 1}, {\"b\", 2}, {:c, 3}])\n    ** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {\"b\", 2}\n\n","title":"Keyword.keys/1","type":"function"},{"doc":"Returns true if term is a keyword list, otherwise false . When term is a list it is traversed to the end. Examples iex&gt; Keyword . keyword? ( [ ] ) true iex&gt; Keyword . keyword? ( a : 1 ) true iex&gt; Keyword . keyword? ( [ { Foo , 1 } ] ) true iex&gt; Keyword . keyword? ( [ { } ] ) false iex&gt; Keyword . keyword? ( [ :key ] ) false iex&gt; Keyword . keyword? ( %{ } ) false","ref":"Keyword.html#keyword?/1","source_doc":"Returns `true` if `term` is a keyword list, otherwise `false`.\n\nWhen `term` is a list it is traversed to the end.\n\n## Examples\n\n    iex> Keyword.keyword?([])\n    true\n    iex> Keyword.keyword?(a: 1)\n    true\n    iex> Keyword.keyword?([{Foo, 1}])\n    true\n    iex> Keyword.keyword?([{}])\n    false\n    iex> Keyword.keyword?([:key])\n    false\n    iex> Keyword.keyword?(%{})\n    false\n\n","title":"Keyword.keyword?/1","type":"function"},{"doc":"Merges two keyword lists into one. Adds all keys, including duplicate keys, given in keywords2 to keywords1 , overriding any existing ones. There are no guarantees about the order of the keys in the returned keyword. Examples iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 ] ) [ b : 2 , a : 3 , d : 4 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 , a : 5 ] ) [ b : 2 , a : 3 , d : 4 , a : 5 ] iex&gt; Keyword . merge ( [ a : 1 ] , [ 2 , 3 ] ) ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]","ref":"Keyword.html#merge/2","source_doc":"Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`, overriding any existing ones.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n    [b: 2, a: 3, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n    [b: 2, a: 3, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1], [2, 3])\n    ** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]\n\n","title":"Keyword.merge/2","type":"function"},{"doc":"Merges two keyword lists into one. Adds all keys, including duplicate keys, given in keywords2 to keywords1 . Invokes the given function to solve conflicts. If keywords2 has duplicate keys, it invokes the given function for each matching pair in keywords1 . There are no guarantees about the order of the keys in the returned keyword. Examples iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 ] , fn _k , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) [ b : 2 , a : 4 , d : 4 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ a : 3 , d : 4 , a : 5 ] , fn :a , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) [ b : 2 , a : 4 , d : 4 , a : 5 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 , a : 3 ] , [ a : 3 , d : 4 , a : 5 ] , fn :a , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) [ b : 2 , a : 4 , d : 4 , a : 8 ] iex&gt; Keyword . merge ( [ a : 1 , b : 2 ] , [ :a , :b ] , fn :a , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]","ref":"Keyword.html#merge/3","source_doc":"Merges two keyword lists into one.\n\nAdds all keys, including duplicate keys, given in `keywords2`\nto `keywords1`. Invokes the given function to solve conflicts.\n\nIf `keywords2` has duplicate keys, it invokes the given function\nfor each matching pair in `keywords1`.\n\nThere are no guarantees about the order of the keys in the returned keyword.\n\n## Examples\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4]\n\n    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 5]\n\n    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    [b: 2, a: 4, d: 4, a: 8]\n\n    iex> Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    ** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]\n\n","title":"Keyword.merge/3","type":"function"},{"doc":"Returns an empty keyword list, i.e. an empty list. Examples iex&gt; Keyword . new ( ) [ ]","ref":"Keyword.html#new/0","source_doc":"Returns an empty keyword list, i.e. an empty list.\n\n## Examples\n\n    iex> Keyword.new()\n    []\n\n","title":"Keyword.new/0","type":"function"},{"doc":"Creates a keyword list from an enumerable. Removes duplicate entries and the last one prevails. Unlike Enum.into(enumerable, []) , Keyword.new(enumerable) guarantees the keys are unique. Examples iex&gt; Keyword . new ( [ { :b , 1 } , { :a , 2 } ] ) [ b : 1 , a : 2 ] iex&gt; Keyword . new ( [ { :a , 1 } , { :a , 2 } , { :a , 3 } ] ) [ a : 3 ]","ref":"Keyword.html#new/1","source_doc":"Creates a keyword list from an enumerable.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\nguarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([{:b, 1}, {:a, 2}])\n    [b: 1, a: 2]\n\n    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n    [a: 3]\n\n","title":"Keyword.new/1","type":"function"},{"doc":"Creates a keyword list from an enumerable via the transformation function. Removes duplicate entries and the last one prevails. Unlike Enum.into(enumerable, [], fun) , Keyword.new(enumerable, fun) guarantees the keys are unique. Examples iex&gt; Keyword . new ( [ :a , :b ] , fn x -&gt; { x , x } end ) [ a : :a , b : :b ]","ref":"Keyword.html#new/2","source_doc":"Creates a keyword list from an enumerable via the transformation function.\n\nRemoves duplicate entries and the last one prevails.\nUnlike `Enum.into(enumerable, [], fun)`,\n`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n\n## Examples\n\n    iex> Keyword.new([:a, :b], fn x -> {x, x} end)\n    [a: :a, b: :b]\n\n","title":"Keyword.new/2","type":"function"},{"doc":"Returns the first value for key and removes all associated entries in the keyword list. It returns a tuple where the first element is the first value for key and the second element is a keyword list with all entries associated with key removed. If the key is not present in the keyword list, it returns {default, keyword_list} . If you don't want to remove all the entries associated with key use pop_first/3 instead, which will remove only the first entry. Examples iex&gt; Keyword . pop ( [ a : 1 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop ( [ a : 1 ] , :b ) { nil , [ a : 1 ] } iex&gt; Keyword . pop ( [ a : 1 ] , :b , 3 ) { 3 , [ a : 1 ] } iex&gt; Keyword . pop ( [ a : 1 , a : 2 ] , :a ) { 1 , [ ] }","ref":"Keyword.html#pop/3","source_doc":"Returns the first value for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is the first value for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{default, keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop([a: 1, a: 2], :a)\n    {1, []}\n\n","title":"Keyword.pop/3","type":"function"},{"doc":"Returns the first value for key and removes all associated entries in the keyword list, raising if key is not present. This function behaves like pop/3 , but raises in case the key is not present in the given keywords . Examples iex&gt; Keyword . pop! ( [ a : 1 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop! ( [ a : 1 , a : 2 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop! ( [ a : 1 ] , :b ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#pop!/2","source_doc":"Returns the first value for `key` and removes all associated entries in the keyword list,\nraising if `key` is not present.\n\nThis function behaves like `pop/3`, but raises in case the `key` is not present in the\ngiven `keywords`.\n\n## Examples\n\n    iex> Keyword.pop!([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1, a: 2], :a)\n    {1, []}\n    iex> Keyword.pop!([a: 1], :b)\n    ** (KeyError) key :b not found in: [a: 1]\n\n","title":"Keyword.pop!/2","type":"function"},{"doc":"Returns and removes the first value associated with key in the keyword list. Keeps duplicate keys in the resulting keyword list. Examples iex&gt; Keyword . pop_first ( [ a : 1 ] , :a ) { 1 , [ ] } iex&gt; Keyword . pop_first ( [ a : 1 ] , :b ) { nil , [ a : 1 ] } iex&gt; Keyword . pop_first ( [ a : 1 ] , :b , 3 ) { 3 , [ a : 1 ] } iex&gt; Keyword . pop_first ( [ a : 1 , a : 2 ] , :a ) { 1 , [ a : 2 ] }","ref":"Keyword.html#pop_first/3","source_doc":"Returns and removes the first value associated with `key` in the keyword list.\n\nKeeps duplicate keys in the resulting keyword list.\n\n## Examples\n\n    iex> Keyword.pop_first([a: 1], :a)\n    {1, []}\n    iex> Keyword.pop_first([a: 1], :b)\n    {nil, [a: 1]}\n    iex> Keyword.pop_first([a: 1], :b, 3)\n    {3, [a: 1]}\n    iex> Keyword.pop_first([a: 1, a: 2], :a)\n    {1, [a: 2]}\n\n","title":"Keyword.pop_first/3","type":"function"},{"doc":"Lazily returns and removes all values associated with key in the keyword list. This is useful if the default value is very expensive to calculate or generally difficult to set up and tear down again. Removes all duplicate keys. See pop_first/3 for removing only the first entry. Examples iex&gt; keyword = [ a : 1 ] iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Keyword . pop_lazy ( keyword , :a , fun ) { 1 , [ ] } iex&gt; Keyword . pop_lazy ( keyword , :b , fun ) { 13 , [ a : 1 ] }","ref":"Keyword.html#pop_lazy/3","source_doc":"Lazily returns and removes all values associated with `key` in the keyword list.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\nRemoves all duplicate keys. See `pop_first/3` for removing only the first entry.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.pop_lazy(keyword, :a, fun)\n    {1, []}\n    iex> Keyword.pop_lazy(keyword, :b, fun)\n    {13, [a: 1]}\n\n","title":"Keyword.pop_lazy/3","type":"function"},{"doc":"Returns all values for key and removes all associated entries in the keyword list. It returns a tuple where the first element is a list of values for key and the second element is a keyword list with all entries associated with key removed. If the key is not present in the keyword list, it returns {[], keyword_list} . If you don't want to remove all the entries associated with key use pop_first/3 instead, which will remove only the first entry. Examples iex&gt; Keyword . pop_values ( [ a : 1 ] , :a ) { [ 1 ] , [ ] } iex&gt; Keyword . pop_values ( [ a : 1 ] , :b ) { [ ] , [ a : 1 ] } iex&gt; Keyword . pop_values ( [ a : 1 , a : 2 ] , :a ) { [ 1 , 2 ] , [ ] }","ref":"Keyword.html#pop_values/2","source_doc":"Returns all values for `key` and removes all associated entries in the keyword list.\n\nIt returns a tuple where the first element is a list of values for `key` and the\nsecond element is a keyword list with all entries associated with `key` removed.\nIf the `key` is not present in the keyword list, it returns `{[], keyword_list}`.\n\nIf you don't want to remove all the entries associated with `key` use `pop_first/3`\ninstead, which will remove only the first entry.\n\n## Examples\n\n    iex> Keyword.pop_values([a: 1], :a)\n    {[1], []}\n    iex> Keyword.pop_values([a: 1], :b)\n    {[], [a: 1]}\n    iex> Keyword.pop_values([a: 1, a: 2], :a)\n    {[1, 2], []}\n\n","title":"Keyword.pop_values/2","type":"function"},{"doc":"Puts the given value under the specified key . If a value under key already exists, it overrides the value and removes all duplicate entries. Examples iex&gt; Keyword . put ( [ a : 1 ] , :b , 2 ) [ b : 2 , a : 1 ] iex&gt; Keyword . put ( [ a : 1 , b : 2 ] , :a , 3 ) [ a : 3 , b : 2 ] iex&gt; Keyword . put ( [ a : 1 , b : 2 , a : 4 ] , :a , 3 ) [ a : 3 , b : 2 ]","ref":"Keyword.html#put/3","source_doc":"Puts the given `value` under the specified `key`.\n\nIf a value under `key` already exists, it overrides the value\nand removes all duplicate entries.\n\n## Examples\n\n    iex> Keyword.put([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put([a: 1, b: 2], :a, 3)\n    [a: 3, b: 2]\n    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n","title":"Keyword.put/3","type":"function"},{"doc":"Puts the given value under key , unless the entry key already exists. Examples iex&gt; Keyword . put_new ( [ a : 1 ] , :b , 2 ) [ b : 2 , a : 1 ] iex&gt; Keyword . put_new ( [ a : 1 , b : 2 ] , :a , 3 ) [ a : 1 , b : 2 ]","ref":"Keyword.html#put_new/3","source_doc":"Puts the given `value` under `key`, unless the entry `key` already exists.\n\n## Examples\n\n    iex> Keyword.put_new([a: 1], :b, 2)\n    [b: 2, a: 1]\n    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n    [a: 1, b: 2]\n\n","title":"Keyword.put_new/3","type":"function"},{"doc":"Evaluates fun and puts the result under key in keyword list unless key is already present. This is useful if the value is very expensive to calculate or generally difficult to set up and tear down again. Examples iex&gt; keyword = [ a : 1 ] iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Keyword . put_new_lazy ( keyword , :a , fun ) [ a : 1 ] iex&gt; Keyword . put_new_lazy ( keyword , :b , fun ) [ b : 13 , a : 1 ]","ref":"Keyword.html#put_new_lazy/3","source_doc":"Evaluates `fun` and puts the result under `key`\nin keyword list unless `key` is already present.\n\nThis is useful if the value is very expensive to calculate or\ngenerally difficult to set up and tear down again.\n\n## Examples\n\n    iex> keyword = [a: 1]\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Keyword.put_new_lazy(keyword, :a, fun)\n    [a: 1]\n    iex> Keyword.put_new_lazy(keyword, :b, fun)\n    [b: 13, a: 1]\n\n","title":"Keyword.put_new_lazy/3","type":"function"},{"doc":"Returns a keyword list excluding the entries from keywords for which the function fun returns a truthy value. See also filter/2 . Examples iex&gt; Keyword . reject ( [ one : 1 , two : 2 , three : 3 ] , fn { _key , val } -&gt; rem ( val , 2 ) == 1 end ) [ two : 2 ]","ref":"Keyword.html#reject/2","source_doc":"Returns a keyword list excluding the entries from `keywords`\nfor which the function `fun` returns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Keyword.reject([one: 1, two: 2, three: 3], fn {_key, val} -> rem(val, 2) == 1 end)\n    [two: 2]\n\n","title":"Keyword.reject/2","type":"function"},{"doc":"Puts a value under key only if the key already exists in keywords . In case a key exists multiple times in the keyword list, it removes later occurrences. Examples iex&gt; Keyword . replace ( [ a : 1 , b : 2 , a : 4 ] , :a , 3 ) [ a : 3 , b : 2 ] iex&gt; Keyword . replace ( [ a : 1 ] , :b , 2 ) [ a : 1 ]","ref":"Keyword.html#replace/3","source_doc":"Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIn case a key exists multiple times in the keyword list,\nit removes later occurrences.\n\n## Examples\n\n    iex> Keyword.replace([a: 1, b: 2, a: 4], :a, 3)\n    [a: 3, b: 2]\n\n    iex> Keyword.replace([a: 1], :b, 2)\n    [a: 1]\n\n","title":"Keyword.replace/3","type":"function"},{"doc":"Puts a value under key only if the key already exists in keywords . If key is not present in keywords , it raises a KeyError . Examples iex&gt; Keyword . replace! ( [ a : 1 , b : 2 , a : 3 ] , :a , :new ) [ a : :new , b : 2 ] iex&gt; Keyword . replace! ( [ a : 1 , b : 2 , c : 3 , b : 4 ] , :b , :new ) [ a : 1 , b : :new , c : 3 ] iex&gt; Keyword . replace! ( [ a : 1 ] , :b , 2 ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#replace!/3","source_doc":"Puts a value under `key` only if the `key` already exists in `keywords`.\n\nIf `key` is not present in `keywords`, it raises a `KeyError`.\n\n## Examples\n\n    iex> Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)\n    [a: :new, b: 2]\n    iex> Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)\n    [a: 1, b: :new, c: 3]\n\n    iex> Keyword.replace!([a: 1], :b, 2)\n    ** (KeyError) key :b not found in: [a: 1]\n\n","title":"Keyword.replace!/3","type":"function"},{"doc":"Replaces the value under key using the given function only if key already exists in keywords . In comparison to replace/3 , this can be useful when it's expensive to calculate the value. If key does not exist, the original keyword list is returned unchanged. Examples iex&gt; Keyword . replace_lazy ( [ a : 1 , b : 2 ] , :a , fn v -&gt; v * 4 end ) [ a : 4 , b : 2 ] iex&gt; Keyword . replace_lazy ( [ a : 2 , b : 2 , a : 1 ] , :a , fn v -&gt; v * 4 end ) [ a : 8 , b : 2 ] iex&gt; Keyword . replace_lazy ( [ a : 1 , b : 2 ] , :c , fn v -&gt; v * 4 end ) [ a : 1 , b : 2 ]","ref":"Keyword.html#replace_lazy/3","source_doc":"Replaces the value under `key` using the given function only if\n`key` already exists in `keywords`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original keyword list is returned unchanged.\n\n## Examples\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :a, fn v -> v * 4 end)\n    [a: 4, b: 2]\n\n    iex> Keyword.replace_lazy([a: 2, b: 2, a: 1], :a, fn v -> v * 4 end)\n    [a: 8, b: 2]\n\n    iex> Keyword.replace_lazy([a: 1, b: 2], :c, fn v -> v * 4 end)\n    [a: 1, b: 2]\n\n","title":"Keyword.replace_lazy/3","type":"function"},{"doc":"Takes all entries corresponding to the given keys and extracts them into a separate keyword list. Returns a tuple with the new list and the old list with removed keys. Ignores keys for which there are no entries in the keyword list. Entries with duplicate keys end up in the same keyword list. Examples iex&gt; Keyword . split ( [ a : 1 , b : 2 , c : 3 ] , [ :a , :c , :e ] ) { [ a : 1 , c : 3 ] , [ b : 2 ] } iex&gt; Keyword . split ( [ a : 1 , b : 2 , c : 3 , a : 4 ] , [ :a , :c , :e ] ) { [ a : 1 , c : 3 , a : 4 ] , [ b : 2 ] }","ref":"Keyword.html#split/2","source_doc":"Takes all entries corresponding to the given `keys` and extracts them into a\nseparate keyword list.\n\nReturns a tuple with the new list and the old list with removed keys.\n\nIgnores keys for which there are no entries in the keyword list.\n\nEntries with duplicate keys end up in the same keyword list.\n\n## Examples\n\n    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n    {[a: 1, c: 3], [b: 2]}\n    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n    {[a: 1, c: 3, a: 4], [b: 2]}\n\n","title":"Keyword.split/2","type":"function"},{"doc":"Splits the keywords into two keyword lists according to the given function fun . The provided fun receives each {key, value} pair in the keywords as its only argument. Returns a tuple with the first keyword list containing all the elements in keywords for which applying fun returned a truthy value, and a second keyword list with all the elements for which applying fun returned a falsy value ( false or nil ). Examples iex&gt; Keyword . split_with ( [ a : 1 , b : 2 , c : 3 ] , fn { _k , v } -&gt; rem ( v , 2 ) == 0 end ) { [ b : 2 ] , [ a : 1 , c : 3 ] } iex&gt; Keyword . split_with ( [ a : 1 , b : 2 , c : 3 , b : 4 ] , fn { _k , v } -&gt; rem ( v , 2 ) == 0 end ) { [ b : 2 , b : 4 ] , [ a : 1 , c : 3 ] } iex&gt; Keyword . split_with ( [ a : 1 , b : 2 , c : 3 , b : 4 ] , fn { k , v } -&gt; k in [ :a , :c ] and rem ( v , 2 ) == 0 end ) { [ ] , [ a : 1 , b : 2 , c : 3 , b : 4 ] } iex&gt; Keyword . split_with ( [ ] , fn { _k , v } -&gt; rem ( v , 2 ) == 0 end ) { [ ] , [ ] }","ref":"Keyword.html#split_with/2","source_doc":"Splits the `keywords` into two keyword lists according to the given function\n`fun`.\n\nThe provided `fun` receives each `{key, value}` pair in the `keywords` as its only\nargument. Returns a tuple with the first keyword list containing all the\nelements in `keywords` for which applying `fun` returned a truthy value, and\na second keyword list with all the elements for which applying `fun` returned\na falsy value (`false` or `nil`).\n\n## Examples\n\n    iex> Keyword.split_with([a: 1, b: 2, c: 3], fn {_k, v} -> rem(v, 2) == 0 end)\n    {[b: 2], [a: 1, c: 3]}\n\n    iex> Keyword.split_with([a: 1, b: 2, c: 3, b: 4], fn {_k, v} -> rem(v, 2) == 0 end)\n    {[b: 2, b: 4], [a: 1, c: 3]}\n\n    iex> Keyword.split_with([a: 1, b: 2, c: 3, b: 4], fn {k, v} -> k in [:a, :c] and rem(v, 2) == 0 end)\n    {[], [a: 1, b: 2, c: 3, b: 4]}\n\n    iex> Keyword.split_with([], fn {_k, v} -> rem(v, 2) == 0 end)\n    {[], []}\n\n","title":"Keyword.split_with/2","type":"function"},{"doc":"Takes all entries corresponding to the given keys and returns them as a new keyword list. Preserves duplicate keys in the new keyword list. Examples iex&gt; Keyword . take ( [ a : 1 , b : 2 , c : 3 ] , [ :a , :c , :e ] ) [ a : 1 , c : 3 ] iex&gt; Keyword . take ( [ a : 1 , b : 2 , c : 3 , a : 5 ] , [ :a , :c , :e ] ) [ a : 1 , c : 3 , a : 5 ]","ref":"Keyword.html#take/2","source_doc":"Takes all entries corresponding to the given `keys` and returns them as a new\nkeyword list.\n\nPreserves duplicate keys in the new keyword list.\n\n## Examples\n\n    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n    [a: 1, c: 3]\n    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n    [a: 1, c: 3, a: 5]\n\n","title":"Keyword.take/2","type":"function"},{"doc":"Returns the keyword list itself. Examples iex&gt; Keyword . to_list ( a : 1 ) [ a : 1 ]","ref":"Keyword.html#to_list/1","source_doc":"Returns the keyword list itself.\n\n## Examples\n\n    iex> Keyword.to_list(a: 1)\n    [a: 1]\n\n","title":"Keyword.to_list/1","type":"function"},{"doc":"Updates the value under key in keywords using the given function. If the key does not exist, it inserts the given default value. Does not pass the default value through the update function. Removes all duplicate keys and only updates the first one. Examples iex&gt; Keyword . update ( [ a : 1 ] , :a , 13 , fn existing_value -&gt; existing_value * 2 end ) [ a : 2 ] iex&gt; Keyword . update ( [ a : 1 , a : 2 ] , :a , 13 , fn existing_value -&gt; existing_value * 2 end ) [ a : 2 ] iex&gt; Keyword . update ( [ a : 1 ] , :b , 11 , fn existing_value -&gt; existing_value * 2 end ) [ a : 1 , b : 11 ]","ref":"Keyword.html#update/4","source_doc":"Updates the value under `key` in `keywords` using the given function.\n\nIf the `key` does not exist, it inserts the given `default` value.\nDoes not pass the `default` value through the update function.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update([a: 1], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -> existing_value * 2 end)\n    [a: 2]\n\n    iex> Keyword.update([a: 1], :b, 11, fn existing_value -> existing_value * 2 end)\n    [a: 1, b: 11]\n\n","title":"Keyword.update/4","type":"function"},{"doc":"Updates the value under key using the given function. Raises KeyError if the key does not exist. Removes all duplicate keys and only updates the first one. Examples iex&gt; Keyword . update! ( [ a : 1 , b : 2 , a : 3 ] , :a , &amp; ( &amp;1 * 2 ) ) [ a : 2 , b : 2 ] iex&gt; Keyword . update! ( [ a : 1 , b : 2 , c : 3 ] , :b , &amp; ( &amp;1 * 2 ) ) [ a : 1 , b : 4 , c : 3 ] iex&gt; Keyword . update! ( [ a : 1 ] , :b , &amp; ( &amp;1 * 2 ) ) ** (KeyError) key :b not found in: [a: 1]","ref":"Keyword.html#update!/3","source_doc":"Updates the value under `key` using the given function.\n\nRaises `KeyError` if the `key` does not exist.\n\nRemoves all duplicate keys and only updates the first one.\n\n## Examples\n\n    iex> Keyword.update!([a: 1, b: 2, a: 3], :a, &(&1 * 2))\n    [a: 2, b: 2]\n    iex> Keyword.update!([a: 1, b: 2, c: 3], :b, &(&1 * 2))\n    [a: 1, b: 4, c: 3]\n\n    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: [a: 1]\n\n","title":"Keyword.update!/3","type":"function"},{"doc":"Ensures the given keyword has only the keys given in values . The second argument must be a list of atoms, specifying a given key, or tuples specifying a key and a default value. If the keyword list has only the given keys, it returns {:ok, keyword} with default values applied. Otherwise it returns {:error, invalid_keys} with invalid keys. See also: validate!/2 . Examples iex&gt; { :ok , result } = Keyword . validate ( [ ] , [ one : 1 , two : 2 ] ) iex&gt; Enum . sort ( result ) [ one : 1 , two : 2 ] iex&gt; { :ok , result } = Keyword . validate ( [ two : 3 ] , [ one : 1 , two : 2 ] ) iex&gt; Enum . sort ( result ) [ one : 1 , two : 3 ] If atoms are given, they are supported as keys but do not provide a default value: iex&gt; { :ok , result } = Keyword . validate ( [ ] , [ :one , two : 2 ] ) iex&gt; Enum . sort ( result ) [ two : 2 ] iex&gt; { :ok , result } = Keyword . validate ( [ one : 1 ] , [ :one , two : 2 ] ) iex&gt; Enum . sort ( result ) [ one : 1 , two : 2 ] Passing unknown keys returns an error: iex&gt; Keyword . validate ( [ three : 3 , four : 4 ] , [ one : 1 , two : 2 ] ) { :error , [ :four , :three ] } Passing the same key multiple times also errors: iex&gt; Keyword . validate ( [ one : 1 , two : 2 , one : 1 ] , [ :one , :two ] ) { :error , [ :one ] }","ref":"Keyword.html#validate/2","source_doc":"Ensures the given `keyword` has only the keys given in `values`.\n\nThe second argument must be a list of atoms, specifying\na given key, or tuples specifying a key and a default value.\n\nIf the keyword list has only the given keys, it returns\n`{:ok, keyword}` with default values applied. Otherwise it\nreturns `{:error, invalid_keys}` with invalid keys.\n\nSee also: `validate!/2`.\n\n## Examples\n\n    iex> {:ok, result} = Keyword.validate([], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\n    iex> {:ok, result} = Keyword.validate([two: 3], [one: 1, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> {:ok, result} = Keyword.validate([], [:one, two: 2])\n    iex> Enum.sort(result)\n    [two: 2]\n\n    iex> {:ok, result} = Keyword.validate([one: 1], [:one, two: 2])\n    iex> Enum.sort(result)\n    [one: 1, two: 2]\n\nPassing unknown keys returns an error:\n\n    iex> Keyword.validate([three: 3, four: 4], [one: 1, two: 2])\n    {:error, [:four, :three]}\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate([one: 1, two: 2, one: 1], [:one, :two])\n    {:error, [:one]}\n\n","title":"Keyword.validate/2","type":"function"},{"doc":"Similar to validate/2 but returns the keyword or raises an error. Examples iex&gt; Keyword . validate! ( [ ] , [ one : 1 , two : 2 ] ) |&gt; Enum . sort ( ) [ one : 1 , two : 2 ] iex&gt; Keyword . validate! ( [ two : 3 ] , [ one : 1 , two : 2 ] ) |&gt; Enum . sort ( ) [ one : 1 , two : 3 ] If atoms are given, they are supported as keys but do not provide a default value: iex&gt; Keyword . validate! ( [ ] , [ :one , two : 2 ] ) |&gt; Enum . sort ( ) [ two : 2 ] iex&gt; Keyword . validate! ( [ one : 1 ] , [ :one , two : 2 ] ) |&gt; Enum . sort ( ) [ one : 1 , two : 2 ] Passing unknown keys raises an error: iex&gt; Keyword . validate! ( [ three : 3 ] , [ one : 1 , two : 2 ] ) ** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two] Passing the same key multiple times also errors: iex&gt; Keyword . validate! ( [ one : 1 , two : 2 , one : 1 ] , [ :one , :two ] ) ** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]","ref":"Keyword.html#validate!/2","source_doc":"Similar to `validate/2` but returns the keyword or raises an error.\n\n## Examples\n\n    iex> Keyword.validate!([], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n    iex> Keyword.validate!([two: 3], [one: 1, two: 2]) |> Enum.sort()\n    [one: 1, two: 3]\n\nIf atoms are given, they are supported as keys but do not\nprovide a default value:\n\n    iex> Keyword.validate!([], [:one, two: 2]) |> Enum.sort()\n    [two: 2]\n    iex> Keyword.validate!([one: 1], [:one, two: 2]) |> Enum.sort()\n    [one: 1, two: 2]\n\nPassing unknown keys raises an error:\n\n    iex> Keyword.validate!([three: 3], [one: 1, two: 2])\n    ** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two]\n\nPassing the same key multiple times also errors:\n\n    iex> Keyword.validate!([one: 1, two: 2, one: 1], [:one, :two])\n    ** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]\n\n","title":"Keyword.validate!/2","type":"function"},{"doc":"Returns all values from the keyword list. Keeps values from duplicate keys in the resulting list of values. Examples iex&gt; Keyword . values ( a : 1 , b : 2 ) [ 1 , 2 ] iex&gt; Keyword . values ( a : 1 , b : 2 , a : 3 ) [ 1 , 2 , 3 ]","ref":"Keyword.html#values/1","source_doc":"Returns all values from the keyword list.\n\nKeeps values from duplicate keys in the resulting list of values.\n\n## Examples\n\n    iex> Keyword.values(a: 1, b: 2)\n    [1, 2]\n    iex> Keyword.values(a: 1, b: 2, a: 3)\n    [1, 2, 3]\n\n","title":"Keyword.values/1","type":"function"},{"doc":"","ref":"Keyword.html#t:key/0","source_doc":false,"title":"Keyword.key/0","type":"type"},{"doc":"","ref":"Keyword.html#t:t/0","source_doc":false,"title":"Keyword.t/0","type":"type"},{"doc":"","ref":"Keyword.html#t:t/1","source_doc":false,"title":"Keyword.t/1","type":"type"},{"doc":"","ref":"Keyword.html#t:value/0","source_doc":false,"title":"Keyword.value/0","type":"type"},{"doc":"Linked lists hold zero, one, or more elements in the chosen order. Lists in Elixir are specified between square brackets: iex&gt; [ 1 , &quot;two&quot; , 3 , :four ] [ 1 , &quot;two&quot; , 3 , :four ] Two lists can be concatenated and subtracted using the ++/2 and --/2 operators: iex&gt; [ 1 , 2 , 3 ] ++ [ 4 , 5 , 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; [ 1 , true , 2 , false , 3 , true ] -- [ true , false ] [ 1 , 2 , 3 , true ] An element can be prepended to a list using | : iex&gt; new = 0 iex&gt; list = [ 1 , 2 , 3 ] iex&gt; [ new | list ] [ 0 , 1 , 2 , 3 ] Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list: iex&gt; [ head | tail ] = [ 1 , 2 , 3 ] iex&gt; head 1 iex&gt; tail [ 2 , 3 ] Similarly, we could write the list [1, 2, 3] using only such pairs (called cons cells): iex&gt; [ 1 | [ 2 | [ 3 | [ ] ] ] ] [ 1 , 2 , 3 ] Some lists, called improper lists, do not have an empty list as the second element in the last cons cell: iex&gt; [ 1 | [ 2 | [ 3 | 4 ] ] ] [ 1 , 2 , 3 | 4 ] Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the IO module). Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time): iex&gt; list = [ 1 , 2 , 3 ] iex&gt; [ 0 | list ] # fast [ 0 , 1 , 2 , 3 ] iex&gt; list ++ [ 4 ] # slow [ 1 , 2 , 3 , 4 ] Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example length/1 and last/1 will run in linear time because they need to iterate through every element of the list, but first/1 will run in constant time because it only needs the first element. Lists also implement the Enumerable protocol, so many functions to work with lists are found in the Enum module. Additionally, the following functions and operators for lists are found in Kernel : ++/2 --/2 hd/1 tl/1 in/2 length/1 Charlists If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must: be within the range 0..0x10FFFF ( 0..1_114_111 ); and be out of the range 0xD800..0xDFFF ( 55_296..57_343 ), which is reserved in Unicode for UTF-16 surrogate pairs. Elixir uses the ~c sigil to define charlists: iex&gt; ~c&quot;héllo&quot; [ 104 , 233 , 108 , 108 , 111 ] In particular, charlists will be printed back by default with the ~c sigil if they contain only printable ASCII characters: iex&gt; ~c&quot;abc&quot; ~c&quot;abc&quot; Even though the representation changed, the raw data does remain a list of integers, which can be handled as such: iex&gt; inspect ( ~c&quot;abc&quot; , charlists : :as_list ) &quot;[97, 98, 99]&quot; iex&gt; Enum . map ( ~c&quot;abc&quot; , fn num -&gt; 1000 + num end ) [ 1097 , 1098 , 1099 ] You can use the IEx.Helpers.i/1 helper to get a condensed rundown on charlists in IEx when you encounter them, which shows you the type, description and also the raw representation in one single summary. The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is Application.loaded_applications/0 : Application . loaded_applications ( ) #=&gt; [ #=&gt; {:stdlib, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;2.6&quot;}, #=&gt; {:compiler, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;6.0.1&quot;}, #=&gt; {:elixir, ~c&quot;elixir&quot;, ~c&quot;1.0.0&quot;}, #=&gt; {:kernel, ~c&quot;ERTS CXC 138 10&quot;, ~c&quot;4.1&quot;}, #=&gt; {:logger, ~c&quot;logger&quot;, ~c&quot;1.0.0&quot;} #=&gt; ] A list can be checked if it is made of only printable ASCII characters with ascii_printable?/2 . Improper lists are never deemed as charlists.","ref":"List.html","source_doc":"Linked lists hold zero, one, or more elements in the chosen order.\n\nLists in Elixir are specified between square brackets:\n\n    iex> [1, \"two\", 3, :four]\n    [1, \"two\", 3, :four]\n\nTwo lists can be concatenated and subtracted using the\n`++/2` and `--/2` operators:\n\n    iex> [1, 2, 3] ++ [4, 5, 6]\n    [1, 2, 3, 4, 5, 6]\n    iex> [1, true, 2, false, 3, true] -- [true, false]\n    [1, 2, 3, true]\n\nAn element can be prepended to a list using `|`:\n\n    iex> new = 0\n    iex> list = [1, 2, 3]\n    iex> [new | list]\n    [0, 1, 2, 3]\n\nLists in Elixir are effectively linked lists, which means\nthey are internally represented in pairs containing the\nhead and the tail of a list:\n\n    iex> [head | tail] = [1, 2, 3]\n    iex> head\n    1\n    iex> tail\n    [2, 3]\n\nSimilarly, we could write the list `[1, 2, 3]` using only\nsuch pairs (called cons cells):\n\n    iex> [1 | [2 | [3 | []]]]\n    [1, 2, 3]\n\nSome lists, called improper lists, do not have an empty list as\nthe second element in the last cons cell:\n\n    iex> [1 | [2 | [3 | 4]]]\n    [1, 2, 3 | 4]\n\nAlthough improper lists are generally avoided, they are used in some\nspecial circumstances like iodata and chardata entities (see the `IO` module).\n\nDue to their cons cell based representation, prepending an element\nto a list is always fast (constant time), while appending becomes\nslower as the list grows in size (linear time):\n\n    iex> list = [1, 2, 3]\n    iex> [0 | list] # fast\n    [0, 1, 2, 3]\n    iex> list ++ [4] # slow\n    [1, 2, 3, 4]\n\nMost of the functions in this module work in linear time. This means that,\nthat the time it takes to perform an operation grows at the same rate as the\nlength of the list. For example `length/1` and `last/1` will run in linear\ntime because they need to iterate through every element of the list, but\n`first/1` will run in constant time because it only needs the first element.\n\nLists also implement the `Enumerable` protocol, so many functions to work with\nlists are found in the `Enum` module. Additionally, the following functions and\noperators for lists are found in `Kernel`:\n\n  * `++/2`\n  * `--/2`\n  * `hd/1`\n  * `tl/1`\n  * `in/2`\n  * `length/1`\n\n## Charlists\n\nIf a list is made of non-negative integers, where each integer represents a\nUnicode code point, the list can also be called a charlist. These integers\nmust:\n\n  * be within the range `0..0x10FFFF` (`0..1_114_111`);\n  * and be out of the range `0xD800..0xDFFF` (`55_296..57_343`), which is\n    reserved in Unicode for UTF-16 surrogate pairs.\n\nElixir uses the [`~c` sigil](`sigil_c/2`) to define charlists:\n\n    iex> ~c\"héllo\"\n    [104, 233, 108, 108, 111]\n\nIn particular, charlists will be printed back by default with the `~c`\nsigil if they contain only printable ASCII characters:\n\n    iex> ~c\"abc\"\n    ~c\"abc\"\n\nEven though the representation changed, the raw data does remain a list of\nintegers, which can be handled as such:\n\n    iex> inspect(~c\"abc\", charlists: :as_list)\n    \"[97, 98, 99]\"\n    iex> Enum.map(~c\"abc\", fn num -> 1000 + num end)\n    [1097, 1098, 1099]\n\nYou can use the `IEx.Helpers.i/1` helper to get a condensed rundown on\ncharlists in IEx when you encounter them, which shows you the type, description\nand also the raw representation in one single summary.\n\nThe rationale behind this behaviour is to better support\nErlang libraries which may return text as charlists\ninstead of Elixir strings. In Erlang, charlists are the default\nway of handling strings, while in Elixir it's binaries. One\nexample of such functions is `Application.loaded_applications/0`:\n\n    Application.loaded_applications()\n    #=>  [\n    #=>    {:stdlib, ~c\"ERTS  CXC 138 10\", ~c\"2.6\"},\n    #=>    {:compiler, ~c\"ERTS  CXC 138 10\", ~c\"6.0.1\"},\n    #=>    {:elixir, ~c\"elixir\", ~c\"1.0.0\"},\n    #=>    {:kernel, ~c\"ERTS  CXC 138 10\", ~c\"4.1\"},\n    #=>    {:logger, ~c\"logger\", ~c\"1.0.0\"}\n    #=>  ]\n\nA list can be checked if it is made of only printable ASCII\ncharacters with `ascii_printable?/2`.\n\nImproper lists are never deemed as charlists.\n","title":"List","type":"module"},{"doc":"Checks if list is a charlist made only of printable ASCII characters. Takes an optional limit as a second argument. ascii_printable?/2 only checks the printability of the list up to the limit . A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters: ?\\a - Bell ?\\b - Backspace ?\\t - Horizontal tab ?\\n - Line feed ?\\v - Vertical tab ?\\f - Form feed ?\\r - Carriage return ?\\e - Escape For more information read the Character groups section in the Wikipedia article of the ASCII standard. Examples iex&gt; List . ascii_printable? ( ~c&quot;abc&quot; ) true iex&gt; List . ascii_printable? ( ~c&quot;abc&quot; ++ [ 0 ] ) false iex&gt; List . ascii_printable? ( ~c&quot;abc&quot; ++ [ 0 ] , 2 ) true Improper lists are not printable, even if made only of ASCII characters: iex&gt; List . ascii_printable? ( ~c&quot;abc&quot; ++ ?d ) false","ref":"List.html#ascii_printable?/2","source_doc":"Checks if `list` is a charlist made only of printable ASCII characters.\n\nTakes an optional `limit` as a second argument. `ascii_printable?/2` only\nchecks the printability of the list up to the `limit`.\n\nA printable charlist in Elixir contains only the printable characters in the\nstandard seven-bit ASCII character encoding, which are characters ranging from\n32 to 126 in decimal notation, plus the following control characters:\n\n  * `?\\a` - Bell\n  * `?\\b` - Backspace\n  * `?\\t` - Horizontal tab\n  * `?\\n` - Line feed\n  * `?\\v` - Vertical tab\n  * `?\\f` - Form feed\n  * `?\\r` - Carriage return\n  * `?\\e` - Escape\n\nFor more information read the [Character groups](https://en.wikipedia.org/wiki/ASCII#Character_groups)\nsection in the Wikipedia article of the [ASCII](https://en.wikipedia.org/wiki/ASCII) standard.\n\n## Examples\n\n    iex> List.ascii_printable?(~c\"abc\")\n    true\n\n    iex> List.ascii_printable?(~c\"abc\" ++ [0])\n    false\n\n    iex> List.ascii_printable?(~c\"abc\" ++ [0], 2)\n    true\n\nImproper lists are not printable, even if made only of ASCII characters:\n\n    iex> List.ascii_printable?(~c\"abc\" ++ ?d)\n    false\n\n","title":"List.ascii_printable?/2","type":"function"},{"doc":"Deletes the given element from the list . Returns a new list without the element. If the element occurs more than once in the list , just the first occurrence is removed. Examples iex&gt; List . delete ( [ :a , :b , :c ] , :a ) [ :b , :c ] iex&gt; List . delete ( [ :a , :b , :c ] , :d ) [ :a , :b , :c ] iex&gt; List . delete ( [ :a , :b , :b , :c ] , :b ) [ :a , :b , :c ] iex&gt; List . delete ( [ ] , :b ) [ ]","ref":"List.html#delete/2","source_doc":"Deletes the given `element` from the `list`. Returns a new list without\nthe element.\n\nIf the `element` occurs more than once in the `list`, just\nthe first occurrence is removed.\n\n## Examples\n\n    iex> List.delete([:a, :b, :c], :a)\n    [:b, :c]\n\n    iex> List.delete([:a, :b, :c], :d)\n    [:a, :b, :c]\n\n    iex> List.delete([:a, :b, :b, :c], :b)\n    [:a, :b, :c]\n\n    iex> List.delete([], :b)\n    []\n\n","title":"List.delete/2","type":"function"},{"doc":"Produces a new list by removing the value at the specified index . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . delete_at ( [ 1 , 2 , 3 ] , 0 ) [ 2 , 3 ] iex&gt; List . delete_at ( [ 1 , 2 , 3 ] , 10 ) [ 1 , 2 , 3 ] iex&gt; List . delete_at ( [ 1 , 2 , 3 ] , - 1 ) [ 1 , 2 ]","ref":"List.html#delete_at/2","source_doc":"Produces a new list by removing the value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.delete_at([1, 2, 3], 0)\n    [2, 3]\n\n    iex> List.delete_at([1, 2, 3], 10)\n    [1, 2, 3]\n\n    iex> List.delete_at([1, 2, 3], -1)\n    [1, 2]\n\n","title":"List.delete_at/2","type":"function"},{"doc":"Duplicates the given element n times in a list. n is an integer greater than or equal to 0 . If n is 0 , an empty list is returned. Examples iex&gt; List . duplicate ( &quot;hello&quot; , 0 ) [ ] iex&gt; List . duplicate ( &quot;hi&quot; , 1 ) [ &quot;hi&quot; ] iex&gt; List . duplicate ( &quot;bye&quot; , 2 ) [ &quot;bye&quot; , &quot;bye&quot; ] iex&gt; List . duplicate ( [ 1 , 2 ] , 3 ) [ [ 1 , 2 ] , [ 1 , 2 ] , [ 1 , 2 ] ]","ref":"List.html#duplicate/2","source_doc":"Duplicates the given element `n` times in a list.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty list is returned.\n\n## Examples\n\n    iex> List.duplicate(\"hello\", 0)\n    []\n\n    iex> List.duplicate(\"hi\", 1)\n    [\"hi\"]\n\n    iex> List.duplicate(\"bye\", 2)\n    [\"bye\", \"bye\"]\n\n    iex> List.duplicate([1, 2], 3)\n    [[1, 2], [1, 2], [1, 2]]\n\n","title":"List.duplicate/2","type":"function"},{"doc":"Returns the first element in list or default if list is empty. first/2 has been introduced in Elixir v1.12.0, while first/1 has been available since v1.0.0. Examples iex&gt; List . first ( [ ] ) nil iex&gt; List . first ( [ ] , 1 ) 1 iex&gt; List . first ( [ 1 ] ) 1 iex&gt; List . first ( [ 1 , 2 , 3 ] ) 1","ref":"List.html#first/2","source_doc":"Returns the first element in `list` or `default` if `list` is empty.\n\n`first/2` has been introduced in Elixir v1.12.0, while `first/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.first([])\n    nil\n\n    iex> List.first([], 1)\n    1\n\n    iex> List.first([1])\n    1\n\n    iex> List.first([1, 2, 3])\n    1\n\n","title":"List.first/2","type":"function"},{"doc":"Flattens the given list of nested lists. Empty list elements are discarded. Examples iex&gt; List . flatten ( [ 1 , [ [ 2 ] , 3 ] ] ) [ 1 , 2 , 3 ] iex&gt; List . flatten ( [ [ ] , [ [ ] , [ ] ] ] ) [ ]","ref":"List.html#flatten/1","source_doc":"Flattens the given `list` of nested lists.\n\nEmpty list elements are discarded.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]])\n    [1, 2, 3]\n\n    iex> List.flatten([[], [[], []]])\n    []\n\n","title":"List.flatten/1","type":"function"},{"doc":"Flattens the given list of nested lists. The list tail will be added at the end of the flattened list. Empty list elements from list are discarded, but not the ones from tail . Examples iex&gt; List . flatten ( [ 1 , [ [ 2 ] , 3 ] ] , [ 4 , 5 ] ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; List . flatten ( [ 1 , [ ] , 2 ] , [ 3 , [ ] , 4 ] ) [ 1 , 2 , 3 , [ ] , 4 ]","ref":"List.html#flatten/2","source_doc":"Flattens the given `list` of nested lists.\nThe list `tail` will be added at the end of\nthe flattened list.\n\nEmpty list elements from `list` are discarded,\nbut not the ones from `tail`.\n\n## Examples\n\n    iex> List.flatten([1, [[2], 3]], [4, 5])\n    [1, 2, 3, 4, 5]\n\n    iex> List.flatten([1, [], 2], [3, [], 4])\n    [1, 2, 3, [], 4]\n\n","title":"List.flatten/2","type":"function"},{"doc":"Folds (reduces) the given list from the left with a function. Requires an accumulator, which can be any value. Examples iex&gt; List . foldl ( [ 5 , 5 ] , 10 , fn x , acc -&gt; x + acc end ) 20 iex&gt; List . foldl ( [ 1 , 2 , 3 , 4 ] , 0 , fn x , acc -&gt; x - acc end ) 2 iex&gt; List . foldl ( [ 1 , 2 , 3 ] , { 0 , 0 } , fn x , { a1 , a2 } -&gt; { a1 + x , a2 - x } end ) { 6 , - 6 }","ref":"List.html#foldl/3","source_doc":"Folds (reduces) the given list from the left with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldl([5, 5], 10, fn x, acc -> x + acc end)\n    20\n\n    iex> List.foldl([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    2\n\n    iex> List.foldl([1, 2, 3], {0, 0}, fn x, {a1, a2} -> {a1 + x, a2 - x} end)\n    {6, -6}\n\n","title":"List.foldl/3","type":"function"},{"doc":"Folds (reduces) the given list from the right with a function. Requires an accumulator, which can be any value. Examples iex&gt; List . foldr ( [ 1 , 2 , 3 , 4 ] , 0 , fn x , acc -&gt; x - acc end ) - 2 iex&gt; List . foldr ( [ 1 , 2 , 3 , 4 ] , %{ sum : 0 , product : 1 } , fn x , %{ sum : a1 , product : a2 } -&gt; %{ sum : a1 + x , product : a2 * x } end ) %{ product : 24 , sum : 10 }","ref":"List.html#foldr/3","source_doc":"Folds (reduces) the given list from the right with\na function. Requires an accumulator, which can be any value.\n\n## Examples\n\n    iex> List.foldr([1, 2, 3, 4], 0, fn x, acc -> x - acc end)\n    -2\n\n    iex> List.foldr([1, 2, 3, 4], %{sum: 0, product: 1}, fn x, %{sum: a1, product: a2} -> %{sum: a1 + x, product: a2 * x} end)\n    %{product: 24, sum: 10}\n\n","title":"List.foldr/3","type":"function"},{"doc":"Returns true if list is an improper list. Otherwise returns false . Examples iex&gt; List . improper? ( [ 1 , 2 | 3 ] ) true iex&gt; List . improper? ( [ 1 , 2 , 3 ] ) false","ref":"List.html#improper?/1","source_doc":"Returns `true` if `list` is an improper list. Otherwise returns `false`.\n\n## Examples\n\n    iex> List.improper?([1, 2 | 3])\n    true\n\n    iex> List.improper?([1, 2, 3])\n    false\n\n","title":"List.improper?/1","type":"function"},{"doc":"Returns a list with value inserted at the specified index . Note that index is capped at the list length. Negative indices indicate an offset from the end of the list . Examples iex&gt; List . insert_at ( [ 1 , 2 , 3 , 4 ] , 2 , 0 ) [ 1 , 2 , 0 , 3 , 4 ] iex&gt; List . insert_at ( [ 1 , 2 , 3 ] , 10 , 0 ) [ 1 , 2 , 3 , 0 ] iex&gt; List . insert_at ( [ 1 , 2 , 3 ] , - 1 , 0 ) [ 1 , 2 , 3 , 0 ] iex&gt; List . insert_at ( [ 1 , 2 , 3 ] , - 10 , 0 ) [ 0 , 1 , 2 , 3 ]","ref":"List.html#insert_at/3","source_doc":"Returns a list with `value` inserted at the specified `index`.\n\nNote that `index` is capped at the list length. Negative indices\nindicate an offset from the end of the `list`.\n\n## Examples\n\n    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n    [1, 2, 0, 3, 4]\n\n    iex> List.insert_at([1, 2, 3], 10, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -1, 0)\n    [1, 2, 3, 0]\n\n    iex> List.insert_at([1, 2, 3], -10, 0)\n    [0, 1, 2, 3]\n\n","title":"List.insert_at/3","type":"function"},{"doc":"Receives a list of tuples and deletes the first tuple where the element at position matches the given key . Returns the new list. Examples iex&gt; List . keydelete ( [ a : 1 , b : 2 ] , :a , 0 ) [ b : 2 ] iex&gt; List . keydelete ( [ a : 1 , b : 2 ] , 2 , 1 ) [ a : 1 ] iex&gt; List . keydelete ( [ a : 1 , b : 2 ] , :c , 0 ) [ a : 1 , b : 2 ] This function works for any list of tuples: iex&gt; List . keydelete ( [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ] , 80 , 0 ) [ { 22 , &quot;SSH&quot; } ]","ref":"List.html#keydelete/3","source_doc":"Receives a `list` of tuples and deletes the first tuple\nwhere the element at `position` matches the\ngiven `key`. Returns the new list.\n\n## Examples\n\n    iex> List.keydelete([a: 1, b: 2], :a, 0)\n    [b: 2]\n\n    iex> List.keydelete([a: 1, b: 2], 2, 1)\n    [a: 1]\n\n    iex> List.keydelete([a: 1, b: 2], :c, 0)\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keydelete([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    [{22, \"SSH\"}]\n\n","title":"List.keydelete/3","type":"function"},{"doc":"Receives a list of tuples and returns the first tuple where the element at position in the tuple matches the given key . If no matching tuple is found, default is returned. Examples iex&gt; List . keyfind ( [ a : 1 , b : 2 ] , :a , 0 ) { :a , 1 } iex&gt; List . keyfind ( [ a : 1 , b : 2 ] , 2 , 1 ) { :b , 2 } iex&gt; List . keyfind ( [ a : 1 , b : 2 ] , :c , 0 ) nil This function works for any list of tuples: iex&gt; List . keyfind ( [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ] , 22 , 0 ) { 22 , &quot;SSH&quot; }","ref":"List.html#keyfind/4","source_doc":"Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, `default` is returned.\n\n## Examples\n\n    iex> List.keyfind([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}\n\n","title":"List.keyfind/4","type":"function"},{"doc":"Receives a list of tuples and returns the first tuple where the element at position in the tuple matches the given key . If no matching tuple is found, an error is raised. Examples iex&gt; List . keyfind! ( [ a : 1 , b : 2 ] , :a , 0 ) { :a , 1 } iex&gt; List . keyfind! ( [ a : 1 , b : 2 ] , 2 , 1 ) { :b , 2 } iex&gt; List . keyfind! ( [ a : 1 , b : 2 ] , :c , 0 ) ** (KeyError) key :c at position 0 not found in: [a: 1, b: 2] This function works for any list of tuples: iex&gt; List . keyfind! ( [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ] , 22 , 0 ) { 22 , &quot;SSH&quot; }","ref":"List.html#keyfind!/3","source_doc":"Receives a list of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`.\n\nIf no matching tuple is found, an error is raised.\n\n## Examples\n\n    iex> List.keyfind!([a: 1, b: 2], :a, 0)\n    {:a, 1}\n\n    iex> List.keyfind!([a: 1, b: 2], 2, 1)\n    {:b, 2}\n\n    iex> List.keyfind!([a: 1, b: 2], :c, 0)\n    ** (KeyError) key :c at position 0 not found in: [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyfind!([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    {22, \"SSH\"}\n\n","title":"List.keyfind!/3","type":"function"},{"doc":"Receives a list of tuples and returns true if there is a tuple where the element at position in the tuple matches the given key . Examples iex&gt; List . keymember? ( [ a : 1 , b : 2 ] , :a , 0 ) true iex&gt; List . keymember? ( [ a : 1 , b : 2 ] , 2 , 1 ) true iex&gt; List . keymember? ( [ a : 1 , b : 2 ] , :c , 0 ) false This function works for any list of tuples: iex&gt; List . keymember? ( [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ] , 22 , 0 ) true","ref":"List.html#keymember?/3","source_doc":"Receives a list of tuples and returns `true` if there is\na tuple where the element at `position` in the tuple matches\nthe given `key`.\n\n## Examples\n\n    iex> List.keymember?([a: 1, b: 2], :a, 0)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], 2, 1)\n    true\n\n    iex> List.keymember?([a: 1, b: 2], :c, 0)\n    false\n\nThis function works for any list of tuples:\n\n    iex> List.keymember?([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0)\n    true\n\n","title":"List.keymember?/3","type":"function"},{"doc":"Receives a list of tuples and if the identified element by key at position exists, it is replaced with new_tuple . Examples iex&gt; List . keyreplace ( [ a : 1 , b : 2 ] , :a , 0 , { :a , 3 } ) [ a : 3 , b : 2 ] iex&gt; List . keyreplace ( [ a : 1 , b : 2 ] , :a , 1 , { :a , 3 } ) [ a : 1 , b : 2 ] This function works for any list of tuples: iex&gt; List . keyreplace ( [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ] , 22 , 0 , { 22 , &quot;Secure Shell&quot; } ) [ { 22 , &quot;Secure Shell&quot; } , { 80 , &quot;HTTP&quot; } ]","ref":"List.html#keyreplace/4","source_doc":"Receives a list of tuples and if the identified element by `key` at `position`\nexists, it is replaced with `new_tuple`.\n\n## Examples\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keyreplace([a: 1, b: 2], :a, 1, {:a, 3})\n    [a: 1, b: 2]\n\nThis function works for any list of tuples:\n\n    iex> List.keyreplace([{22, \"SSH\"}, {80, \"HTTP\"}], 22, 0, {22, \"Secure Shell\"})\n    [{22, \"Secure Shell\"}, {80, \"HTTP\"}]\n\n","title":"List.keyreplace/4","type":"function"},{"doc":"Receives a list of tuples and sorts the elements at position of the tuples. The sort is stable. A sorter argument is available since Elixir v1.14.0. Similar to Enum.sort/2 , the sorter can be an anonymous function, the atoms :asc or :desc , or module that implements a compare function. Examples iex&gt; List . keysort ( [ a : 5 , b : 1 , c : 3 ] , 1 ) [ b : 1 , c : 3 , a : 5 ] iex&gt; List . keysort ( [ a : 5 , c : 1 , b : 3 ] , 0 ) [ a : 5 , b : 3 , c : 1 ] To sort in descending order: iex&gt; List . keysort ( [ a : 5 , c : 1 , b : 3 ] , 0 , :desc ) [ c : 1 , b : 3 , a : 5 ] As in Enum.sort/2 , avoid using the default sorting function to sort structs, as by default it performs structural comparison instead of a semantic one. In such cases, you shall pass a sorting function as third element or any module that implements a compare/2 function. For example, if you have tuples with user names and their birthday, and you want to sort on their birthday, in both ascending and descending order, you should do: iex&gt; users = [ ...&gt; { &quot;Ellis&quot; , ~D[1943-05-11] } , ...&gt; { &quot;Lovelace&quot; , ~D[1815-12-10] } , ...&gt; { &quot;Turing&quot; , ~D[1912-06-23] } ...&gt; ] iex&gt; List . keysort ( users , 1 , Date ) [ { &quot;Lovelace&quot; , ~D[1815-12-10] } , { &quot;Turing&quot; , ~D[1912-06-23] } , { &quot;Ellis&quot; , ~D[1943-05-11] } ] iex&gt; List . keysort ( users , 1 , { :desc , Date } ) [ { &quot;Ellis&quot; , ~D[1943-05-11] } , { &quot;Turing&quot; , ~D[1912-06-23] } , { &quot;Lovelace&quot; , ~D[1815-12-10] } ]","ref":"List.html#keysort/3","source_doc":"Receives a list of tuples and sorts the elements\nat `position` of the tuples.\n\nThe sort is stable.\n\nA `sorter` argument is available since Elixir v1.14.0. Similar to\n`Enum.sort/2`, the sorter can be an anonymous function, the atoms\n`:asc` or `:desc`, or module that implements a compare function.\n\n## Examples\n\n    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n    [b: 1, c: 3, a: 5]\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n    [a: 5, b: 3, c: 1]\n\nTo sort in descending order:\n\n    iex> List.keysort([a: 5, c: 1, b: 3], 0, :desc)\n    [c: 1, b: 3, a: 5]\n\nAs in `Enum.sort/2`, avoid using the default sorting function to sort\nstructs, as by default it performs structural comparison instead of a\nsemantic one. In such cases, you shall pass a sorting function as third\nelement or any module that implements a `compare/2` function. For example,\nif you have tuples with user names and their birthday, and you want to\nsort on their birthday, in both ascending and descending order, you should\ndo:\n\n    iex> users = [\n    ...>   {\"Ellis\", ~D[1943-05-11]},\n    ...>   {\"Lovelace\", ~D[1815-12-10]},\n    ...>   {\"Turing\", ~D[1912-06-23]}\n    ...> ]\n    iex> List.keysort(users, 1, Date)\n    [\n      {\"Lovelace\", ~D[1815-12-10]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Ellis\", ~D[1943-05-11]}\n    ]\n    iex> List.keysort(users, 1, {:desc, Date})\n    [\n      {\"Ellis\", ~D[1943-05-11]},\n      {\"Turing\", ~D[1912-06-23]},\n      {\"Lovelace\", ~D[1815-12-10]}\n    ]\n\n","title":"List.keysort/3","type":"function"},{"doc":"Receives a list of tuples and replaces the element identified by key at position with new_tuple . If the element does not exist, it is added to the end of the list . Examples iex&gt; List . keystore ( [ a : 1 , b : 2 ] , :a , 0 , { :a , 3 } ) [ a : 3 , b : 2 ] iex&gt; List . keystore ( [ a : 1 , b : 2 ] , :c , 0 , { :c , 3 } ) [ a : 1 , b : 2 , c : 3 ] This function works for any list of tuples: iex&gt; List . keystore ( [ { 22 , &quot;SSH&quot; } ] , 80 , 0 , { 80 , &quot;HTTP&quot; } ) [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ]","ref":"List.html#keystore/4","source_doc":"Receives a `list` of tuples and replaces the element\nidentified by `key` at `position` with `new_tuple`.\n\nIf the element does not exist, it is added to the end of the `list`.\n\n## Examples\n\n    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n    [a: 3, b: 2]\n\n    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n    [a: 1, b: 2, c: 3]\n\nThis function works for any list of tuples:\n\n    iex> List.keystore([{22, \"SSH\"}], 80, 0, {80, \"HTTP\"})\n    [{22, \"SSH\"}, {80, \"HTTP\"}]\n\n","title":"List.keystore/4","type":"function"},{"doc":"Receives a list of tuples and returns the first tuple where the element at position in the tuple matches the given key , as well as the list without found tuple. If such a tuple is not found, nil will be returned. Examples iex&gt; List . keytake ( [ a : 1 , b : 2 ] , :a , 0 ) { { :a , 1 } , [ b : 2 ] } iex&gt; List . keytake ( [ a : 1 , b : 2 ] , 2 , 1 ) { { :b , 2 } , [ a : 1 ] } iex&gt; List . keytake ( [ a : 1 , b : 2 ] , :c , 0 ) nil This function works for any list of tuples: iex&gt; List . keytake ( [ { 22 , &quot;SSH&quot; } , { 80 , &quot;HTTP&quot; } ] , 80 , 0 ) { { 80 , &quot;HTTP&quot; } , [ { 22 , &quot;SSH&quot; } ] }","ref":"List.html#keytake/3","source_doc":"Receives a `list` of tuples and returns the first tuple\nwhere the element at `position` in the tuple matches the\ngiven `key`, as well as the `list` without found tuple.\n\nIf such a tuple is not found, `nil` will be returned.\n\n## Examples\n\n    iex> List.keytake([a: 1, b: 2], :a, 0)\n    {{:a, 1}, [b: 2]}\n\n    iex> List.keytake([a: 1, b: 2], 2, 1)\n    {{:b, 2}, [a: 1]}\n\n    iex> List.keytake([a: 1, b: 2], :c, 0)\n    nil\n\nThis function works for any list of tuples:\n\n    iex> List.keytake([{22, \"SSH\"}, {80, \"HTTP\"}], 80, 0)\n    {{80, \"HTTP\"}, [{22, \"SSH\"}]}\n\n","title":"List.keytake/3","type":"function"},{"doc":"Returns the last element in list or default if list is empty. last/2 has been introduced in Elixir v1.12.0, while last/1 has been available since v1.0.0. Examples iex&gt; List . last ( [ ] ) nil iex&gt; List . last ( [ ] , 1 ) 1 iex&gt; List . last ( [ 1 ] ) 1 iex&gt; List . last ( [ 1 , 2 , 3 ] ) 3","ref":"List.html#last/2","source_doc":"Returns the last element in `list` or `default` if `list` is empty.\n\n`last/2` has been introduced in Elixir v1.12.0, while `last/1` has been available since v1.0.0.\n\n## Examples\n\n    iex> List.last([])\n    nil\n\n    iex> List.last([], 1)\n    1\n\n    iex> List.last([1])\n    1\n\n    iex> List.last([1, 2, 3])\n    3\n\n","title":"List.last/2","type":"function"},{"doc":"Returns a keyword list that represents an edit script . The algorithm is outlined in the &quot;An O(ND) Difference Algorithm and Its Variations&quot; paper by E. Myers. An edit script is a keyword list. Each key describes the &quot;editing action&quot; to take in order to bring list1 closer to being equal to list2 ; a key can be :eq , :ins , or :del . Each value is a sublist of either list1 or list2 that should be inserted (if the corresponding key :ins ), deleted (if the corresponding key is :del ), or left alone (if the corresponding key is :eq ) in list1 in order to be closer to list2 . See myers_difference/3 if you want to handle nesting in the diff scripts. Examples iex&gt; List . myers_difference ( [ 1 , 4 , 2 , 3 ] , [ 1 , 2 , 3 , 4 ] ) [ eq : [ 1 ] , del : [ 4 ] , eq : [ 2 , 3 ] , ins : [ 4 ] ]","ref":"List.html#myers_difference/2","source_doc":"Returns a keyword list that represents an *edit script*.\n\nThe algorithm is outlined in the\n\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n\nAn *edit script* is a keyword list. Each key describes the \"editing action\" to\ntake in order to bring `list1` closer to being equal to `list2`; a key can be\n`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or `list2`\nthat should be inserted (if the corresponding key `:ins`), deleted (if the\ncorresponding key is `:del`), or left alone (if the corresponding key is\n`:eq`) in `list1` in order to be closer to `list2`.\n\nSee `myers_difference/3` if you want to handle nesting in the diff scripts.\n\n## Examples\n\n    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n    [eq: [1], del: [4], eq: [2, 3], ins: [4]]\n\n","title":"List.myers_difference/2","type":"function"},{"doc":"Returns a keyword list that represents an edit script with nested diffs. This is an extension of myers_difference/2 where a diff_script function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or nil in case there is no such script. The returned inner edit script will be under the :diff key. Examples iex&gt; List . myers_difference ( [ &quot;a&quot; , &quot;db&quot; , &quot;c&quot; ] , [ &quot;a&quot; , &quot;bc&quot; ] , &amp; String . myers_difference / 2 ) [ eq : [ &quot;a&quot; ] , diff : [ del : &quot;d&quot; , eq : &quot;b&quot; , ins : &quot;c&quot; ] , del : [ &quot;c&quot; ] ]","ref":"List.html#myers_difference/3","source_doc":"Returns a keyword list that represents an *edit script* with nested diffs.\n\nThis is an extension of `myers_difference/2` where a `diff_script` function\ncan be given in case it is desired to compute nested differences. The function\nmay return a list with the inner edit script or `nil` in case there is no\nsuch script. The returned inner edit script will be under the `:diff` key.\n\n## Examples\n\n    iex> List.myers_difference([\"a\", \"db\", \"c\"], [\"a\", \"bc\"], &String.myers_difference/2)\n    [eq: [\"a\"], diff: [del: \"d\", eq: \"b\", ins: \"c\"], del: [\"c\"]]\n\n","title":"List.myers_difference/3","type":"function"},{"doc":"Returns and removes the value at the specified index in the list . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , 0 ) { 1 , [ 2 , 3 ] } iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , 5 ) { nil , [ 1 , 2 , 3 ] } iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , 5 , 10 ) { 10 , [ 1 , 2 , 3 ] } iex&gt; List . pop_at ( [ 1 , 2 , 3 ] , - 1 ) { 3 , [ 1 , 2 ] }","ref":"List.html#pop_at/3","source_doc":"Returns and removes the value at the specified `index` in the `list`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.pop_at([1, 2, 3], 0)\n    {1, [2, 3]}\n    iex> List.pop_at([1, 2, 3], 5)\n    {nil, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], 5, 10)\n    {10, [1, 2, 3]}\n    iex> List.pop_at([1, 2, 3], -1)\n    {3, [1, 2]}\n\n","title":"List.pop_at/3","type":"function"},{"doc":"Returns a list with a replaced value at the specified index . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , 0 , 0 ) [ 0 , 2 , 3 ] iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , 10 , 0 ) [ 1 , 2 , 3 ] iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , - 1 , 0 ) [ 1 , 2 , 0 ] iex&gt; List . replace_at ( [ 1 , 2 , 3 ] , - 10 , 0 ) [ 1 , 2 , 3 ]","ref":"List.html#replace_at/3","source_doc":"Returns a list with a replaced value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.replace_at([1, 2, 3], 0, 0)\n    [0, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], 10, 0)\n    [1, 2, 3]\n\n    iex> List.replace_at([1, 2, 3], -1, 0)\n    [1, 2, 0]\n\n    iex> List.replace_at([1, 2, 3], -10, 0)\n    [1, 2, 3]\n\n","title":"List.replace_at/3","type":"function"},{"doc":"Returns true if list starts with the given prefix list; otherwise returns false . If prefix is an empty list, it returns true . Examples iex&gt; List . starts_with? ( [ 1 , 2 , 3 ] , [ 1 , 2 ] ) true iex&gt; List . starts_with? ( [ 1 , 2 ] , [ 1 , 2 , 3 ] ) false iex&gt; List . starts_with? ( [ :alpha ] , [ ] ) true iex&gt; List . starts_with? ( [ ] , [ :alpha ] ) false","ref":"List.html#starts_with?/2","source_doc":"Returns `true` if `list` starts with the given `prefix` list; otherwise returns `false`.\n\nIf `prefix` is an empty list, it returns `true`.\n\n### Examples\n\n    iex> List.starts_with?([1, 2, 3], [1, 2])\n    true\n\n    iex> List.starts_with?([1, 2], [1, 2, 3])\n    false\n\n    iex> List.starts_with?([:alpha], [])\n    true\n\n    iex> List.starts_with?([], [:alpha])\n    false\n\n","title":"List.starts_with?/2","type":"function"},{"doc":"Converts a charlist to an atom. Elixir supports conversions from charlists which contains any Unicode code point. Inlined by the compiler. Examples iex&gt; List . to_atom ( ~c&quot;Elixir&quot; ) :Elixir iex&gt; List . to_atom ( ~c&quot;🌢 Elixir&quot; ) :&quot;🌢 Elixir&quot;","ref":"List.html#to_atom/1","source_doc":"Converts a charlist to an atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_atom(~c\"Elixir\")\n    :Elixir\n\n    iex> List.to_atom(~c\"🌢 Elixir\")\n    :\"🌢 Elixir\"\n\n","title":"List.to_atom/1","type":"function"},{"doc":"Converts a list of integers representing Unicode code points, lists or strings into a charlist. Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the :binary module . Examples iex&gt; ~c&quot;æß&quot; = List . to_charlist ( [ 0x00E6 , 0x00DF ] ) [ 230 , 223 ] iex&gt; List . to_charlist ( [ 0x0061 , &quot;bc&quot; ] ) ~c&quot;abc&quot; iex&gt; List . to_charlist ( [ 0x0064 , &quot;ee&quot; , [ ~c&quot;p&quot; ] ] ) ~c&quot;deep&quot;","ref":"List.html#to_charlist/1","source_doc":"Converts a list of integers representing Unicode code points, lists or\nstrings into a charlist.\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> ~c\"æß\" = List.to_charlist([0x00E6, 0x00DF])\n    [230, 223]\n\n    iex> List.to_charlist([0x0061, \"bc\"])\n    ~c\"abc\"\n\n    iex> List.to_charlist([0x0064, \"ee\", [~c\"p\"]])\n    ~c\"deep\"\n\n","title":"List.to_charlist/1","type":"function"},{"doc":"Converts a charlist to an existing atom. Elixir supports conversions from charlists which contains any Unicode code point. Raises an ArgumentError if the atom does not exist. Inlined by the compiler. Atoms and modules Since Elixir is a compiled language, the atoms defined in a module will only exist after said module is loaded, which typically happens whenever a function in the module is executed. Therefore, it is generally recommended to call List.to_existing_atom/1 only to convert atoms defined within the module making the function call to to_existing_atom/1 . Examples iex&gt; _ = :my_atom iex&gt; List . to_existing_atom ( ~c&quot;my_atom&quot; ) :my_atom iex&gt; _ = :&quot;🌢 Elixir&quot; iex&gt; List . to_existing_atom ( ~c&quot;🌢 Elixir&quot; ) :&quot;🌢 Elixir&quot;","ref":"List.html#to_existing_atom/1","source_doc":"Converts a charlist to an existing atom.\n\nElixir supports conversions from charlists which contains any Unicode\ncode point. Raises an `ArgumentError` if the atom does not exist.\n\nInlined by the compiler.\n\n> #### Atoms and modules {: .info}\n>\n> Since Elixir is a compiled language, the atoms defined in a module\n> will only exist after said module is loaded, which typically happens\n> whenever a function in the module is executed. Therefore, it is\n> generally recommended to call `List.to_existing_atom/1` only to\n> convert atoms defined within the module making the function call\n> to `to_existing_atom/1`.\n\n## Examples\n\n    iex> _ = :my_atom\n    iex> List.to_existing_atom(~c\"my_atom\")\n    :my_atom\n\n    iex> _ = :\"🌢 Elixir\"\n    iex> List.to_existing_atom(~c\"🌢 Elixir\")\n    :\"🌢 Elixir\"\n\n","title":"List.to_existing_atom/1","type":"function"},{"doc":"Returns the float whose text representation is charlist . Inlined by the compiler. Examples iex&gt; List . to_float ( ~c&quot;2.2017764e+0&quot; ) 2.2017764","ref":"List.html#to_float/1","source_doc":"Returns the float whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_float(~c\"2.2017764e+0\")\n    2.2017764\n\n","title":"List.to_float/1","type":"function"},{"doc":"Returns an integer whose text representation is charlist . Inlined by the compiler. Examples iex&gt; List . to_integer ( ~c&quot;123&quot; ) 123","ref":"List.html#to_integer/1","source_doc":"Returns an integer whose text representation is `charlist`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_integer(~c\"123\")\n    123\n\n","title":"List.to_integer/1","type":"function"},{"doc":"Returns an integer whose text representation is charlist in base base . Inlined by the compiler. The base needs to be between 2 and 36 . Examples iex&gt; List . to_integer ( ~c&quot;3FF&quot; , 16 ) 1023","ref":"List.html#to_integer/2","source_doc":"Returns an integer whose text representation is `charlist` in base `base`.\n\nInlined by the compiler.\n\nThe base needs to be between `2` and `36`.\n\n## Examples\n\n    iex> List.to_integer(~c\"3FF\", 16)\n    1023\n\n","title":"List.to_integer/2","type":"function"},{"doc":"Converts a list of integers representing code points, lists or strings into a string. To be converted to a string, a list must either be empty or only contain the following elements: strings integers representing Unicode code points a list containing one of these three elements Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the :binary module . Examples iex&gt; List . to_string ( [ 0x00E6 , 0x00DF ] ) &quot;æß&quot; iex&gt; List . to_string ( [ 0x0061 , &quot;bc&quot; ] ) &quot;abc&quot; iex&gt; List . to_string ( [ 0x0064 , &quot;ee&quot; , [ ~c&quot;p&quot; ] ] ) &quot;deep&quot; iex&gt; List . to_string ( [ ] ) &quot;&quot;","ref":"List.html#to_string/1","source_doc":"Converts a list of integers representing code points, lists or\nstrings into a string.\n\nTo be converted to a string, a list must either be empty or only\ncontain the following elements:\n\n  * strings\n  * integers representing Unicode code points\n  * a list containing one of these three elements\n\nNote that this function expects a list of integers representing\nUnicode code points. If you have a list of bytes, you must instead use\nthe [`:binary` module](`:binary`).\n\n## Examples\n\n    iex> List.to_string([0x00E6, 0x00DF])\n    \"æß\"\n\n    iex> List.to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> List.to_string([0x0064, \"ee\", [~c\"p\"]])\n    \"deep\"\n\n    iex> List.to_string([])\n    \"\"\n\n","title":"List.to_string/1","type":"function"},{"doc":"Converts a list to a tuple. Inlined by the compiler. Examples iex&gt; List . to_tuple ( [ :share , [ :elixir , 163 ] ] ) { :share , [ :elixir , 163 ] }","ref":"List.html#to_tuple/1","source_doc":"Converts a list to a tuple.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> List.to_tuple([:share, [:elixir, 163]])\n    {:share, [:elixir, 163]}\n\n","title":"List.to_tuple/1","type":"function"},{"doc":"Returns a list with an updated value at the specified index . Negative indices indicate an offset from the end of the list . If index is out of bounds, the original list is returned. Examples iex&gt; List . update_at ( [ 1 , 2 , 3 ] , 0 , &amp; ( &amp;1 + 10 ) ) [ 11 , 2 , 3 ] iex&gt; List . update_at ( [ 1 , 2 , 3 ] , 10 , &amp; ( &amp;1 + 10 ) ) [ 1 , 2 , 3 ] iex&gt; List . update_at ( [ 1 , 2 , 3 ] , - 1 , &amp; ( &amp;1 + 10 ) ) [ 1 , 2 , 13 ] iex&gt; List . update_at ( [ 1 , 2 , 3 ] , - 10 , &amp; ( &amp;1 + 10 ) ) [ 1 , 2 , 3 ]","ref":"List.html#update_at/3","source_doc":"Returns a list with an updated value at the specified `index`.\n\nNegative indices indicate an offset from the end of the `list`.\nIf `index` is out of bounds, the original `list` is returned.\n\n## Examples\n\n    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n    [11, 2, 3]\n\n    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n    [1, 2, 3]\n\n    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n    [1, 2, 13]\n\n    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n    [1, 2, 3]\n\n","title":"List.update_at/3","type":"function"},{"doc":"Wraps term in a list if this is not list. If term is already a list, it returns the list. If term is nil , it returns an empty list. Examples iex&gt; List . wrap ( &quot;hello&quot; ) [ &quot;hello&quot; ] iex&gt; List . wrap ( [ 1 , 2 , 3 ] ) [ 1 , 2 , 3 ] iex&gt; List . wrap ( nil ) [ ]","ref":"List.html#wrap/1","source_doc":"Wraps `term` in a list if this is not list.\n\nIf `term` is already a list, it returns the list.\nIf `term` is `nil`, it returns an empty list.\n\n## Examples\n\n    iex> List.wrap(\"hello\")\n    [\"hello\"]\n\n    iex> List.wrap([1, 2, 3])\n    [1, 2, 3]\n\n    iex> List.wrap(nil)\n    []\n\n","title":"List.wrap/1","type":"function"},{"doc":"Zips corresponding elements from each list in list_of_lists . The zipping finishes as soon as any list terminates. Examples iex&gt; List . zip ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) [ { 1 , 3 , 5 } , { 2 , 4 , 6 } ] iex&gt; List . zip ( [ [ 1 , 2 ] , [ 3 ] , [ 5 , 6 ] ] ) [ { 1 , 3 , 5 } ]","ref":"List.html#zip/1","source_doc":"Zips corresponding elements from each list in `list_of_lists`.\n\nThe zipping finishes as soon as any list terminates.\n\n## Examples\n\n    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n    [{1, 3, 5}, {2, 4, 6}]\n\n    iex> List.zip([[1, 2], [3], [5, 6]])\n    [{1, 3, 5}]\n\n","title":"List.zip/1","type":"function"},{"doc":"Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the %{} syntax, and key-value pairs can be expressed as key =&gt; value : iex&gt; %{ } %{ } iex&gt; %{ &quot;one&quot; =&gt; :two , 3 =&gt; &quot;four&quot; } %{ 3 =&gt; &quot;four&quot; , &quot;one&quot; =&gt; :two } Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created). Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator ( ===/2 ). If colliding keys are defined in a map literal, the last one prevails. When the key in a key-value pair is an atom, the key: value shorthand syntax can be used (as in many other special forms): iex&gt; %{ a : 1 , b : 2 } %{ a : 1 , b : 2 } If you want to mix the shorthand syntax with =&gt; , the shorthand syntax must come at the end: iex&gt; %{ &quot;hello&quot; =&gt; &quot;world&quot; , a : 1 , b : 2 } %{ :a =&gt; 1 , :b =&gt; 2 , &quot;hello&quot; =&gt; &quot;world&quot; } Keys in maps can be accessed through some of the functions in this module (such as Map.get/3 or Map.fetch/2 ) or through the map[] syntax provided by the Access module: iex&gt; map = %{ a : 1 , b : 2 } iex&gt; Map . fetch ( map , :a ) { :ok , 1 } iex&gt; map [ :b ] 2 iex&gt; map [ &quot;non_existing_key&quot; ] nil To access atom keys, one may also use the map.key notation. Note that map.key will raise a KeyError if the map doesn't contain the key :key , compared to map[:key] , that would return nil . map = %{ foo : &quot;bar&quot; , baz : &quot;bong&quot; } map . foo #=&gt; &quot;bar&quot; map . non_existing_key ** (KeyError) key :non_existing_key not found in: %{baz: &quot;bong&quot;, foo: &quot;bar&quot;} Avoid parentheses Do not add parentheses when accessing fields, such as in data.key() . If parentheses are used, Elixir will expect data to be an atom representing a module and attempt to call the function key/0 in it. The two syntaxes for accessing keys reveal the dual nature of maps. The map[key] syntax is used for dynamically created maps that may have any key, of any type. map.key is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via defstruct/1 , are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time. Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map. iex&gt; %{ } = %{ foo : &quot;bar&quot; } %{ foo : &quot;bar&quot; } iex&gt; %{ a : a } = %{ :a =&gt; 1 , &quot;b&quot; =&gt; 2 , [ :c , :e , :e ] =&gt; 3 } iex&gt; a 1 But this will raise a MatchError exception: %{ :c =&gt; 3 } = %{ :a =&gt; 1 , 2 =&gt; :b } Variables can be used as map keys both when writing map literals as well as when matching: iex&gt; n = 1 1 iex&gt; %{ n =&gt; :one } %{ 1 =&gt; :one } iex&gt; %{ ^ n =&gt; :one } = %{ 1 =&gt; :one , 2 =&gt; :two , 3 =&gt; :three } %{ 1 =&gt; :one , 2 =&gt; :two , 3 =&gt; :three } Maps also support a specific update syntax to update the value stored under existing keys. You can update using the atom keys syntax: iex&gt; map = %{ one : 1 , two : 2 } iex&gt; %{ map | one : &quot;one&quot; } %{ one : &quot;one&quot; , two : 2 } Or any other key: iex&gt; other_map = %{ &quot;three&quot; =&gt; 3 , &quot;four&quot; =&gt; 4 } iex&gt; %{ other_map | &quot;three&quot; =&gt; &quot;three&quot; } %{ &quot;four&quot; =&gt; 4 , &quot;three&quot; =&gt; &quot;three&quot; } When a key that does not exist in the map is updated a KeyError exception will be raised: %{ map | three : 3 } The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as keys/1 and values/1 , run in linear time because they need to get to every element in the map. Maps also implement the Enumerable protocol, so many functions to work with maps are found in the Enum module. Additionally, the following functions for maps are found in Kernel : map_size/1","ref":"Map.html","source_doc":"Maps are the \"go to\" key-value data structure in Elixir.\n\nMaps can be created with the `%{}` syntax, and key-value pairs can be\nexpressed as `key => value`:\n\n    iex> %{}\n    %{}\n    iex> %{\"one\" => :two, 3 => \"four\"}\n    %{3 => \"four\", \"one\" => :two}\n\nKey-value pairs in a map do not follow any order (that's why the printed map\nin the example above has a different order than the map that was created).\n\nMaps do not impose any restriction on the key type: anything can be a key in a\nmap. As a key-value structure, maps do not allow duplicated keys. Keys are\ncompared using the exact-equality operator (`===/2`). If colliding keys are defined\nin a map literal, the last one prevails.\n\nWhen the key in a key-value pair is an atom, the `key: value` shorthand syntax\ncan be used (as in many other special forms):\n\n    iex> %{a: 1, b: 2}\n    %{a: 1, b: 2}\n\nIf you want to mix the shorthand syntax with `=>`, the shorthand syntax must come\nat the end:\n\n    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n\nKeys in maps can be accessed through some of the functions in this module\n(such as `Map.get/3` or `Map.fetch/2`) or through the `map[]` syntax provided\nby the `Access` module:\n\n    iex> map = %{a: 1, b: 2}\n    iex> Map.fetch(map, :a)\n    {:ok, 1}\n    iex> map[:b]\n    2\n    iex> map[\"non_existing_key\"]\n    nil\n\nTo access atom keys, one may also use the `map.key` notation. Note that `map.key`\nwill raise a `KeyError` if the `map` doesn't contain the key `:key`, compared to\n`map[:key]`, that would return `nil`.\n\n    map = %{foo: \"bar\", baz: \"bong\"}\n    map.foo\n    #=> \"bar\"\n    map.non_existing_key\n    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: \"bar\"}\n\n> #### Avoid parentheses {: .warning}\n>\n> Do not add parentheses when accessing fields, such as in `data.key()`.\n> If parentheses are used, Elixir will expect `data` to be an atom representing\n> a module and attempt to call the *function* `key/0` in it.\n\nThe two syntaxes for accessing keys reveal the dual nature of maps. The `map[key]`\nsyntax is used for dynamically created maps that may have any key, of any type.\n`map.key` is used with maps that hold a predetermined set of atoms keys, which are\nexpected to always be present. Structs, defined via `defstruct/1`, are one example\nof such \"static maps\", where the keys can also be checked during compile time.\n\nMaps can be pattern matched on. When a map is on the left-hand side of a\npattern match, it will match if the map on the right-hand side contains the\nkeys on the left-hand side and their values match the ones on the left-hand\nside. This means that an empty map matches every map.\n\n    iex> %{} = %{foo: \"bar\"}\n    %{foo: \"bar\"}\n    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n    iex> a\n    1\n\nBut this will raise a `MatchError` exception:\n\n    %{:c => 3} = %{:a => 1, 2 => :b}\n\nVariables can be used as map keys both when writing map literals as well as\nwhen matching:\n\n    iex> n = 1\n    1\n    iex> %{n => :one}\n    %{1 => :one}\n    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n    %{1 => :one, 2 => :two, 3 => :three}\n\nMaps also support a specific update syntax to update the value stored under\n*existing* keys. You can update using the atom keys syntax:\n\n    iex> map = %{one: 1, two: 2}\n    iex> %{map | one: \"one\"}\n    %{one: \"one\", two: 2}\n\nOr any other key:\n\n    iex> other_map = %{\"three\" => 3, \"four\" => 4}\n    iex> %{other_map | \"three\" => \"three\"}\n    %{\"four\" => 4, \"three\" => \"three\"}\n\nWhen a key that does not exist in the map is updated a `KeyError` exception will be raised:\n\n    %{map | three: 3}\n\nThe functions in this module that need to find a specific key work in logarithmic time.\nThis means that the time it takes to find keys grows as the map grows, but it's not\ndirectly proportional to the map size. In comparison to finding an element in a list,\nit performs better because lists have a linear time complexity. Some functions,\nsuch as `keys/1` and `values/1`, run in linear time because they need to get to every\nelement in the map.\n\nMaps also implement the `Enumerable` protocol, so many functions to work with maps\nare found in the `Enum` module. Additionally, the following functions for maps are\nfound in `Kernel`:\n\n  * `map_size/1`\n\n","title":"Map","type":"module"},{"doc":"Deletes the entry in map for a specific key . If the key does not exist, returns map unchanged. Inlined by the compiler. Examples iex&gt; Map . delete ( %{ a : 1 , b : 2 } , :a ) %{ b : 2 } iex&gt; Map . delete ( %{ b : 2 } , :a ) %{ b : 2 }","ref":"Map.html#delete/2","source_doc":"Deletes the entry in `map` for a specific `key`.\n\nIf the `key` does not exist, returns `map` unchanged.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.delete(%{a: 1, b: 2}, :a)\n    %{b: 2}\n    iex> Map.delete(%{b: 2}, :a)\n    %{b: 2}\n\n","title":"Map.delete/2","type":"function"},{"doc":"Drops the given keys from map . If keys contains keys that are not in map , they're simply ignored. Examples iex&gt; Map . drop ( %{ a : 1 , b : 2 , c : 3 } , [ :b , :d ] ) %{ a : 1 , c : 3 }","ref":"Map.html#drop/2","source_doc":"Drops the given `keys` from `map`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n    %{a: 1, c: 3}\n\n","title":"Map.drop/2","type":"function"},{"doc":"Checks if two maps are equal. Two maps are considered to be equal if they contain the same keys and those keys contain the same values. Note this function exists for completeness so the Map and Keyword modules provide similar APIs. In practice, developers often compare maps using ==/2 or ===/2 directly. Examples iex&gt; Map . equal? ( %{ a : 1 , b : 2 } , %{ b : 2 , a : 1 } ) true iex&gt; Map . equal? ( %{ a : 1 , b : 2 } , %{ b : 1 , a : 2 } ) false Comparison between keys and values is done with ===/3 , which means integers are not equivalent to floats: iex&gt; Map . equal? ( %{ a : 1.0 } , %{ a : 1 } ) false","ref":"Map.html#equal?/2","source_doc":"Checks if two maps are equal.\n\nTwo maps are considered to be equal if they contain\nthe same keys and those keys contain the same values.\n\nNote this function exists for completeness so the `Map`\nand `Keyword` modules provide similar APIs. In practice,\ndevelopers often compare maps using `==/2` or `===/2`\ndirectly.\n\n## Examples\n\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n    true\n    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n    false\n\nComparison between keys and values is done with `===/3`,\nwhich means integers are not equivalent to floats:\n\n    iex> Map.equal?(%{a: 1.0}, %{a: 1})\n    false\n\n","title":"Map.equal?/2","type":"function"},{"doc":"Fetches the value for a specific key in the given map . If map contains the given key then its value is returned in the shape of {:ok, value} . If map doesn't contain key , :error is returned. Inlined by the compiler. Examples iex&gt; Map . fetch ( %{ a : 1 } , :a ) { :ok , 1 } iex&gt; Map . fetch ( %{ a : 1 } , :b ) :error","ref":"Map.html#fetch/2","source_doc":"Fetches the value for a specific `key` in the given `map`.\n\nIf `map` contains the given `key` then its value is returned in the shape of `{:ok, value}`.\nIf `map` doesn't contain `key`, `:error` is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch(%{a: 1}, :a)\n    {:ok, 1}\n    iex> Map.fetch(%{a: 1}, :b)\n    :error\n\n","title":"Map.fetch/2","type":"function"},{"doc":"Fetches the value for a specific key in the given map , erroring out if map doesn't contain key . If map contains key , the corresponding value is returned. If map doesn't contain key , a KeyError exception is raised. Inlined by the compiler. Examples iex&gt; Map . fetch! ( %{ a : 1 } , :a ) 1","ref":"Map.html#fetch!/2","source_doc":"Fetches the value for a specific `key` in the given `map`, erroring out if\n`map` doesn't contain `key`.\n\nIf `map` contains `key`, the corresponding value is returned. If\n`map` doesn't contain `key`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.fetch!(%{a: 1}, :a)\n    1\n\n","title":"Map.fetch!/2","type":"function"},{"doc":"Returns a map containing only those pairs from map for which fun returns a truthy value. fun receives the key and value of each of the elements in the map as a key-value pair. See also reject/2 which discards all elements where the function returns a truthy value. Performance considerations If you find yourself doing multiple calls to Map.filter/2 and Map.reject/2 in a pipeline, it is likely more efficient to use Enum.map/2 and Enum.filter/2 instead and convert to a map at the end using Map.new/1 . Examples iex&gt; Map . filter ( %{ one : 1 , two : 2 , three : 3 } , fn { _key , val } -&gt; rem ( val , 2 ) == 1 end ) %{ one : 1 , three : 3 }","ref":"Map.html#filter/2","source_doc":"Returns a map containing only those pairs from `map`\nfor which `fun` returns a truthy value.\n\n`fun` receives the key and value of each of the\nelements in the map as a key-value pair.\n\nSee also `reject/2` which discards all elements where the\nfunction returns a truthy value.\n\n> #### Performance considerations {: .tip}\n>\n> If you find yourself doing multiple calls to `Map.filter/2`\n> and `Map.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `Map.new/1`.\n\n## Examples\n\n    iex> Map.filter(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{one: 1, three: 3}\n\n","title":"Map.filter/2","type":"function"},{"doc":"Builds a map from the given keys and the fixed value . Examples iex&gt; Map . from_keys ( [ 1 , 2 , 3 ] , :number ) %{ 1 =&gt; :number , 2 =&gt; :number , 3 =&gt; :number }","ref":"Map.html#from_keys/2","source_doc":"Builds a map from the given `keys` and the fixed `value`.\n\n## Examples\n\n    iex> Map.from_keys([1, 2, 3], :number)\n    %{1 => :number, 2 => :number, 3 => :number}\n\n","title":"Map.from_keys/2","type":"function"},{"doc":"Converts a struct to map. It accepts the struct module or a struct itself and simply removes the __struct__ field from the given struct or from a new struct generated from the given module. Example defmodule User do defstruct [ :name ] end Map . from_struct ( User ) #=&gt; %{name: nil} Map . from_struct ( % User { name : &quot;john&quot; } ) #=&gt; %{name: &quot;john&quot;}","ref":"Map.html#from_struct/1","source_doc":"Converts a `struct` to map.\n\nIt accepts the struct module or a struct itself and\nsimply removes the `__struct__` field from the given struct\nor from a new struct generated from the given module.\n\n## Example\n\n    defmodule User do\n      defstruct [:name]\n    end\n\n    Map.from_struct(User)\n    #=> %{name: nil}\n\n    Map.from_struct(%User{name: \"john\"})\n    #=> %{name: \"john\"}\n\n","title":"Map.from_struct/1","type":"function"},{"doc":"Gets the value for a specific key in map . If key is present in map then its value value is returned. Otherwise, default is returned. If default is not provided, nil is used. Examples iex&gt; Map . get ( %{ } , :a ) nil iex&gt; Map . get ( %{ a : 1 } , :a ) 1 iex&gt; Map . get ( %{ a : 1 } , :b ) nil iex&gt; Map . get ( %{ a : 1 } , :b , 3 ) 3 iex&gt; Map . get ( %{ a : nil } , :a , 1 ) nil","ref":"Map.html#get/3","source_doc":"Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `default` is returned.\n\nIf `default` is not provided, `nil` is used.\n\n## Examples\n\n    iex> Map.get(%{}, :a)\n    nil\n    iex> Map.get(%{a: 1}, :a)\n    1\n    iex> Map.get(%{a: 1}, :b)\n    nil\n    iex> Map.get(%{a: 1}, :b, 3)\n    3\n    iex> Map.get(%{a: nil}, :a, 1)\n    nil\n\n","title":"Map.get/3","type":"function"},{"doc":"Gets the value from key and updates it, all in one pass. fun is called with the current value under key in map (or nil if key is not present in map ) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under key in the resulting new map. fun may also return :pop , which means the current value shall be removed from map and returned (making this function behave like Map.pop(map, key) ). The returned value is a two-element tuple with the current value returned by fun and a new map with the updated value under key . Examples iex&gt; Map . get_and_update ( %{ a : 1 } , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , %{ a : &quot;new value!&quot; } } iex&gt; Map . get_and_update ( %{ a : 1 } , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { nil , %{ a : 1 , b : &quot;new value!&quot; } } iex&gt; Map . get_and_update ( %{ a : 1 } , :a , fn _ -&gt; :pop end ) { 1 , %{ } } iex&gt; Map . get_and_update ( %{ a : 1 } , :b , fn _ -&gt; :pop end ) { nil , %{ a : 1 } }","ref":"Map.html#get_and_update/3","source_doc":"Gets the value from `key` and updates it, all in one pass.\n\n`fun` is called with the current value under `key` in `map` (or `nil` if `key`\nis not present in `map`) and must return a two-element tuple: the current value\n(the retrieved value, which can be operated on before being returned) and the\nnew value to be stored under `key` in the resulting new map. `fun` may also\nreturn `:pop`, which means the current value shall be removed from `map` and\nreturned (making this function behave like `Map.pop(map, key)`).\n\nThe returned value is a two-element tuple with the current value returned by\n`fun` and a new map with the updated value under `key`.\n\n## Examples\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {nil, %{a: 1, b: \"new value!\"}}\n\n    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n    {1, %{}}\n\n    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n    {nil, %{a: 1}}\n\n","title":"Map.get_and_update/3","type":"function"},{"doc":"Gets the value from key and updates it, all in one pass. Raises if there is no key . Behaves exactly like get_and_update/3 , but raises a KeyError exception if key is not present in map . Examples iex&gt; Map . get_and_update! ( %{ a : 1 } , :a , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) { 1 , %{ a : &quot;new value!&quot; } } iex&gt; Map . get_and_update! ( %{ a : 1 } , :b , fn current_value -&gt; ...&gt; { current_value , &quot;new value!&quot; } ...&gt; end ) ** (KeyError) key :b not found in: %{a: 1} iex&gt; Map . get_and_update! ( %{ a : 1 } , :a , fn _ -&gt; ...&gt; :pop ...&gt; end ) { 1 , %{ } }","ref":"Map.html#get_and_update!/3","source_doc":"Gets the value from `key` and updates it, all in one pass. Raises if there is no `key`.\n\nBehaves exactly like `get_and_update/3`, but raises a `KeyError` exception if\n`key` is not present in `map`.\n\n## Examples\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    {1, %{a: \"new value!\"}}\n\n    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n    ...>   {current_value, \"new value!\"}\n    ...> end)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n    ...>   :pop\n    ...> end)\n    {1, %{}}\n\n","title":"Map.get_and_update!/3","type":"function"},{"doc":"Gets the value for a specific key in map . If key is present in map then its value value is returned. Otherwise, fun is evaluated and its result is returned. This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; map = %{ a : 1 } iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Map . get_lazy ( map , :a , fun ) 1 iex&gt; Map . get_lazy ( map , :b , fun ) 13","ref":"Map.html#get_lazy/3","source_doc":"Gets the value for a specific `key` in `map`.\n\nIf `key` is present in `map` then its value `value` is\nreturned. Otherwise, `fun` is evaluated and its result is returned.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.get_lazy(map, :a, fun)\n    1\n    iex> Map.get_lazy(map, :b, fun)\n    13\n\n","title":"Map.get_lazy/3","type":"function"},{"doc":"Returns whether the given key exists in the given map . Inlined by the compiler. Examples iex&gt; Map . has_key? ( %{ a : 1 } , :a ) true iex&gt; Map . has_key? ( %{ a : 1 } , :b ) false","ref":"Map.html#has_key?/2","source_doc":"Returns whether the given `key` exists in the given `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.has_key?(%{a: 1}, :a)\n    true\n    iex> Map.has_key?(%{a: 1}, :b)\n    false\n\n","title":"Map.has_key?/2","type":"function"},{"doc":"Intersects two maps, returning a map with the common keys. The values in the returned map are the values of the intersected keys in map2 . Inlined by the compiler. Examples iex&gt; Map . intersect ( %{ a : 1 , b : 2 } , %{ b : &quot;b&quot; , c : &quot;c&quot; } ) %{ b : &quot;b&quot; }","ref":"Map.html#intersect/2","source_doc":"Intersects two maps, returning a map with the common keys.\n\nThe values in the returned map are the values of the intersected keys in `map2`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.intersect(%{a: 1, b: 2}, %{b: \"b\", c: \"c\"})\n    %{b: \"b\"}\n\n","title":"Map.intersect/2","type":"function"},{"doc":"Intersects two maps, returning a map with the common keys and resolving conflicts through a function. The given function will be invoked when there are duplicate keys; its arguments are key (the duplicate key), value1 (the value of key in map1 ), and value2 (the value of key in map2 ). The value returned by fun is used as the value under key in the resulting map. Examples iex&gt; Map . intersect ( %{ a : 1 , b : 2 } , %{ b : 2 , c : 3 } , fn _k , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) %{ b : 4 }","ref":"Map.html#intersect/3","source_doc":"Intersects two maps, returning a map with the common keys and resolving conflicts through a function.\n\nThe given function will be invoked when there are duplicate keys; its\narguments are `key` (the duplicate key), `value1` (the value of `key` in\n`map1`), and `value2` (the value of `key` in `map2`). The value returned by\n`fun` is used as the value under `key` in the resulting map.\n\n## Examples\n\n    iex> Map.intersect(%{a: 1, b: 2}, %{b: 2, c: 3}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{b: 4}\n","title":"Map.intersect/3","type":"function"},{"doc":"Returns all keys from map . Inlined by the compiler. Examples iex&gt; Map . keys ( %{ a : 1 , b : 2 } ) [ :a , :b ]","ref":"Map.html#keys/1","source_doc":"Returns all keys from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.keys(%{a: 1, b: 2})\n    [:a, :b]\n\n","title":"Map.keys/1","type":"function"},{"doc":"Merges two maps into one. All keys in map2 will be added to map1 , overriding any existing one (i.e., the keys in map2 &quot;have precedence&quot; over the ones in map1 ). If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use struct/2 . Inlined by the compiler. Examples iex&gt; Map . merge ( %{ a : 1 , b : 2 } , %{ a : 3 , d : 4 } ) %{ a : 3 , b : 2 , d : 4 }","ref":"Map.html#merge/2","source_doc":"Merges two maps into one.\n\nAll keys in `map2` will be added to `map1`, overriding any existing one\n(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n\nIf you have a struct and you would like to merge a set of keys into the\nstruct, do not use this function, as it would merge all keys on the right\nside into the struct, even if the key is not part of the struct. Instead,\nuse `struct/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n    %{a: 3, b: 2, d: 4}\n\n","title":"Map.merge/2","type":"function"},{"doc":"Merges two maps into one, resolving conflicts through the given fun . All keys in map2 will be added to map1 . The given function will be invoked when there are duplicate keys; its arguments are key (the duplicate key), value1 (the value of key in map1 ), and value2 (the value of key in map2 ). The value returned by fun is used as the value under key in the resulting map. Examples iex&gt; Map . merge ( %{ a : 1 , b : 2 } , %{ a : 3 , d : 4 } , fn _k , v1 , v2 -&gt; ...&gt; v1 + v2 ...&gt; end ) %{ a : 4 , b : 2 , d : 4 }","ref":"Map.html#merge/3","source_doc":"Merges two maps into one, resolving conflicts through the given `fun`.\n\nAll keys in `map2` will be added to `map1`. The given function will be invoked\nwhen there are duplicate keys; its arguments are `key` (the duplicate key),\n`value1` (the value of `key` in `map1`), and `value2` (the value of `key` in\n`map2`). The value returned by `fun` is used as the value under `key` in\nthe resulting map.\n\n## Examples\n\n    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n    ...>   v1 + v2\n    ...> end)\n    %{a: 4, b: 2, d: 4}\n\n","title":"Map.merge/3","type":"function"},{"doc":"Returns a new empty map. Examples iex&gt; Map . new ( ) %{ }","ref":"Map.html#new/0","source_doc":"Returns a new empty map.\n\n## Examples\n\n    iex> Map.new()\n    %{}\n\n","title":"Map.new/0","type":"function"},{"doc":"Creates a map from an enumerable . Duplicated keys are removed; the latest one prevails. Examples iex&gt; Map . new ( [ { :b , 1 } , { :a , 2 } ] ) %{ a : 2 , b : 1 } iex&gt; Map . new ( a : 1 , a : 2 , a : 3 ) %{ a : 3 }","ref":"Map.html#new/1","source_doc":"Creates a map from an `enumerable`.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([{:b, 1}, {:a, 2}])\n    %{a: 2, b: 1}\n    iex> Map.new(a: 1, a: 2, a: 3)\n    %{a: 3}\n\n","title":"Map.new/1","type":"function"},{"doc":"Creates a map from an enumerable via the given transformation function. Duplicated keys are removed; the latest one prevails. Examples iex&gt; Map . new ( [ :a , :b ] , fn x -&gt; { x , x } end ) %{ a : :a , b : :b } iex&gt; Map . new ( %{ a : 2 , b : 3 , c : 4 } , fn { key , val } -&gt; { key , val * 2 } end ) %{ a : 4 , b : 6 , c : 8 }","ref":"Map.html#new/2","source_doc":"Creates a map from an `enumerable` via the given transformation function.\n\nDuplicated keys are removed; the latest one prevails.\n\n## Examples\n\n    iex> Map.new([:a, :b], fn x -> {x, x} end)\n    %{a: :a, b: :b}\n\n    iex> Map.new(%{a: 2, b: 3, c: 4}, fn {key, val} -> {key, val * 2} end)\n    %{a: 4, b: 6, c: 8}\n\n","title":"Map.new/2","type":"function"},{"doc":"Removes the value associated with key in map and returns the value and the updated map. If key is present in map , it returns {value, updated_map} where value is the value of the key and updated_map is the result of removing key from map . If key is not present in map , {default, map} is returned. Examples iex&gt; Map . pop ( %{ a : 1 } , :a ) { 1 , %{ } } iex&gt; Map . pop ( %{ a : 1 } , :b ) { nil , %{ a : 1 } } iex&gt; Map . pop ( %{ a : 1 } , :b , 3 ) { 3 , %{ a : 1 } }","ref":"Map.html#pop/3","source_doc":"Removes the value associated with `key` in `map` and returns the value and the updated map.\n\nIf `key` is present in `map`, it returns `{value, updated_map}` where `value` is the value of\nthe key and `updated_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{default, map}` is returned.\n\n## Examples\n\n    iex> Map.pop(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop(%{a: 1}, :b)\n    {nil, %{a: 1}}\n    iex> Map.pop(%{a: 1}, :b, 3)\n    {3, %{a: 1}}\n\n","title":"Map.pop/3","type":"function"},{"doc":"Removes the value associated with key in map and returns the value and the updated map, or it raises if key is not present. Behaves the same as pop/3 but raises if key is not present in map . Examples iex&gt; Map . pop! ( %{ a : 1 } , :a ) { 1 , %{ } } iex&gt; Map . pop! ( %{ a : 1 , b : 2 } , :a ) { 1 , %{ b : 2 } } iex&gt; Map . pop! ( %{ a : 1 } , :b ) ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#pop!/2","source_doc":"Removes the value associated with `key` in `map` and returns the value\nand the updated map, or it raises if `key` is not present.\n\nBehaves the same as `pop/3` but raises if `key` is not present in `map`.\n\n## Examples\n\n    iex> Map.pop!(%{a: 1}, :a)\n    {1, %{}}\n    iex> Map.pop!(%{a: 1, b: 2}, :a)\n    {1, %{b: 2}}\n    iex> Map.pop!(%{a: 1}, :b)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n","title":"Map.pop!/2","type":"function"},{"doc":"Lazily returns and removes the value associated with key in map . If key is present in map , it returns {value, new_map} where value is the value of the key and new_map is the result of removing key from map . If key is not present in map , {fun_result, map} is returned, where fun_result is the result of applying fun . This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; map = %{ a : 1 } iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 13 ...&gt; end iex&gt; Map . pop_lazy ( map , :a , fun ) { 1 , %{ } } iex&gt; Map . pop_lazy ( map , :b , fun ) { 13 , %{ a : 1 } }","ref":"Map.html#pop_lazy/3","source_doc":"Lazily returns and removes the value associated with `key` in `map`.\n\nIf `key` is present in `map`, it returns `{value, new_map}` where `value` is the value of\nthe key and `new_map` is the result of removing `key` from `map`. If `key`\nis not present in `map`, `{fun_result, map}` is returned, where `fun_result`\nis the result of applying `fun`.\n\nThis is useful if the default value is very expensive to calculate or\ngenerally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   13\n    ...> end\n    iex> Map.pop_lazy(map, :a, fun)\n    {1, %{}}\n    iex> Map.pop_lazy(map, :b, fun)\n    {13, %{a: 1}}\n\n","title":"Map.pop_lazy/3","type":"function"},{"doc":"Puts the given value under key in map . Inlined by the compiler. Examples iex&gt; Map . put ( %{ a : 1 } , :b , 2 ) %{ a : 1 , b : 2 } iex&gt; Map . put ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 3 , b : 2 }","ref":"Map.html#put/3","source_doc":"Puts the given `value` under `key` in `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.put(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n","title":"Map.put/3","type":"function"},{"doc":"Puts the given value under key unless the entry key already exists in map . Examples iex&gt; Map . put_new ( %{ a : 1 } , :b , 2 ) %{ a : 1 , b : 2 } iex&gt; Map . put_new ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 1 , b : 2 }","ref":"Map.html#put_new/3","source_doc":"Puts the given `value` under `key` unless the entry `key`\nalready exists in `map`.\n\n## Examples\n\n    iex> Map.put_new(%{a: 1}, :b, 2)\n    %{a: 1, b: 2}\n    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n    %{a: 1, b: 2}\n\n","title":"Map.put_new/3","type":"function"},{"doc":"Evaluates fun and puts the result under key in map unless key is already present. This function is useful in case you want to compute the value to put under key only if key is not already present, as for example, when the value is expensive to calculate or generally difficult to setup and teardown again. Examples iex&gt; map = %{ a : 1 } iex&gt; fun = fn -&gt; ...&gt; # some expensive operation here ...&gt; 3 ...&gt; end iex&gt; Map . put_new_lazy ( map , :a , fun ) %{ a : 1 } iex&gt; Map . put_new_lazy ( map , :b , fun ) %{ a : 1 , b : 3 }","ref":"Map.html#put_new_lazy/3","source_doc":"Evaluates `fun` and puts the result under `key`\nin `map` unless `key` is already present.\n\nThis function is useful in case you want to compute the value to put under\n`key` only if `key` is not already present, as for example, when the value is expensive to\ncalculate or generally difficult to setup and teardown again.\n\n## Examples\n\n    iex> map = %{a: 1}\n    iex> fun = fn ->\n    ...>   # some expensive operation here\n    ...>   3\n    ...> end\n    iex> Map.put_new_lazy(map, :a, fun)\n    %{a: 1}\n    iex> Map.put_new_lazy(map, :b, fun)\n    %{a: 1, b: 3}\n\n","title":"Map.put_new_lazy/3","type":"function"},{"doc":"Returns map excluding the pairs from map for which fun returns a truthy value. See also filter/2 . Examples iex&gt; Map . reject ( %{ one : 1 , two : 2 , three : 3 } , fn { _key , val } -&gt; rem ( val , 2 ) == 1 end ) %{ two : 2 }","ref":"Map.html#reject/2","source_doc":"Returns map excluding the pairs from `map` for which `fun` returns\na truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> Map.reject(%{one: 1, two: 2, three: 3}, fn {_key, val} -> rem(val, 2) == 1 end)\n    %{two: 2}\n\n","title":"Map.reject/2","type":"function"},{"doc":"Puts a value under key only if the key already exists in map . Examples iex&gt; Map . replace ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 3 , b : 2 } iex&gt; Map . replace ( %{ a : 1 } , :b , 2 ) %{ a : 1 }","ref":"Map.html#replace/3","source_doc":"Puts a value under `key` only if the `key` already exists in `map`.\n\n## Examples\n\n    iex> Map.replace(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace(%{a: 1}, :b, 2)\n    %{a: 1}\n\n","title":"Map.replace/3","type":"function"},{"doc":"Puts a value under key only if the key already exists in map . If key is not present in map , a KeyError exception is raised. Inlined by the compiler. Examples iex&gt; Map . replace! ( %{ a : 1 , b : 2 } , :a , 3 ) %{ a : 3 , b : 2 } iex&gt; Map . replace! ( %{ a : 1 } , :b , 2 ) ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#replace!/3","source_doc":"Puts a value under `key` only if the `key` already exists in `map`.\n\nIf `key` is not present in `map`, a `KeyError` exception is raised.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.replace!(%{a: 1, b: 2}, :a, 3)\n    %{a: 3, b: 2}\n\n    iex> Map.replace!(%{a: 1}, :b, 2)\n    ** (KeyError) key :b not found in: %{a: 1}\n\n","title":"Map.replace!/3","type":"function"},{"doc":"Replaces the value under key using the given function only if key already exists in map . In comparison to replace/3 , this can be useful when it's expensive to calculate the value. If key does not exist, the original map is returned unchanged. Examples iex&gt; Map . replace_lazy ( %{ a : 1 , b : 2 } , :a , fn v -&gt; v * 4 end ) %{ a : 4 , b : 2 } iex&gt; Map . replace_lazy ( %{ a : 1 , b : 2 } , :c , fn v -&gt; v * 4 end ) %{ a : 1 , b : 2 }","ref":"Map.html#replace_lazy/3","source_doc":"Replaces the value under `key` using the given function only if\n`key` already exists in `map`.\n\nIn comparison to `replace/3`, this can be useful when it's expensive to calculate the value.\n\nIf `key` does not exist, the original map is returned unchanged.\n\n## Examples\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :a, fn v -> v * 4 end)\n    %{a: 4, b: 2}\n\n    iex> Map.replace_lazy(%{a: 1, b: 2}, :c, fn v -> v * 4 end)\n    %{a: 1, b: 2}\n\n","title":"Map.replace_lazy/3","type":"function"},{"doc":"Takes all entries corresponding to the given keys in map and extracts them into a separate map. Returns a tuple with the new map and the old map with removed keys. Keys for which there are no entries in map are ignored. Examples iex&gt; Map . split ( %{ a : 1 , b : 2 , c : 3 } , [ :a , :c , :e ] ) { %{ a : 1 , c : 3 } , %{ b : 2 } }","ref":"Map.html#split/2","source_doc":"Takes all entries corresponding to the given `keys` in `map` and extracts\nthem into a separate map.\n\nReturns a tuple with the new map and the old map with removed keys.\n\nKeys for which there are no entries in `map` are ignored.\n\n## Examples\n\n    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    {%{a: 1, c: 3}, %{b: 2}}\n\n","title":"Map.split/2","type":"function"},{"doc":"Splits the map into two maps according to the given function fun . fun receives each {key, value} pair in the map as its only argument. Returns a tuple with the first map containing all the elements in map for which applying fun returned a truthy value, and a second map with all the elements for which applying fun returned a falsy value ( false or nil ). Examples iex&gt; Map . split_with ( %{ a : 1 , b : 2 , c : 3 , d : 4 } , fn { _k , v } -&gt; rem ( v , 2 ) == 0 end ) { %{ b : 2 , d : 4 } , %{ a : 1 , c : 3 } } iex&gt; Map . split_with ( %{ a : 1 , b : - 2 , c : 1 , d : - 3 } , fn { k , _v } -&gt; k in [ :b , :d ] end ) { %{ b : - 2 , d : - 3 } , %{ a : 1 , c : 1 } } iex&gt; Map . split_with ( %{ a : 1 , b : - 2 , c : 1 , d : - 3 } , fn { _k , v } -&gt; v &gt; 50 end ) { %{ } , %{ a : 1 , b : - 2 , c : 1 , d : - 3 } } iex&gt; Map . split_with ( %{ } , fn { _k , v } -&gt; v &gt; 50 end ) { %{ } , %{ } }","ref":"Map.html#split_with/2","source_doc":"Splits the `map` into two maps according to the given function `fun`.\n\n`fun` receives each `{key, value}` pair in the `map` as its only argument. Returns\na tuple with the first map containing all the elements in `map` for which\napplying `fun` returned a truthy value, and a second map with all the elements\nfor which applying `fun` returned a falsy value (`false` or `nil`).\n\n## Examples\n\n    iex> Map.split_with(%{a: 1, b: 2, c: 3, d: 4}, fn {_k, v} -> rem(v, 2) == 0 end)\n    {%{b: 2, d: 4}, %{a: 1, c: 3}}\n\n    iex> Map.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {k, _v} -> k in [:b, :d] end)\n    {%{b: -2, d: -3}, %{a: 1, c: 1}}\n\n    iex> Map.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn {_k, v} -> v > 50 end)\n    {%{}, %{a: 1, b: -2, c: 1, d: -3}}\n\n    iex> Map.split_with(%{}, fn {_k, v} -> v > 50 end)\n    {%{}, %{}}\n\n","title":"Map.split_with/2","type":"function"},{"doc":"Returns a new map with all the key-value pairs in map where the key is in keys . If keys contains keys that are not in map , they're simply ignored. Examples iex&gt; Map . take ( %{ a : 1 , b : 2 , c : 3 } , [ :a , :c , :e ] ) %{ a : 1 , c : 3 }","ref":"Map.html#take/2","source_doc":"Returns a new map with all the key-value pairs in `map` where the key\nis in `keys`.\n\nIf `keys` contains keys that are not in `map`, they're simply ignored.\n\n## Examples\n\n    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n    %{a: 1, c: 3}\n\n","title":"Map.take/2","type":"function"},{"doc":"Converts map to a list. Each key-value pair in the map is converted to a two-element tuple {key, value} in the resulting list. Inlined by the compiler. Examples iex&gt; Map . to_list ( %{ a : 1 } ) [ a : 1 ] iex&gt; Map . to_list ( %{ 1 =&gt; 2 } ) [ { 1 , 2 } ]","ref":"Map.html#to_list/1","source_doc":"Converts `map` to a list.\n\nEach key-value pair in the map is converted to a two-element tuple `{key,\nvalue}` in the resulting list.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.to_list(%{a: 1})\n    [a: 1]\n    iex> Map.to_list(%{1 => 2})\n    [{1, 2}]\n\n","title":"Map.to_list/1","type":"function"},{"doc":"Updates the key in map with the given function. If key is present in map then the existing value is passed to fun and its result is used as the updated value of key . If key is not present in map , default is inserted as the value of key . The default value will not be passed through the update function. Examples iex&gt; Map . update ( %{ a : 1 } , :a , 13 , fn existing_value -&gt; existing_value * 2 end ) %{ a : 2 } iex&gt; Map . update ( %{ a : 1 } , :b , 11 , fn existing_value -&gt; existing_value * 2 end ) %{ a : 1 , b : 11 }","ref":"Map.html#update/4","source_doc":"Updates the `key` in `map` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, `default` is inserted as the value of `key`. The default\nvalue will not be passed through the update function.\n\n## Examples\n\n    iex> Map.update(%{a: 1}, :a, 13, fn existing_value -> existing_value * 2 end)\n    %{a: 2}\n    iex> Map.update(%{a: 1}, :b, 11, fn existing_value -> existing_value * 2 end)\n    %{a: 1, b: 11}\n\n","title":"Map.update/4","type":"function"},{"doc":"Updates key with the given function. If key is present in map then the existing value is passed to fun and its result is used as the updated value of key . If key is not present in map , a KeyError exception is raised. Examples iex&gt; Map . update! ( %{ a : 1 } , :a , &amp; ( &amp;1 * 2 ) ) %{ a : 2 } iex&gt; Map . update! ( %{ a : 1 } , :b , &amp; ( &amp;1 * 2 ) ) ** (KeyError) key :b not found in: %{a: 1}","ref":"Map.html#update!/3","source_doc":"Updates `key` with the given function.\n\nIf `key` is present in `map` then the existing value is passed to `fun` and its result is\nused as the updated value of `key`. If `key` is\nnot present in `map`, a `KeyError` exception is raised.\n\n## Examples\n\n    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n    %{a: 2}\n\n    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n    ** (KeyError) key :b not found in: %{a: 1}\n\n","title":"Map.update!/3","type":"function"},{"doc":"Returns all values from map . Inlined by the compiler. Examples iex&gt; Map . values ( %{ a : 1 , b : 2 } ) [ 1 , 2 ]","ref":"Map.html#values/1","source_doc":"Returns all values from `map`.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> Map.values(%{a: 1, b: 2})\n    [1, 2]\n\n","title":"Map.values/1","type":"function"},{"doc":"","ref":"Map.html#t:key/0","source_doc":false,"title":"Map.key/0","type":"type"},{"doc":"","ref":"Map.html#t:value/0","source_doc":false,"title":"Map.value/0","type":"type"},{"doc":"Functions that work on sets. A set is a data structure that can contain unique elements of any kind, without any particular order. MapSet is the &quot;go to&quot; set data structure in Elixir. A set can be constructed using MapSet.new/0 : iex&gt; MapSet . new ( ) MapSet . new ( [ ] ) Elements in a set don't have to be of the same type and they can be populated from an enumerable using MapSet.new/1 : iex&gt; MapSet . new ( [ 1 , :two , { &quot;three&quot; } ] ) MapSet . new ( [ 1 , :two , { &quot;three&quot; } ] ) Elements can be inserted using MapSet.put/2 : iex&gt; MapSet . new ( [ 2 ] ) |&gt; MapSet . put ( 4 ) |&gt; MapSet . put ( 0 ) MapSet . new ( [ 0 , 2 , 4 ] ) By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op. iex&gt; map_set = MapSet . new ( ) iex&gt; MapSet . put ( map_set , &quot;foo&quot; ) MapSet . new ( [ &quot;foo&quot; ] ) iex&gt; map_set |&gt; MapSet . put ( &quot;foo&quot; ) |&gt; MapSet . put ( &quot;foo&quot; ) MapSet . new ( [ &quot;foo&quot; ] ) A MapSet is represented internally using the %MapSet{} struct. This struct can be used whenever there's a need to pattern match on something being a MapSet : iex&gt; match? ( % MapSet { } , MapSet . new ( ) ) true Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets. MapSet s can also be constructed starting from other collection-type data structures: for example, see MapSet.new/1 or Enum.into/2 . MapSet is built on top of Erlang's :sets (version 2). This means that they share many properties, including logarithmic time complexity. Erlang :sets (version 2) are implemented on top of maps, so see the documentation for Map for more information on its execution time complexity.","ref":"MapSet.html","source_doc":"Functions that work on sets.\n\nA set is a data structure that can contain unique elements of any kind,\nwithout any particular order. `MapSet` is the \"go to\" set data structure in Elixir.\n\nA set can be constructed using `MapSet.new/0`:\n\n    iex> MapSet.new()\n    MapSet.new([])\n\nElements in a set don't have to be of the same type and they can be\npopulated from an [enumerable](`t:Enumerable.t/0`) using `MapSet.new/1`:\n\n    iex> MapSet.new([1, :two, {\"three\"}])\n    MapSet.new([1, :two, {\"three\"}])\n\nElements can be inserted using `MapSet.put/2`:\n\n    iex> MapSet.new([2]) |> MapSet.put(4) |> MapSet.put(0)\n    MapSet.new([0, 2, 4])\n\nBy definition, sets can't contain duplicate elements: when\ninserting an element in a set where it's already present, the insertion is\nsimply a no-op.\n\n    iex> map_set = MapSet.new()\n    iex> MapSet.put(map_set, \"foo\")\n    MapSet.new([\"foo\"])\n    iex> map_set |> MapSet.put(\"foo\") |> MapSet.put(\"foo\")\n    MapSet.new([\"foo\"])\n\nA `MapSet` is represented internally using the `%MapSet{}` struct. This struct\ncan be used whenever there's a need to pattern match on something being a `MapSet`:\n\n    iex> match?(%MapSet{}, MapSet.new())\n    true\n\nNote that, however, the struct fields are private and must not be accessed\ndirectly; use the functions in this module to perform operations on sets.\n\n`MapSet`s can also be constructed starting from other collection-type data\nstructures: for example, see `MapSet.new/1` or `Enum.into/2`.\n\n`MapSet` is built on top of Erlang's\n[`:sets`](https://www.erlang.org/doc/man/sets.html) (version 2). This means\nthat they share many properties, including logarithmic time complexity. Erlang\n`:sets` (version 2) are implemented on top of maps, so see the documentation\nfor `Map` for more information on its execution time complexity.\n","title":"MapSet","type":"module"},{"doc":"Deletes value from map_set . Returns a new set which is a copy of map_set but without value . Examples iex&gt; map_set = MapSet . new ( [ 1 , 2 , 3 ] ) iex&gt; MapSet . delete ( map_set , 4 ) MapSet . new ( [ 1 , 2 , 3 ] ) iex&gt; MapSet . delete ( map_set , 2 ) MapSet . new ( [ 1 , 3 ] )","ref":"MapSet.html#delete/2","source_doc":"Deletes `value` from `map_set`.\n\nReturns a new set which is a copy of `map_set` but without `value`.\n\n## Examples\n\n    iex> map_set = MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 4)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.delete(map_set, 2)\n    MapSet.new([1, 3])\n\n","title":"MapSet.delete/2","type":"function"},{"doc":"Returns a set that is map_set1 without the members of map_set2 . Examples iex&gt; MapSet . difference ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) MapSet . new ( [ 1 ] )","ref":"MapSet.html#difference/2","source_doc":"Returns a set that is `map_set1` without the members of `map_set2`.\n\n## Examples\n\n    iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1])\n\n","title":"MapSet.difference/2","type":"function"},{"doc":"Checks if map_set1 and map_set2 have no members in common. Examples iex&gt; MapSet . disjoint? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 3 , 4 ] ) ) true iex&gt; MapSet . disjoint? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 ] ) ) false","ref":"MapSet.html#disjoint?/2","source_doc":"Checks if `map_set1` and `map_set2` have no members in common.\n\n## Examples\n\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    true\n    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n    false\n\n","title":"MapSet.disjoint?/2","type":"function"},{"doc":"Checks if two sets are equal. The comparison between elements is done using ===/2 , which a set with 1 is not equivalent to a set with 1.0 . Examples iex&gt; MapSet . equal? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 1 , 1 ] ) ) true iex&gt; MapSet . equal? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 3 , 4 ] ) ) false iex&gt; MapSet . equal? ( MapSet . new ( [ 1 ] ) , MapSet . new ( [ 1.0 ] ) ) false","ref":"MapSet.html#equal?/2","source_doc":"Checks if two sets are equal.\n\nThe comparison between elements is done using `===/2`,\nwhich a set with `1` is not equivalent to a set with\n`1.0`.\n\n## Examples\n\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n    true\n    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    false\n    iex> MapSet.equal?(MapSet.new([1]), MapSet.new([1.0]))\n    false\n\n","title":"MapSet.equal?/2","type":"function"},{"doc":"Filters the set by returning only the elements from set for which invoking fun returns a truthy value. Also see reject/2 which discards all elements where the function returns a truthy value. Performance considerations If you find yourself doing multiple calls to MapSet.filter/2 and MapSet.reject/2 in a pipeline, it is likely more efficient to use Enum.map/2 and Enum.filter/2 instead and convert to a map at the end using MapSet.new/1 . Examples iex&gt; MapSet . filter ( MapSet . new ( 1 .. 5 ) , fn x -&gt; x &gt; 3 end ) MapSet . new ( [ 4 , 5 ] ) iex&gt; MapSet . filter ( MapSet . new ( [ &quot;a&quot; , :b , &quot;c&quot; ] ) , &amp; is_atom / 1 ) MapSet . new ( [ :b ] )","ref":"MapSet.html#filter/2","source_doc":"Filters the set by returning only the elements from `set` for which invoking\n`fun` returns a truthy value.\n\nAlso see `reject/2` which discards all elements where the function returns\na truthy value.\n\n> #### Performance considerations {: .tip}\n>\n> If you find yourself doing multiple calls to `MapSet.filter/2`\n> and `MapSet.reject/2` in a pipeline, it is likely more efficient\n> to use `Enum.map/2` and `Enum.filter/2` instead and convert to\n> a map at the end using `MapSet.new/1`.\n\n## Examples\n\n    iex> MapSet.filter(MapSet.new(1..5), fn x -> x > 3 end)\n    MapSet.new([4, 5])\n\n    iex> MapSet.filter(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([:b])\n\n","title":"MapSet.filter/2","type":"function"},{"doc":"Returns a set containing only members that map_set1 and map_set2 have in common. Examples iex&gt; MapSet . intersection ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) MapSet . new ( [ 2 ] ) iex&gt; MapSet . intersection ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 3 , 4 ] ) ) MapSet . new ( [ ] )","ref":"MapSet.html#intersection/2","source_doc":"Returns a set containing only members that `map_set1` and `map_set2` have in common.\n\n## Examples\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([2])\n\n    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n    MapSet.new([])\n\n","title":"MapSet.intersection/2","type":"function"},{"doc":"Checks if map_set contains value . Examples iex&gt; MapSet . member? ( MapSet . new ( [ 1 , 2 , 3 ] ) , 2 ) true iex&gt; MapSet . member? ( MapSet . new ( [ 1 , 2 , 3 ] ) , 4 ) false","ref":"MapSet.html#member?/2","source_doc":"Checks if `map_set` contains `value`.\n\n## Examples\n\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n    true\n    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n    false\n\n","title":"MapSet.member?/2","type":"function"},{"doc":"Returns a new set. Examples iex&gt; MapSet . new ( ) MapSet . new ( [ ] )","ref":"MapSet.html#new/0","source_doc":"Returns a new set.\n\n## Examples\n\n    iex> MapSet.new()\n    MapSet.new([])\n\n","title":"MapSet.new/0","type":"function"},{"doc":"Creates a set from an enumerable. Examples iex&gt; MapSet . new ( [ :b , :a , 3 ] ) MapSet . new ( [ 3 , :a , :b ] ) iex&gt; MapSet . new ( [ 3 , 3 , 3 , 2 , 2 , 1 ] ) MapSet . new ( [ 1 , 2 , 3 ] )","ref":"MapSet.html#new/1","source_doc":"Creates a set from an enumerable.\n\n## Examples\n\n    iex> MapSet.new([:b, :a, 3])\n    MapSet.new([3, :a, :b])\n    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n    MapSet.new([1, 2, 3])\n\n","title":"MapSet.new/1","type":"function"},{"doc":"Creates a set from an enumerable via the transformation function. Examples iex&gt; MapSet . new ( [ 1 , 2 , 1 ] , fn x -&gt; 2 * x end ) MapSet . new ( [ 2 , 4 ] )","ref":"MapSet.html#new/2","source_doc":"Creates a set from an enumerable via the transformation function.\n\n## Examples\n\n    iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n    MapSet.new([2, 4])\n\n","title":"MapSet.new/2","type":"function"},{"doc":"Inserts value into map_set if map_set doesn't already contain it. Examples iex&gt; MapSet . put ( MapSet . new ( [ 1 , 2 , 3 ] ) , 3 ) MapSet . new ( [ 1 , 2 , 3 ] ) iex&gt; MapSet . put ( MapSet . new ( [ 1 , 2 , 3 ] ) , 4 ) MapSet . new ( [ 1 , 2 , 3 , 4 ] )","ref":"MapSet.html#put/2","source_doc":"Inserts `value` into `map_set` if `map_set` doesn't already contain it.\n\n## Examples\n\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n    MapSet.new([1, 2, 3])\n    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n    MapSet.new([1, 2, 3, 4])\n\n","title":"MapSet.put/2","type":"function"},{"doc":"Returns a set by excluding the elements from set for which invoking fun returns a truthy value. See also filter/2 . Examples iex&gt; MapSet . reject ( MapSet . new ( 1 .. 5 ) , fn x -&gt; rem ( x , 2 ) != 0 end ) MapSet . new ( [ 2 , 4 ] ) iex&gt; MapSet . reject ( MapSet . new ( [ &quot;a&quot; , :b , &quot;c&quot; ] ) , &amp; is_atom / 1 ) MapSet . new ( [ &quot;a&quot; , &quot;c&quot; ] )","ref":"MapSet.html#reject/2","source_doc":"Returns a set by excluding the elements from `set` for which invoking `fun`\nreturns a truthy value.\n\nSee also `filter/2`.\n\n## Examples\n\n    iex> MapSet.reject(MapSet.new(1..5), fn x -> rem(x, 2) != 0 end)\n    MapSet.new([2, 4])\n\n    iex> MapSet.reject(MapSet.new([\"a\", :b, \"c\"]), &is_atom/1)\n    MapSet.new([\"a\", \"c\"])\n\n","title":"MapSet.reject/2","type":"function"},{"doc":"Returns the number of elements in map_set . Examples iex&gt; MapSet . size ( MapSet . new ( [ 1 , 2 , 3 ] ) ) 3","ref":"MapSet.html#size/1","source_doc":"Returns the number of elements in `map_set`.\n\n## Examples\n\n    iex> MapSet.size(MapSet.new([1, 2, 3]))\n    3\n\n","title":"MapSet.size/1","type":"function"},{"doc":"Splits the MapSet into two MapSet s according to the given function fun . fun receives each element in the MapSet as its only argument. Returns a tuple with the first MapSet containing all the elements in MapSet for which applying fun returned a truthy value, and a second MapSet with all the elements for which applying fun returned a falsy value ( false or nil ). Examples iex&gt; { while_true , while_false } = MapSet . split_with ( MapSet . new ( [ 1 , 2 , 3 , 4 ] ) , fn v -&gt; rem ( v , 2 ) == 0 end ) iex&gt; while_true MapSet . new ( [ 2 , 4 ] ) iex&gt; while_false MapSet . new ( [ 1 , 3 ] ) iex&gt; { while_true , while_false } = MapSet . split_with ( MapSet . new ( ) , fn { _k , v } -&gt; v &gt; 50 end ) iex&gt; while_true MapSet . new ( [ ] ) iex&gt; while_false MapSet . new ( [ ] )","ref":"MapSet.html#split_with/2","source_doc":"Splits the `MapSet` into two `MapSet`s according to the given function `fun`.\n\n`fun` receives each element in the `MapSet` as its only argument. Returns\na tuple with the first `MapSet` containing all the elements in `MapSet` for which\napplying `fun` returned a truthy value, and a second `MapSet` with all the elements\nfor which applying `fun` returned a falsy value (`false` or `nil`).\n\n## Examples\n\n    iex> {while_true, while_false} = MapSet.split_with(MapSet.new([1, 2, 3, 4]), fn v -> rem(v, 2) == 0 end)\n    iex> while_true\n    MapSet.new([2, 4])\n    iex> while_false\n    MapSet.new([1, 3])\n\n    iex> {while_true, while_false} = MapSet.split_with(MapSet.new(), fn {_k, v} -> v > 50 end)\n    iex> while_true\n    MapSet.new([])\n    iex> while_false\n    MapSet.new([])\n\n","title":"MapSet.split_with/2","type":"function"},{"doc":"Checks if map_set1 's members are all contained in map_set2 . This function checks if map_set1 is a subset of map_set2 . Examples iex&gt; MapSet . subset? ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 1 , 2 , 3 ] ) ) true iex&gt; MapSet . subset? ( MapSet . new ( [ 1 , 2 , 3 ] ) , MapSet . new ( [ 1 , 2 ] ) ) false","ref":"MapSet.html#subset?/2","source_doc":"Checks if `map_set1`'s members are all contained in `map_set2`.\n\nThis function checks if `map_set1` is a subset of `map_set2`.\n\n## Examples\n\n    iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n    true\n    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n    false\n\n","title":"MapSet.subset?/2","type":"function"},{"doc":"Returns a set with elements that are present in only one but not both sets. Examples iex&gt; MapSet . symmetric_difference ( MapSet . new ( [ 1 , 2 , 3 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) MapSet . new ( [ 1 , 4 ] )","ref":"MapSet.html#symmetric_difference/2","source_doc":"Returns a set with elements that are present in only one but not both sets.\n\n## Examples\n\n    iex> MapSet.symmetric_difference(MapSet.new([1, 2, 3]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 4])\n\n","title":"MapSet.symmetric_difference/2","type":"function"},{"doc":"Converts map_set to a list. Examples iex&gt; MapSet . to_list ( MapSet . new ( [ 1 , 2 , 3 ] ) ) [ 1 , 2 , 3 ]","ref":"MapSet.html#to_list/1","source_doc":"Converts `map_set` to a list.\n\n## Examples\n\n    iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n    [1, 2, 3]\n\n","title":"MapSet.to_list/1","type":"function"},{"doc":"Returns a set containing all members of map_set1 and map_set2 . Examples iex&gt; MapSet . union ( MapSet . new ( [ 1 , 2 ] ) , MapSet . new ( [ 2 , 3 , 4 ] ) ) MapSet . new ( [ 1 , 2 , 3 , 4 ] )","ref":"MapSet.html#union/2","source_doc":"Returns a set containing all members of `map_set1` and `map_set2`.\n\n## Examples\n\n    iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n    MapSet.new([1, 2, 3, 4])\n\n","title":"MapSet.union/2","type":"function"},{"doc":"","ref":"MapSet.html#t:internal/1","source_doc":false,"title":"MapSet.internal/1","type":"opaque"},{"doc":"","ref":"MapSet.html#t:t/0","source_doc":false,"title":"MapSet.t/0","type":"type"},{"doc":"","ref":"MapSet.html#t:t/1","source_doc":false,"title":"MapSet.t/1","type":"type"},{"doc":"","ref":"MapSet.html#t:value/0","source_doc":false,"title":"MapSet.value/0","type":"type"},{"doc":"Ranges represent a sequence of zero, one or many, ascending or descending integers with a common difference called step. The most common form of creating and matching on ranges is via the first..last and first..last//step notations, auto-imported from Kernel : iex&gt; 1 in 1 .. 10 true iex&gt; 5 in 1 .. 10 true iex&gt; 10 in 1 .. 10 true Ranges are always inclusive in Elixir. When a step is defined, integers will only belong to the range if they match the step: iex&gt; 5 in 1 .. 10 // 2 true iex&gt; 4 in 1 .. 10 // 2 false When defining a range without a step, the step will be defined based on the first and last position of the range, If last &gt;= first , it will be an increasing range with a step of 1. Otherwise, it is a decreasing range. Note, however, implicit decreasing ranges are deprecated. Therefore, if you need a decreasing range from 3 to 1 , prefer to write 3..1//-1 instead. ../0 can also be used as a shortcut to create the range 0..-1//1 , also known as the full-slice range: iex&gt; .. 0 .. - 1 // 1 Use cases Ranges typically have two uses in Elixir: as a collection or to represent a slice of another data structure. Ranges as collections Ranges in Elixir are enumerables and therefore can be used with the Enum module: iex&gt; Enum . to_list ( 1 .. 3 ) [ 1 , 2 , 3 ] iex&gt; Enum . to_list ( 3 .. 1 // - 1 ) [ 3 , 2 , 1 ] iex&gt; Enum . to_list ( 1 .. 5 // 2 ) [ 1 , 3 , 5 ] Ranges may also have a single element: iex&gt; Enum . to_list ( 1 .. 1 ) [ 1 ] iex&gt; Enum . to_list ( 1 .. 1 // 2 ) [ 1 ] Or even no elements at all: iex&gt; Enum . to_list ( 10 .. 0 // 1 ) [ ] iex&gt; Enum . to_list ( 0 .. 10 // - 1 ) [ ] The full-slice range, returned by ../0 , is an empty collection: iex&gt; Enum . to_list ( .. ) [ ] Ranges as slices Ranges are also frequently used to slice collections. You can slice strings or any enumerable: iex&gt; String . slice ( &quot;elixir&quot; , 1 .. 4 ) &quot;lixi&quot; iex&gt; Enum . slice ( [ 0 , 1 , 2 , 3 , 4 , 5 ] , 1 .. 4 ) [ 1 , 2 , 3 , 4 ] In those cases, the first and last values of the range are mapped to positions in the collections. If a negative number is given, it maps to a position from the back: iex&gt; String . slice ( &quot;elixir&quot; , 1 .. - 2 // 1 ) &quot;lixi&quot; iex&gt; Enum . slice ( [ 0 , 1 , 2 , 3 , 4 , 5 ] , 1 .. - 2 // 1 ) [ 1 , 2 , 3 , 4 ] The range 0..-1//1 , returned by ../0 , returns the collection as is, which is why it is called the full-slice range: iex&gt; String . slice ( &quot;elixir&quot; , .. ) &quot;elixir&quot; iex&gt; Enum . slice ( [ 0 , 1 , 2 , 3 , 4 , 5 ] , .. ) [ 0 , 1 , 2 , 3 , 4 , 5 ] Definition An increasing range first..last//step is a range from first to last increasing by step where step must be a positive integer and all values v must be first &lt;= v and v &lt;= last . Therefore, a range 10..0//1 is an empty range because there is no value v that is 10 &lt;= v and v &lt;= 0 . Similarly, a decreasing range first..last//step is a range from first to last decreasing by step where step must be a negative integer and values v must be first &gt;= v and v &gt;= last . Therefore, a range 0..10//-1 is an empty range because there is no value v that is 0 &gt;= v and v &gt;= 10 . Representation Internally, ranges are represented as structs: iex&gt; range = 1 .. 9 // 2 1 .. 9 // 2 iex&gt; first .. last // step = range iex&gt; first 1 iex&gt; last 9 iex&gt; step 2 iex&gt; range . step 2 You can access the range fields ( first , last , and step ) directly but you should not modify nor create ranges by hand. Instead use the proper operators or new/2 and new/3 . Ranges implement the Enumerable protocol with memory efficient versions of all Enumerable callbacks: iex&gt; range = 1 .. 10 1 .. 10 iex&gt; Enum . reduce ( range , 0 , fn i , acc -&gt; i * i + acc end ) 385 iex&gt; Enum . count ( range ) 10 iex&gt; Enum . member? ( range , 11 ) false iex&gt; Enum . member? ( range , 8 ) true Such function calls are efficient memory-wise no matter the size of the range. The implementation of the Enumerable protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.","ref":"Range.html","source_doc":"Ranges represent a sequence of zero, one or many, ascending\nor descending integers with a common difference called step.\n\nThe most common form of creating and matching on ranges is\nvia the [`first..last`](`../2`) and [`first..last//step`](`..///3`)\nnotations, auto-imported from `Kernel`:\n\n    iex> 1 in 1..10\n    true\n    iex> 5 in 1..10\n    true\n    iex> 10 in 1..10\n    true\n\nRanges are always inclusive in Elixir. When a step is defined,\nintegers will only belong to the range if they match the step:\n\n    iex> 5 in 1..10//2\n    true\n    iex> 4 in 1..10//2\n    false\n\nWhen defining a range without a step, the step will be\ndefined based on the first and last position of the\nrange, If `last >= first`, it will be an increasing range\nwith a step of 1. Otherwise, it is a decreasing range.\nNote, however, implicit decreasing ranges are deprecated.\nTherefore, if you need a decreasing range from `3` to `1`,\nprefer to write `3..1//-1` instead.\n\n`../0` can also be used as a shortcut to create the range `0..-1//1`,\nalso known as the full-slice range:\n\n    iex> ..\n    0..-1//1\n\n## Use cases\n\nRanges typically have two uses in Elixir: as a collection or\nto represent a slice of another data structure.\n\n### Ranges as collections\n\nRanges in Elixir are enumerables and therefore can be used\nwith the `Enum` module:\n\n    iex> Enum.to_list(1..3)\n    [1, 2, 3]\n    iex> Enum.to_list(3..1//-1)\n    [3, 2, 1]\n    iex> Enum.to_list(1..5//2)\n    [1, 3, 5]\n\nRanges may also have a single element:\n\n    iex> Enum.to_list(1..1)\n    [1]\n    iex> Enum.to_list(1..1//2)\n    [1]\n\nOr even no elements at all:\n\n    iex> Enum.to_list(10..0//1)\n    []\n    iex> Enum.to_list(0..10//-1)\n    []\n\nThe full-slice range, returned by `../0`, is an empty collection:\n\n    iex> Enum.to_list(..)\n    []\n\n### Ranges as slices\n\nRanges are also frequently used to slice collections.\nYou can slice strings or any enumerable:\n\n    iex> String.slice(\"elixir\", 1..4)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..4)\n    [1, 2, 3, 4]\n\nIn those cases, the first and last values of the range\nare mapped to positions in the collections.\n\nIf a negative number is given, it maps to a position\nfrom the back:\n\n    iex> String.slice(\"elixir\", 1..-2//1)\n    \"lixi\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], 1..-2//1)\n    [1, 2, 3, 4]\n\nThe range `0..-1//1`, returned by `../0`, returns the\ncollection as is, which is why it is called the full-slice\nrange:\n\n    iex> String.slice(\"elixir\", ..)\n    \"elixir\"\n    iex> Enum.slice([0, 1, 2, 3, 4, 5], ..)\n    [0, 1, 2, 3, 4, 5]\n\n## Definition\n\nAn increasing range `first..last//step` is a range from `first`\nto `last` increasing by `step` where  `step` must be a positive\ninteger and all values `v` must be `first <= v and v <= last`.\nTherefore, a range `10..0//1` is an empty range because there\nis no value `v` that is `10 <= v and v <= 0`.\n\nSimilarly, a decreasing range `first..last//step` is a range\nfrom `first` to `last` decreasing by `step` where `step` must\nbe a negative integer and  values `v` must be `first >= v and v >= last`.\nTherefore, a range `0..10//-1` is an empty range because there\nis no value `v` that is `0 >= v and v >= 10`.\n\n## Representation\n\nInternally, ranges are represented as structs:\n\n    iex> range = 1..9//2\n    1..9//2\n    iex> first..last//step = range\n    iex> first\n    1\n    iex> last\n    9\n    iex> step\n    2\n    iex> range.step\n    2\n\nYou can access the range fields (`first`, `last`, and `step`)\ndirectly but you should not modify nor create ranges by hand.\nInstead use the proper operators or `new/2` and `new/3`.\n\nRanges implement the `Enumerable` protocol with memory\nefficient versions of all `Enumerable` callbacks:\n\n    iex> range = 1..10\n    1..10\n    iex> Enum.reduce(range, 0, fn i, acc -> i * i + acc end)\n    385\n    iex> Enum.count(range)\n    10\n    iex> Enum.member?(range, 11)\n    false\n    iex> Enum.member?(range, 8)\n    true\n\nSuch function calls are efficient memory-wise no matter the\nsize of the range. The implementation of the `Enumerable`\nprotocol uses logic based solely on the endpoints and does\nnot materialize the whole list of integers.\n","title":"Range","type":"module"},{"doc":"Checks if two ranges are disjoint. Examples iex&gt; Range . disjoint? ( 1 .. 5 , 6 .. 9 ) true iex&gt; Range . disjoint? ( 5 .. 1 , 6 .. 9 ) true iex&gt; Range . disjoint? ( 1 .. 5 , 5 .. 9 ) false iex&gt; Range . disjoint? ( 1 .. 5 , 2 .. 7 ) false Steps are also considered when computing the ranges to be disjoint: iex&gt; Range . disjoint? ( 1 .. 10 // 2 , 2 .. 10 // 2 ) true # First element in common is 29 iex&gt; Range . disjoint? ( 1 .. 100 // 14 , 8 .. 100 // 21 ) false iex&gt; Range . disjoint? ( 57 .. - 1 // - 14 , 8 .. 100 // 21 ) false iex&gt; Range . disjoint? ( 1 .. 100 // 14 , 50 .. 8 // - 21 ) false iex&gt; Range . disjoint? ( 1 .. 28 // 14 , 8 .. 28 // 21 ) true # First element in common is 14 iex&gt; Range . disjoint? ( 2 .. 28 // 3 , 9 .. 28 // 5 ) false iex&gt; Range . disjoint? ( 26 .. 2 // - 3 , 29 .. 9 // - 5 ) false # Starting from the back without alignment iex&gt; Range . disjoint? ( 27 .. 11 // - 3 , 30 .. 0 // - 7 ) true","ref":"Range.html#disjoint?/2","source_doc":"Checks if two ranges are disjoint.\n\n## Examples\n\n    iex> Range.disjoint?(1..5, 6..9)\n    true\n    iex> Range.disjoint?(5..1, 6..9)\n    true\n    iex> Range.disjoint?(1..5, 5..9)\n    false\n    iex> Range.disjoint?(1..5, 2..7)\n    false\n\nSteps are also considered when computing the ranges to be disjoint:\n\n    iex> Range.disjoint?(1..10//2, 2..10//2)\n    true\n\n    # First element in common is 29\n    iex> Range.disjoint?(1..100//14, 8..100//21)\n    false\n    iex> Range.disjoint?(57..-1//-14, 8..100//21)\n    false\n    iex> Range.disjoint?(1..100//14, 50..8//-21)\n    false\n    iex> Range.disjoint?(1..28//14, 8..28//21)\n    true\n\n    # First element in common is 14\n    iex> Range.disjoint?(2..28//3, 9..28//5)\n    false\n    iex> Range.disjoint?(26..2//-3, 29..9//-5)\n    false\n\n    # Starting from the back without alignment\n    iex> Range.disjoint?(27..11//-3, 30..0//-7)\n    true\n\n","title":"Range.disjoint?/2","type":"function"},{"doc":"Creates a new range. If first is less than last , the range will be increasing from first to last . If first is equal to last , the range will contain one element, which is the number itself. If first is greater than last , the range will be decreasing from first to last , albeit this behaviour is deprecated. Therefore, it is advised to explicitly list the step with new/3 . Examples iex&gt; Range . new ( - 100 , 100 ) - 100 .. 100","ref":"Range.html#new/2","source_doc":"Creates a new range.\n\nIf `first` is less than `last`, the range will be increasing from\n`first` to `last`. If `first` is equal to `last`, the range will contain\none element, which is the number itself.\n\nIf `first` is greater than `last`, the range will be decreasing from `first`\nto `last`, albeit this behaviour is deprecated. Therefore, it is advised to\nexplicitly list the step with `new/3`.\n\n## Examples\n\n    iex> Range.new(-100, 100)\n    -100..100\n\n","title":"Range.new/2","type":"function"},{"doc":"Creates a new range with step . Examples iex&gt; Range . new ( - 100 , 100 , 2 ) - 100 .. 100 // 2","ref":"Range.html#new/3","source_doc":"Creates a new range with `step`.\n\n## Examples\n\n    iex> Range.new(-100, 100, 2)\n    -100..100//2\n\n","title":"Range.new/3","type":"function"},{"doc":"Shifts a range by the given number of steps. Examples iex&gt; Range . shift ( 0 .. 10 , 1 ) 1 .. 11 iex&gt; Range . shift ( 0 .. 10 , 2 ) 2 .. 12 iex&gt; Range . shift ( 0 .. 10 // 2 , 2 ) 4 .. 14 // 2 iex&gt; Range . shift ( 10 .. 0 // - 2 , 2 ) 6 .. - 4 // - 2","ref":"Range.html#shift/2","source_doc":"Shifts a range by the given number of steps.\n\n## Examples\n\n    iex> Range.shift(0..10, 1)\n    1..11\n    iex> Range.shift(0..10, 2)\n    2..12\n\n    iex> Range.shift(0..10//2, 2)\n    4..14//2\n    iex> Range.shift(10..0//-2, 2)\n    6..-4//-2\n\n","title":"Range.shift/2","type":"function"},{"doc":"Returns the size of range . Examples iex&gt; Range . size ( 1 .. 10 ) 10 iex&gt; Range . size ( 1 .. 10 // 2 ) 5 iex&gt; Range . size ( 1 .. 10 // 3 ) 4 iex&gt; Range . size ( 1 .. 10 // - 1 ) 0 iex&gt; Range . size ( 10 .. 1 ) 10 iex&gt; Range . size ( 10 .. 1 // - 1 ) 10 iex&gt; Range . size ( 10 .. 1 // - 2 ) 5 iex&gt; Range . size ( 10 .. 1 // - 3 ) 4 iex&gt; Range . size ( 10 .. 1 // 1 ) 0","ref":"Range.html#size/1","source_doc":"Returns the size of `range`.\n\n## Examples\n\n    iex> Range.size(1..10)\n    10\n    iex> Range.size(1..10//2)\n    5\n    iex> Range.size(1..10//3)\n    4\n    iex> Range.size(1..10//-1)\n    0\n\n    iex> Range.size(10..1)\n    10\n    iex> Range.size(10..1//-1)\n    10\n    iex> Range.size(10..1//-2)\n    5\n    iex> Range.size(10..1//-3)\n    4\n    iex> Range.size(10..1//1)\n    0\n\n","title":"Range.size/1","type":"function"},{"doc":"Splits a range in two. It returns a tuple of two elements. If split is less than the number of elements in the range, the first element in the range will have split entries and the second will have all remaining entries. If split is more than the number of elements in the range, the second range in the tuple will emit zero elements. Examples Increasing ranges: iex&gt; Range . split ( 1 .. 5 , 2 ) { 1 .. 2 , 3 .. 5 } iex&gt; Range . split ( 1 .. 5 // 2 , 2 ) { 1 .. 3 // 2 , 5 .. 5 // 2 } iex&gt; Range . split ( 1 .. 5 // 2 , 0 ) { 1 .. - 1 // 2 , 1 .. 5 // 2 } iex&gt; Range . split ( 1 .. 5 // 2 , 10 ) { 1 .. 5 // 2 , 7 .. 5 // 2 } Decreasing ranges can also be split: iex&gt; Range . split ( 5 .. 1 // - 1 , 2 ) { 5 .. 4 // - 1 , 3 .. 1 // - 1 } iex&gt; Range . split ( 5 .. 1 // - 2 , 2 ) { 5 .. 3 // - 2 , 1 .. 1 // - 2 } iex&gt; Range . split ( 5 .. 1 // - 2 , 0 ) { 5 .. 7 // - 2 , 5 .. 1 // - 2 } iex&gt; Range . split ( 5 .. 1 // - 2 , 10 ) { 5 .. 1 // - 2 , - 1 .. 1 // - 2 } Empty ranges preserve their property but still return empty ranges: iex&gt; Range . split ( 2 .. 5 // - 1 , 2 ) { 2 .. 3 // - 1 , 4 .. 5 // - 1 } iex&gt; Range . split ( 2 .. 5 // - 1 , 10 ) { 2 .. 3 // - 1 , 4 .. 5 // - 1 } iex&gt; Range . split ( 5 .. 2 // 1 , 2 ) { 5 .. 4 // 1 , 3 .. 2 // 1 } iex&gt; Range . split ( 5 .. 2 // 1 , 10 ) { 5 .. 4 // 1 , 3 .. 2 // 1 } If the number to split is negative, it splits from the back: iex&gt; Range . split ( 1 .. 5 , - 2 ) { 1 .. 3 , 4 .. 5 } iex&gt; Range . split ( 5 .. 1 // - 1 , - 2 ) { 5 .. 3 // - 1 , 2 .. 1 // - 1 } If it is negative and greater than the elements in the range, the first element of the tuple will be an empty range: iex&gt; Range . split ( 1 .. 5 , - 10 ) { 1 .. 0 // 1 , 1 .. 5 } iex&gt; Range . split ( 5 .. 1 // - 1 , - 10 ) { 5 .. 6 // - 1 , 5 .. 1 // - 1 } Properties When a range is split, the following properties are observed. Given split(input) returns {left, right} , we have: assert input . first == left . first assert input . last == right . last assert input . step == left . step assert input . step == right . step assert Range . size ( input ) == Range . size ( left ) + Range . size ( right )","ref":"Range.html#split/2","source_doc":"Splits a range in two.\n\nIt returns a tuple of two elements.\n\nIf `split` is less than the number of elements in the range, the first\nelement in the range will have `split` entries and the second will have\nall remaining entries.\n\nIf `split` is more than the number of elements in the range, the second\nrange in the tuple will emit zero elements.\n\n## Examples\n\nIncreasing ranges:\n\n    iex> Range.split(1..5, 2)\n    {1..2, 3..5}\n\n    iex> Range.split(1..5//2, 2)\n    {1..3//2, 5..5//2}\n\n    iex> Range.split(1..5//2, 0)\n    {1..-1//2, 1..5//2}\n\n    iex> Range.split(1..5//2, 10)\n    {1..5//2, 7..5//2}\n\nDecreasing ranges can also be split:\n\n    iex> Range.split(5..1//-1, 2)\n    {5..4//-1, 3..1//-1}\n\n    iex> Range.split(5..1//-2, 2)\n    {5..3//-2, 1..1//-2}\n\n    iex> Range.split(5..1//-2, 0)\n    {5..7//-2, 5..1//-2}\n\n    iex> Range.split(5..1//-2, 10)\n    {5..1//-2, -1..1//-2}\n\nEmpty ranges preserve their property but still return empty ranges:\n\n    iex> Range.split(2..5//-1, 2)\n    {2..3//-1, 4..5//-1}\n\n    iex> Range.split(2..5//-1, 10)\n    {2..3//-1, 4..5//-1}\n\n    iex> Range.split(5..2//1, 2)\n    {5..4//1, 3..2//1}\n\n    iex> Range.split(5..2//1, 10)\n    {5..4//1, 3..2//1}\n\nIf the number to split is negative, it splits from the back:\n\n    iex> Range.split(1..5, -2)\n    {1..3, 4..5}\n\n    iex> Range.split(5..1//-1, -2)\n    {5..3//-1, 2..1//-1}\n\nIf it is negative and greater than the elements in the range,\nthe first element of the tuple will be an empty range:\n\n    iex> Range.split(1..5, -10)\n    {1..0//1, 1..5}\n\n    iex> Range.split(5..1//-1, -10)\n    {5..6//-1, 5..1//-1}\n\n## Properties\n\nWhen a range is split, the following properties are observed.\nGiven `split(input)` returns `{left, right}`, we have:\n\n    assert input.first == left.first\n    assert input.last == right.last\n    assert input.step == left.step\n    assert input.step == right.step\n    assert Range.size(input) == Range.size(left) + Range.size(right)\n\n","title":"Range.split/2","type":"function"},{"doc":"Converts a range to a list.","ref":"Range.html#to_list/1","source_doc":"Converts a range to a list.\n","title":"Range.to_list/1","type":"function"},{"doc":"","ref":"Range.html#t:limit/0","source_doc":false,"title":"Range.limit/0","type":"type"},{"doc":"","ref":"Range.html#t:step/0","source_doc":false,"title":"Range.step/0","type":"type"},{"doc":"","ref":"Range.html#t:t/0","source_doc":false,"title":"Range.t/0","type":"type"},{"doc":"","ref":"Range.html#t:t/2","source_doc":false,"title":"Range.t/2","type":"type"},{"doc":"Functions for creating and composing streams. Streams are composable, lazy enumerables (for an introduction on enumerables, see the Enum module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's Range is a stream: iex&gt; range = 1 .. 5 1 .. 5 iex&gt; Enum . map ( range , &amp; ( &amp;1 * 2 ) ) [ 2 , 4 , 6 , 8 , 10 ] In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The Stream module allows us to map the range, without triggering its enumeration: iex&gt; range = 1 .. 3 iex&gt; stream = Stream . map ( range , &amp; ( &amp;1 * 2 ) ) iex&gt; Enum . map ( stream , &amp; ( &amp;1 + 1 ) ) [ 3 , 5 , 7 ] Note that we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when Enum.map/2 is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in Stream are lazy and the functions in Enum are eager . Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with Enum , intermediate lists are created, while Stream creates a recipe of computations that are executed at a later moment. Let's see another example: 1 .. 3 |&gt; Enum . map ( &amp; IO . inspect ( &amp;1 ) ) |&gt; Enum . map ( &amp; ( &amp;1 * 2 ) ) |&gt; Enum . map ( &amp; IO . inspect ( &amp;1 ) ) 1 2 3 2 4 6 #=&gt; [2, 4, 6] Note that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams: stream = 1 .. 3 |&gt; Stream . map ( &amp; IO . inspect ( &amp;1 ) ) |&gt; Stream . map ( &amp; ( &amp;1 * 2 ) ) |&gt; Stream . map ( &amp; IO . inspect ( &amp;1 ) ) Enum . to_list ( stream ) 1 2 2 4 3 6 #=&gt; [2, 4, 6] Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once! That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call Stream.map/2 multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the Enum module. Like with Enum , the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as Stream.map/2 . After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take. Creating Streams There are many functions in Elixir's standard library that return streams, some examples are: IO.stream/2 - streams input lines, one by one URI.query_decoder/1 - decodes a query string, pair by pair This module also provides many convenience functions for creating streams, like Stream.cycle/1 , Stream.unfold/2 , Stream.resource/3 and more. Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.","ref":"Stream.html","source_doc":"Functions for creating and composing streams.\n\nStreams are composable, lazy enumerables (for an introduction on\nenumerables, see the `Enum` module). Any enumerable that generates\nelements one by one during enumeration is called a stream. For example,\nElixir's `Range` is a stream:\n\n    iex> range = 1..5\n    1..5\n    iex> Enum.map(range, &(&1 * 2))\n    [2, 4, 6, 8, 10]\n\nIn the example above, as we mapped over the range, the elements being\nenumerated were created one by one, during enumeration. The `Stream`\nmodule allows us to map the range, without triggering its enumeration:\n\n    iex> range = 1..3\n    iex> stream = Stream.map(range, &(&1 * 2))\n    iex> Enum.map(stream, &(&1 + 1))\n    [3, 5, 7]\n\nNote that we started with a range and then we created a stream that is\nmeant to multiply each element in the range by 2. At this point, no\ncomputation was done. Only when `Enum.map/2` is called we actually\nenumerate over each element in the range, multiplying it by 2 and adding 1.\nWe say the functions in `Stream` are *lazy* and the functions in `Enum`\nare *eager*.\n\nDue to their laziness, streams are useful when working with large\n(or even infinite) collections. When chaining many operations with `Enum`,\nintermediate lists are created, while `Stream` creates a recipe of\ncomputations that are executed at a later moment. Let's see another\nexample:\n\n    1..3\n    |> Enum.map(&IO.inspect(&1))\n    |> Enum.map(&(&1 * 2))\n    |> Enum.map(&IO.inspect(&1))\n    1\n    2\n    3\n    2\n    4\n    6\n    #=> [2, 4, 6]\n\nNote that we first printed each element in the list, then multiplied each\nelement by 2 and finally printed each new value. In this example, the list\nwas enumerated three times. Let's see an example with streams:\n\n    stream = 1..3\n    |> Stream.map(&IO.inspect(&1))\n    |> Stream.map(&(&1 * 2))\n    |> Stream.map(&IO.inspect(&1))\n    Enum.to_list(stream)\n    1\n    2\n    2\n    4\n    3\n    6\n    #=> [2, 4, 6]\n\nAlthough the end result is the same, the order in which the elements were\nprinted changed! With streams, we print the first element and then print\nits double. In this example, the list was enumerated just once!\n\nThat's what we meant when we said earlier that streams are composable,\nlazy enumerables. Note that we could call `Stream.map/2` multiple times,\neffectively composing the streams and keeping them lazy. The computations\nare only performed when you call a function from the `Enum` module.\n\nLike with `Enum`, the functions in this module work in linear time. This\nmeans that, the time it takes to perform an operation grows at the same\nrate as the length of the list. This is expected on operations such as\n`Stream.map/2`. After all, if we want to traverse every element on a\nstream, the longer the stream, the more elements we need to traverse,\nand the longer it will take.\n\n## Creating Streams\n\nThere are many functions in Elixir's standard library that return\nstreams, some examples are:\n\n  * `IO.stream/2`         - streams input lines, one by one\n  * `URI.query_decoder/1` - decodes a query string, pair by pair\n\nThis module also provides many convenience functions for creating streams,\nlike `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n\nNote the functions in this module are guaranteed to return enumerables.\nSince enumerables can have different shapes (structs, anonymous functions,\nand so on), the functions in this module may return any of those shapes\nand this may change at any time. For example, a function that today\nreturns an anonymous function may return a struct in future releases.\n","title":"Stream","type":"module"},{"doc":"Chunks the enum by buffering elements for which fun returns the same value. Elements are only emitted when fun returns a new value or the enum finishes. Examples iex&gt; stream = Stream . chunk_by ( [ 1 , 2 , 2 , 3 , 4 , 4 , 6 , 7 , 7 ] , &amp; ( rem ( &amp;1 , 2 ) == 1 ) ) iex&gt; Enum . to_list ( stream ) [ [ 1 ] , [ 2 , 2 ] , [ 3 ] , [ 4 , 4 , 6 ] , [ 7 , 7 ] ]","ref":"Stream.html#chunk_by/2","source_doc":"Chunks the `enum` by buffering elements for which `fun` returns the same value.\n\nElements are only emitted when `fun` returns a new value or the `enum` finishes.\n\n## Examples\n\n    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n    iex> Enum.to_list(stream)\n    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n\n","title":"Stream.chunk_by/2","type":"function"},{"doc":"Shortcut to chunk_every(enum, count, count) .","ref":"Stream.html#chunk_every/2","source_doc":"Shortcut to `chunk_every(enum, count, count)`.\n","title":"Stream.chunk_every/2","type":"function"},{"doc":"Streams the enumerable in chunks, containing count elements each, where each new chunk starts step elements into the enumerable. step is optional and, if not passed, defaults to count , i.e. chunks do not overlap. Chunking will stop as soon as the collection ends or when we emit an incomplete chunk. If the last chunk does not have count elements to fill the chunk, elements are taken from leftover to fill in the chunk. If leftover does not have enough elements to fill the chunk, then a partial chunk is returned with less than count elements. If :discard is given in leftover , the last chunk is discarded unless it has exactly count elements. Examples iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 2 ) |&gt; Enum . to_list ( ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , :discard ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 2 , [ 7 ] ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 3 , 4 , 5 ] , [ 5 , 6 , 7 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 3 , 3 , [ ] ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] iex&gt; Stream . chunk_every ( [ 1 , 2 , 3 , 4 ] , 3 , 3 , Stream . cycle ( [ 0 ] ) ) |&gt; Enum . to_list ( ) [ [ 1 , 2 , 3 ] , [ 4 , 0 , 0 ] ]","ref":"Stream.html#chunk_every/4","source_doc":"Streams the enumerable in chunks, containing `count` elements each,\nwhere each new chunk starts `step` elements into the enumerable.\n\n`step` is optional and, if not passed, defaults to `count`, i.e.\nchunks do not overlap. Chunking will stop as soon as the collection\nends or when we emit an incomplete chunk.\n\nIf the last chunk does not have `count` elements to fill the chunk,\nelements are taken from `leftover` to fill in the chunk. If `leftover`\ndoes not have enough elements to fill the chunk, then a partial chunk\nis returned with less than `count` elements.\n\nIf `:discard` is given in `leftover`, the last chunk is discarded\nunless it has exactly `count` elements.\n\n## Examples\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list()\n    [[1, 2], [3, 4], [5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list()\n    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list()\n    [[1, 2, 3], [4, 5, 6]]\n\n    iex> Stream.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0])) |> Enum.to_list()\n    [[1, 2, 3], [4, 0, 0]]\n\n","title":"Stream.chunk_every/4","type":"function"},{"doc":"Chunks the enum with fine grained control when every chunk is emitted. chunk_fun receives the current element and the accumulator and must return {:cont, element, acc} to emit the given chunk and continue with accumulator or {:cont, acc} to not emit any chunk and continue with the return accumulator. after_fun is invoked when iteration is done and must also return {:cont, element, acc} or {:cont, acc} . Examples iex&gt; chunk_fun = fn element , acc -&gt; ...&gt; if rem ( element , 2 ) == 0 do ...&gt; { :cont , Enum . reverse ( [ element | acc ] ) , [ ] } ...&gt; else ...&gt; { :cont , [ element | acc ] } ...&gt; end ...&gt; end iex&gt; after_fun = fn ...&gt; [ ] -&gt; { :cont , [ ] } ...&gt; acc -&gt; { :cont , Enum . reverse ( acc ) , [ ] } ...&gt; end iex&gt; stream = Stream . chunk_while ( 1 .. 10 , [ ] , chunk_fun , after_fun ) iex&gt; Enum . to_list ( stream ) [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] , [ 7 , 8 ] , [ 9 , 10 ] ]","ref":"Stream.html#chunk_while/4","source_doc":"Chunks the `enum` with fine grained control when every chunk is emitted.\n\n`chunk_fun` receives the current element and the accumulator and\nmust return `{:cont, element, acc}` to emit the given chunk and\ncontinue with accumulator or `{:cont, acc}` to not emit any chunk\nand continue with the return accumulator.\n\n`after_fun` is invoked when iteration is done and must also return\n`{:cont, element, acc}` or `{:cont, acc}`.\n\n## Examples\n\n    iex> chunk_fun = fn element, acc ->\n    ...>   if rem(element, 2) == 0 do\n    ...>     {:cont, Enum.reverse([element | acc]), []}\n    ...>   else\n    ...>     {:cont, [element | acc]}\n    ...>   end\n    ...> end\n    iex> after_fun = fn\n    ...>   [] -> {:cont, []}\n    ...>   acc -> {:cont, Enum.reverse(acc), []}\n    ...> end\n    iex> stream = Stream.chunk_while(1..10, [], chunk_fun, after_fun)\n    iex> Enum.to_list(stream)\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n\n","title":"Stream.chunk_while/4","type":"function"},{"doc":"Creates a stream that enumerates each enumerable in an enumerable. Examples iex&gt; stream = Stream . concat ( [ 1 .. 3 , 4 .. 6 , 7 .. 9 ] ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]","ref":"Stream.html#concat/1","source_doc":"Creates a stream that enumerates each enumerable in an enumerable.\n\n## Examples\n\n    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n","title":"Stream.concat/1","type":"function"},{"doc":"Creates a stream that enumerates the first argument, followed by the second. Examples iex&gt; stream = Stream . concat ( 1 .. 3 , 4 .. 6 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 , 6 ] iex&gt; stream1 = Stream . cycle ( [ 1 , 2 , 3 ] ) iex&gt; stream2 = Stream . cycle ( [ 4 , 5 , 6 ] ) iex&gt; stream = Stream . concat ( stream1 , stream2 ) iex&gt; Enum . take ( stream , 6 ) [ 1 , 2 , 3 , 1 , 2 , 3 ]","ref":"Stream.html#concat/2","source_doc":"Creates a stream that enumerates the first argument, followed by the second.\n\n## Examples\n\n    iex> stream = Stream.concat(1..3, 4..6)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5, 6]\n\n    iex> stream1 = Stream.cycle([1, 2, 3])\n    iex> stream2 = Stream.cycle([4, 5, 6])\n    iex> stream = Stream.concat(stream1, stream2)\n    iex> Enum.take(stream, 6)\n    [1, 2, 3, 1, 2, 3]\n\n","title":"Stream.concat/2","type":"function"},{"doc":"Creates a stream that cycles through the given enumerable, infinitely. Examples iex&gt; stream = Stream . cycle ( [ 1 , 2 , 3 ] ) iex&gt; Enum . take ( stream , 5 ) [ 1 , 2 , 3 , 1 , 2 ]","ref":"Stream.html#cycle/1","source_doc":"Creates a stream that cycles through the given enumerable,\ninfinitely.\n\n## Examples\n\n    iex> stream = Stream.cycle([1, 2, 3])\n    iex> Enum.take(stream, 5)\n    [1, 2, 3, 1, 2]\n\n","title":"Stream.cycle/1","type":"function"},{"doc":"Creates a stream that only emits elements if they are different from the last emitted element. This function only ever needs to store the last emitted element. Elements are compared using ===/2 . Examples iex&gt; Stream . dedup ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 , 2 , 1 ]","ref":"Stream.html#dedup/1","source_doc":"Creates a stream that only emits elements if they are different from the last emitted element.\n\nThis function only ever needs to store the last emitted element.\n\nElements are compared using `===/2`.\n\n## Examples\n\n    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3, 2, 1]\n\n","title":"Stream.dedup/1","type":"function"},{"doc":"Creates a stream that only emits elements if the result of calling fun on the element is different from the (stored) result of calling fun on the last emitted element. Examples iex&gt; Stream . dedup_by ( [ { 1 , :x } , { 2 , :y } , { 2 , :z } , { 1 , :x } ] , fn { x , _ } -&gt; x end ) |&gt; Enum . to_list ( ) [ { 1 , :x } , { 2 , :y } , { 1 , :x } ]","ref":"Stream.html#dedup_by/2","source_doc":"Creates a stream that only emits elements if the result of calling `fun` on the element is\ndifferent from the (stored) result of calling `fun` on the last emitted element.\n\n## Examples\n\n    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}, {1, :x}]\n\n","title":"Stream.dedup_by/2","type":"function"},{"doc":"Lazily drops the next n elements from the enumerable. If a negative n is given, it will drop the last n elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until n additional elements have been emitted by the enum. Examples iex&gt; stream = Stream . drop ( 1 .. 10 , 5 ) iex&gt; Enum . to_list ( stream ) [ 6 , 7 , 8 , 9 , 10 ] iex&gt; stream = Stream . drop ( 1 .. 10 , - 5 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#drop/2","source_doc":"Lazily drops the next `n` elements from the enumerable.\n\nIf a negative `n` is given, it will drop the last `n` elements from\nthe collection. Note that the mechanism by which this is implemented\nwill delay the emission of any element until `n` additional elements have\nbeen emitted by the enum.\n\n## Examples\n\n    iex> stream = Stream.drop(1..10, 5)\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n    iex> stream = Stream.drop(1..10, -5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n","title":"Stream.drop/2","type":"function"},{"doc":"Creates a stream that drops every nth element from the enumerable. The first element is always dropped, unless nth is 0. nth must be a non-negative integer. Examples iex&gt; stream = Stream . drop_every ( 1 .. 10 , 2 ) iex&gt; Enum . to_list ( stream ) [ 2 , 4 , 6 , 8 , 10 ] iex&gt; stream = Stream . drop_every ( 1 .. 1000 , 1 ) iex&gt; Enum . to_list ( stream ) [ ] iex&gt; stream = Stream . drop_every ( [ 1 , 2 , 3 , 4 , 5 ] , 0 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#drop_every/2","source_doc":"Creates a stream that drops every `nth` element from the enumerable.\n\nThe first element is always dropped, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.drop_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.drop_every(1..1000, 1)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n","title":"Stream.drop_every/2","type":"function"},{"doc":"Lazily drops elements of the enumerable while the given function returns a truthy value. Examples iex&gt; stream = Stream . drop_while ( 1 .. 10 , &amp; ( &amp;1 &lt;= 5 ) ) iex&gt; Enum . to_list ( stream ) [ 6 , 7 , 8 , 9 , 10 ]","ref":"Stream.html#drop_while/2","source_doc":"Lazily drops elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [6, 7, 8, 9, 10]\n\n","title":"Stream.drop_while/2","type":"function"},{"doc":"Duplicates the given element n times in a stream. n is an integer greater than or equal to 0 . If n is 0 , an empty stream is returned. Examples iex&gt; stream = Stream . duplicate ( &quot;hello&quot; , 0 ) iex&gt; Enum . to_list ( stream ) [ ] iex&gt; stream = Stream . duplicate ( &quot;hi&quot; , 1 ) iex&gt; Enum . to_list ( stream ) [ &quot;hi&quot; ] iex&gt; stream = Stream . duplicate ( &quot;bye&quot; , 2 ) iex&gt; Enum . to_list ( stream ) [ &quot;bye&quot; , &quot;bye&quot; ] iex&gt; stream = Stream . duplicate ( [ 1 , 2 ] , 3 ) iex&gt; Enum . to_list ( stream ) [ [ 1 , 2 ] , [ 1 , 2 ] , [ 1 , 2 ] ]","ref":"Stream.html#duplicate/2","source_doc":"Duplicates the given element `n` times in a stream.\n\n`n` is an integer greater than or equal to `0`.\n\nIf `n` is `0`, an empty stream is returned.\n\n## Examples\n\n    iex> stream = Stream.duplicate(\"hello\", 0)\n    iex> Enum.to_list(stream)\n    []\n\n    iex> stream = Stream.duplicate(\"hi\", 1)\n    iex> Enum.to_list(stream)\n    [\"hi\"]\n\n    iex> stream = Stream.duplicate(\"bye\", 2)\n    iex> Enum.to_list(stream)\n    [\"bye\", \"bye\"]\n\n    iex> stream = Stream.duplicate([1, 2], 3)\n    iex> Enum.to_list(stream)\n    [[1, 2], [1, 2], [1, 2]]\n","title":"Stream.duplicate/2","type":"function"},{"doc":"Executes the given function for each element. The values in the stream do not change, therefore this function is useful for adding side effects (like printing) to a stream. See map/2 if producing a different stream is desired. Examples iex&gt; stream = Stream . each ( [ 1 , 2 , 3 ] , fn x -&gt; send ( self ( ) , x ) end ) iex&gt; Enum . to_list ( stream ) iex&gt; receive do : ( x when is_integer ( x ) -&gt; x ) 1 iex&gt; receive do : ( x when is_integer ( x ) -&gt; x ) 2 iex&gt; receive do : ( x when is_integer ( x ) -&gt; x ) 3","ref":"Stream.html#each/2","source_doc":"Executes the given function for each element.\n\nThe values in the stream do not change, therefore this\nfunction is useful for adding side effects (like printing)\nto a stream. See `map/2` if producing a different stream\nis desired.\n\n## Examples\n\n    iex> stream = Stream.each([1, 2, 3], fn x -> send(self(), x) end)\n    iex> Enum.to_list(stream)\n    iex> receive do: (x when is_integer(x) -> x)\n    1\n    iex> receive do: (x when is_integer(x) -> x)\n    2\n    iex> receive do: (x when is_integer(x) -> x)\n    3\n\n","title":"Stream.each/2","type":"function"},{"doc":"Creates a stream that filters elements according to the given function on enumeration. Examples iex&gt; stream = Stream . filter ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) iex&gt; Enum . to_list ( stream ) [ 2 ]","ref":"Stream.html#filter/2","source_doc":"Creates a stream that filters elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.filter([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [2]\n\n","title":"Stream.filter/2","type":"function"},{"doc":"Maps the given fun over enumerable and flattens the result. This function returns a new stream built by appending the result of invoking fun on each element of enumerable together. Examples iex&gt; stream = Stream . flat_map ( [ 1 , 2 , 3 ] , fn x -&gt; [ x , x * 2 ] end ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 2 , 4 , 3 , 6 ] iex&gt; stream = Stream . flat_map ( [ 1 , 2 , 3 ] , fn x -&gt; [ [ x ] ] end ) iex&gt; Enum . to_list ( stream ) [ [ 1 ] , [ 2 ] , [ 3 ] ]","ref":"Stream.html#flat_map/2","source_doc":"Maps the given `fun` over `enumerable` and flattens the result.\n\nThis function returns a new stream built by appending the result of invoking `fun`\non each element of `enumerable` together.\n\n## Examples\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [x, x * 2] end)\n    iex> Enum.to_list(stream)\n    [1, 2, 2, 4, 3, 6]\n\n    iex> stream = Stream.flat_map([1, 2, 3], fn x -> [[x]] end)\n    iex> Enum.to_list(stream)\n    [[1], [2], [3]]\n\n","title":"Stream.flat_map/2","type":"function"},{"doc":"Lazily intersperses intersperse_element between each element of the enumeration. Examples iex&gt; Stream . intersperse ( [ 1 , 2 , 3 ] , 0 ) |&gt; Enum . to_list ( ) [ 1 , 0 , 2 , 0 , 3 ] iex&gt; Stream . intersperse ( [ 1 ] , 0 ) |&gt; Enum . to_list ( ) [ 1 ] iex&gt; Stream . intersperse ( [ ] , 0 ) |&gt; Enum . to_list ( ) [ ]","ref":"Stream.html#intersperse/2","source_doc":"Lazily intersperses `intersperse_element` between each element of the enumeration.\n\n## Examples\n\n    iex> Stream.intersperse([1, 2, 3], 0) |> Enum.to_list()\n    [1, 0, 2, 0, 3]\n\n    iex> Stream.intersperse([1], 0) |> Enum.to_list()\n    [1]\n\n    iex> Stream.intersperse([], 0) |> Enum.to_list()\n    []\n\n","title":"Stream.intersperse/2","type":"function"},{"doc":"Creates a stream that emits a value after the given period n in milliseconds. The values emitted are an increasing counter starting at 0 . This operation will block the caller by the given interval every time a new element is streamed. Do not use this function to generate a sequence of numbers. If blocking the caller process is not necessary, use Stream.iterate(0, &amp; &amp;1 + 1) instead. Examples iex&gt; Stream . interval ( 10 ) |&gt; Enum . take ( 10 ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]","ref":"Stream.html#interval/1","source_doc":"Creates a stream that emits a value after the given period `n`\nin milliseconds.\n\nThe values emitted are an increasing counter starting at `0`.\nThis operation will block the caller by the given interval\nevery time a new element is streamed.\n\nDo not use this function to generate a sequence of numbers.\nIf blocking the caller process is not necessary, use\n`Stream.iterate(0, & &1 + 1)` instead.\n\n## Examples\n\n    iex> Stream.interval(10) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n","title":"Stream.interval/1","type":"function"},{"doc":"Injects the stream values into the given collectable as a side-effect. This function is often used with run/1 since any evaluation is delayed until the stream is executed. See run/1 for an example.","ref":"Stream.html#into/3","source_doc":"Injects the stream values into the given collectable as a side-effect.\n\nThis function is often used with `run/1` since any evaluation\nis delayed until the stream is executed. See `run/1` for an example.\n","title":"Stream.into/3","type":"function"},{"doc":"Emits a sequence of values, starting with start_value . Successive values are generated by calling next_fun on the previous value. Examples iex&gt; Stream . iterate ( 0 , &amp; ( &amp;1 + 1 ) ) |&gt; Enum . take ( 5 ) [ 0 , 1 , 2 , 3 , 4 ]","ref":"Stream.html#iterate/2","source_doc":"Emits a sequence of values, starting with `start_value`. Successive\nvalues are generated by calling `next_fun` on the previous value.\n\n## Examples\n\n    iex> Stream.iterate(0, &(&1 + 1)) |> Enum.take(5)\n    [0, 1, 2, 3, 4]\n\n","title":"Stream.iterate/2","type":"function"},{"doc":"Creates a stream that will apply the given function on enumeration. Examples iex&gt; stream = Stream . map ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 2 , 4 , 6 ]","ref":"Stream.html#map/2","source_doc":"Creates a stream that will apply the given function on\nenumeration.\n\n## Examples\n\n    iex> stream = Stream.map([1, 2, 3], fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6]\n\n","title":"Stream.map/2","type":"function"},{"doc":"Creates a stream that will apply the given function on every nth element from the enumerable. The first element is always passed to the given function. nth must be a non-negative integer. Examples iex&gt; stream = Stream . map_every ( 1 .. 10 , 2 , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 2 , 2 , 6 , 4 , 10 , 6 , 14 , 8 , 18 , 10 ] iex&gt; stream = Stream . map_every ( [ 1 , 2 , 3 , 4 , 5 ] , 1 , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 2 , 4 , 6 , 8 , 10 ] iex&gt; stream = Stream . map_every ( 1 .. 5 , 0 , fn x -&gt; x * 2 end ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#map_every/3","source_doc":"Creates a stream that will apply the given function on\nevery `nth` element from the enumerable.\n\nThe first element is always passed to the given function.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.map_every(1..10, 2, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n\n    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [2, 4, 6, 8, 10]\n\n    iex> stream = Stream.map_every(1..5, 0, fn x -> x * 2 end)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n","title":"Stream.map_every/3","type":"function"},{"doc":"Creates a stream that will reject elements according to the given function on enumeration. Examples iex&gt; stream = Stream . reject ( [ 1 , 2 , 3 ] , fn x -&gt; rem ( x , 2 ) == 0 end ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 ]","ref":"Stream.html#reject/2","source_doc":"Creates a stream that will reject elements according to\nthe given function on enumeration.\n\n## Examples\n\n    iex> stream = Stream.reject([1, 2, 3], fn x -> rem(x, 2) == 0 end)\n    iex> Enum.to_list(stream)\n    [1, 3]\n\n","title":"Stream.reject/2","type":"function"},{"doc":"Returns a stream generated by calling generator_fun repeatedly. Examples # Although not necessary, let&#39;s seed the random algorithm iex&gt; :rand . seed ( :exsss , { 1 , 2 , 3 } ) iex&gt; Stream . repeatedly ( &amp; :rand . uniform / 0 ) |&gt; Enum . take ( 3 ) [ 0.5455598952593053 , 0.6039309974353404 , 0.6684893034823949 ]","ref":"Stream.html#repeatedly/1","source_doc":"Returns a stream generated by calling `generator_fun` repeatedly.\n\n## Examples\n\n    # Although not necessary, let's seed the random algorithm\n    iex> :rand.seed(:exsss, {1, 2, 3})\n    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n    [0.5455598952593053, 0.6039309974353404, 0.6684893034823949]\n\n","title":"Stream.repeatedly/1","type":"function"},{"doc":"Emits a sequence of values for the given resource. Similar to transform/3 but the initial accumulated value is computed lazily via start_fun and executes an after_fun at the end of enumeration (both in cases of success and failure). Successive values are generated by calling next_fun with the previous accumulator (the initial value being the result returned by start_fun ) and it must return a tuple containing a list of elements to be emitted and the next accumulator. The enumeration finishes if it returns {:halt, acc} . As the function name suggests, this function is useful to stream values from resources. Examples Stream . resource ( fn -&gt; File . open! ( &quot;sample&quot; ) end , fn file -&gt; case IO . read ( file , :line ) do data when is_binary ( data ) -&gt; { [ data ] , file } _ -&gt; { :halt , file } end end , fn file -&gt; File . close ( file ) end ) iex&gt; Stream . resource ( ...&gt; fn -&gt; ...&gt; { :ok , pid } = StringIO . open ( &quot;string&quot; ) ...&gt; pid ...&gt; end , ...&gt; fn pid -&gt; ...&gt; case IO . getn ( pid , &quot;&quot; , 1 ) do ...&gt; :eof -&gt; { :halt , pid } ...&gt; char -&gt; { [ char ] , pid } ...&gt; end ...&gt; end , ...&gt; fn pid -&gt; StringIO . close ( pid ) end ...&gt; ) |&gt; Enum . to_list ( ) [ &quot;s&quot; , &quot;t&quot; , &quot;r&quot; , &quot;i&quot; , &quot;n&quot; , &quot;g&quot; ]","ref":"Stream.html#resource/3","source_doc":"Emits a sequence of values for the given resource.\n\nSimilar to `transform/3` but the initial accumulated value is\ncomputed lazily via `start_fun` and executes an `after_fun` at\nthe end of enumeration (both in cases of success and failure).\n\nSuccessive values are generated by calling `next_fun` with the\nprevious accumulator (the initial value being the result returned\nby `start_fun`) and it must return a tuple containing a list\nof elements to be emitted and the next accumulator. The enumeration\nfinishes if it returns `{:halt, acc}`.\n\nAs the function name suggests, this function is useful to stream values from\nresources.\n\n## Examples\n\n    Stream.resource(\n      fn -> File.open!(\"sample\") end,\n      fn file ->\n        case IO.read(file, :line) do\n          data when is_binary(data) -> {[data], file}\n          _ -> {:halt, file}\n        end\n      end,\n      fn file -> File.close(file) end\n    )\n\n    iex> Stream.resource(\n    ...>  fn ->\n    ...>    {:ok, pid} = StringIO.open(\"string\")\n    ...>    pid\n    ...>  end,\n    ...>  fn pid ->\n    ...>    case IO.getn(pid, \"\", 1) do\n    ...>      :eof -> {:halt, pid}\n    ...>      char -> {[char], pid}\n    ...>    end\n    ...>  end,\n    ...>  fn pid -> StringIO.close(pid) end\n    ...> ) |> Enum.to_list()\n    [\"s\", \"t\", \"r\", \"i\", \"n\", \"g\"]\n\n","title":"Stream.resource/3","type":"function"},{"doc":"Runs the given stream. This is useful when a stream needs to be run, for side effects, and there is no interest in its return result. Examples Open up a file, replace all # by % and stream to another file without loading the whole file in memory: File . stream! ( &quot;/path/to/file&quot; ) |&gt; Stream . map ( &amp; String . replace ( &amp;1 , &quot;#&quot; , &quot;%&quot; ) ) |&gt; Stream . into ( File . stream! ( &quot;/path/to/other/file&quot; ) ) |&gt; Stream . run ( ) No computation will be done until we call one of the Enum functions or run/1 .","ref":"Stream.html#run/1","source_doc":"Runs the given stream.\n\nThis is useful when a stream needs to be run, for side effects,\nand there is no interest in its return result.\n\n## Examples\n\nOpen up a file, replace all `#` by `%` and stream to another file\nwithout loading the whole file in memory:\n\n    File.stream!(\"/path/to/file\")\n    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n    |> Stream.into(File.stream!(\"/path/to/other/file\"))\n    |> Stream.run()\n\nNo computation will be done until we call one of the `Enum` functions\nor `run/1`.\n","title":"Stream.run/1","type":"function"},{"doc":"Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the first element in the enumerable as the starting value. Examples iex&gt; stream = Stream . scan ( 1 .. 5 , &amp; ( &amp;1 + &amp;2 ) ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Stream.html#scan/2","source_doc":"Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the first element in the enumerable\nas the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]\n\n","title":"Stream.scan/2","type":"function"},{"doc":"Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given acc as the starting value. Examples iex&gt; stream = Stream . scan ( 1 .. 5 , 0 , &amp; ( &amp;1 + &amp;2 ) ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 , 6 , 10 , 15 ]","ref":"Stream.html#scan/3","source_doc":"Creates a stream that applies the given function to each\nelement, emits the result and uses the same result as the accumulator\nfor the next computation. Uses the given `acc` as the starting value.\n\n## Examples\n\n    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n    iex> Enum.to_list(stream)\n    [1, 3, 6, 10, 15]\n\n","title":"Stream.scan/3","type":"function"},{"doc":"Lazily takes the next count elements from the enumerable and stops enumeration. If a negative count is given, the last count values will be taken. For such, the collection is fully enumerated keeping up to 2 * count elements in memory. Once the end of the collection is reached, the last count elements will be executed. Therefore, using a negative count on an infinite collection will never return. Examples iex&gt; stream = Stream . take ( 1 .. 100 , 5 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; stream = Stream . take ( 1 .. 100 , - 5 ) iex&gt; Enum . to_list ( stream ) [ 96 , 97 , 98 , 99 , 100 ] iex&gt; stream = Stream . cycle ( [ 1 , 2 , 3 ] ) |&gt; Stream . take ( 5 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 1 , 2 ]","ref":"Stream.html#take/2","source_doc":"Lazily takes the next `count` elements from the enumerable and stops\nenumeration.\n\nIf a negative `count` is given, the last `count` values will be taken.\nFor such, the collection is fully enumerated keeping up to `2 * count`\nelements in memory. Once the end of the collection is reached,\nthe last `count` elements will be executed. Therefore, using\na negative `count` on an infinite collection will never return.\n\n## Examples\n\n    iex> stream = Stream.take(1..100, 5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take(1..100, -5)\n    iex> Enum.to_list(stream)\n    [96, 97, 98, 99, 100]\n\n    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 1, 2]\n\n","title":"Stream.take/2","type":"function"},{"doc":"Creates a stream that takes every nth element from the enumerable. The first element is always included, unless nth is 0. nth must be a non-negative integer. Examples iex&gt; stream = Stream . take_every ( 1 .. 10 , 2 ) iex&gt; Enum . to_list ( stream ) [ 1 , 3 , 5 , 7 , 9 ] iex&gt; stream = Stream . take_every ( [ 1 , 2 , 3 , 4 , 5 ] , 1 ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ] iex&gt; stream = Stream . take_every ( 1 .. 1000 , 0 ) iex&gt; Enum . to_list ( stream ) [ ]","ref":"Stream.html#take_every/2","source_doc":"Creates a stream that takes every `nth` element from the enumerable.\n\nThe first element is always included, unless `nth` is 0.\n\n`nth` must be a non-negative integer.\n\n## Examples\n\n    iex> stream = Stream.take_every(1..10, 2)\n    iex> Enum.to_list(stream)\n    [1, 3, 5, 7, 9]\n\n    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n    iex> stream = Stream.take_every(1..1000, 0)\n    iex> Enum.to_list(stream)\n    []\n\n","title":"Stream.take_every/2","type":"function"},{"doc":"Lazily takes elements of the enumerable while the given function returns a truthy value. Examples iex&gt; stream = Stream . take_while ( 1 .. 100 , &amp; ( &amp;1 &lt;= 5 ) ) iex&gt; Enum . to_list ( stream ) [ 1 , 2 , 3 , 4 , 5 ]","ref":"Stream.html#take_while/2","source_doc":"Lazily takes elements of the enumerable while the given\nfunction returns a truthy value.\n\n## Examples\n\n    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n    iex> Enum.to_list(stream)\n    [1, 2, 3, 4, 5]\n\n","title":"Stream.take_while/2","type":"function"},{"doc":"Creates a stream that emits a single value after n milliseconds. The value emitted is 0 . This operation will block the caller by the given time until the element is streamed. Examples iex&gt; Stream . timer ( 10 ) |&gt; Enum . to_list ( ) [ 0 ]","ref":"Stream.html#timer/1","source_doc":"Creates a stream that emits a single value after `n` milliseconds.\n\nThe value emitted is `0`. This operation will block the caller by\nthe given time until the element is streamed.\n\n## Examples\n\n    iex> Stream.timer(10) |> Enum.to_list()\n    [0]\n\n","title":"Stream.timer/1","type":"function"},{"doc":"Transforms an existing stream. It expects an accumulator and a function that receives two arguments, the stream element and the updated accumulator. It must return a tuple, where the first element is a new stream (often a list) or the atom :halt , and the second element is the accumulator to be used by the next element. Note: this function is equivalent to Enum.flat_map_reduce/3 , except this function does not return the accumulator once the stream is processed. Examples Stream.transform/3 is useful as it can be used as the basis to implement many of the functions defined in this module. For example, we can implement Stream.take(enum, n) as follows: iex&gt; enum = 1001 .. 9999 iex&gt; n = 3 iex&gt; stream = Stream . transform ( enum , 0 , fn i , acc -&gt; ...&gt; if acc &lt; n , do : { [ i ] , acc + 1 } , else : { :halt , acc } ...&gt; end ) iex&gt; Enum . to_list ( stream ) [ 1001 , 1002 , 1003 ] Stream.transform/5 further generalizes this function to allow wrapping around resources.","ref":"Stream.html#transform/3","source_doc":"Transforms an existing stream.\n\nIt expects an accumulator and a function that receives two arguments,\nthe stream element and the updated accumulator. It must return a tuple,\nwhere the first element is a new stream (often a list) or the atom `:halt`,\nand the second element is the accumulator to be used by the next element.\n\nNote: this function is equivalent to `Enum.flat_map_reduce/3`, except this\nfunction does not return the accumulator once the stream is processed.\n\n## Examples\n\n`Stream.transform/3` is useful as it can be used as the basis to implement\nmany of the functions defined in this module. For example, we can implement\n`Stream.take(enum, n)` as follows:\n\n    iex> enum = 1001..9999\n    iex> n = 3\n    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n    ...> end)\n    iex> Enum.to_list(stream)\n    [1001, 1002, 1003]\n\n`Stream.transform/5` further generalizes this function to allow wrapping\naround resources.\n","title":"Stream.transform/3","type":"function"},{"doc":"Similar to Stream.transform/5 , except last_fun is not supplied. This function can be seen as a combination of Stream.resource/3 with Stream.transform/3 .","ref":"Stream.html#transform/4","source_doc":"Similar to `Stream.transform/5`, except `last_fun` is not supplied.\n\nThis function can be seen as a combination of `Stream.resource/3` with\n`Stream.transform/3`.\n","title":"Stream.transform/4","type":"function"},{"doc":"Transforms an existing stream with function-based start, last, and after callbacks. Once transformation starts, start_fun is invoked to compute the initial accumulator. Then, for each element in the enumerable, the reducer function is invoked with the element and the accumulator, returning new elements and a new accumulator, as in transform/3 . Once the collection is done, last_fun is invoked with the accumulator to emit any remaining items. Then after_fun is invoked, to close any resource, but not emitting any new items. last_fun is only invoked if the given enumerable terminates successfully (either because it is done or it halted itself). after_fun is always invoked, therefore after_fun must be the one used for closing resources.","ref":"Stream.html#transform/5","source_doc":"Transforms an existing stream with function-based start, last, and after\ncallbacks.\n\nOnce transformation starts, `start_fun` is invoked to compute the initial\naccumulator. Then, for each element in the enumerable, the `reducer` function\nis invoked with the element and the accumulator, returning new elements and a\nnew accumulator, as in `transform/3`.\n\nOnce the collection is done, `last_fun` is invoked with the accumulator to\nemit any remaining items. Then `after_fun` is invoked, to close any resource,\nbut not emitting any new items. `last_fun` is only invoked if the given\nenumerable terminates successfully (either because it is done or it halted\nitself). `after_fun` is always invoked, therefore `after_fun` must be the\none used for closing resources.\n","title":"Stream.transform/5","type":"function"},{"doc":"Emits a sequence of values for the given accumulator. Successive values are generated by calling next_fun with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns nil . Examples To create a stream that counts down and stops before zero: iex&gt; Stream . unfold ( 5 , fn ...&gt; 0 -&gt; nil ...&gt; n -&gt; { n , n - 1 } ...&gt; end ) |&gt; Enum . to_list ( ) [ 5 , 4 , 3 , 2 , 1 ] If next_fun never returns nil , the returned stream is infinite : iex&gt; Stream . unfold ( 0 , fn ...&gt; n -&gt; { n , n + 1 } ...&gt; end ) |&gt; Enum . take ( 10 ) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] iex&gt; Stream . unfold ( 1 , fn ...&gt; n -&gt; { n , n * 2 } ...&gt; end ) |&gt; Enum . take ( 10 ) [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ]","ref":"Stream.html#unfold/2","source_doc":"Emits a sequence of values for the given accumulator.\n\nSuccessive values are generated by calling `next_fun` with the previous\naccumulator and it must return a tuple with the current value and next\naccumulator. The enumeration finishes if it returns `nil`.\n\n## Examples\n\nTo create a stream that counts down and stops before zero:\n\n    iex> Stream.unfold(5, fn\n    ...>   0 -> nil\n    ...>   n -> {n, n - 1}\n    ...> end) |> Enum.to_list()\n    [5, 4, 3, 2, 1]\n\nIf `next_fun` never returns `nil`, the returned stream is *infinite*:\n\n    iex> Stream.unfold(0, fn\n    ...>   n -> {n, n + 1}\n    ...> end) |> Enum.take(10)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    iex> Stream.unfold(1, fn\n    ...>   n -> {n, n * 2}\n    ...> end) |> Enum.take(10)\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n","title":"Stream.unfold/2","type":"function"},{"doc":"Creates a stream that only emits elements if they are unique. Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected. Examples iex&gt; Stream . uniq ( [ 1 , 2 , 3 , 3 , 2 , 1 ] ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 ]","ref":"Stream.html#uniq/1","source_doc":"Creates a stream that only emits elements if they are unique.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Examples\n\n    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list()\n    [1, 2, 3]\n\n","title":"Stream.uniq/1","type":"function"},{"doc":"Creates a stream that only emits elements if they are unique, by removing the elements for which function fun returned duplicate elements. The function fun maps every element to a term which is used to determine if two elements are duplicates. Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected. Example iex&gt; Stream . uniq_by ( [ { 1 , :x } , { 2 , :y } , { 1 , :z } ] , fn { x , _ } -&gt; x end ) |&gt; Enum . to_list ( ) [ { 1 , :x } , { 2 , :y } ] iex&gt; Stream . uniq_by ( [ a : { :tea , 2 } , b : { :tea , 2 } , c : { :coffee , 1 } ] , fn { _ , y } -&gt; y end ) |&gt; Enum . to_list ( ) [ a : { :tea , 2 } , c : { :coffee , 1 } ]","ref":"Stream.html#uniq_by/2","source_doc":"Creates a stream that only emits elements if they are unique, by removing the\nelements for which function `fun` returned duplicate elements.\n\nThe function `fun` maps every element to a term which is used to\ndetermine if two elements are duplicates.\n\nKeep in mind that, in order to know if an element is unique\nor not, this function needs to store all unique values emitted\nby the stream. Therefore, if the stream is infinite, the number\nof elements stored will grow infinitely, never being garbage-collected.\n\n## Example\n\n    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list()\n    [{1, :x}, {2, :y}]\n\n    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end) |> Enum.to_list()\n    [a: {:tea, 2}, c: {:coffee, 1}]\n\n","title":"Stream.uniq_by/2","type":"function"},{"doc":"Creates a stream where each element in the enumerable will be wrapped in a tuple alongside its index. If an offset is given, we will index from the given offset instead of from zero. Examples iex&gt; stream = Stream . with_index ( [ 1 , 2 , 3 ] ) iex&gt; Enum . to_list ( stream ) [ { 1 , 0 } , { 2 , 1 } , { 3 , 2 } ] iex&gt; stream = Stream . with_index ( [ 1 , 2 , 3 ] , 3 ) iex&gt; Enum . to_list ( stream ) [ { 1 , 3 } , { 2 , 4 } , { 3 , 5 } ]","ref":"Stream.html#with_index/2","source_doc":"Creates a stream where each element in the enumerable will\nbe wrapped in a tuple alongside its index.\n\nIf an `offset` is given, we will index from the given offset instead of from zero.\n\n## Examples\n\n    iex> stream = Stream.with_index([1, 2, 3])\n    iex> Enum.to_list(stream)\n    [{1, 0}, {2, 1}, {3, 2}]\n\n    iex> stream = Stream.with_index([1, 2, 3], 3)\n    iex> Enum.to_list(stream)\n    [{1, 3}, {2, 4}, {3, 5}]\n\n","title":"Stream.with_index/2","type":"function"},{"doc":"Zips corresponding elements from a finite collection of enumerables into one stream of tuples. The zipping finishes as soon as any enumerable in the given collection completes. Examples iex&gt; concat = Stream . concat ( 1 .. 3 , 4 .. 6 ) iex&gt; cycle = Stream . cycle ( [ &quot;foo&quot; , &quot;bar&quot; , &quot;baz&quot; ] ) iex&gt; Stream . zip ( [ concat , [ :a , :b , :c ] , cycle ] ) |&gt; Enum . to_list ( ) [ { 1 , :a , &quot;foo&quot; } , { 2 , :b , &quot;bar&quot; } , { 3 , :c , &quot;baz&quot; } ]","ref":"Stream.html#zip/1","source_doc":"Zips corresponding elements from a finite collection of enumerables\ninto one stream of tuples.\n\nThe zipping finishes as soon as any enumerable in the given collection completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list()\n    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n\n","title":"Stream.zip/1","type":"function"},{"doc":"Zips two enumerables together, lazily. The zipping finishes as soon as either enumerable completes. Examples iex&gt; concat = Stream . concat ( 1 .. 3 , 4 .. 6 ) iex&gt; cycle = Stream . cycle ( [ :a , :b , :c ] ) iex&gt; Stream . zip ( concat , cycle ) |&gt; Enum . to_list ( ) [ { 1 , :a } , { 2 , :b } , { 3 , :c } , { 4 , :a } , { 5 , :b } , { 6 , :c } ]","ref":"Stream.html#zip/2","source_doc":"Zips two enumerables together, lazily.\n\nThe zipping finishes as soon as either enumerable completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> cycle = Stream.cycle([:a, :b, :c])\n    iex> Stream.zip(concat, cycle) |> Enum.to_list()\n    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n\n","title":"Stream.zip/2","type":"function"},{"doc":"Lazily zips corresponding elements from a finite collection of enumerables into a new enumerable, transforming them with the zip_fun function as it goes. The first element from each of the enums in enumerables will be put into a list which is then passed to the one-arity zip_fun function. Then, the second elements from each of the enums are put into a list and passed to zip_fun , and so on until any one of the enums in enumerables completes. Returns a new enumerable with the results of calling zip_fun . Examples iex&gt; concat = Stream . concat ( 1 .. 3 , 4 .. 6 ) iex&gt; Stream . zip_with ( [ concat , concat ] , fn [ a , b ] -&gt; a + b end ) |&gt; Enum . to_list ( ) [ 2 , 4 , 6 , 8 , 10 , 12 ] iex&gt; concat = Stream . concat ( 1 .. 3 , 4 .. 6 ) iex&gt; Stream . zip_with ( [ concat , concat , 1 .. 3 ] , fn [ a , b , c ] -&gt; a + b + c end ) |&gt; Enum . to_list ( ) [ 3 , 6 , 9 ]","ref":"Stream.html#zip_with/2","source_doc":"Lazily zips corresponding elements from a finite collection of enumerables into a new\nenumerable, transforming them with the `zip_fun` function as it goes.\n\nThe first element from each of the enums in `enumerables` will be put into a list which is then passed to\nthe one-arity `zip_fun` function. Then, the second elements from each of the enums are put into a list and passed to\n`zip_fun`, and so on until any one of the enums in `enumerables` completes.\n\nReturns a new enumerable with the results of calling `zip_fun`.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat], fn [a, b] -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with([concat, concat, 1..3], fn [a, b, c] -> a + b + c end) |> Enum.to_list()\n    [3, 6, 9]\n\n","title":"Stream.zip_with/2","type":"function"},{"doc":"Lazily zips corresponding elements from two enumerables into a new one, transforming them with the zip_fun function as it goes. The zip_fun will be called with the first element from enumerable1 and the first element from enumerable2 , then with the second element from each, and so on until either one of the enumerables completes. Examples iex&gt; concat = Stream . concat ( 1 .. 3 , 4 .. 6 ) iex&gt; Stream . zip_with ( concat , concat , fn a , b -&gt; a + b end ) |&gt; Enum . to_list ( ) [ 2 , 4 , 6 , 8 , 10 , 12 ]","ref":"Stream.html#zip_with/3","source_doc":"Lazily zips corresponding elements from two enumerables into a new one, transforming them with\nthe `zip_fun` function as it goes.\n\nThe `zip_fun` will be called with the first element from `enumerable1` and the first\nelement from `enumerable2`, then with the second element from each, and so on until\neither one of the enumerables completes.\n\n## Examples\n\n    iex> concat = Stream.concat(1..3, 4..6)\n    iex> Stream.zip_with(concat, concat, fn a, b -> a + b end) |> Enum.to_list()\n    [2, 4, 6, 8, 10, 12]\n\n","title":"Stream.zip_with/3","type":"function"},{"doc":"","ref":"Stream.html#t:acc/0","source_doc":false,"title":"Stream.acc/0","type":"type"},{"doc":"","ref":"Stream.html#t:default/0","source_doc":false,"title":"Stream.default/0","type":"type"},{"doc":"","ref":"Stream.html#t:element/0","source_doc":false,"title":"Stream.element/0","type":"type"},{"doc":"Zero-based index.","ref":"Stream.html#t:index/0","source_doc":"Zero-based index.","title":"Stream.index/0","type":"type"},{"doc":"","ref":"Stream.html#t:timer/0","source_doc":false,"title":"Stream.timer/0","type":"type"},{"doc":"This module contains functions to manipulate files. Some of those functions are low-level, allowing the user to interact with files or IO devices, like open/2 , copy/3 and others. This module also provides higher level functions that work with filenames and have their naming based on Unix variants. For example, one can copy a file via cp/3 and remove files and directories recursively via rm_rf/1 . Paths given to functions in this module can be either relative to the current working directory (as returned by File.cwd/0 ), or absolute paths. Shell conventions like ~ are not expanded automatically. To use paths like ~/Downloads , you can use Path.expand/1 or Path.expand/2 to expand your path to an absolute path. Encoding In order to write and read files, one must use the functions in the IO module. By default, a file is opened in binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file, then the slower IO.read/2 and IO.write/2 functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees. Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is. API Most of the functions in this module return :ok or {:ok, result} in case of success, {:error, reason} otherwise. Those functions also have a variant that ends with ! which returns the result (instead of the {:ok, result} tuple) in case of success or raises an exception in case it fails. For example: File . read ( &quot;hello.txt&quot; ) #=&gt; {:ok, &quot;World&quot;} File . read ( &quot;invalid.txt&quot; ) #=&gt; {:error, :enoent} File . read! ( &quot;hello.txt&quot; ) #=&gt; &quot;World&quot; File . read! ( &quot;invalid.txt&quot; ) #=&gt; raises File.Error In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception). Processes and raw files Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor. This means files can be passed between nodes and message passing guarantees they can write to the same file in a network. However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in :raw mode. The options :read_ahead and :delayed_write are also useful when operating on large files or working with files in tight loops. Check :file.open/2 for more information about such options and other performance considerations.","ref":"File.html","source_doc":"This module contains functions to manipulate files.\n\nSome of those functions are low-level, allowing the user\nto interact with files or IO devices, like `open/2`,\n`copy/3` and others. This module also provides higher\nlevel functions that work with filenames and have their naming\nbased on Unix variants. For example, one can copy a file\nvia `cp/3` and remove files and directories recursively\nvia `rm_rf/1`.\n\nPaths given to functions in this module can be either relative to the\ncurrent working directory (as returned by `File.cwd/0`), or absolute\npaths. Shell conventions like `~` are not expanded automatically.\nTo use paths like `~/Downloads`, you can use `Path.expand/1` or\n`Path.expand/2` to expand your path to an absolute path.\n\n## Encoding\n\nIn order to write and read files, one must use the functions\nin the `IO` module. By default, a file is opened in binary mode,\nwhich requires the functions `IO.binread/2` and `IO.binwrite/2`\nto interact with the file. A developer may pass `:utf8` as an\noption when opening the file, then the slower `IO.read/2` and\n`IO.write/2` functions must be used as they are responsible for\ndoing the proper conversions and providing the proper data guarantees.\n\nNote that filenames when given as charlists in Elixir are\nalways treated as UTF-8. In particular, we expect that the\nshell and the operating system are configured to use UTF-8\nencoding. Binary filenames are considered raw and passed\nto the operating system as is.\n\n## API\n\nMost of the functions in this module return `:ok` or\n`{:ok, result}` in case of success, `{:error, reason}`\notherwise. Those functions also have a variant\nthat ends with `!` which returns the result (instead of the\n`{:ok, result}` tuple) in case of success or raises an\nexception in case it fails. For example:\n\n    File.read(\"hello.txt\")\n    #=> {:ok, \"World\"}\n\n    File.read(\"invalid.txt\")\n    #=> {:error, :enoent}\n\n    File.read!(\"hello.txt\")\n    #=> \"World\"\n\n    File.read!(\"invalid.txt\")\n    #=> raises File.Error\n\nIn general, a developer should use the former in case they want\nto react if the file does not exist. The latter should be used\nwhen the developer expects their software to fail in case the\nfile cannot be read (i.e. it is literally an exception).\n\n## Processes and raw files\n\nEvery time a file is opened, Elixir spawns a new process. Writing\nto a file is equivalent to sending messages to the process that\nwrites to the file descriptor.\n\nThis means files can be passed between nodes and message passing\nguarantees they can write to the same file in a network.\n\nHowever, you may not always want to pay the price for this abstraction.\nIn such cases, a file can be opened in `:raw` mode. The options `:read_ahead`\nand `:delayed_write` are also useful when operating on large files or\nworking with files in tight loops.\n\nCheck `:file.open/2` for more information about such options and\nother performance considerations.\n","title":"File","type":"module"},{"doc":"Sets the current working directory. The current working directory is set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the :cd option of System.cmd/3 and Port.open/2 . Returns :ok if successful, {:error, reason} otherwise.","ref":"File.html#cd/1","source_doc":"Sets the current working directory.\n\nThe current working directory is set for the BEAM globally. This can lead to\nrace conditions if multiple processes are changing the current working\ndirectory concurrently. To run an external command in a given directory\nwithout changing the global current working directory, use the `:cd` option\nof `System.cmd/3` and `Port.open/2`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\n","title":"File.cd/1","type":"function"},{"doc":"The same as cd/1 , but raises a File.Error exception if it fails.","ref":"File.html#cd!/1","source_doc":"The same as `cd/1`, but raises a `File.Error` exception if it fails.\n","title":"File.cd!/1","type":"function"},{"doc":"Changes the current directory to the given path , executes the given function and then reverts back to the previous path regardless of whether there is an exception. The current working directory is temporarily set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the :cd option of System.cmd/3 and Port.open/2 . Raises an error if retrieving or changing the current directory fails.","ref":"File.html#cd!/2","source_doc":"Changes the current directory to the given `path`,\nexecutes the given function and then reverts back\nto the previous path regardless of whether there is an exception.\n\nThe current working directory is temporarily set for the BEAM globally. This\ncan lead to race conditions if multiple processes are changing the current\nworking directory concurrently. To run an external command in a given\ndirectory without changing the global current working directory, use the\n`:cd` option of `System.cmd/3` and `Port.open/2`.\n\nRaises an error if retrieving or changing the current\ndirectory fails.\n","title":"File.cd!/2","type":"function"},{"doc":"Changes the group given by the group ID gid for a given file . Returns :ok on success, or {:error, reason} on failure.","ref":"File.html#chgrp/2","source_doc":"Changes the group given by the group ID `gid`\nfor a given `file`. Returns `:ok` on success, or\n`{:error, reason}` on failure.\n","title":"File.chgrp/2","type":"function"},{"doc":"Same as chgrp/2 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#chgrp!/2","source_doc":"Same as `chgrp/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.chgrp!/2","type":"function"},{"doc":"Changes the mode for a given file . Returns :ok on success, or {:error, reason} on failure. Permissions File permissions are specified by adding together the following octal modes: 0o400 - read permission: owner 0o200 - write permission: owner 0o100 - execute permission: owner 0o040 - read permission: group 0o020 - write permission: group 0o010 - execute permission: group 0o004 - read permission: other 0o002 - write permission: other 0o001 - execute permission: other For example, setting the mode 0o755 gives it write, read and execute permission to the owner and both read and execute permission to group and others.","ref":"File.html#chmod/2","source_doc":"Changes the `mode` for a given `file`.\n\nReturns `:ok` on success, or `{:error, reason}` on failure.\n\n## Permissions\n\nFile permissions are specified by adding together the following octal modes:\n\n  * `0o400` - read permission: owner\n  * `0o200` - write permission: owner\n  * `0o100` - execute permission: owner\n\n  * `0o040` - read permission: group\n  * `0o020` - write permission: group\n  * `0o010` - execute permission: group\n\n  * `0o004` - read permission: other\n  * `0o002` - write permission: other\n  * `0o001` - execute permission: other\n\nFor example, setting the mode `0o755` gives it\nwrite, read and execute permission to the owner\nand both read and execute permission to group\nand others.\n","title":"File.chmod/2","type":"function"},{"doc":"Same as chmod/2 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#chmod!/2","source_doc":"Same as `chmod/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.chmod!/2","type":"function"},{"doc":"Changes the owner given by the user ID uid for a given file . Returns :ok on success, or {:error, reason} on failure.","ref":"File.html#chown/2","source_doc":"Changes the owner given by the user ID `uid`\nfor a given `file`. Returns `:ok` on success,\nor `{:error, reason}` on failure.\n","title":"File.chown/2","type":"function"},{"doc":"Same as chown/2 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#chown!/2","source_doc":"Same as `chown/2`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.chown!/2","type":"function"},{"doc":"Closes the file referenced by io_device . It mostly returns :ok , except for some severe errors such as out of memory. Note that if the option :delayed_write was used when opening the file, close/1 might return an old write error and not even try to close the file. See open/2 for more information.","ref":"File.html#close/1","source_doc":"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\nfor some severe errors such as out of memory.\n\nNote that if the option `:delayed_write` was used when opening the file,\n`close/1` might return an old write error and not even try to close the file.\nSee `open/2` for more information.\n","title":"File.close/1","type":"function"},{"doc":"Copies the contents of source to destination . Both parameters can be a filename or an IO device opened with open/2 . bytes_count specifies the number of bytes to copy, the default being :infinity . If file destination already exists, it is overwritten by the contents in source . Returns {:ok, bytes_copied} if successful, {:error, reason} otherwise. Compared to the cp/3 , this function is more low-level, allowing a copy from device to device limited by a number of bytes. On the other hand, cp/3 performs more extensive checks on both source and destination and it also preserves the file mode after copy. Typical error reasons are the same as in open/2 , read/1 and write/3 .","ref":"File.html#copy/3","source_doc":"Copies the contents of `source` to `destination`.\n\nBoth parameters can be a filename or an IO device opened\nwith `open/2`. `bytes_count` specifies the number of\nbytes to copy, the default being `:infinity`.\n\nIf file `destination` already exists, it is overwritten\nby the contents in `source`.\n\nReturns `{:ok, bytes_copied}` if successful,\n`{:error, reason}` otherwise.\n\nCompared to the `cp/3`, this function is more low-level,\nallowing a copy from device to device limited by a number of\nbytes. On the other hand, `cp/3` performs more extensive\nchecks on both source and destination and it also preserves\nthe file mode after copy.\n\nTypical error reasons are the same as in `open/2`,\n`read/1` and `write/3`.\n","title":"File.copy/3","type":"function"},{"doc":"The same as copy/3 but raises a File.CopyError exception if it fails. Returns the bytes_copied otherwise.","ref":"File.html#copy!/3","source_doc":"The same as `copy/3` but raises a `File.CopyError` exception if it fails.\nReturns the `bytes_copied` otherwise.\n","title":"File.copy!/3","type":"function"},{"doc":"Copies the contents of source_file to destination_file preserving its modes. source_file must be a file or a symbolic link to one. destination_file must be a path to a non-existent file. If either is a directory, {:error, :eisdir} will be returned. The function returns :ok in case of success. Otherwise, it returns {:error, reason} . If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check copy/3 instead. Note: The command cp in Unix-like systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried. Options :on_conflict - (since v1.14.0) Invoked when a file already exists in the destination. The function receives arguments for source_file and destination_file . It should return true if the existing file should be overwritten, false if otherwise. The default callback returns true . On earlier versions, this callback could be given as third argument, but such behaviour is now deprecated.","ref":"File.html#cp/3","source_doc":"Copies the contents of `source_file` to `destination_file` preserving its modes.\n\n`source_file` must be a file or a symbolic link to one. `destination_file` must\nbe a path to a non-existent file. If either is a directory, `{:error, :eisdir}`\nwill be returned.\n\nThe function returns `:ok` in case of success. Otherwise, it returns\n`{:error, reason}`.\n\nIf you want to copy contents from an IO device to another device\nor do a straight copy from a source to a destination without\npreserving modes, check `copy/3` instead.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether the destination is an existing directory or not. We have chosen to\nexplicitly disallow copying to a destination which is a directory,\nand an error will be returned if tried.\n\n## Options\n\n  * `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source_file` and `destination_file`. It should\n    return `true` if the existing file should be overwritten, `false` if otherwise.\n    The default callback returns `true`. On earlier versions, this callback could be\n    given as third argument, but such behaviour is now deprecated.\n\n","title":"File.cp/3","type":"function"},{"doc":"The same as cp/3 , but raises a File.CopyError exception if it fails. Returns :ok otherwise.","ref":"File.html#cp!/3","source_doc":"The same as `cp/3`, but raises a `File.CopyError` exception if it fails.\nReturns `:ok` otherwise.\n","title":"File.cp!/3","type":"function"},{"doc":"Copies the contents in source to destination recursively, maintaining the source directory structure and modes. If source is a file or a symbolic link to it, destination must be a path to an existent file, a symbolic link to one, or a path to a non-existent file. If source is a directory, or a symbolic link to it, then destination must be an existent directory or a symbolic link to one, or a path to a non-existent directory. If the source is a file, it copies source to destination . If the source is a directory, it copies the contents inside source into the destination directory. If a file already exists in the destination, it invokes the optional on_conflict callback given as an option. See &quot;Options&quot; for more information. This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed. The function returns {:ok, files_and_directories} in case of success, files_and_directories lists all files and directories copied in no specific order. It returns {:error, reason, file} otherwise. Note: The command cp in Unix-like systems behaves differently depending on whether destination is an existing directory or not. We have chosen to explicitly disallow this behaviour. If source is a file and destination is a directory, {:error, :eisdir} will be returned. Options :on_conflict - (since v1.14.0) Invoked when a file already exists in the destination. The function receives arguments for source and destination . It should return true if the existing file should be overwritten, false if otherwise. The default callback returns true . On earlier versions, this callback could be given as third argument, but such behaviour is now deprecated. :dereference_symlinks - (since v1.14.0) By default, this function will copy symlinks by creating symlinks that point to the same location. This option forces symlinks to be dereferenced and have their contents copied instead when set to true . If the dereferenced files do not exist, than the operation fails. The default is false . Examples # Copies file &quot;a.txt&quot; to &quot;b.txt&quot; File . cp_r ( &quot;a.txt&quot; , &quot;b.txt&quot; ) # Copies all files in &quot;samples&quot; to &quot;tmp&quot; File . cp_r ( &quot;samples&quot; , &quot;tmp&quot; ) # Same as before, but asks the user how to proceed in case of conflicts File . cp_r ( &quot;samples&quot; , &quot;tmp&quot; , on_conflict : fn source , destination -&gt; IO . gets ( &quot;Overwriting \#{ destination } by \#{ source } . Type y to confirm. &quot; ) == &quot;y \\n &quot; end )","ref":"File.html#cp_r/3","source_doc":"Copies the contents in `source` to `destination` recursively, maintaining the\nsource directory structure and modes.\n\nIf `source` is a file or a symbolic link to it, `destination` must be a path\nto an existent file, a symbolic link to one, or a path to a non-existent file.\n\nIf `source` is a directory, or a symbolic link to it, then `destination` must\nbe an existent `directory` or a symbolic link to one, or a path to a non-existent directory.\n\nIf the source is a file, it copies `source` to `destination`. If the `source`\nis a directory, it copies the contents inside source into the `destination` directory.\n\nIf a file already exists in the destination, it invokes the optional `on_conflict`\ncallback given as an option. See \"Options\" for more information.\n\nThis function may fail while copying files, in such cases, it will leave the\ndestination directory in a dirty state, where file which have already been\ncopied won't be removed.\n\nThe function returns `{:ok, files_and_directories}` in case of\nsuccess, `files_and_directories` lists all files and directories copied in no\nspecific order. It returns `{:error, reason, file}` otherwise.\n\nNote: The command `cp` in Unix-like systems behaves differently depending on\nwhether `destination` is an existing directory or not. We have chosen to\nexplicitly disallow this behaviour. If `source` is a `file` and `destination`\nis a directory, `{:error, :eisdir}` will be returned.\n\n## Options\n\n  * `:on_conflict` - (since v1.14.0) Invoked when a file already exists in the destination.\n    The function receives arguments for `source` and `destination`. It should return\n    `true` if the existing file should be overwritten, `false` if otherwise. The default\n    callback returns `true`. On earlier versions, this callback could be given as third\n    argument, but such behaviour is now deprecated.\n\n  * `:dereference_symlinks` - (since v1.14.0) By default, this function will copy symlinks\n    by creating symlinks that point to the same location. This option forces symlinks to be\n    dereferenced and have their contents copied instead when set to `true`. If the dereferenced\n    files do not exist, than the operation fails. The default is `false`.\n\n## Examples\n\n    # Copies file \"a.txt\" to \"b.txt\"\n    File.cp_r(\"a.txt\", \"b.txt\")\n\n    # Copies all files in \"samples\" to \"tmp\"\n    File.cp_r(\"samples\", \"tmp\")\n\n    # Same as before, but asks the user how to proceed in case of conflicts\n    File.cp_r(\"samples\", \"tmp\", on_conflict: fn source, destination ->\n      IO.gets(\"Overwriting \#{destination} by \#{source}. Type y to confirm. \") == \"y\\n\"\n    end)\n\n","title":"File.cp_r/3","type":"function"},{"doc":"The same as cp_r/3 , but raises a File.CopyError exception if it fails. Returns the list of copied files otherwise.","ref":"File.html#cp_r!/3","source_doc":"The same as `cp_r/3`, but raises a `File.CopyError` exception if it fails.\nReturns the list of copied files otherwise.\n","title":"File.cp_r!/3","type":"function"},{"doc":"Gets the current working directory. In rare circumstances, this function can fail on Unix-like systems. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns {:ok, cwd} in case of success, {:error, reason} otherwise.","ref":"File.html#cwd/0","source_doc":"Gets the current working directory.\n\nIn rare circumstances, this function can fail on Unix-like systems. It may happen\nif read permissions do not exist for the parent directories of the\ncurrent directory. For this reason, returns `{:ok, cwd}` in case\nof success, `{:error, reason}` otherwise.\n","title":"File.cwd/0","type":"function"},{"doc":"The same as cwd/0 , but raises a File.Error exception if it fails.","ref":"File.html#cwd!/0","source_doc":"The same as `cwd/0`, but raises a `File.Error` exception if it fails.\n","title":"File.cwd!/0","type":"function"},{"doc":"Returns true if the given path is a directory. This function follows symbolic links, so if a symbolic link points to a directory, true is returned. Options The supported options are: :raw - a single atom to bypass the file server and only check for the file locally Examples File . dir? ( &quot;./test&quot; ) #=&gt; true File . dir? ( &quot;test&quot; ) #=&gt; true File . dir? ( &quot;/usr/bin&quot; ) #=&gt; true File . dir? ( &quot;~/Downloads&quot; ) #=&gt; false &quot;~/Downloads&quot; |&gt; Path . expand ( ) |&gt; File . dir? ( ) #=&gt; true","ref":"File.html#dir?/2","source_doc":"Returns `true` if the given path is a directory.\n\nThis function follows symbolic links, so if a symbolic link points to a\ndirectory, `true` is returned.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.dir?(\"./test\")\n    #=> true\n\n    File.dir?(\"test\")\n    #=> true\n\n    File.dir?(\"/usr/bin\")\n    #=> true\n\n    File.dir?(\"~/Downloads\")\n    #=> false\n\n    \"~/Downloads\" |> Path.expand() |> File.dir?()\n    #=> true\n\n","title":"File.dir?/2","type":"function"},{"doc":"Returns true if the given path exists. It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns false for symbolic links pointing to non-existing targets. Options The supported options are: :raw - a single atom to bypass the file server and only check for the file locally Examples File . exists? ( &quot;test/&quot; ) #=&gt; true File . exists? ( &quot;missing.txt&quot; ) #=&gt; false File . exists? ( &quot;/dev/null&quot; ) #=&gt; true","ref":"File.html#exists?/2","source_doc":"Returns `true` if the given path exists.\n\nIt can be a regular file, directory, socket, symbolic link, named pipe, or device file.\nReturns `false` for symbolic links pointing to non-existing targets.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.exists?(\"test/\")\n    #=> true\n\n    File.exists?(\"missing.txt\")\n    #=> false\n\n    File.exists?(\"/dev/null\")\n    #=> true\n\n","title":"File.exists?/2","type":"function"},{"doc":"Creates a hard link new to the file existing . Returns :ok if successful, {:error, reason} otherwise. If the operating system does not support hard links, returns {:error, :enotsup} .","ref":"File.html#ln/2","source_doc":"Creates a hard link `new` to the file `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support hard links, returns\n`{:error, :enotsup}`.\n","title":"File.ln/2","type":"function"},{"doc":"Same as ln/2 but raises a File.LinkError exception if it fails. Returns :ok otherwise.","ref":"File.html#ln!/2","source_doc":"Same as `ln/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.\n","title":"File.ln!/2","type":"function"},{"doc":"Creates a symbolic link new to the file or directory existing . Returns :ok if successful, {:error, reason} otherwise. If the operating system does not support symlinks, returns {:error, :enotsup} .","ref":"File.html#ln_s/2","source_doc":"Creates a symbolic link `new` to the file or directory `existing`.\n\nReturns `:ok` if successful, `{:error, reason}` otherwise.\nIf the operating system does not support symlinks, returns\n`{:error, :enotsup}`.\n","title":"File.ln_s/2","type":"function"},{"doc":"Same as ln_s/2 but raises a File.LinkError exception if it fails. Returns :ok otherwise.","ref":"File.html#ln_s!/2","source_doc":"Same as `ln_s/2` but raises a `File.LinkError` exception if it fails.\nReturns `:ok` otherwise.\n","title":"File.ln_s!/2","type":"function"},{"doc":"Returns the list of files in the given directory. Returns {:ok, files} in case of success, {:error, reason} otherwise.","ref":"File.html#ls/1","source_doc":"Returns the list of files in the given directory.\n\nReturns `{:ok, files}` in case of success,\n`{:error, reason}` otherwise.\n","title":"File.ls/1","type":"function"},{"doc":"The same as ls/1 but raises a File.Error exception in case of an error.","ref":"File.html#ls!/1","source_doc":"The same as `ls/1` but raises a `File.Error` exception in case of an error.\n","title":"File.ls!/1","type":"function"},{"doc":"Returns information about the path . If the file is a symlink, sets the type to :symlink and returns a File.Stat struct for the link. For any other file, returns exactly the same values as stat/2 . For more details, see :file.read_link_info/2 . Options The accepted options are: :time - configures how the file timestamps are returned The values for :time can be: :universal - returns a {date, time} tuple in UTC (default) :local - returns a {date, time} tuple using the machine time :posix - returns the time as integer seconds since epoch Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the time: :posix option.","ref":"File.html#lstat/2","source_doc":"Returns information about the `path`. If the file is a symlink, sets\nthe `type` to `:symlink` and returns a `File.Stat` struct for the link. For any\nother file, returns exactly the same values as `stat/2`.\n\nFor more details, see `:file.read_link_info/2`.\n\n## Options\n\nThe accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the machine time\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.\n","title":"File.lstat/2","type":"function"},{"doc":"Same as lstat/2 but returns the File.Stat struct directly, or raises a File.Error exception if an error is returned.","ref":"File.html#lstat!/2","source_doc":"Same as `lstat/2` but returns the `File.Stat` struct directly,\nor raises a `File.Error` exception if an error is returned.\n","title":"File.lstat!/2","type":"function"},{"doc":"Tries to create the directory path . Missing parent directories are not created. Returns :ok if successful, or {:error, reason} if an error occurs. Typical error reasons are: :eacces - missing search or write permissions for the parent directories of path :eexist - there is already a file or directory named path :enoent - a component of path does not exist :enospc - there is no space left on the device :enotdir - a component of path is not a directory; on some platforms, :enoent is returned instead","ref":"File.html#mkdir/1","source_doc":"Tries to create the directory `path`.\n\nMissing parent directories are not created.\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:eexist`  - there is already a file or directory named `path`\n  * `:enoent`  - a component of `path` does not exist\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory;\n    on some platforms, `:enoent` is returned instead\n\n","title":"File.mkdir/1","type":"function"},{"doc":"Same as mkdir/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#mkdir!/1","source_doc":"Same as `mkdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.mkdir!/1","type":"function"},{"doc":"Tries to create the directory path . Missing parent directories are created. Returns :ok if successful, or {:error, reason} if an error occurs. Typical error reasons are: :eacces - missing search or write permissions for the parent directories of path :enospc - there is no space left on the device :enotdir - a component of path is not a directory","ref":"File.html#mkdir_p/1","source_doc":"Tries to create the directory `path`.\n\nMissing parent directories are created. Returns `:ok` if successful, or\n`{:error, reason}` if an error occurs.\n\nTypical error reasons are:\n\n  * `:eacces`  - missing search or write permissions for the parent\n    directories of `path`\n  * `:enospc`  - there is no space left on the device\n  * `:enotdir` - a component of `path` is not a directory\n\n","title":"File.mkdir_p/1","type":"function"},{"doc":"Same as mkdir_p/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#mkdir_p!/1","source_doc":"Same as `mkdir_p/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.mkdir_p!/1","type":"function"},{"doc":"Opens the given path . In order to write and read files, one must use the functions in the IO module. By default, a file is opened in :binary mode, which requires the functions IO.binread/2 and IO.binwrite/2 to interact with the file. A developer may pass :utf8 as an option when opening the file and then all other functions from IO are available, since they work directly with Unicode data. modes_or_function can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling open(path, [], modes_or_function) . See the documentation for open/3 for more information on this function. The allowed modes: :binary - opens the file in binary mode, disabling special handling of Unicode sequences (default mode). :read - the file, which must exist, is opened for reading. :write - the file is opened for writing. It is created if it does not exist. If the file does exist, and if write is not combined with read, the file will be truncated. :append - the file will be opened for writing, and it will be created if it does not exist. Every write operation to a file opened with append will take place at the end of the file. :exclusive - the file, when opened for writing, is created if it does not exist. If the file exists, open will return {:error, :eexist} . :charlist - when this term is given, read operations on the file will return charlists rather than binaries. :compressed - makes it possible to read or write gzip compressed files. The compressed option must be combined with either read or write, but not both. Note that the file size obtained with stat/1 will most probably not match the number of bytes that can be read from a compressed file. :utf8 - this option denotes how data is actually stored in the disk file and makes the file perform automatic translation of characters to and from UTF-8. If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed. :delayed_write , :raw , :ram , :read_ahead , :sync , {:encoding, ...} , {:read_ahead, pos_integer} , {:delayed_write, non_neg_integer, non_neg_integer} - for more information about these options see :file.open/2 . This function returns: {:ok, io_device} - the file has been opened in the requested mode. io_device is actually the PID of the process which handles the file. This process monitors the process that originally opened the file (the owner process). If the owner process terminates, the file is closed and the process itself terminates too. If any process to which the io_device is linked terminates, the file will be closed and the process itself will be terminated. An io_device returned from this call can be used as an argument to the IO module functions. {:error, reason} - the file could not be opened. Examples { :ok , file } = File . open ( &quot;foo.tar.gz&quot; , [ :read , :compressed ] ) IO . read ( file , :line ) File . close ( file )","ref":"File.html#open/2","source_doc":"Opens the given `path`.\n\nIn order to write and read files, one must use the functions\nin the `IO` module. By default, a file is opened in `:binary` mode,\nwhich requires the functions `IO.binread/2` and `IO.binwrite/2`\nto interact with the file. A developer may pass `:utf8` as an\noption when opening the file and then all other functions from\n`IO` are available, since they work directly with Unicode data.\n\n`modes_or_function` can either be a list of modes or a function. If it's a\nlist, it's considered to be a list of modes (that are documented below). If\nit's a function, then it's equivalent to calling `open(path, [],\nmodes_or_function)`. See the documentation for `open/3` for more information\non this function.\n\nThe allowed modes:\n\n  * `:binary` - opens the file in binary mode, disabling special handling of Unicode sequences\n    (default mode).\n\n  * `:read` - the file, which must exist, is opened for reading.\n\n  * `:write` - the file is opened for writing. It is created if it does not\n    exist.\n\n    If the file does exist, and if write is not combined with read, the file\n    will be truncated.\n\n  * `:append` - the file will be opened for writing, and it will be created\n    if it does not exist. Every write operation to a file opened with append\n    will take place at the end of the file.\n\n  * `:exclusive` - the file, when opened for writing, is created if it does\n    not exist. If the file exists, open will return `{:error, :eexist}`.\n\n  * `:charlist` - when this term is given, read operations on the file will\n    return charlists rather than binaries.\n\n  * `:compressed` - makes it possible to read or write gzip compressed files.\n\n    The compressed option must be combined with either read or write, but not\n    both. Note that the file size obtained with `stat/1` will most probably\n    not match the number of bytes that can be read from a compressed file.\n\n  * `:utf8` - this option denotes how data is actually stored in the disk\n    file and makes the file perform automatic translation of characters to\n    and from UTF-8.\n\n    If data is sent to a file in a format that cannot be converted to the\n    UTF-8 or if data is read by a function that returns data in a format that\n    cannot cope with the character range of the data, an error occurs and the\n    file will be closed.\n\n  * `:delayed_write`, `:raw`, `:ram`, `:read_ahead`, `:sync`, `{:encoding, ...}`,\n    `{:read_ahead, pos_integer}`, `{:delayed_write, non_neg_integer, non_neg_integer}` -\n    for more information about these options see `:file.open/2`.\n\nThis function returns:\n\n  * `{:ok, io_device}` - the file has been opened in the requested mode.\n\n    `io_device` is actually the PID of the process which handles the file.\n    This process monitors the process that originally opened the file (the\n    owner process). If the owner process terminates, the file is closed and\n    the process itself terminates too. If any process to which the `io_device`\n    is linked terminates, the file will be closed and the process itself will\n    be terminated.\n\n    An `io_device` returned from this call can be used as an argument to the\n    `IO` module functions.\n\n  * `{:error, reason}` - the file could not be opened.\n\n## Examples\n\n    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n    IO.read(file, :line)\n    File.close(file)\n\n","title":"File.open/2","type":"function"},{"doc":"Similar to open/2 but expects a function as its last argument. The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function. Returns {:ok, function_result} in case of success, {:error, reason} otherwise. This function expects the file to be closed with success, which is usually the case unless the :delayed_write option is given. For this reason, we do not recommend passing :delayed_write to this function. Examples File . open ( &quot;file.txt&quot; , [ :read , :write ] , fn file -&gt; IO . read ( file , :line ) end ) See open/2 for the list of available modes .","ref":"File.html#open/3","source_doc":"Similar to `open/2` but expects a function as its last argument.\n\nThe file is opened, given to the function as an argument and\nautomatically closed after the function returns, regardless\nif there was an error when executing the function.\n\nReturns `{:ok, function_result}` in case of success,\n`{:error, reason}` otherwise.\n\nThis function expects the file to be closed with success,\nwhich is usually the case unless the `:delayed_write` option\nis given. For this reason, we do not recommend passing\n`:delayed_write` to this function.\n\n## Examples\n\n    File.open(\"file.txt\", [:read, :write], fn file ->\n      IO.read(file, :line)\n    end)\n\nSee `open/2` for the list of available `modes`.\n","title":"File.open/3","type":"function"},{"doc":"Similar to open/2 but raises a File.Error exception if the file could not be opened. Returns the IO device otherwise. See open/2 for the list of available modes.","ref":"File.html#open!/2","source_doc":"Similar to `open/2` but raises a `File.Error` exception if the file\ncould not be opened. Returns the IO device otherwise.\n\nSee `open/2` for the list of available modes.\n","title":"File.open!/2","type":"function"},{"doc":"Similar to open/3 but raises a File.Error exception if the file could not be opened. If it succeeds opening the file, it returns the function result on the IO device. See open/2 for the list of available modes .","ref":"File.html#open!/3","source_doc":"Similar to `open/3` but raises a `File.Error` exception if the file\ncould not be opened.\n\nIf it succeeds opening the file, it returns the `function` result on the IO device.\n\nSee `open/2` for the list of available `modes`.\n","title":"File.open!/3","type":"function"},{"doc":"Returns {:ok, binary} , where binary is a binary data object that contains the contents of path , or {:error, reason} if an error occurs. Typical error reasons: :enoent - the file does not exist :eacces - missing permission for reading the file, or for searching one of the parent directories :eisdir - the named file is a directory :enotdir - a component of the file name is not a directory; on some platforms, :enoent is returned instead :enomem - there is not enough memory for the contents of the file You can use :file.format_error/1 to get a descriptive string of the error.","ref":"File.html#read/1","source_doc":"Returns `{:ok, binary}`, where `binary` is a binary data object that contains the contents\nof `path`, or `{:error, reason}` if an error occurs.\n\nTypical error reasons:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for reading the file,\n    or for searching one of the parent directories\n  * `:eisdir`  - the named file is a directory\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enomem`  - there is not enough memory for the contents of the file\n\nYou can use `:file.format_error/1` to get a descriptive string of the error.\n","title":"File.read/1","type":"function"},{"doc":"Returns a binary with the contents of the given filename, or raises a File.Error exception if an error occurs.","ref":"File.html#read!/1","source_doc":"Returns a binary with the contents of the given filename,\nor raises a `File.Error` exception if an error occurs.\n","title":"File.read!/1","type":"function"},{"doc":"Reads the symbolic link at path . If path exists and is a symlink, returns {:ok, target} , otherwise returns {:error, reason} . For more details, see :file.read_link/1 . Typical error reasons are: :einval - path is not a symbolic link :enoent - path does not exist :enotsup - symbolic links are not supported on the current platform","ref":"File.html#read_link/1","source_doc":"Reads the symbolic link at `path`.\n\nIf `path` exists and is a symlink, returns `{:ok, target}`, otherwise returns\n`{:error, reason}`.\n\nFor more details, see `:file.read_link/1`.\n\nTypical error reasons are:\n\n  * `:einval` - path is not a symbolic link\n  * `:enoent` - path does not exist\n  * `:enotsup` - symbolic links are not supported on the current platform\n\n","title":"File.read_link/1","type":"function"},{"doc":"Same as read_link/1 but returns the target directly, or raises a File.Error exception if an error is returned.","ref":"File.html#read_link!/1","source_doc":"Same as `read_link/1` but returns the target directly,\nor raises a `File.Error` exception if an error is returned.\n","title":"File.read_link!/1","type":"function"},{"doc":"Returns true if the path is a regular file. This function follows symbolic links, so if a symbolic link points to a regular file, true is returned. Options The supported options are: :raw - a single atom to bypass the file server and only check for the file locally Examples File . regular? ( __ENV__ . file ) #=&gt; true","ref":"File.html#regular?/2","source_doc":"Returns `true` if the path is a regular file.\n\nThis function follows symbolic links, so if a symbolic link points to a\nregular file, `true` is returned.\n\n## Options\n\nThe supported options are:\n\n  * `:raw` - a single atom to bypass the file server and only check\n    for the file locally\n\n## Examples\n\n    File.regular?(__ENV__.file)\n    #=> true\n\n","title":"File.regular?/2","type":"function"},{"doc":"Renames the source file to destination file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the destination filename, it is not sufficient to simply specify its directory. Returns :ok in case of success, {:error, reason} otherwise. Note: The command mv in Unix-like systems behaves differently depending on whether source is a file and the destination is an existing directory. We have chosen to explicitly disallow this behaviour. Examples # Rename file &quot;a.txt&quot; to &quot;b.txt&quot; File . rename ( &quot;a.txt&quot; , &quot;b.txt&quot; ) # Rename directory &quot;samples&quot; to &quot;tmp&quot; File . rename ( &quot;samples&quot; , &quot;tmp&quot; )","ref":"File.html#rename/2","source_doc":"Renames the `source` file to `destination` file.  It can be used to move files\n(and directories) between directories.  If moving a file, you must fully\nspecify the `destination` filename, it is not sufficient to simply specify\nits directory.\n\nReturns `:ok` in case of success, `{:error, reason}` otherwise.\n\nNote: The command `mv` in Unix-like systems behaves differently depending on\nwhether `source` is a file and the `destination` is an existing directory.\nWe have chosen to explicitly disallow this behaviour.\n\n## Examples\n\n    # Rename file \"a.txt\" to \"b.txt\"\n    File.rename(\"a.txt\", \"b.txt\")\n\n    # Rename directory \"samples\" to \"tmp\"\n    File.rename(\"samples\", \"tmp\")\n\n","title":"File.rename/2","type":"function"},{"doc":"The same as rename/2 but raises a File.RenameError exception if it fails. Returns :ok otherwise.","ref":"File.html#rename!/2","source_doc":"The same as `rename/2` but raises a `File.RenameError` exception if it fails.\nReturns `:ok` otherwise.\n","title":"File.rename!/2","type":"function"},{"doc":"Tries to delete the file path . Returns :ok if successful, or {:error, reason} if an error occurs. Note the file is deleted even if in read-only mode. Typical error reasons are: :enoent - the file does not exist :eacces - missing permission for the file or one of its parents :eperm - the file is a directory and user is not super-user :enotdir - a component of the file name is not a directory; on some platforms, :enoent is returned instead :einval - filename had an improper type, such as tuple Examples File . rm ( &quot;file.txt&quot; ) #=&gt; :ok File . rm ( &quot;tmp_dir/&quot; ) #=&gt; {:error, :eperm}","ref":"File.html#rm/1","source_doc":"Tries to delete the file `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\n\nNote the file is deleted even if in read-only mode.\n\nTypical error reasons are:\n\n  * `:enoent`  - the file does not exist\n  * `:eacces`  - missing permission for the file or one of its parents\n  * `:eperm`   - the file is a directory and user is not super-user\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:einval`  - filename had an improper type, such as tuple\n\n## Examples\n\n    File.rm(\"file.txt\")\n    #=> :ok\n\n    File.rm(\"tmp_dir/\")\n    #=> {:error, :eperm}\n\n","title":"File.rm/1","type":"function"},{"doc":"Same as rm/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#rm!/1","source_doc":"Same as `rm/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.rm!/1","type":"function"},{"doc":"Removes files and directories recursively at the given path . Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail). Returns {:ok, files_and_directories} with all files and directories removed in no specific order, {:error, reason, file} otherwise. Examples File . rm_rf ( &quot;samples&quot; ) #=&gt; {:ok, [&quot;samples&quot;, &quot;samples/1.txt&quot;]} File . rm_rf ( &quot;unknown&quot; ) #=&gt; {:ok, []}","ref":"File.html#rm_rf/1","source_doc":"Removes files and directories recursively at the given `path`.\nSymlinks are not followed but simply removed, non-existing\nfiles are simply ignored (i.e. doesn't make this function fail).\n\nReturns `{:ok, files_and_directories}` with all files and\ndirectories removed in no specific order, `{:error, reason, file}`\notherwise.\n\n## Examples\n\n    File.rm_rf(\"samples\")\n    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n\n    File.rm_rf(\"unknown\")\n    #=> {:ok, []}\n\n","title":"File.rm_rf/1","type":"function"},{"doc":"Same as rm_rf/1 but raises a File.Error exception in case of failures, otherwise the list of files or directories removed.","ref":"File.html#rm_rf!/1","source_doc":"Same as `rm_rf/1` but raises a `File.Error` exception in case of failures,\notherwise the list of files or directories removed.\n","title":"File.rm_rf!/1","type":"function"},{"doc":"Tries to delete the dir at path . Returns :ok if successful, or {:error, reason} if an error occurs. It returns {:error, :eexist} if the directory is not empty. Examples File . rmdir ( &quot;tmp_dir&quot; ) #=&gt; :ok File . rmdir ( &quot;non_empty_dir&quot; ) #=&gt; {:error, :eexist} File . rmdir ( &quot;file.txt&quot; ) #=&gt; {:error, :enotdir}","ref":"File.html#rmdir/1","source_doc":"Tries to delete the dir at `path`.\n\nReturns `:ok` if successful, or `{:error, reason}` if an error occurs.\nIt returns `{:error, :eexist}` if the directory is not empty.\n\n## Examples\n\n    File.rmdir(\"tmp_dir\")\n    #=> :ok\n\n    File.rmdir(\"non_empty_dir\")\n    #=> {:error, :eexist}\n\n    File.rmdir(\"file.txt\")\n    #=> {:error, :enotdir}\n\n","title":"File.rmdir/1","type":"function"},{"doc":"Same as rmdir/1 , but raises a File.Error exception in case of failure. Otherwise :ok .","ref":"File.html#rmdir!/1","source_doc":"Same as `rmdir/1`, but raises a `File.Error` exception in case of failure.\nOtherwise `:ok`.\n","title":"File.rmdir!/1","type":"function"},{"doc":"Returns information about the path . If it exists, it returns a {:ok, info} tuple, where info is a File.Stat struct. Returns {:error, reason} with the same reasons as read/1 if a failure occurs. Options The accepted options are: :time - configures how the file timestamps are returned The values for :time can be: :universal - returns a {date, time} tuple in UTC (default) :local - returns a {date, time} tuple using the same time zone as the machine :posix - returns the time as integer seconds since epoch Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the time: :posix option.","ref":"File.html#stat/2","source_doc":"Returns information about the `path`. If it exists, it\nreturns a `{:ok, info}` tuple, where info is a\n`File.Stat` struct. Returns `{:error, reason}` with\nthe same reasons as `read/1` if a failure occurs.\n\n## Options\n\nThe accepted options are:\n\n  * `:time` - configures how the file timestamps are returned\n\nThe values for `:time` can be:\n\n  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n  * `:local` - returns a `{date, time}` tuple using the same time zone as the\n    machine\n  * `:posix` - returns the time as integer seconds since epoch\n\nNote: Since file times are stored in POSIX time format on most operating systems,\nit is faster to retrieve file information with the `time: :posix` option.\n","title":"File.stat/2","type":"function"},{"doc":"Same as stat/2 but returns the File.Stat directly, or raises a File.Error exception if an error is returned.","ref":"File.html#stat!/2","source_doc":"Same as `stat/2` but returns the `File.Stat` directly,\nor raises a `File.Error` exception if an error is returned.\n","title":"File.stat!/2","type":"function"},{"doc":"Returns a File.Stream for the given path with the given modes . The stream implements both Enumerable and Collectable protocols, which means it can be used both for read and write. The line_or_bytes argument configures how the file is read when streaming, by :line (default) or by a given number of bytes. When using the :line option, CRLF line breaks ( &quot;\\r\\n&quot; ) are normalized to LF ( &quot;\\n&quot; ). Operating the stream can fail on open for the same reasons as File.open!/2 . Note that the file is automatically opened each time streaming begins. There is no need to pass :read and :write modes, as those are automatically set by Elixir. Raw files Since Elixir controls when the streamed file is opened, the underlying device cannot be shared and as such it is convenient to open the file in raw mode for performance reasons. Therefore, Elixir will open streams in :raw mode with the :read_ahead option unless an encoding is specified. This means any data streamed into the file must be converted to iodata/0 type. If you pass, for example, [encoding: :utf8] or [encoding: {:utf16, :little}] in the modes parameter, the underlying stream will use IO.write/2 and the String.Chars protocol to convert the data. See IO.binwrite/2 and IO.write/2 . One may also consider passing the :delayed_write option if the stream is meant to be written to under a tight loop. Byte order marks If you pass :trim_bom in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file. Note that this function does not try to discover the file encoding basing on BOM. Examples # Read in 2048 byte chunks rather than lines File . stream! ( &quot;./test/test.data&quot; , [ ] , 2048 ) #=&gt; %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary], #=&gt; path: &quot;./test/test.data&quot;, raw: true} See Stream.run/1 for an example of streaming into a file.","ref":"File.html#stream!/3","source_doc":"Returns a `File.Stream` for the given `path` with the given `modes`.\n\nThe stream implements both `Enumerable` and `Collectable` protocols,\nwhich means it can be used both for read and write.\n\nThe `line_or_bytes` argument configures how the file is read when\nstreaming, by `:line` (default) or by a given number of bytes. When\nusing the `:line` option, CRLF line breaks (`\"\\r\\n\"`) are normalized\nto LF (`\"\\n\"`).\n\nOperating the stream can fail on open for the same reasons as\n`File.open!/2`. Note that the file is automatically opened each time streaming\nbegins. There is no need to pass `:read` and `:write` modes, as those are\nautomatically set by Elixir.\n\n## Raw files\n\nSince Elixir controls when the streamed file is opened, the underlying\ndevice cannot be shared and as such it is convenient to open the file\nin raw mode for performance reasons. Therefore, Elixir **will** open\nstreams in `:raw` mode with the `:read_ahead` option unless an encoding\nis specified. This means any data streamed into the file must be\nconverted to `t:iodata/0` type. If you pass, for example, `[encoding: :utf8]`\nor `[encoding: {:utf16, :little}]` in the modes parameter,\nthe underlying stream will use `IO.write/2` and the `String.Chars` protocol\nto convert the data. See `IO.binwrite/2` and `IO.write/2` .\n\nOne may also consider passing the `:delayed_write` option if the stream\nis meant to be written to under a tight loop.\n\n## Byte order marks\n\nIf you pass `:trim_bom` in the modes parameter, the stream will\ntrim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.\n\nNote that this function does not try to discover the file encoding basing\non BOM.\n\n## Examples\n\n    # Read in 2048 byte chunks rather than lines\n    File.stream!(\"./test/test.data\", [], 2048)\n    #=> %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary],\n    #=>   path: \"./test/test.data\", raw: true}\n\nSee `Stream.run/1` for an example of streaming into a file.\n","title":"File.stream!/3","type":"function"},{"doc":"Updates modification time (mtime) and access time (atime) of the given file. The file is created if it doesn't exist. Requires datetime in UTC (as returned by :erlang.universaltime() ) or an integer representing the POSIX timestamp (as returned by System.os_time(:second) ). In Unix-like systems, changing the modification time may require you to be either root or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with {:error, :eperm} . Examples File . touch ( &quot;/tmp/a.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) #=&gt; :ok File . touch ( &quot;/fakedir/b.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) { :error , :enoent } File . touch ( &quot;/tmp/a.txt&quot; , 1544519753 ) #=&gt; :ok","ref":"File.html#touch/2","source_doc":"Updates modification time (mtime) and access time (atime) of\nthe given file.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\nIn Unix-like systems, changing the modification time may require\nyou to be either `root` or the owner of the file. Having write\naccess may not be enough. In those cases, touching the file the\nfirst time (to create it) will succeed, but touching an existing\nfile with fail with `{:error, :eperm}`.\n\n## Examples\n\n    File.touch(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    {:error, :enoent}\n\n    File.touch(\"/tmp/a.txt\", 1544519753)\n    #=> :ok\n\n","title":"File.touch/2","type":"function"},{"doc":"Same as touch/2 but raises a File.Error exception if it fails. Returns :ok otherwise. The file is created if it doesn't exist. Requires datetime in UTC (as returned by :erlang.universaltime() ) or an integer representing the POSIX timestamp (as returned by System.os_time(:second) ). Examples File . touch! ( &quot;/tmp/a.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) #=&gt; :ok File . touch! ( &quot;/fakedir/b.txt&quot; , { { 2018 , 1 , 30 } , { 13 , 59 , 59 } } ) ** (File.Error) could not touch &quot;/fakedir/b.txt&quot;: no such file or directory File . touch! ( &quot;/tmp/a.txt&quot; , 1544519753 )","ref":"File.html#touch!/2","source_doc":"Same as `touch/2` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n\nThe file is created if it doesn't exist. Requires datetime in UTC\n(as returned by `:erlang.universaltime()`) or an integer\nrepresenting the POSIX timestamp (as returned by `System.os_time(:second)`).\n\n## Examples\n\n    File.touch!(\"/tmp/a.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    #=> :ok\n    File.touch!(\"/fakedir/b.txt\", {{2018, 1, 30}, {13, 59, 59}})\n    ** (File.Error) could not touch \"/fakedir/b.txt\": no such file or directory\n\n    File.touch!(\"/tmp/a.txt\", 1544519753)\n\n","title":"File.touch!/2","type":"function"},{"doc":"Writes content to the file path . The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns :ok if successful, or {:error, reason} if an error occurs. content must be iodata (a list of bytes or a binary). Setting the encoding for this function has no effect. Warning: Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via File.open/2 and using the functions in IO to write to the file will yield much better performance than calling this function multiple times. Typical error reasons are: :enoent - a component of the file name does not exist :enotdir - a component of the file name is not a directory; on some platforms, :enoent is returned instead :enospc - there is no space left on the device :eacces - missing permission for writing the file or searching one of the parent directories :eisdir - the named file is a directory Check File.open/2 for other available options.","ref":"File.html#write/3","source_doc":"Writes `content` to the file `path`.\n\nThe file is created if it does not exist. If it exists, the previous\ncontents are overwritten. Returns `:ok` if successful, or `{:error, reason}`\nif an error occurs.\n\n`content` must be `iodata` (a list of bytes or a binary). Setting the\nencoding for this function has no effect.\n\n**Warning:** Every time this function is invoked, a file descriptor is opened\nand a new process is spawned to write to the file. For this reason, if you are\ndoing multiple writes in a loop, opening the file via `File.open/2` and using\nthe functions in `IO` to write to the file will yield much better performance\nthan calling this function multiple times.\n\nTypical error reasons are:\n\n  * `:enoent`  - a component of the file name does not exist\n  * `:enotdir` - a component of the file name is not a directory;\n    on some platforms, `:enoent` is returned instead\n  * `:enospc`  - there is no space left on the device\n  * `:eacces`  - missing permission for writing the file or searching one of\n    the parent directories\n  * `:eisdir`  - the named file is a directory\n\nCheck `File.open/2` for other available options.\n","title":"File.write/3","type":"function"},{"doc":"Same as write/3 but raises a File.Error exception if it fails. Returns :ok otherwise.","ref":"File.html#write!/3","source_doc":"Same as `write/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n","title":"File.write!/3","type":"function"},{"doc":"Writes the given File.Stat back to the file system at the given path. Returns :ok or {:error, reason} .","ref":"File.html#write_stat/3","source_doc":"Writes the given `File.Stat` back to the file system at the given\npath. Returns `:ok` or `{:error, reason}`.\n","title":"File.write_stat/3","type":"function"},{"doc":"Same as write_stat/3 but raises a File.Error exception if it fails. Returns :ok otherwise.","ref":"File.html#write_stat!/3","source_doc":"Same as `write_stat/3` but raises a `File.Error` exception if it fails.\nReturns `:ok` otherwise.\n","title":"File.write_stat!/3","type":"function"},{"doc":"","ref":"File.html#t:encoding_mode/0","source_doc":false,"title":"File.encoding_mode/0","type":"type"},{"doc":"","ref":"File.html#t:erlang_time/0","source_doc":false,"title":"File.erlang_time/0","type":"type"},{"doc":"","ref":"File.html#t:io_device/0","source_doc":false,"title":"File.io_device/0","type":"type"},{"doc":"","ref":"File.html#t:mode/0","source_doc":false,"title":"File.mode/0","type":"type"},{"doc":"","ref":"File.html#t:on_conflict_callback/0","source_doc":false,"title":"File.on_conflict_callback/0","type":"type"},{"doc":"","ref":"File.html#t:posix/0","source_doc":false,"title":"File.posix/0","type":"type"},{"doc":"","ref":"File.html#t:posix_time/0","source_doc":false,"title":"File.posix_time/0","type":"type"},{"doc":"","ref":"File.html#t:stat_options/0","source_doc":false,"title":"File.stat_options/0","type":"type"},{"doc":"","ref":"File.html#t:stream_mode/0","source_doc":false,"title":"File.stream_mode/0","type":"type"},{"doc":"A struct that holds file information. In Erlang, this struct is represented by a :file_info record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct. Its fields are: size - size of file in bytes. type - :device | :directory | :regular | :other | :symlink ; the type of the file. access - :read | :write | :read_write | :none ; the current system access to the file. atime - the last time the file was read. mtime - the last time the file was written. ctime - the interpretation of this time field depends on the operating system. On Unix-like operating systems, it is the last time the file or the inode was changed. In Windows, it is the time of creation. mode - the file permissions. links - the number of links to this file. This is always 1 for file systems which have no concept of links. major_device - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on. minor_device - only valid for character devices on Unix-like systems. In all other cases, this field is zero. inode - gives the inode number. On non-Unix-like file systems, this field will be zero. uid - indicates the owner of the file. Will be zero for non-Unix-like file systems. gid - indicates the group that owns the file. Will be zero for non-Unix-like file systems. The time type returned in atime , mtime , and ctime is dependent on the time type set in options. {:time, type} where type can be :local , :universal , or :posix . Default is :universal .","ref":"File.Stat.html","source_doc":"A struct that holds file information.\n\nIn Erlang, this struct is represented by a `:file_info` record.\nTherefore this module also provides functions for converting\nbetween the Erlang record and the Elixir struct.\n\nIts fields are:\n\n  * `size` - size of file in bytes.\n\n  * `type` - `:device | :directory | :regular | :other | :symlink`; the type of the\n    file.\n\n  * `access` - `:read | :write | :read_write | :none`; the current system\n    access to the file.\n\n  * `atime` - the last time the file was read.\n\n  * `mtime` - the last time the file was written.\n\n  * `ctime` - the interpretation of this time field depends on the operating\n    system. On Unix-like operating systems, it is the last time the file or the inode was changed.\n    In Windows, it is the time of creation.\n\n  * `mode` - the file permissions.\n\n  * `links` - the number of links to this file. This is always 1 for file\n    systems which have no concept of links.\n\n  * `major_device` - identifies the file system where the file is located.\n    In Windows, the number indicates a drive as follows: 0 means A:, 1 means\n    B:, and so on.\n\n  * `minor_device` - only valid for character devices on Unix-like systems. In all other\n    cases, this field is zero.\n\n  * `inode` - gives the inode number. On non-Unix-like file systems, this field\n    will be zero.\n\n  * `uid` - indicates the owner of the file. Will be zero for non-Unix-like file\n    systems.\n\n  * `gid` - indicates the group that owns the file. Will be zero for\n    non-Unix-like file systems.\n\nThe time type returned in `atime`, `mtime`, and `ctime` is dependent on the\ntime type set in options. `{:time, type}` where type can be `:local`,\n`:universal`, or `:posix`. Default is `:universal`.\n","title":"File.Stat","type":"module"},{"doc":"Converts a :file_info record into a File.Stat .","ref":"File.Stat.html#from_record/1","source_doc":"Converts a `:file_info` record into a `File.Stat`.\n","title":"File.Stat.from_record/1","type":"function"},{"doc":"Converts a File.Stat struct to a :file_info record.","ref":"File.Stat.html#to_record/1","source_doc":"Converts a `File.Stat` struct to a `:file_info` record.\n","title":"File.Stat.to_record/1","type":"function"},{"doc":"","ref":"File.Stat.html#t:t/0","source_doc":false,"title":"File.Stat.t/0","type":"type"},{"doc":"Defines a File.Stream struct returned by File.stream!/3 . The following fields are public: path - the file path modes - the file modes raw - a boolean indicating if bin functions should be used line_or_bytes - if reading should read lines or a given number of bytes","ref":"File.Stream.html","source_doc":"Defines a `File.Stream` struct returned by `File.stream!/3`.\n\nThe following fields are public:\n\n  * `path`          - the file path\n  * `modes`         - the file modes\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes\n\n","title":"File.Stream","type":"module"},{"doc":"","ref":"File.Stream.html#t:t/0","source_doc":false,"title":"File.Stream.t/0","type":"type"},{"doc":"Functions handling input/output (IO). Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides :stdio and :stderr as shortcuts to Erlang's :standard_io and :standard_error . The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the String.Chars protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below. IO devices An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts: :stdio - a shortcut for :standard_io , which maps to the current Process.group_leader/0 in Erlang :stderr - a shortcut for the named process :standard_error provided in Erlang IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the :file.position/2 function. IO data IO data is a data type that can be used as a more efficient alternative to binaries in certain situations. A term of type IO data is a binary or a list containing bytes (integers within the 0..255 range) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary &quot;hello&quot; : [ ?h , &quot;el&quot; , [ &quot;l&quot; , [ ?o ] ] ] The built-in iodata/0 type is defined in terms of iolist/0 . An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself). Use cases for IO data IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary. def email ( username , domain ) do username &lt;&gt; &quot;@&quot; &lt;&gt; domain end In this function, creating the email address will copy the username and domain binaries. Now imagine you want to use the resulting email inside another binary: def welcome_message ( name , username , domain ) do &quot;Welcome \#{ name } , your email is: \#{ email ( username , domain ) } &quot; end IO . puts ( welcome_message ( &quot;Meg&quot; , &quot;meg&quot; , &quot;example.com&quot; ) ) #=&gt; &quot;Welcome Meg, your email is: meg@example.com&quot; Every time you concatenate binaries or use interpolation ( \#{} ) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data: def email ( username , domain ) do [ username , ?@ , domain ] end def welcome_message ( name , username , domain ) do [ &quot;Welcome &quot; , name , &quot;, your email is: &quot; , email ( username , domain ) ] end IO . puts ( welcome_message ( &quot;Meg&quot; , &quot;meg&quot; , &quot;example.com&quot; ) ) #=&gt; &quot;Welcome Meg, your email is: meg@example.com&quot; Building IO data is cheaper than concatenating binaries. Concatenating multiple pieces of IO data just means putting them together inside a list since IO data can be arbitrarily nested, and that's a cheap and efficient operation. Most of the IO-based APIs, such as :gen_tcp and IO , receive IO data and write it to the socket directly without converting it to binary. One drawback of IO data is that you can't do things like pattern match on the first part of a piece of IO data like you can with a binary, because you usually don't know the shape of the IO data. In those cases, you may need to convert it to a binary by calling iodata_to_binary/1 , which is reasonably efficient since it's implemented natively in C. Other functionality, like computing the length of IO data, can be computed directly on the iodata by calling iodata_length/1 . Chardata Erlang and Elixir also have the idea of chardata/0 . Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode code points. Bytes ( byte/0 ) are integers within the 0..255 range, while Unicode code points ( char/0 ) are integers within the 0..0x10FFFF range. The IO module provides the chardata_to_string/1 function for chardata as the &quot;counter-part&quot; of the iodata_to_binary/1 function for IO data. If you try to use iodata_to_binary/1 on chardata, it will result in an argument error. For example, let's try to put a code point that is not representable with one byte, like ?π , inside IO data: IO . iodata_to_binary ( [ &quot;The symbol for pi is: &quot; , ?π ] ) #=&gt; ** (ArgumentError) argument error If we use chardata instead, it will work as expected: iex&gt; IO . chardata_to_string ( [ &quot;The symbol for pi is: &quot; , ?π ] ) &quot;The symbol for pi is: π&quot;","ref":"IO.html","source_doc":"Functions handling input/output (IO).\n\nMany functions in this module expect an IO device as an argument.\nAn IO device must be a PID or an atom representing a process.\nFor convenience, Elixir provides `:stdio` and `:stderr` as\nshortcuts to Erlang's `:standard_io` and `:standard_error`.\n\nThe majority of the functions expect chardata. In case another type is given,\nfunctions will convert those types to string via the `String.Chars` protocol\n(as shown in typespecs). For more information on chardata, see the\n\"IO data\" section below.\n\n## IO devices\n\nAn IO device may be an atom or a PID. In case it is an atom,\nthe atom must be the name of a registered process. In addition,\nElixir provides two shortcuts:\n\n  * `:stdio` - a shortcut for `:standard_io`, which maps to\n    the current `Process.group_leader/0` in Erlang\n\n  * `:stderr` - a shortcut for the named process `:standard_error`\n    provided in Erlang\n\nIO devices maintain their position, which means subsequent calls to any\nreading or writing functions will start from the place where the device\nwas last accessed. The position of files can be changed using the\n`:file.position/2` function.\n\n## IO data\n\nIO data is a data type that can be used as a more efficient alternative to binaries\nin certain situations.\n\nA term of type **IO data** is a binary or a list containing bytes (integers within the `0..255` range)\nor nested IO data. The type is recursive. Let's see an example of one of\nthe possible IO data representing the binary `\"hello\"`:\n\n    [?h, \"el\", [\"l\", [?o]]]\n\nThe built-in `t:iodata/0` type is defined in terms of `t:iolist/0`. An IO list is\nthe same as IO data but it doesn't allow for a binary at the top level (but binaries\nare still allowed in the list itself).\n\n### Use cases for IO data\n\nIO data exists because often you need to do many append operations\non smaller chunks of binaries in order to create a bigger binary. However, in\nErlang and Elixir concatenating binaries will copy the concatenated binaries\ninto a new binary.\n\n    def email(username, domain) do\n      username <> \"@\" <> domain\n    end\n\nIn this function, creating the email address will copy the `username` and `domain`\nbinaries. Now imagine you want to use the resulting email inside another binary:\n\n    def welcome_message(name, username, domain) do\n      \"Welcome \#{name}, your email is: \#{email(username, domain)}\"\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nEvery time you concatenate binaries or use interpolation (`\#{}`) you are making\ncopies of those binaries. However, in many cases you don't need the complete\nbinary while you create it, but only at the end to print it out or send it\nsomewhere. In such cases, you can construct the binary by creating IO data:\n\n    def email(username, domain) do\n      [username, ?@, domain]\n    end\n\n    def welcome_message(name, username, domain) do\n      [\"Welcome \", name, \", your email is: \", email(username, domain)]\n    end\n\n    IO.puts(welcome_message(\"Meg\", \"meg\", \"example.com\"))\n    #=> \"Welcome Meg, your email is: meg@example.com\"\n\nBuilding IO data is cheaper than concatenating binaries. Concatenating multiple\npieces of IO data just means putting them together inside a list since IO data\ncan be arbitrarily nested, and that's a cheap and efficient operation. Most of\nthe IO-based APIs, such as `:gen_tcp` and `IO`, receive IO data and write it\nto the socket directly without converting it to binary.\n\nOne drawback of IO data is that you can't do things like pattern match on the\nfirst part of a piece of IO data like you can with a binary, because you usually\ndon't know the shape of the IO data. In those cases, you may need to convert it\nto a binary by calling `iodata_to_binary/1`, which is reasonably efficient\nsince it's implemented natively in C. Other functionality, like computing the\nlength of IO data, can be computed directly on the iodata by calling `iodata_length/1`.\n\n### Chardata\n\nErlang and Elixir also have the idea of `t:chardata/0`. Chardata is very\nsimilar to IO data: the only difference is that integers in IO data represent\nbytes while integers in chardata represent Unicode code points. Bytes\n(`t:byte/0`) are integers within the `0..255` range, while Unicode code points\n(`t:char/0`) are integers within the `0..0x10FFFF` range. The `IO` module provides\nthe `chardata_to_string/1` function for chardata as the \"counter-part\" of the\n`iodata_to_binary/1` function for IO data.\n\nIf you try to use `iodata_to_binary/1` on chardata, it will result in an\nargument error. For example, let's try to put a code point that is not\nrepresentable with one byte, like `?π`, inside IO data:\n\n    IO.iodata_to_binary([\"The symbol for pi is: \", ?π])\n    #=> ** (ArgumentError) argument error\n\nIf we use chardata instead, it will work as expected:\n\n    iex> IO.chardata_to_string([\"The symbol for pi is: \", ?π])\n    \"The symbol for pi is: π\"\n\n","title":"IO","type":"module"},{"doc":"Reads from the IO device . The operation is Unicode unsafe. The device is iterated as specified by the line_or_chars argument: if line_or_chars is an integer, it represents a number of bytes. The device is iterated by that number of bytes. if line_or_chars is :line , the device is iterated line by line. if line_or_chars is :eof , the device is iterated until :eof . line_or_chars can only be :eof since Elixir 1.13.0. :eof replaces the deprecated :all , with the difference that :all returns &quot;&quot; on end of file, while :eof returns :eof itself. It returns: data - the output bytes :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.","ref":"IO.html#binread/2","source_doc":"Reads from the IO `device`. The operation is Unicode unsafe.\n\nThe `device` is iterated as specified by the `line_or_chars` argument:\n\n  * if `line_or_chars` is an integer, it represents a number of bytes. The device is\n    iterated by that number of bytes.\n\n  * if `line_or_chars` is `:line`, the device is iterated line by line.\n\n  * if `line_or_chars` is `:eof`, the device is iterated until `:eof`. `line_or_chars`\n    can only be `:eof` since Elixir 1.13.0. `:eof` replaces the deprecated `:all`,\n    with the difference that `:all` returns `\"\"` on end of file, while `:eof` returns\n    `:eof` itself.\n\nIt returns:\n\n  * `data` - the output bytes\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\nNote: do not use this function on IO devices in Unicode mode\nas it will return the wrong result.\n","title":"IO.binread/2","type":"function"},{"doc":"Returns a raw, line-based IO.Stream on :stdio . The operation is Unicode unsafe. This is equivalent to: IO . binstream ( :stdio , :line )","ref":"IO.html#binstream/0","source_doc":"Returns a raw, line-based `IO.Stream` on `:stdio`. The operation is Unicode unsafe.\n\nThis is equivalent to:\n\n    IO.binstream(:stdio, :line)\n\n","title":"IO.binstream/0","type":"function"},{"doc":"Converts the IO device into an IO.Stream . The operation is Unicode unsafe. An IO.Stream implements both Enumerable and Collectable , allowing it to be used for both read and write. The device is iterated by the given number of bytes or line by line if :line is given. This reads from the IO device as a raw binary. Note that an IO stream has side effects and every time you go over the stream you may get different results. Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result. binstream/0 has been introduced in Elixir v1.12.0, while binstream/2 has been available since v1.0.0.","ref":"IO.html#binstream/2","source_doc":"Converts the IO `device` into an `IO.Stream`. The operation is Unicode unsafe.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of bytes or line by line if\n`:line` is given. This reads from the IO device as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\nFinally, do not use this function on IO devices in Unicode\nmode as it will return the wrong result.\n\n`binstream/0` has been introduced in Elixir v1.12.0,\nwhile `binstream/2` has been available since v1.0.0.\n","title":"IO.binstream/2","type":"function"},{"doc":"Writes iodata to the given device . This operation is meant to be used with &quot;raw&quot; devices that are started without an encoding. The given iodata is written as is to the device, without conversion. For more information on IO data, see the &quot;IO data&quot; section in the module documentation. Use write/2 for devices with encoding. Important: do not use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.","ref":"IO.html#binwrite/2","source_doc":"Writes `iodata` to the given `device`.\n\nThis operation is meant to be used with \"raw\" devices\nthat are started without an encoding. The given `iodata`\nis written as is to the device, without conversion. For\nmore information on IO data, see the \"IO data\" section in\nthe module documentation.\n\nUse `write/2` for devices with encoding.\n\nImportant: do **not** use this function on IO devices in\nUnicode mode as it will write the wrong data. In particular,\nthe standard IO device is set to Unicode by default, so writing\nto stdio with this function will likely result in the wrong data\nbeing sent down the wire.\n","title":"IO.binwrite/2","type":"function"},{"doc":"Converts chardata into a string. For more information about chardata, see the &quot;Chardata&quot; section in the module documentation. In case the conversion fails, it raises an UnicodeConversionError . If a string is given, it returns the string itself. Examples iex&gt; IO . chardata_to_string ( [ 0x00E6 , 0x00DF ] ) &quot;æß&quot; iex&gt; IO . chardata_to_string ( [ 0x0061 , &quot;bc&quot; ] ) &quot;abc&quot; iex&gt; IO . chardata_to_string ( &quot;string&quot; ) &quot;string&quot;","ref":"IO.html#chardata_to_string/1","source_doc":"Converts chardata into a string.\n\nFor more information about chardata, see the [\"Chardata\"](#module-chardata)\nsection in the module documentation.\n\nIn case the conversion fails, it raises an `UnicodeConversionError`.\nIf a string is given, it returns the string itself.\n\n## Examples\n\n    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n    \"æß\"\n\n    iex> IO.chardata_to_string([0x0061, \"bc\"])\n    \"abc\"\n\n    iex> IO.chardata_to_string(\"string\")\n    \"string\"\n\n","title":"IO.chardata_to_string/1","type":"function"},{"doc":"Gets a number of bytes from IO device :stdio . If :stdio is a Unicode device, count implies the number of Unicode code points to be retrieved. Otherwise, count is the number of raw bytes to be retrieved. See IO.getn/3 for a description of return values.","ref":"IO.html#getn/2","source_doc":"Gets a number of bytes from IO device `:stdio`.\n\nIf `:stdio` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nSee `IO.getn/3` for a description of return values.\n","title":"IO.getn/2","type":"function"},{"doc":"Gets a number of bytes from the IO device . If the IO device is a Unicode device, count implies the number of Unicode code points to be retrieved. Otherwise, count is the number of raw bytes to be retrieved. It returns: data - the input characters :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume","ref":"IO.html#getn/3","source_doc":"Gets a number of bytes from the IO `device`.\n\nIf the IO `device` is a Unicode device, `count` implies\nthe number of Unicode code points to be retrieved.\nOtherwise, `count` is the number of raw bytes to be retrieved.\n\nIt returns:\n\n  * `data` - the input characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n","title":"IO.getn/3","type":"function"},{"doc":"Reads a line from the IO device . It returns: data - the characters in the line terminated by a line-feed (LF) or end of file (EOF) :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume Examples To display &quot;What is your name?&quot; as a prompt and await user input: IO . gets ( &quot;What is your name? \\n &quot; )","ref":"IO.html#gets/2","source_doc":"Reads a line from the IO `device`.\n\nIt returns:\n\n  * `data` - the characters in the line terminated\n    by a line-feed (LF) or end of file (EOF)\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n## Examples\n\nTo display \"What is your name?\" as a prompt and await user input:\n\n    IO.gets(\"What is your name?\\n\")\n\n","title":"IO.gets/2","type":"function"},{"doc":"Inspects and writes the given item to the device. It's important to note that it returns the given item unchanged. This makes it possible to &quot;spy&quot; on values by inserting an IO.inspect/2 call almost anywhere in your code, for example, in the middle of a pipeline. It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the :width option. The output can be decorated with a label, by providing the :label option to easily distinguish it from other IO.inspect/2 calls. The label will be printed before the inspected item . See Inspect.Opts for a full list of remaining formatting options. Examples IO . inspect ( &lt;&lt; 0 , 1 , 2 &gt;&gt; , width : 40 ) Prints: &lt;&lt; 0 , 1 , 2 &gt;&gt; We can use the :label option to decorate the output: IO . inspect ( 1 .. 100 , label : &quot;a wonderful range&quot; ) Prints: a wonderful range : 1 .. 100 The :label option is especially useful with pipelines: [ 1 , 2 , 3 ] |&gt; IO . inspect ( label : &quot;before&quot; ) |&gt; Enum . map ( &amp; ( &amp;1 * 2 ) ) |&gt; IO . inspect ( label : &quot;after&quot; ) |&gt; Enum . sum ( ) Prints: before : [ 1 , 2 , 3 ] after : [ 2 , 4 , 6 ]","ref":"IO.html#inspect/2","source_doc":"Inspects and writes the given `item` to the device.\n\nIt's important to note that it returns the given `item` unchanged.\nThis makes it possible to \"spy\" on values by inserting an\n`IO.inspect/2` call almost anywhere in your code, for example,\nin the middle of a pipeline.\n\nIt enables pretty printing by default with width of\n80 characters. The width can be changed by explicitly\npassing the `:width` option.\n\nThe output can be decorated with a label, by providing the `:label`\noption to easily distinguish it from other `IO.inspect/2` calls.\nThe label will be printed before the inspected `item`.\n\nSee `Inspect.Opts` for a full list of remaining formatting options.\n\n## Examples\n\n    IO.inspect(<<0, 1, 2>>, width: 40)\n\nPrints:\n\n    <<0, 1, 2>>\n\nWe can use the `:label` option to decorate the output:\n\n    IO.inspect(1..100, label: \"a wonderful range\")\n\nPrints:\n\n    a wonderful range: 1..100\n\nThe `:label` option is especially useful with pipelines:\n\n    [1, 2, 3]\n    |> IO.inspect(label: \"before\")\n    |> Enum.map(&(&1 * 2))\n    |> IO.inspect(label: \"after\")\n    |> Enum.sum()\n\nPrints:\n\n    before: [1, 2, 3]\n    after: [2, 4, 6]\n\n","title":"IO.inspect/2","type":"function"},{"doc":"Inspects item according to the given options using the IO device . See inspect/2 for a full list of options.","ref":"IO.html#inspect/3","source_doc":"Inspects `item` according to the given options using the IO `device`.\n\nSee `inspect/2` for a full list of options.\n","title":"IO.inspect/3","type":"function"},{"doc":"Returns the size of an IO data. For more information about IO data, see the &quot;IO data&quot; section in the module documentation. Inlined by the compiler. Examples iex&gt; IO . iodata_length ( [ 1 , 2 | &lt;&lt; 3 , 4 &gt;&gt; ] ) 4","ref":"IO.html#iodata_length/1","source_doc":"Returns the size of an IO data.\n\nFor more information about IO data, see the [\"IO data\"](#module-io-data)\nsection in the module documentation.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n    4\n\n","title":"IO.iodata_length/1","type":"function"},{"doc":"Converts IO data into a binary The operation is Unicode unsafe. Note that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use chardata_to_string/1 instead. For more information about IO data and chardata, see the &quot;IO data&quot; section in the module documentation. If this function receives a binary, the same binary is returned. Inlined by the compiler. Examples iex&gt; bin1 = &lt;&lt; 1 , 2 , 3 &gt;&gt; iex&gt; bin2 = &lt;&lt; 4 , 5 &gt;&gt; iex&gt; bin3 = &lt;&lt; 6 &gt;&gt; iex&gt; IO . iodata_to_binary ( [ bin1 , 1 , [ 2 , 3 , bin2 ] , 4 | bin3 ] ) &lt;&lt; 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 4 , 6 &gt;&gt; iex&gt; bin = &lt;&lt; 1 , 2 , 3 &gt;&gt; iex&gt; IO . iodata_to_binary ( bin ) &lt;&lt; 1 , 2 , 3 &gt;&gt;","ref":"IO.html#iodata_to_binary/1","source_doc":"Converts IO data into a binary\n\nThe operation is Unicode unsafe.\n\nNote that this function treats integers in the given IO data as\nraw bytes and does not perform any kind of encoding conversion.\nIf you want to convert from a charlist to a UTF-8-encoded string,\nuse `chardata_to_string/1` instead. For more information about\nIO data and chardata, see the [\"IO data\"](#module-io-data) section in the\nmodule documentation.\n\nIf this function receives a binary, the same binary is returned.\n\nInlined by the compiler.\n\n## Examples\n\n    iex> bin1 = <<1, 2, 3>>\n    iex> bin2 = <<4, 5>>\n    iex> bin3 = <<6>>\n    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n\n    iex> bin = <<1, 2, 3>>\n    iex> IO.iodata_to_binary(bin)\n    <<1, 2, 3>>\n\n","title":"IO.iodata_to_binary/1","type":"function"},{"doc":"Writes item to the given device , similar to write/2 , but adds a newline at the end. By default, the device is the standard output. It returns :ok if it succeeds. Examples IO . puts ( &quot;Hello World!&quot; ) #=&gt; Hello World! IO . puts ( :stderr , &quot;error&quot; ) #=&gt; error","ref":"IO.html#puts/2","source_doc":"Writes `item` to the given `device`, similar to `write/2`,\nbut adds a newline at the end.\n\nBy default, the `device` is the standard output. It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    IO.puts(\"Hello World!\")\n    #=> Hello World!\n\n    IO.puts(:stderr, \"error\")\n    #=> error\n\n","title":"IO.puts/2","type":"function"},{"doc":"Reads from the IO device . The device is iterated by the given number of characters, line by line if :line is given, or until :eof . It returns: data - the output characters :eof - end of file was encountered {:error, reason} - other (rare) error condition; for instance, {:error, :estale} if reading from an NFS volume","ref":"IO.html#read/2","source_doc":"Reads from the IO `device`.\n\nThe `device` is iterated by the given number of characters, line by line if\n`:line` is given, or until `:eof`.\n\nIt returns:\n\n  * `data` - the output characters\n\n  * `:eof` - end of file was encountered\n\n  * `{:error, reason}` - other (rare) error condition;\n    for instance, `{:error, :estale}` if reading from an\n    NFS volume\n\n","title":"IO.read/2","type":"function"},{"doc":"Returns a line-based IO.Stream on :stdio . This is equivalent to: IO . stream ( :stdio , :line )","ref":"IO.html#stream/0","source_doc":"Returns a line-based `IO.Stream` on `:stdio`.\n\nThis is equivalent to:\n\n    IO.stream(:stdio, :line)\n\n","title":"IO.stream/0","type":"function"},{"doc":"Converts the IO device into an IO.Stream . An IO.Stream implements both Enumerable and Collectable , allowing it to be used for both read and write. The device is iterated by the given number of characters or line by line if :line is given. This reads from the IO as UTF-8. Check out IO.binstream/2 to handle the IO as a raw binary. Note that an IO stream has side effects and every time you go over the stream you may get different results. stream/0 has been introduced in Elixir v1.12.0, while stream/2 has been available since v1.0.0. Examples Here is an example on how we mimic an echo server from the command line: Enum . each ( IO . stream ( :stdio , :line ) , &amp; IO . write ( &amp;1 ) ) Another example where you might want to collect a user input every new line and break on an empty line, followed by removing redundant new line characters ( &quot; &quot; ): IO . stream ( :stdio , :line ) |&gt; Enum . take_while ( &amp; ( &amp;1 != &quot; &quot;)) |&gt; Enum . map ( &amp; String . replace ( &amp;1 , &quot; &quot;, &quot;&quot;))","ref":"IO.html#stream/2","source_doc":"Converts the IO `device` into an `IO.Stream`.\n\nAn `IO.Stream` implements both `Enumerable` and\n`Collectable`, allowing it to be used for both read\nand write.\n\nThe `device` is iterated by the given number of characters or line by line if\n`:line` is given.\n\nThis reads from the IO as UTF-8. Check out\n`IO.binstream/2` to handle the IO as a raw binary.\n\nNote that an IO stream has side effects and every time\nyou go over the stream you may get different results.\n\n`stream/0` has been introduced in Elixir v1.12.0,\nwhile `stream/2` has been available since v1.0.0.\n\n## Examples\n\nHere is an example on how we mimic an echo server\nfrom the command line:\n\n    Enum.each(IO.stream(:stdio, :line), &IO.write(&1))\n\nAnother example where you might want to collect a user input\nevery new line and break on an empty line, followed by removing\nredundant new line characters (`\"\n\"`):\n\n    IO.stream(:stdio, :line)\n    |> Enum.take_while(&(&1 != \"\n\"))\n    |> Enum.map(&String.replace(&1, \"\n\", \"\"))\n\n","title":"IO.stream/2","type":"function"},{"doc":"Writes a message to stderr, along with the current stacktrace. It returns :ok if it succeeds. Do not call this function at the tail of another function. Due to tail call optimization, a stacktrace entry would not be added and the stacktrace would be incorrectly trimmed. Therefore make sure at least one expression (or an atom such as :ok ) follows the IO.warn/1 call. Examples IO . warn ( &quot;variable bar is unused&quot; ) #=&gt; warning: variable bar is unused #=&gt; (iex) evaluator.ex:108: IEx.Evaluator.eval/4","ref":"IO.html#warn/1","source_doc":"Writes a `message` to stderr, along with the current stacktrace.\n\nIt returns `:ok` if it succeeds.\n\nDo not call this function at the tail of another function. Due to tail\ncall optimization, a stacktrace entry would not be added and the\nstacktrace would be incorrectly trimmed. Therefore make sure at least\none expression (or an atom such as `:ok`) follows the `IO.warn/1` call.\n\n## Examples\n\n    IO.warn(\"variable bar is unused\")\n    #=> warning: variable bar is unused\n    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4\n\n","title":"IO.warn/1","type":"function"},{"doc":"Writes a message to stderr, along with the given stacktrace_info . The stacktrace_info must be one of: a __STACKTRACE__ , where all entries in the stacktrace will be included in the error message a Macro.Env structure (since v1.14.0), where a single stacktrace entry from the compilation environment will be used a keyword list with at least the :file option representing a single stacktrace entry (since v1.14.0). The :line , :module , :function options are also supported This function also notifies the compiler a warning was printed (in case --warnings-as-errors was enabled). It returns :ok if it succeeds. Examples stacktrace = [ { MyApp , :main , 1 , [ file : &#39;my_app.ex&#39; , line : 4 ] } ] IO . warn ( &quot;variable bar is unused&quot; , stacktrace ) #=&gt; warning: variable bar is unused #=&gt; my_app.ex:4: MyApp.main/1","ref":"IO.html#warn/2","source_doc":"Writes a `message` to stderr, along with the given `stacktrace_info`.\n\nThe `stacktrace_info` must be one of:\n\n  * a `__STACKTRACE__`, where all entries in the stacktrace will be\n    included in the error message\n\n  * a `Macro.Env` structure (since v1.14.0), where a single stacktrace\n    entry from the compilation environment will be used\n\n  * a keyword list with at least the `:file` option representing\n    a single stacktrace entry (since v1.14.0). The `:line`, `:module`,\n    `:function` options are also supported\n\nThis function also notifies the compiler a warning was printed\n(in case --warnings-as-errors was enabled). It returns `:ok`\nif it succeeds.\n\n## Examples\n\n    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n    IO.warn(\"variable bar is unused\", stacktrace)\n    #=> warning: variable bar is unused\n    #=>   my_app.ex:4: MyApp.main/1\n\n","title":"IO.warn/2","type":"function"},{"doc":"Writes chardata to the given device . By default, the device is the standard output. Examples IO . write ( &quot;sample&quot; ) #=&gt; sample IO . write ( :stderr , &quot;error&quot; ) #=&gt; error","ref":"IO.html#write/2","source_doc":"Writes `chardata` to the given `device`.\n\nBy default, the `device` is the standard output.\n\n## Examples\n\n    IO.write(\"sample\")\n    #=> sample\n\n    IO.write(:stderr, \"error\")\n    #=> error\n\n","title":"IO.write/2","type":"function"},{"doc":"","ref":"IO.html#t:chardata/0","source_doc":false,"title":"IO.chardata/0","type":"type"},{"doc":"","ref":"IO.html#t:device/0","source_doc":false,"title":"IO.device/0","type":"type"},{"doc":"","ref":"IO.html#t:nodata/0","source_doc":false,"title":"IO.nodata/0","type":"type"},{"doc":"Functionality to render ANSI escape sequences. ANSI escape sequences are characters embedded in text used to control formatting, color, and other output options on video text terminals. ANSI escapes are typically enabled on all Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command: reg add HKCU \\ Console / v VirtualTerminalLevel / t REG_DWORD / d 1 After running the command above, you must restart your current console. Examples Because the ANSI escape sequences are embedded in text, the normal usage of these functions is to concatenate their output with text. formatted_text = IO.ANSI . blue_background ( ) &lt;&gt; &quot;Example&quot; &lt;&gt; IO.ANSI . reset ( ) IO . puts ( formatted_text ) A higher level and more convenient API is also available via IO.ANSI.format/1 , where you use atoms to represent each ANSI escape sequence and by default checks if ANSI is enabled: IO . puts ( IO.ANSI . format ( [ :blue_background , &quot;Example&quot; ] ) ) In case ANSI is disabled, the ANSI escape sequences are simply discarded.","ref":"IO.ANSI.html","source_doc":"Functionality to render ANSI escape sequences.\n\n[ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)\nare characters embedded in text used to control formatting, color, and\nother output options on video text terminals.\n\nANSI escapes are typically enabled on all Unix terminals. They are also\navailable on Windows consoles from Windows 10, although it must be\nexplicitly enabled for the current user in the registry by running the\nfollowing command:\n\n    reg add HKCU\\Console /v VirtualTerminalLevel /t REG_DWORD /d 1\n\nAfter running the command above, you must restart your current console.\n\n## Examples\n\nBecause the ANSI escape sequences are embedded in text, the normal usage of\nthese functions is to concatenate their output with text.\n\n    formatted_text = IO.ANSI.blue_background() <> \"Example\" <> IO.ANSI.reset()\n    IO.puts(formatted_text)\n\nA higher level and more convenient API is also available via `IO.ANSI.format/1`,\nwhere you use atoms to represent each ANSI escape sequence and by default\nchecks if ANSI is enabled:\n\n    IO.puts(IO.ANSI.format([:blue_background, \"Example\"]))\n\nIn case ANSI is disabled, the ANSI escape sequences are simply discarded.\n","title":"IO.ANSI","type":"module"},{"doc":"Sets foreground color to black.","ref":"IO.ANSI.html#black/0","source_doc":"Sets foreground color to black.","title":"IO.ANSI.black/0","type":"function"},{"doc":"Sets background color to black.","ref":"IO.ANSI.html#black_background/0","source_doc":"Sets background color to black.","title":"IO.ANSI.black_background/0","type":"function"},{"doc":"Blink: off.","ref":"IO.ANSI.html#blink_off/0","source_doc":"Blink: off.","title":"IO.ANSI.blink_off/0","type":"function"},{"doc":"Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported.","ref":"IO.ANSI.html#blink_rapid/0","source_doc":"Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported.","title":"IO.ANSI.blink_rapid/0","type":"function"},{"doc":"Blink: slow. Less than 150 per minute.","ref":"IO.ANSI.html#blink_slow/0","source_doc":"Blink: slow. Less than 150 per minute.","title":"IO.ANSI.blink_slow/0","type":"function"},{"doc":"Sets foreground color to blue.","ref":"IO.ANSI.html#blue/0","source_doc":"Sets foreground color to blue.","title":"IO.ANSI.blue/0","type":"function"},{"doc":"Sets background color to blue.","ref":"IO.ANSI.html#blue_background/0","source_doc":"Sets background color to blue.","title":"IO.ANSI.blue_background/0","type":"function"},{"doc":"Bright (increased intensity) or bold.","ref":"IO.ANSI.html#bright/0","source_doc":"Bright (increased intensity) or bold.","title":"IO.ANSI.bright/0","type":"function"},{"doc":"Clears screen.","ref":"IO.ANSI.html#clear/0","source_doc":"Clears screen.","title":"IO.ANSI.clear/0","type":"function"},{"doc":"Clears line.","ref":"IO.ANSI.html#clear_line/0","source_doc":"Clears line.","title":"IO.ANSI.clear_line/0","type":"function"},{"doc":"Sets foreground color.","ref":"IO.ANSI.html#color/1","source_doc":"Sets foreground color.","title":"IO.ANSI.color/1","type":"function"},{"doc":"Sets the foreground color from individual RGB values. Valid values for each color are in the range 0 to 5.","ref":"IO.ANSI.html#color/3","source_doc":"Sets the foreground color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.\n","title":"IO.ANSI.color/3","type":"function"},{"doc":"Sets background color.","ref":"IO.ANSI.html#color_background/1","source_doc":"Sets background color.","title":"IO.ANSI.color_background/1","type":"function"},{"doc":"Sets the background color from individual RGB values. Valid values for each color are in the range 0 to 5.","ref":"IO.ANSI.html#color_background/3","source_doc":"Sets the background color from individual RGB values.\n\nValid values for each color are in the range 0 to 5.\n","title":"IO.ANSI.color_background/3","type":"function"},{"doc":"Conceal. Not widely supported.","ref":"IO.ANSI.html#conceal/0","source_doc":"Conceal. Not widely supported.","title":"IO.ANSI.conceal/0","type":"function"},{"doc":"Crossed-out. Characters legible, but marked for deletion. Not widely supported.","ref":"IO.ANSI.html#crossed_out/0","source_doc":"Crossed-out. Characters legible, but marked for deletion. Not widely supported.","title":"IO.ANSI.crossed_out/0","type":"function"},{"doc":"Sends cursor to the absolute position specified by line and column . Line 0 and column 0 would mean the top left corner.","ref":"IO.ANSI.html#cursor/2","source_doc":"Sends cursor to the absolute position specified by `line` and `column`.\n\nLine `0` and column `0` would mean the top left corner.\n","title":"IO.ANSI.cursor/2","type":"function"},{"doc":"Sends cursor lines down.","ref":"IO.ANSI.html#cursor_down/1","source_doc":"Sends cursor `lines` down.","title":"IO.ANSI.cursor_down/1","type":"function"},{"doc":"Sends cursor columns to the left.","ref":"IO.ANSI.html#cursor_left/1","source_doc":"Sends cursor `columns` to the left.","title":"IO.ANSI.cursor_left/1","type":"function"},{"doc":"Sends cursor columns to the right.","ref":"IO.ANSI.html#cursor_right/1","source_doc":"Sends cursor `columns` to the right.","title":"IO.ANSI.cursor_right/1","type":"function"},{"doc":"Sends cursor lines up.","ref":"IO.ANSI.html#cursor_up/1","source_doc":"Sends cursor `lines` up.","title":"IO.ANSI.cursor_up/1","type":"function"},{"doc":"Sets foreground color to cyan.","ref":"IO.ANSI.html#cyan/0","source_doc":"Sets foreground color to cyan.","title":"IO.ANSI.cyan/0","type":"function"},{"doc":"Sets background color to cyan.","ref":"IO.ANSI.html#cyan_background/0","source_doc":"Sets background color to cyan.","title":"IO.ANSI.cyan_background/0","type":"function"},{"doc":"Default background color.","ref":"IO.ANSI.html#default_background/0","source_doc":"Default background color.","title":"IO.ANSI.default_background/0","type":"function"},{"doc":"Default text color.","ref":"IO.ANSI.html#default_color/0","source_doc":"Default text color.","title":"IO.ANSI.default_color/0","type":"function"},{"doc":"Checks if ANSI coloring is supported and enabled on this machine. This function simply reads the configuration value for :ansi_enabled in the :elixir application. The value is by default false unless Elixir can detect during startup that both stdout and stderr are terminals.","ref":"IO.ANSI.html#enabled?/0","source_doc":"Checks if ANSI coloring is supported and enabled on this machine.\n\nThis function simply reads the configuration value for\n`:ansi_enabled` in the `:elixir` application. The value is by\ndefault `false` unless Elixir can detect during startup that\nboth `stdout` and `stderr` are terminals.\n","title":"IO.ANSI.enabled?/0","type":"function"},{"doc":"Encircled.","ref":"IO.ANSI.html#encircled/0","source_doc":"Encircled.","title":"IO.ANSI.encircled/0","type":"function"},{"doc":"Faint (decreased intensity). Not widely supported.","ref":"IO.ANSI.html#faint/0","source_doc":"Faint (decreased intensity). Not widely supported.","title":"IO.ANSI.faint/0","type":"function"},{"doc":"Sets alternative font 1.","ref":"IO.ANSI.html#font_1/0","source_doc":"Sets alternative font 1.","title":"IO.ANSI.font_1/0","type":"function"},{"doc":"Sets alternative font 2.","ref":"IO.ANSI.html#font_2/0","source_doc":"Sets alternative font 2.","title":"IO.ANSI.font_2/0","type":"function"},{"doc":"Sets alternative font 3.","ref":"IO.ANSI.html#font_3/0","source_doc":"Sets alternative font 3.","title":"IO.ANSI.font_3/0","type":"function"},{"doc":"Sets alternative font 4.","ref":"IO.ANSI.html#font_4/0","source_doc":"Sets alternative font 4.","title":"IO.ANSI.font_4/0","type":"function"},{"doc":"Sets alternative font 5.","ref":"IO.ANSI.html#font_5/0","source_doc":"Sets alternative font 5.","title":"IO.ANSI.font_5/0","type":"function"},{"doc":"Sets alternative font 6.","ref":"IO.ANSI.html#font_6/0","source_doc":"Sets alternative font 6.","title":"IO.ANSI.font_6/0","type":"function"},{"doc":"Sets alternative font 7.","ref":"IO.ANSI.html#font_7/0","source_doc":"Sets alternative font 7.","title":"IO.ANSI.font_7/0","type":"function"},{"doc":"Sets alternative font 8.","ref":"IO.ANSI.html#font_8/0","source_doc":"Sets alternative font 8.","title":"IO.ANSI.font_8/0","type":"function"},{"doc":"Sets alternative font 9.","ref":"IO.ANSI.html#font_9/0","source_doc":"Sets alternative font 9.","title":"IO.ANSI.font_9/0","type":"function"},{"doc":"Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes. The named sequences are represented by atoms. It will also append an IO.ANSI.reset/0 to the chardata when a conversion is performed. If you don't want this behaviour, use format_fragment/2 . An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When false , no ANSI codes will be emitted. By default checks if ANSI is enabled using the enabled?/0 function. Examples iex&gt; IO.ANSI . format ( [ &quot;Hello, &quot; , :red , :bright , &quot;world!&quot; ] , true ) [ [ [ [ [ [ ] , &quot;Hello, &quot; ] | &quot; \\e [31m&quot; ] | &quot; \\e [1m&quot; ] , &quot;world!&quot; ] | &quot; \\e [0m&quot; ]","ref":"IO.ANSI.html#format/2","source_doc":"Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nIt will also append an `IO.ANSI.reset/0` to the chardata when a conversion is\nperformed. If you don't want this behaviour, use `format_fragment/2`.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]\n\n","title":"IO.ANSI.format/2","type":"function"},{"doc":"Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes. The named sequences are represented by atoms. An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When false , no ANSI codes will be emitted. By default checks if ANSI is enabled using the enabled?/0 function. Examples iex&gt; IO.ANSI . format_fragment ( [ :bright , &#39;Word&#39; ] , true ) [ [ [ [ [ [ ] | &quot; \\e [1m&quot; ] , 87 ] , 111 ] , 114 ] , 100 ]","ref":"IO.ANSI.html#format_fragment/2","source_doc":"Formats a chardata-like argument by converting named ANSI sequences into actual\nANSI codes.\n\nThe named sequences are represented by atoms.\n\nAn optional boolean parameter can be passed to enable or disable\nemitting actual ANSI codes. When `false`, no ANSI codes will be emitted.\nBy default checks if ANSI is enabled using the `enabled?/0` function.\n\n## Examples\n\n    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]\n\n","title":"IO.ANSI.format_fragment/2","type":"function"},{"doc":"Framed.","ref":"IO.ANSI.html#framed/0","source_doc":"Framed.","title":"IO.ANSI.framed/0","type":"function"},{"doc":"Sets foreground color to green.","ref":"IO.ANSI.html#green/0","source_doc":"Sets foreground color to green.","title":"IO.ANSI.green/0","type":"function"},{"doc":"Sets background color to green.","ref":"IO.ANSI.html#green_background/0","source_doc":"Sets background color to green.","title":"IO.ANSI.green_background/0","type":"function"},{"doc":"Sends cursor home.","ref":"IO.ANSI.html#home/0","source_doc":"Sends cursor home.","title":"IO.ANSI.home/0","type":"function"},{"doc":"Image: negative. Swap foreground and background.","ref":"IO.ANSI.html#inverse/0","source_doc":"Image: negative. Swap foreground and background.","title":"IO.ANSI.inverse/0","type":"function"},{"doc":"Image: positive. Normal foreground and background.","ref":"IO.ANSI.html#inverse_off/0","source_doc":"Image: positive. Normal foreground and background.","title":"IO.ANSI.inverse_off/0","type":"function"},{"doc":"Italic: on. Not widely supported. Sometimes treated as inverse.","ref":"IO.ANSI.html#italic/0","source_doc":"Italic: on. Not widely supported. Sometimes treated as inverse.","title":"IO.ANSI.italic/0","type":"function"},{"doc":"Sets foreground color to light black.","ref":"IO.ANSI.html#light_black/0","source_doc":"Sets foreground color to light black.","title":"IO.ANSI.light_black/0","type":"function"},{"doc":"Sets background color to light black.","ref":"IO.ANSI.html#light_black_background/0","source_doc":"Sets background color to light black.","title":"IO.ANSI.light_black_background/0","type":"function"},{"doc":"Sets foreground color to light blue.","ref":"IO.ANSI.html#light_blue/0","source_doc":"Sets foreground color to light blue.","title":"IO.ANSI.light_blue/0","type":"function"},{"doc":"Sets background color to light blue.","ref":"IO.ANSI.html#light_blue_background/0","source_doc":"Sets background color to light blue.","title":"IO.ANSI.light_blue_background/0","type":"function"},{"doc":"Sets foreground color to light cyan.","ref":"IO.ANSI.html#light_cyan/0","source_doc":"Sets foreground color to light cyan.","title":"IO.ANSI.light_cyan/0","type":"function"},{"doc":"Sets background color to light cyan.","ref":"IO.ANSI.html#light_cyan_background/0","source_doc":"Sets background color to light cyan.","title":"IO.ANSI.light_cyan_background/0","type":"function"},{"doc":"Sets foreground color to light green.","ref":"IO.ANSI.html#light_green/0","source_doc":"Sets foreground color to light green.","title":"IO.ANSI.light_green/0","type":"function"},{"doc":"Sets background color to light green.","ref":"IO.ANSI.html#light_green_background/0","source_doc":"Sets background color to light green.","title":"IO.ANSI.light_green_background/0","type":"function"},{"doc":"Sets foreground color to light magenta.","ref":"IO.ANSI.html#light_magenta/0","source_doc":"Sets foreground color to light magenta.","title":"IO.ANSI.light_magenta/0","type":"function"},{"doc":"Sets background color to light magenta.","ref":"IO.ANSI.html#light_magenta_background/0","source_doc":"Sets background color to light magenta.","title":"IO.ANSI.light_magenta_background/0","type":"function"},{"doc":"Sets foreground color to light red.","ref":"IO.ANSI.html#light_red/0","source_doc":"Sets foreground color to light red.","title":"IO.ANSI.light_red/0","type":"function"},{"doc":"Sets background color to light red.","ref":"IO.ANSI.html#light_red_background/0","source_doc":"Sets background color to light red.","title":"IO.ANSI.light_red_background/0","type":"function"},{"doc":"Sets foreground color to light white.","ref":"IO.ANSI.html#light_white/0","source_doc":"Sets foreground color to light white.","title":"IO.ANSI.light_white/0","type":"function"},{"doc":"Sets background color to light white.","ref":"IO.ANSI.html#light_white_background/0","source_doc":"Sets background color to light white.","title":"IO.ANSI.light_white_background/0","type":"function"},{"doc":"Sets foreground color to light yellow.","ref":"IO.ANSI.html#light_yellow/0","source_doc":"Sets foreground color to light yellow.","title":"IO.ANSI.light_yellow/0","type":"function"},{"doc":"Sets background color to light yellow.","ref":"IO.ANSI.html#light_yellow_background/0","source_doc":"Sets background color to light yellow.","title":"IO.ANSI.light_yellow_background/0","type":"function"},{"doc":"Sets foreground color to magenta.","ref":"IO.ANSI.html#magenta/0","source_doc":"Sets foreground color to magenta.","title":"IO.ANSI.magenta/0","type":"function"},{"doc":"Sets background color to magenta.","ref":"IO.ANSI.html#magenta_background/0","source_doc":"Sets background color to magenta.","title":"IO.ANSI.magenta_background/0","type":"function"},{"doc":"Underline: none.","ref":"IO.ANSI.html#no_underline/0","source_doc":"Underline: none.","title":"IO.ANSI.no_underline/0","type":"function"},{"doc":"Normal color or intensity.","ref":"IO.ANSI.html#normal/0","source_doc":"Normal color or intensity.","title":"IO.ANSI.normal/0","type":"function"},{"doc":"Not framed or encircled.","ref":"IO.ANSI.html#not_framed_encircled/0","source_doc":"Not framed or encircled.","title":"IO.ANSI.not_framed_encircled/0","type":"function"},{"doc":"Not italic.","ref":"IO.ANSI.html#not_italic/0","source_doc":"Not italic.","title":"IO.ANSI.not_italic/0","type":"function"},{"doc":"Not overlined.","ref":"IO.ANSI.html#not_overlined/0","source_doc":"Not overlined.","title":"IO.ANSI.not_overlined/0","type":"function"},{"doc":"Overlined.","ref":"IO.ANSI.html#overlined/0","source_doc":"Overlined.","title":"IO.ANSI.overlined/0","type":"function"},{"doc":"Sets primary (default) font.","ref":"IO.ANSI.html#primary_font/0","source_doc":"Sets primary (default) font.","title":"IO.ANSI.primary_font/0","type":"function"},{"doc":"Sets foreground color to red.","ref":"IO.ANSI.html#red/0","source_doc":"Sets foreground color to red.","title":"IO.ANSI.red/0","type":"function"},{"doc":"Sets background color to red.","ref":"IO.ANSI.html#red_background/0","source_doc":"Sets background color to red.","title":"IO.ANSI.red_background/0","type":"function"},{"doc":"Resets all attributes.","ref":"IO.ANSI.html#reset/0","source_doc":"Resets all attributes.","title":"IO.ANSI.reset/0","type":"function"},{"doc":"Image: negative. Swap foreground and background.","ref":"IO.ANSI.html#reverse/0","source_doc":"Image: negative. Swap foreground and background.","title":"IO.ANSI.reverse/0","type":"function"},{"doc":"Image: positive. Normal foreground and background.","ref":"IO.ANSI.html#reverse_off/0","source_doc":"Image: positive. Normal foreground and background.","title":"IO.ANSI.reverse_off/0","type":"function"},{"doc":"Syntax colors to be used by Inspect . Those colors are used throughout Elixir's standard library, such as dbg/2 and IEx . The colors can be changed by setting the :ansi_syntax_colors in the :elixir application configuration. Configuration for most built-in data types are supported: :atom , :binary , :boolean , :charlist , :list , :map , :nil , :number , :string , and :tuple . The default is: [ atom : :cyan boolean : :magenta , charlist : :yellow , nil : :magenta , number : :yellow , string : :green ]","ref":"IO.ANSI.html#syntax_colors/0","source_doc":"Syntax colors to be used by `Inspect`.\n\nThose colors are used throughout Elixir's standard library,\nsuch as `dbg/2` and `IEx`.\n\nThe colors can be changed by setting the `:ansi_syntax_colors`\nin the `:elixir` application configuration. Configuration for\nmost built-in data types are supported: `:atom`, `:binary`,\n`:boolean`, `:charlist`, `:list`, `:map`, `:nil`, `:number`,\n`:string`, and `:tuple`. The default is:\n\n    [\n      atom: :cyan\n      boolean: :magenta,\n      charlist: :yellow,\n      nil: :magenta,\n      number: :yellow,\n      string: :green\n    ]\n\n","title":"IO.ANSI.syntax_colors/0","type":"function"},{"doc":"Underline: single.","ref":"IO.ANSI.html#underline/0","source_doc":"Underline: single.","title":"IO.ANSI.underline/0","type":"function"},{"doc":"Sets foreground color to white.","ref":"IO.ANSI.html#white/0","source_doc":"Sets foreground color to white.","title":"IO.ANSI.white/0","type":"function"},{"doc":"Sets background color to white.","ref":"IO.ANSI.html#white_background/0","source_doc":"Sets background color to white.","title":"IO.ANSI.white_background/0","type":"function"},{"doc":"Sets foreground color to yellow.","ref":"IO.ANSI.html#yellow/0","source_doc":"Sets foreground color to yellow.","title":"IO.ANSI.yellow/0","type":"function"},{"doc":"Sets background color to yellow.","ref":"IO.ANSI.html#yellow_background/0","source_doc":"Sets background color to yellow.","title":"IO.ANSI.yellow_background/0","type":"function"},{"doc":"","ref":"IO.ANSI.html#t:ansicode/0","source_doc":false,"title":"IO.ANSI.ansicode/0","type":"type"},{"doc":"","ref":"IO.ANSI.html#t:ansidata/0","source_doc":false,"title":"IO.ANSI.ansidata/0","type":"type"},{"doc":"","ref":"IO.ANSI.html#t:ansilist/0","source_doc":false,"title":"IO.ANSI.ansilist/0","type":"type"},{"doc":"Defines an IO.Stream struct returned by IO.stream/2 and IO.binstream/2 . The following fields are public: device - the IO device raw - a boolean indicating if bin functions should be used line_or_bytes - if reading should read lines or a given number of bytes It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.","ref":"IO.Stream.html","source_doc":"Defines an `IO.Stream` struct returned by `IO.stream/2` and `IO.binstream/2`.\n\nThe following fields are public:\n\n  * `device`        - the IO device\n  * `raw`           - a boolean indicating if bin functions should be used\n  * `line_or_bytes` - if reading should read lines or a given number of bytes\n\nIt is worth noting that an IO stream has side effects and every time you go\nover the stream you may get different results.\n\n","title":"IO.Stream","type":"module"},{"doc":"","ref":"IO.Stream.html#t:t/0","source_doc":false,"title":"IO.Stream.t/0","type":"type"},{"doc":"Functions for parsing command line arguments. When calling a command, it's possible to pass command line options to modify what the command does. In this documentation, those are called &quot;switches&quot;, in other situations they may be called &quot;flags&quot; or simply &quot;options&quot;. A switch can be given a value, also called an &quot;argument&quot;. The main function in this module is parse/2 , which parses a list of command line options and arguments into a keyword list: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ ] , [ ] } OptionParser provides some conveniences out of the box, such as aliases and automatic handling of negation switches. The parse_head/2 function is an alternative to parse/2 which stops parsing as soon as it finds a value that is not a switch nor a value for a previous switch. This module also provides low-level functions, such as next/2 , for parsing switches manually, as well as split/1 and to_argv/1 for parsing from and converting switches to strings.","ref":"OptionParser.html","source_doc":"Functions for parsing command line arguments.\n\nWhen calling a command, it's possible to pass command line options\nto modify what the command does. In this documentation, those are\ncalled \"switches\", in other situations they may be called \"flags\"\nor simply \"options\". A switch can be given a value, also called an\n\"argument\".\n\nThe main function in this module is `parse/2`, which parses a list\nof command line options and arguments into a keyword list:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n`OptionParser` provides some conveniences out of the box,\nsuch as aliases and automatic handling of negation switches.\n\nThe `parse_head/2` function is an alternative to `parse/2`\nwhich stops parsing as soon as it finds a value that is not\na switch nor a value for a previous switch.\n\nThis module also provides low-level functions, such as `next/2`,\nfor parsing switches manually, as well as `split/1` and `to_argv/1`\nfor parsing from and converting switches to strings.\n","title":"OptionParser","type":"module"},{"doc":"Low-level function that parses one option. It accepts the same options as parse/2 and parse_head/2 as both functions are built on top of this function. This function may return: {:ok, key, value, rest} - the option key with value was successfully parsed {:invalid, key, value, rest} - the option key is invalid with value (returned when the value cannot be parsed according to the switch type) {:undefined, key, value, rest} - the option key is undefined (returned in strict mode when the switch is unknown or on nonexistent atoms) {:error, rest} - there are no switches at the head of the given argv","ref":"OptionParser.html#next/2","source_doc":"Low-level function that parses one option.\n\nIt accepts the same options as `parse/2` and `parse_head/2`\nas both functions are built on top of this function. This function\nmay return:\n\n  * `{:ok, key, value, rest}` - the option `key` with `value` was\n    successfully parsed\n\n  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n    (returned when the value cannot be parsed according to the switch type)\n\n  * `{:undefined, key, value, rest}` - the option `key` is undefined\n    (returned in strict mode when the switch is unknown or on nonexistent atoms)\n\n  * `{:error, rest}` - there are no switches at the head of the given `argv`\n\n","title":"OptionParser.next/2","type":"function"},{"doc":"Parses argv into a keyword list. It returns a three-element tuple with the form {parsed, args, invalid} , where: parsed is a keyword list of parsed switches with {switch_name, value} tuples in it; switch_name is the atom representing the switch name while value is the value for that switch parsed according to opts (see the &quot;Examples&quot; section for more information) args is a list of the remaining arguments in argv as strings invalid is a list of invalid options as {option_name, value} where option_name is the raw option and value is nil if the option wasn't expected or the string value if the value didn't have the expected type for the corresponding option Elixir converts switches to underscored atoms, so --source-path becomes :source_path . This is done to better suit Elixir conventions. However, this means that switches can't contain underscores and switches that do contain underscores are always returned in the list of invalid switches. When parsing, it is common to list switches and their expected types: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--source&quot; , &quot;lib&quot; ] , strict : [ source : :string ] ) { [ source : &quot;lib&quot; ] , [ ] , [ ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--source-path&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , ...&gt; strict : [ source_path : :string , verbose : :boolean ] ...&gt; ) { [ source_path : &quot;lib&quot; , verbose : true ] , [ &quot;test/enum_test.exs&quot; ] , [ ] } We will explore the valid switches and operation modes of option parser below. Options The following options are supported: :switches or :strict - see the &quot;Switch definitions&quot; section below :allow_nonexistent_atoms - see the &quot;Parsing unknown switches&quot; section below :aliases - see the &quot;Aliases&quot; section below :return_separator - see the &quot;Return separator&quot; section below Switch definitions Switches can be specified via one of two options: :strict - defines strict switches and their types. Any switch in argv that is not specified in the list is returned in the invalid options list. This is the preferred way to parse options. :switches - defines switches and their types. This function still attempts to parse switches that are not in this list. Both these options accept a keyword list where the key is an atom defining the name of the switch and value is the type of the switch (see the &quot;Types&quot; section below for more information). Note that you should only supply the :switches or the :strict option. If you supply both, an ArgumentError exception will be raised. Types Switches parsed by OptionParser may take zero or one arguments. The following switches types take no arguments: :boolean - sets the value to true when given (see also the &quot;Negation switches&quot; section below) :count - counts the number of times the switch is given The following switches take one argument: :integer - parses the value as an integer :float - parses the value as a float :string - parses the value as a string If a switch can't be parsed according to the given type, it is returned in the invalid options list. Modifiers Switches can be specified with modifiers, which change how they behave. The following modifiers are supported: :keep - keeps duplicated elements instead of overriding them; works with all types except :count . Specifying switch_name: :keep assumes the type of :switch_name will be :string . To use :keep with a type other than :string , use a list as the type for the switch. For example: [foo: [:integer, :keep]] . Negation switches In case a switch SWITCH is specified to have type :boolean , it may be passed as --no-SWITCH as well which will set the option to false : iex&gt; OptionParser . parse ( [ &quot;--no-op&quot; , &quot;path/to/file&quot; ] , switches : [ op : :boolean ] ) { [ op : false ] , [ &quot;path/to/file&quot; ] , [ ] } Parsing unknown switches When the :switches option is given, OptionParser will attempt to parse unknown switches: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; ] , switches : [ key : :string ] ) { [ debug : true ] , [ ] , [ ] } Even though we haven't specified --debug in the list of switches, it is part of the returned options. This would also work: iex&gt; OptionParser . parse ( [ &quot;--debug&quot; , &quot;value&quot; ] , switches : [ key : :string ] ) { [ debug : &quot;value&quot; ] , [ ] , [ ] } Switches followed by a value will be assigned the value, as a string. Switches without an argument will be set automatically to true . Since we cannot assert the type of the switch value, it is preferred to use the :strict option that accepts only known switches and always verify their types. If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the --option-parser-example switch because the :option_parser_example atom is never used anywhere: OptionParser . parse ( [ &quot;--option-parser-example&quot; ] , switches : [ debug : :boolean ] ) # The :option_parser_example atom is not used anywhere below However, the code below would work as long as :option_parser_example atom is used at some point later (or earlier) in the same module . For example: { opts , _ , _ } = OptionParser . parse ( [ &quot;--option-parser-example&quot; ] , switches : [ debug : :boolean ] ) # ... then somewhere in the same module you access it ... opts [ :option_parser_example ] In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing allow_nonexistent_atoms: true as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems. Aliases A set of aliases can be specified in the :aliases option: iex&gt; OptionParser . parse ( [ &quot;-d&quot; ] , aliases : [ d : :debug ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ ] , [ ] } Examples Here are some examples of working with different types and modifiers: iex&gt; OptionParser . parse ( [ &quot;--unlock&quot; , &quot;path/to/file&quot; ] , strict : [ unlock : :boolean ] ) { [ unlock : true ] , [ &quot;path/to/file&quot; ] , [ ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--unlock&quot; , &quot;--limit&quot; , &quot;0&quot; , &quot;path/to/file&quot; ] , ...&gt; strict : [ unlock : :boolean , limit : :integer ] ...&gt; ) { [ unlock : true , limit : 0 ] , [ &quot;path/to/file&quot; ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--limit&quot; , &quot;3&quot; ] , strict : [ limit : :integer ] ) { [ limit : 3 ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--limit&quot; , &quot;xyz&quot; ] , strict : [ limit : :integer ] ) { [ ] , [ ] , [ { &quot;--limit&quot; , &quot;xyz&quot; } ] } iex&gt; OptionParser . parse ( [ &quot;--verbose&quot; ] , switches : [ verbose : :count ] ) { [ verbose : 1 ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;-v&quot; , &quot;-v&quot; ] , aliases : [ v : :verbose ] , strict : [ verbose : :count ] ) { [ verbose : 2 ] , [ ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--unknown&quot; , &quot;xyz&quot; ] , strict : [ ] ) { [ ] , [ &quot;xyz&quot; ] , [ { &quot;--unknown&quot; , nil } ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--limit&quot; , &quot;3&quot; , &quot;--unknown&quot; , &quot;xyz&quot; ] , ...&gt; switches : [ limit : :integer ] ...&gt; ) { [ limit : 3 , unknown : &quot;xyz&quot; ] , [ ] , [ ] } iex&gt; OptionParser . parse ( ...&gt; [ &quot;--unlock&quot; , &quot;path/to/file&quot; , &quot;--unlock&quot; , &quot;path/to/another/file&quot; ] , ...&gt; strict : [ unlock : :keep ] ...&gt; ) { [ unlock : &quot;path/to/file&quot; , unlock : &quot;path/to/another/file&quot; ] , [ ] , [ ] } Return separator The separator -- implies options should no longer be processed. By default, the separator is not returned as parts of the arguments, but that can be changed via the :return_separator option: iex&gt; OptionParser . parse ( [ &quot;--&quot; , &quot;lib&quot; ] , return_separator : true , strict : [ ] ) { [ ] , [ &quot;--&quot; , &quot;lib&quot; ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;--no-halt&quot; , &quot;--&quot; , &quot;lib&quot; ] , return_separator : true , switches : [ halt : :boolean ] ) { [ halt : false ] , [ &quot;--&quot; , &quot;lib&quot; ] , [ ] } iex&gt; OptionParser . parse ( [ &quot;script.exs&quot; , &quot;--no-halt&quot; , &quot;--&quot; , &quot;foo&quot; ] , return_separator : true , switches : [ halt : :boolean ] ) { [ { :halt , false } ] , [ &quot;script.exs&quot; , &quot;--&quot; , &quot;foo&quot; ] , [ ] }","ref":"OptionParser.html#parse/2","source_doc":"Parses `argv` into a keyword list.\n\nIt returns a three-element tuple with the form `{parsed, args, invalid}`, where:\n\n  * `parsed` is a keyword list of parsed switches with `{switch_name, value}`\n    tuples in it; `switch_name` is the atom representing the switch name while\n    `value` is the value for that switch parsed according to `opts` (see the\n    \"Examples\" section for more information)\n  * `args` is a list of the remaining arguments in `argv` as strings\n  * `invalid` is a list of invalid options as `{option_name, value}` where\n    `option_name` is the raw option and `value` is `nil` if the option wasn't\n    expected or the string value if the value didn't have the expected type for\n    the corresponding option\n\nElixir converts switches to underscored atoms, so `--source-path` becomes\n`:source_path`. This is done to better suit Elixir conventions. However, this\nmeans that switches can't contain underscores and switches that do contain\nunderscores are always returned in the list of invalid switches.\n\nWhen parsing, it is common to list switches and their expected types:\n\n    iex> OptionParser.parse([\"--debug\"], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n    iex> OptionParser.parse([\"--source\", \"lib\"], strict: [source: :string])\n    {[source: \"lib\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [source_path: :string, verbose: :boolean]\n    ...> )\n    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n\nWe will explore the valid switches and operation modes of option parser below.\n\n## Options\n\nThe following options are supported:\n\n  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n  * `:allow_nonexistent_atoms` - see the \"Parsing unknown switches\" section below\n  * `:aliases` - see the \"Aliases\" section below\n  * `:return_separator` - see the \"Return separator\" section below\n\n## Switch definitions\n\nSwitches can be specified via one of two options:\n\n  * `:strict` - defines strict switches and their types. Any switch\n    in `argv` that is not specified in the list is returned in the\n    invalid options list. This is the preferred way to parse options.\n\n  * `:switches` - defines switches and their types. This function\n    still attempts to parse switches that are not in this list.\n\nBoth these options accept a keyword list where the key is an atom\ndefining the name of the switch and value is the `type` of the\nswitch (see the \"Types\" section below for more information).\n\nNote that you should only supply the `:switches` or the `:strict` option.\nIf you supply both, an `ArgumentError` exception will be raised.\n\n### Types\n\nSwitches parsed by `OptionParser` may take zero or one arguments.\n\nThe following switches types take no arguments:\n\n  * `:boolean` - sets the value to `true` when given (see also the\n    \"Negation switches\" section below)\n  * `:count` - counts the number of times the switch is given\n\nThe following switches take one argument:\n\n  * `:integer` - parses the value as an integer\n  * `:float` - parses the value as a float\n  * `:string` - parses the value as a string\n\nIf a switch can't be parsed according to the given type, it is\nreturned in the invalid options list.\n\n### Modifiers\n\nSwitches can be specified with modifiers, which change how\nthey behave. The following modifiers are supported:\n\n  * `:keep` - keeps duplicated elements instead of overriding them;\n    works with all types except `:count`. Specifying `switch_name: :keep`\n    assumes the type of `:switch_name` will be `:string`.\n\nTo use `:keep` with a type other than `:string`, use a list as the type\nfor the switch. For example: `[foo: [:integer, :keep]]`.\n\n### Negation switches\n\nIn case a switch `SWITCH` is specified to have type `:boolean`, it may be\npassed as `--no-SWITCH` as well which will set the option to `false`:\n\n    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n    {[op: false], [\"path/to/file\"], []}\n\n### Parsing unknown switches\n\nWhen the `:switches` option is given, `OptionParser` will attempt to parse\nunknown switches:\n\n    iex> OptionParser.parse([\"--debug\"], switches: [key: :string])\n    {[debug: true], [], []}\n\nEven though we haven't specified `--debug` in the list of switches, it is part\nof the returned options. This would also work:\n\n    iex> OptionParser.parse([\"--debug\", \"value\"], switches: [key: :string])\n    {[debug: \"value\"], [], []}\n\nSwitches followed by a value will be assigned the value, as a string. Switches\nwithout an argument will be set automatically to `true`. Since we cannot assert\nthe type of the switch value, it is preferred to use the `:strict` option that\naccepts only known switches and always verify their types.\n\nIf you do want to parse unknown switches, remember that Elixir converts switches\nto atoms. Since atoms are not garbage-collected, OptionParser will only parse\nswitches that translate to atoms used by the runtime to avoid leaking atoms.\nFor instance, the code below will discard the `--option-parser-example` switch\nbecause the `:option_parser_example` atom is never used anywhere:\n\n    OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # The :option_parser_example atom is not used anywhere below\n\nHowever, the code below would work as long as `:option_parser_example` atom is\nused at some point later (or earlier) **in the same module**. For example:\n\n    {opts, _, _} = OptionParser.parse([\"--option-parser-example\"], switches: [debug: :boolean])\n    # ... then somewhere in the same module you access it ...\n    opts[:option_parser_example]\n\nIn other words, Elixir will only parse options that are used by the runtime,\nignoring all others. If you would like to parse all switches, regardless if\nthey exist or not, you can force creation of atoms by passing\n`allow_nonexistent_atoms: true` as option. Use this option with care. It is\nonly useful when you are building command-line applications that receive\ndynamically-named arguments and must be avoided in long-running systems.\n\n## Aliases\n\nA set of aliases can be specified in the `:aliases` option:\n\n    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug], strict: [debug: :boolean])\n    {[debug: true], [], []}\n\n## Examples\n\nHere are some examples of working with different types and modifiers:\n\n    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n    {[unlock: true], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n    ...>   strict: [unlock: :boolean, limit: :integer]\n    ...> )\n    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n\n    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n    {[limit: 3], [], []}\n\n    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    {[], [], [{\"--limit\", \"xyz\"}]}\n\n    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n    {[verbose: 1], [], []}\n\n    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n    {[verbose: 2], [], []}\n\n    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n\n    iex> OptionParser.parse(\n    ...>   [\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n    ...>   switches: [limit: :integer]\n    ...> )\n    {[limit: 3, unknown: \"xyz\"], [], []}\n\n    iex> OptionParser.parse(\n    ...>   [\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"],\n    ...>   strict: [unlock: :keep]\n    ...> )\n    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n\n## Return separator\n\nThe separator `--` implies options should no longer be processed.\nBy default, the separator is not returned as parts of the arguments,\nbut that can be changed via the `:return_separator` option:\n\n    iex> OptionParser.parse([\"--\", \"lib\"], return_separator: true, strict: [])\n    {[], [\"--\", \"lib\"], []}\n\n    iex> OptionParser.parse([\"--no-halt\", \"--\", \"lib\"], return_separator: true, switches: [halt: :boolean])\n    {[halt: false], [\"--\", \"lib\"], []}\n\n    iex> OptionParser.parse([\"script.exs\", \"--no-halt\", \"--\", \"foo\"], return_separator: true, switches: [halt: :boolean])\n    {[{:halt, false}], [\"script.exs\", \"--\", \"foo\"], []}\n\n","title":"OptionParser.parse/2","type":"function"},{"doc":"The same as parse/2 but raises an OptionParser.ParseError exception if any invalid options are given. If there are no errors, returns a {parsed, rest} tuple where: parsed is the list of parsed switches (same as in parse/2 ) rest is the list of arguments (same as in parse/2 ) Examples iex&gt; OptionParser . parse! ( [ &quot;--debug&quot; , &quot;path/to/file&quot; ] , strict : [ debug : :boolean ] ) { [ debug : true ] , [ &quot;path/to/file&quot; ] } iex&gt; OptionParser . parse! ( [ &quot;--limit&quot; , &quot;xyz&quot; ] , strict : [ limit : :integer ] ) ** (OptionParser.ParseError) 1 error found! -- limit : Expected type integer , got &quot;xyz&quot; iex&gt; OptionParser . parse! ( [ &quot;--unknown&quot; , &quot;xyz&quot; ] , strict : [ ] ) ** (OptionParser.ParseError) 1 error found! -- unknown : Unknown option iex&gt; OptionParser . parse! ( ...&gt; [ &quot;-l&quot; , &quot;xyz&quot; , &quot;-f&quot; , &quot;bar&quot; ] , ...&gt; switches : [ limit : :integer , foo : :integer ] , ...&gt; aliases : [ l : :limit , f : :foo ] ...&gt; ) ** (OptionParser.ParseError) 2 errors found! - l : Expected type integer , got &quot;xyz&quot; - f : Expected type integer , got &quot;bar&quot;","ref":"OptionParser.html#parse!/2","source_doc":"The same as `parse/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse/2`)\n  * `rest` is the list of arguments (same as in `parse/2`)\n\n## Examples\n\n    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n    {[debug: true], [\"path/to/file\"]}\n\n    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n    ** (OptionParser.ParseError) 1 error found!\n    --limit : Expected type integer, got \"xyz\"\n\n    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n    ** (OptionParser.ParseError) 1 error found!\n    --unknown : Unknown option\n\n    iex> OptionParser.parse!(\n    ...>   [\"-l\", \"xyz\", \"-f\", \"bar\"],\n    ...>   switches: [limit: :integer, foo: :integer],\n    ...>   aliases: [l: :limit, f: :foo]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    -l : Expected type integer, got \"xyz\"\n    -f : Expected type integer, got \"bar\"\n\n","title":"OptionParser.parse!/2","type":"function"},{"doc":"Similar to parse/2 but only parses the head of argv ; as soon as it finds a non-switch, it stops parsing. See parse/2 for more information. Example iex&gt; OptionParser . parse_head ( ...&gt; [ &quot;--source&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , ...&gt; switches : [ source : :string , verbose : :boolean ] ...&gt; ) { [ source : &quot;lib&quot; ] , [ &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , [ ] } iex&gt; OptionParser . parse_head ( ...&gt; [ &quot;--verbose&quot; , &quot;--source&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--unlock&quot; ] , ...&gt; switches : [ source : :string , verbose : :boolean , unlock : :boolean ] ...&gt; ) { [ verbose : true , source : &quot;lib&quot; ] , [ &quot;test/enum_test.exs&quot; , &quot;--unlock&quot; ] , [ ] }","ref":"OptionParser.html#parse_head/2","source_doc":"Similar to `parse/2` but only parses the head of `argv`;\nas soon as it finds a non-switch, it stops parsing.\n\nSee `parse/2` for more information.\n\n## Example\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n\n    iex> OptionParser.parse_head(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   switches: [source: :string, verbose: :boolean, unlock: :boolean]\n    ...> )\n    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}\n\n","title":"OptionParser.parse_head/2","type":"function"},{"doc":"The same as parse_head/2 but raises an OptionParser.ParseError exception if any invalid options are given. If there are no errors, returns a {parsed, rest} tuple where: parsed is the list of parsed switches (same as in parse_head/2 ) rest is the list of arguments (same as in parse_head/2 ) Examples iex&gt; OptionParser . parse_head! ( ...&gt; [ &quot;--source&quot; , &quot;lib&quot; , &quot;path/to/file&quot; , &quot;--verbose&quot; ] , ...&gt; switches : [ source : :string , verbose : :boolean ] ...&gt; ) { [ source : &quot;lib&quot; ] , [ &quot;path/to/file&quot; , &quot;--verbose&quot; ] } iex&gt; OptionParser . parse_head! ( ...&gt; [ &quot;--number&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--verbose&quot; ] , ...&gt; strict : [ number : :integer ] ...&gt; ) ** (OptionParser.ParseError) 1 error found! -- number : Expected type integer , got &quot;lib&quot; iex&gt; OptionParser . parse_head! ( ...&gt; [ &quot;--verbose&quot; , &quot;--source&quot; , &quot;lib&quot; , &quot;test/enum_test.exs&quot; , &quot;--unlock&quot; ] , ...&gt; strict : [ verbose : :integer , source : :integer ] ...&gt; ) ** (OptionParser.ParseError) 2 errors found! -- verbose : Missing argument of type integer -- source : Expected type integer , got &quot;lib&quot;","ref":"OptionParser.html#parse_head!/2","source_doc":"The same as `parse_head/2` but raises an `OptionParser.ParseError`\nexception if any invalid options are given.\n\nIf there are no errors, returns a `{parsed, rest}` tuple where:\n\n  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n  * `rest` is the list of arguments (same as in `parse_head/2`)\n\n## Examples\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--source\", \"lib\", \"path/to/file\", \"--verbose\"],\n    ...>   switches: [source: :string, verbose: :boolean]\n    ...> )\n    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"],\n    ...>   strict: [number: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 1 error found!\n    --number : Expected type integer, got \"lib\"\n\n    iex> OptionParser.parse_head!(\n    ...>   [\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n    ...>   strict: [verbose: :integer, source: :integer]\n    ...> )\n    ** (OptionParser.ParseError) 2 errors found!\n    --verbose : Missing argument of type integer\n    --source : Expected type integer, got \"lib\"\n\n","title":"OptionParser.parse_head!/2","type":"function"},{"doc":"Splits a string into argv/0 chunks. This function splits the given string into a list of strings in a similar way to many shells. Examples iex&gt; OptionParser . split ( &quot;foo bar&quot; ) [ &quot;foo&quot; , &quot;bar&quot; ] iex&gt; OptionParser . split ( &quot;foo \\&quot; bar baz \\&quot; &quot; ) [ &quot;foo&quot; , &quot;bar baz&quot; ]","ref":"OptionParser.html#split/1","source_doc":"Splits a string into `t:argv/0` chunks.\n\nThis function splits the given `string` into a list of strings in a similar\nway to many shells.\n\n## Examples\n\n    iex> OptionParser.split(\"foo bar\")\n    [\"foo\", \"bar\"]\n\n    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n    [\"foo\", \"bar baz\"]\n\n","title":"OptionParser.split/1","type":"function"},{"doc":"Receives a key-value enumerable and converts it to argv/0 . Keys must be atoms. Keys with nil value are discarded, boolean values are converted to --key or --no-key (if the value is true or false , respectively), and all other values are converted using to_string/1 . It is advised to pass to to_argv/2 the same set of options given to parse/2 . Some switches can only be reconstructed correctly with the :switches information in hand. Examples iex&gt; OptionParser . to_argv ( foo_bar : &quot;baz&quot; ) [ &quot;--foo-bar&quot; , &quot;baz&quot; ] iex&gt; OptionParser . to_argv ( bool : true , bool : false , discarded : nil ) [ &quot;--bool&quot; , &quot;--no-bool&quot; ] Some switches will output different values based on the switches types: iex&gt; OptionParser . to_argv ( [ number : 2 ] , switches : [ ] ) [ &quot;--number&quot; , &quot;2&quot; ] iex&gt; OptionParser . to_argv ( [ number : 2 ] , switches : [ number : :count ] ) [ &quot;--number&quot; , &quot;--number&quot; ]","ref":"OptionParser.html#to_argv/2","source_doc":"Receives a key-value enumerable and converts it to `t:argv/0`.\n\nKeys must be atoms. Keys with `nil` value are discarded,\nboolean values are converted to `--key` or `--no-key`\n(if the value is `true` or `false`, respectively),\nand all other values are converted using `to_string/1`.\n\nIt is advised to pass to `to_argv/2` the same set of `options`\ngiven to `parse/2`. Some switches can only be reconstructed\ncorrectly with the `:switches` information in hand.\n\n## Examples\n\n    iex> OptionParser.to_argv(foo_bar: \"baz\")\n    [\"--foo-bar\", \"baz\"]\n    iex> OptionParser.to_argv(bool: true, bool: false, discarded: nil)\n    [\"--bool\", \"--no-bool\"]\n\nSome switches will output different values based on the switches\ntypes:\n\n    iex> OptionParser.to_argv([number: 2], switches: [])\n    [\"--number\", \"2\"]\n    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n    [\"--number\", \"--number\"]\n\n","title":"OptionParser.to_argv/2","type":"function"},{"doc":"","ref":"OptionParser.html#t:argv/0","source_doc":false,"title":"OptionParser.argv/0","type":"type"},{"doc":"","ref":"OptionParser.html#t:errors/0","source_doc":false,"title":"OptionParser.errors/0","type":"type"},{"doc":"","ref":"OptionParser.html#t:options/0","source_doc":false,"title":"OptionParser.options/0","type":"type"},{"doc":"","ref":"OptionParser.html#t:parsed/0","source_doc":false,"title":"OptionParser.parsed/0","type":"type"},{"doc":"This module provides conveniences for manipulating or retrieving file system paths. The functions in this module may receive chardata as arguments and will always return a string encoded in UTF-8. Chardata is a string or a list of characters and strings, see IO.chardata/0 . If a binary is given, in whatever encoding, its encoding will be kept. The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like wildcard/2 and expand/1 ).","ref":"Path.html","source_doc":"This module provides conveniences for manipulating or\nretrieving file system paths.\n\nThe functions in this module may receive chardata as\narguments and will always return a string encoded in UTF-8. Chardata\nis a string or a list of characters and strings, see `t:IO.chardata/0`.\nIf a binary is given, in whatever encoding, its encoding will be kept.\n\nThe majority of the functions in this module do not\ninteract with the file system, except for a few functions\nthat require it (like `wildcard/2` and `expand/1`).\n","title":"Path","type":"module"},{"doc":"Converts the given path to an absolute one. Unlike expand/1 , no attempt is made to resolve .. , . , or ~ . Examples Unix-like operating systems Path . absname ( &quot;foo&quot; ) #=&gt; &quot;/usr/local/foo&quot; Path . absname ( &quot;../x&quot; ) #=&gt; &quot;/usr/local/../x&quot; Windows Path . absname ( &quot;foo&quot; ) #=&gt; &quot;D:/usr/local/foo&quot; Path . absname ( &quot;../x&quot; ) #=&gt; &quot;D:/usr/local/../x&quot;","ref":"Path.html#absname/1","source_doc":"Converts the given path to an absolute one.\n\nUnlike `expand/1`, no attempt is made to resolve `..`, `.`, or `~`.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.absname(\"foo\")\n    #=> \"/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"/usr/local/../x\"\n\n### Windows\n\n    Path.absname(\"foo\")\n    #=> \"D:/usr/local/foo\"\n\n    Path.absname(\"../x\")\n    #=> \"D:/usr/local/../x\"\n\n","title":"Path.absname/1","type":"function"},{"doc":"Builds a path from relative_to to path . If path is already an absolute path, relative_to is ignored. See also relative_to/2 . Unlike expand/2 , no attempt is made to resolve .. , . or ~ . Examples iex&gt; Path . absname ( &quot;foo&quot; , &quot;bar&quot; ) &quot;bar/foo&quot; iex&gt; Path . absname ( &quot;../x&quot; , &quot;bar&quot; ) &quot;bar/../x&quot;","ref":"Path.html#absname/2","source_doc":"Builds a path from `relative_to` to `path`.\n\nIf `path` is already an absolute path, `relative_to` is ignored. See also\n`relative_to/2`.\n\nUnlike `expand/2`, no attempt is made to\nresolve `..`, `.` or `~`.\n\n## Examples\n\n    iex> Path.absname(\"foo\", \"bar\")\n    \"bar/foo\"\n\n    iex> Path.absname(\"../x\", \"bar\")\n    \"bar/../x\"\n\n","title":"Path.absname/2","type":"function"},{"doc":"Returns the last component of the path or the path itself if it does not contain any directory separators. Examples iex&gt; Path . basename ( &quot;foo&quot; ) &quot;foo&quot; iex&gt; Path . basename ( &quot;foo/bar&quot; ) &quot;bar&quot; iex&gt; Path . basename ( &quot;lib/module/submodule.ex&quot; ) &quot;submodule.ex&quot; iex&gt; Path . basename ( &quot;/&quot; ) &quot;&quot;","ref":"Path.html#basename/1","source_doc":"Returns the last component of the path or the path\nitself if it does not contain any directory separators.\n\n## Examples\n\n    iex> Path.basename(\"foo\")\n    \"foo\"\n\n    iex> Path.basename(\"foo/bar\")\n    \"bar\"\n\n    iex> Path.basename(\"lib/module/submodule.ex\")\n    \"submodule.ex\"\n\n    iex> Path.basename(\"/\")\n    \"\"\n\n","title":"Path.basename/1","type":"function"},{"doc":"Returns the last component of path with the extension stripped. This function should be used to remove a specific extension which may or may not be there. Examples iex&gt; Path . basename ( &quot;~/foo/bar.ex&quot; , &quot;.ex&quot; ) &quot;bar&quot; iex&gt; Path . basename ( &quot;~/foo/bar.exs&quot; , &quot;.ex&quot; ) &quot;bar.exs&quot; iex&gt; Path . basename ( &quot;~/foo/bar.old.ex&quot; , &quot;.ex&quot; ) &quot;bar.old&quot;","ref":"Path.html#basename/2","source_doc":"Returns the last component of `path` with the `extension`\nstripped.\n\nThis function should be used to remove a specific\nextension which may or may not be there.\n\n## Examples\n\n    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n    \"bar\"\n\n    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n    \"bar.exs\"\n\n    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n    \"bar.old\"\n\n","title":"Path.basename/2","type":"function"},{"doc":"Returns the directory component of path . Examples iex&gt; Path . dirname ( &quot;/foo/bar.ex&quot; ) &quot;/foo&quot; iex&gt; Path . dirname ( &quot;/foo/bar/baz.ex&quot; ) &quot;/foo/bar&quot; iex&gt; Path . dirname ( &quot;/foo/bar/&quot; ) &quot;/foo/bar&quot; iex&gt; Path . dirname ( &quot;bar.ex&quot; ) &quot;.&quot;","ref":"Path.html#dirname/1","source_doc":"Returns the directory component of `path`.\n\n## Examples\n\n    iex> Path.dirname(\"/foo/bar.ex\")\n    \"/foo\"\n\n    iex> Path.dirname(\"/foo/bar/baz.ex\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"/foo/bar/\")\n    \"/foo/bar\"\n\n    iex> Path.dirname(\"bar.ex\")\n    \".\"\n\n","title":"Path.dirname/1","type":"function"},{"doc":"Converts the path to an absolute one, expanding any . and .. components and a leading ~ . Examples Path . expand ( &quot;/foo/bar/../baz&quot; ) #=&gt; &quot;/foo/baz&quot;","ref":"Path.html#expand/1","source_doc":"Converts the path to an absolute one, expanding\nany `.` and `..` components and a leading `~`.\n\n## Examples\n\n    Path.expand(\"/foo/bar/../baz\")\n    #=> \"/foo/baz\"\n\n","title":"Path.expand/1","type":"function"},{"doc":"Expands the path relative to the path given as the second argument expanding any . and .. characters. If the path is already an absolute path, relative_to is ignored. Note that this function treats a path with a leading ~ as an absolute one. The second argument is first expanded to an absolute path. Examples # Assuming that the absolute path to baz is /quux/baz Path . expand ( &quot;foo/bar/../bar&quot; , &quot;baz&quot; ) #=&gt; &quot;/quux/baz/foo/bar&quot; Path . expand ( &quot;foo/bar/../bar&quot; , &quot;/baz&quot; ) #=&gt; &quot;/baz/foo/bar&quot; Path . expand ( &quot;/foo/bar/../bar&quot; , &quot;/baz&quot; ) #=&gt; &quot;/foo/bar&quot;","ref":"Path.html#expand/2","source_doc":"Expands the path relative to the path given as the second argument\nexpanding any `.` and `..` characters.\n\nIf the path is already an absolute path, `relative_to` is ignored.\n\nNote that this function treats a `path` with a leading `~` as\nan absolute one.\n\nThe second argument is first expanded to an absolute path.\n\n## Examples\n\n    # Assuming that the absolute path to baz is /quux/baz\n    Path.expand(\"foo/bar/../bar\", \"baz\")\n    #=> \"/quux/baz/foo/bar\"\n\n    Path.expand(\"foo/bar/../bar\", \"/baz\")\n    #=> \"/baz/foo/bar\"\n\n    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n    #=> \"/foo/bar\"\n\n","title":"Path.expand/2","type":"function"},{"doc":"Returns the extension of the last component of path . For filenames starting with a dot and without an extension, it returns an empty string. See basename/1 and rootname/1 for related functions to extract information from paths. Examples iex&gt; Path . extname ( &quot;foo.erl&quot; ) &quot;.erl&quot; iex&gt; Path . extname ( &quot;~/foo/bar&quot; ) &quot;&quot; iex&gt; Path . extname ( &quot;.gitignore&quot; ) &quot;&quot;","ref":"Path.html#extname/1","source_doc":"Returns the extension of the last component of `path`.\n\nFor filenames starting with a dot and without an extension, it returns\nan empty string.\n\nSee `basename/1` and `rootname/1` for related functions to extract\ninformation from paths.\n\n## Examples\n\n    iex> Path.extname(\"foo.erl\")\n    \".erl\"\n\n    iex> Path.extname(\"~/foo/bar\")\n    \"\"\n\n    iex> Path.extname(\".gitignore\")\n    \"\"\n\n","title":"Path.extname/1","type":"function"},{"doc":"Joins a list of paths. This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining. Raises an error if the given list of paths is empty. Examples iex&gt; Path . join ( [ &quot;~&quot; , &quot;foo&quot; ] ) &quot;~/foo&quot; iex&gt; Path . join ( [ &quot;foo&quot; ] ) &quot;foo&quot; iex&gt; Path . join ( [ &quot;/&quot; , &quot;foo&quot; , &quot;bar/&quot; ] ) &quot;/foo/bar&quot;","ref":"Path.html#join/1","source_doc":"Joins a list of paths.\n\nThis function should be used to convert a list of paths to a path.\nNote that any trailing slash is removed when joining.\n\nRaises an error if the given list of paths is empty.\n\n## Examples\n\n    iex> Path.join([\"~\", \"foo\"])\n    \"~/foo\"\n\n    iex> Path.join([\"foo\"])\n    \"foo\"\n\n    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n    \"/foo/bar\"\n\n","title":"Path.join/1","type":"function"},{"doc":"Joins two paths. The right path will always be expanded to its relative format and any trailing slash will be removed when joining. Examples iex&gt; Path . join ( &quot;foo&quot; , &quot;bar&quot; ) &quot;foo/bar&quot; iex&gt; Path . join ( &quot;/foo&quot; , &quot;/bar/&quot; ) &quot;/foo/bar&quot; The functions in this module support chardata, so giving a list will treat it as a single entity: iex&gt; Path . join ( &quot;foo&quot; , [ &quot;bar&quot; , &quot;fiz&quot; ] ) &quot;foo/barfiz&quot; iex&gt; Path . join ( [ &quot;foo&quot; , &quot;bar&quot; ] , &quot;fiz&quot; ) &quot;foobar/fiz&quot; Use join/1 if you need to join a list of paths instead.","ref":"Path.html#join/2","source_doc":"Joins two paths.\n\nThe right path will always be expanded to its relative format\nand any trailing slash will be removed when joining.\n\n## Examples\n\n    iex> Path.join(\"foo\", \"bar\")\n    \"foo/bar\"\n\n    iex> Path.join(\"/foo\", \"/bar/\")\n    \"/foo/bar\"\n\nThe functions in this module support chardata, so giving a list will\ntreat it as a single entity:\n\n    iex> Path.join(\"foo\", [\"bar\", \"fiz\"])\n    \"foo/barfiz\"\n\n    iex> Path.join([\"foo\", \"bar\"], \"fiz\")\n    \"foobar/fiz\"\n\nUse `join/1` if you need to join a list of paths instead.\n","title":"Path.join/2","type":"function"},{"doc":"Forces the path to be a relative path. Examples Unix-like operating systems Path . relative ( &quot;/usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;../usr/local/bin&quot; ) #=&gt; &quot;../usr/local/bin&quot; Windows Path . relative ( &quot;D:/usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;usr/local/bin&quot; ) #=&gt; &quot;usr/local/bin&quot; Path . relative ( &quot;D:bar.ex&quot; ) #=&gt; &quot;bar.ex&quot; Path . relative ( &quot;/bar/foo.ex&quot; ) #=&gt; &quot;bar/foo.ex&quot;","ref":"Path.html#relative/1","source_doc":"Forces the path to be a relative path.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n\n### Windows\n\n    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n\n","title":"Path.relative/1","type":"function"},{"doc":"Returns the direct relative path from path in relation to from . In other words, this function tries to strip the from prefix from path . This function does not query the file system, so it assumes no symlinks between the paths. In case a direct relative path cannot be found, it returns the original path. Examples iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/usr/local&quot; ) &quot;foo&quot; iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/&quot; ) &quot;usr/local/foo&quot; iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/etc&quot; ) &quot;/usr/local/foo&quot; iex&gt; Path . relative_to ( &quot;/usr/local/foo&quot; , &quot;/usr/local/foo&quot; ) &quot;.&quot;","ref":"Path.html#relative_to/2","source_doc":"Returns the direct relative path from `path` in relation to `from`.\n\nIn other words, this function tries to strip the `from` prefix from `path`.\n\nThis function does not query the file system, so it assumes\nno symlinks between the paths.\n\nIn case a direct relative path cannot be found, it returns\nthe original path.\n\n## Examples\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n    \"foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n    \"usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n    \"/usr/local/foo\"\n\n    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local/foo\")\n    \".\"\n\n","title":"Path.relative_to/2","type":"function"},{"doc":"Convenience to get the path relative to the current working directory. If, for some reason, the current working directory cannot be retrieved, this function returns the given path .","ref":"Path.html#relative_to_cwd/1","source_doc":"Convenience to get the path relative to the current working\ndirectory.\n\nIf, for some reason, the current working directory\ncannot be retrieved, this function returns the given `path`.\n","title":"Path.relative_to_cwd/1","type":"function"},{"doc":"Returns the path with the extension stripped. Examples iex&gt; Path . rootname ( &quot;/foo/bar&quot; ) &quot;/foo/bar&quot; iex&gt; Path . rootname ( &quot;/foo/bar.ex&quot; ) &quot;/foo/bar&quot;","ref":"Path.html#rootname/1","source_doc":"Returns the `path` with the `extension` stripped.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.ex\")\n    \"/foo/bar\"\n\n","title":"Path.rootname/1","type":"function"},{"doc":"Returns the path with the extension stripped. This function should be used to remove a specific extension which may or may not be there. Examples iex&gt; Path . rootname ( &quot;/foo/bar.erl&quot; , &quot;.erl&quot; ) &quot;/foo/bar&quot; iex&gt; Path . rootname ( &quot;/foo/bar.erl&quot; , &quot;.ex&quot; ) &quot;/foo/bar.erl&quot;","ref":"Path.html#rootname/2","source_doc":"Returns the `path` with the `extension` stripped.\n\nThis function should be used to remove a specific extension which may\nor may not be there.\n\n## Examples\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n    \"/foo/bar\"\n\n    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n    \"/foo/bar.erl\"\n\n","title":"Path.rootname/2","type":"function"},{"doc":"Returns a path relative to the current working directory that is protected from directory-traversal attacks. Same as safe_relative_to/2 with the current working directory as the second argument. If there is an issue retrieving the current working directory, this function raises an error. Examples iex&gt; Path . safe_relative ( &quot;foo&quot; ) { :ok , &quot;foo&quot; } iex&gt; Path . safe_relative ( &quot;foo/../bar&quot; ) { :ok , &quot;bar&quot; } iex&gt; Path . safe_relative ( &quot;foo/../..&quot; ) :error iex&gt; Path . safe_relative ( &quot;/usr/local&quot; ) :error","ref":"Path.html#safe_relative/1","source_doc":"Returns a path relative to the current working directory that is\nprotected from directory-traversal attacks.\n\nSame as `safe_relative_to/2` with the current working directory as\nthe second argument. If there is an issue retrieving the current working\ndirectory, this function raises an error.\n\n## Examples\n\n    iex> Path.safe_relative(\"foo\")\n    {:ok, \"foo\"}\n\n    iex> Path.safe_relative(\"foo/../bar\")\n    {:ok, \"bar\"}\n\n    iex> Path.safe_relative(\"foo/../..\")\n    :error\n\n    iex> Path.safe_relative(\"/usr/local\")\n    :error\n\n","title":"Path.safe_relative/1","type":"function"},{"doc":"Returns a relative path that is protected from directory-traversal attacks. The given relative path is sanitized by eliminating .. and . components. This function checks that, after expanding those components, the path is still &quot;safe&quot;. Paths are considered unsafe if either of these is true: The path is not relative, such as &quot;/foo/bar&quot; . A .. component would make it so that the path would travers up above the root of relative_to . A symbolic link in the path points to something above the root of relative_to . Examples iex&gt; Path . safe_relative_to ( &quot;deps/my_dep/app.beam&quot; , &quot;deps&quot; ) { :ok , &quot;deps/my_dep/app.beam&quot; } iex&gt; Path . safe_relative_to ( &quot;deps/my_dep/./build/../app.beam&quot; , &quot;deps&quot; ) { :ok , &quot;deps/my_dep/app.beam&quot; } iex&gt; Path . safe_relative_to ( &quot;my_dep/../..&quot; , &quot;deps&quot; ) :error iex&gt; Path . safe_relative_to ( &quot;/usr/local&quot; , &quot;.&quot; ) :error","ref":"Path.html#safe_relative_to/2","source_doc":"Returns a relative path that is protected from directory-traversal attacks.\n\nThe given relative path is sanitized by eliminating `..` and `.` components.\n\nThis function checks that, after expanding those components, the path is still \"safe\".\nPaths are considered unsafe if either of these is true:\n\n  * The path is not relative, such as `\"/foo/bar\"`.\n\n  * A `..` component would make it so that the path would travers up above\n    the root of `relative_to`.\n\n  * A symbolic link in the path points to something above the root of `relative_to`.\n\n## Examples\n\n    iex> Path.safe_relative_to(\"deps/my_dep/app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"deps/my_dep/./build/../app.beam\", \"deps\")\n    {:ok, \"deps/my_dep/app.beam\"}\n\n    iex> Path.safe_relative_to(\"my_dep/../..\", \"deps\")\n    :error\n\n    iex> Path.safe_relative_to(\"/usr/local\", \".\")\n    :error\n\n","title":"Path.safe_relative_to/2","type":"function"},{"doc":"Splits the path into a list at the path separator. If an empty string is given, returns an empty list. On Windows, path is split on both &quot;\\&quot; and &quot;/&quot; separators and the driver letter, if there is one, is always returned in lowercase. Examples iex&gt; Path . split ( &quot;&quot; ) [ ] iex&gt; Path . split ( &quot;foo&quot; ) [ &quot;foo&quot; ] iex&gt; Path . split ( &quot;/foo/bar&quot; ) [ &quot;/&quot; , &quot;foo&quot; , &quot;bar&quot; ]","ref":"Path.html#split/1","source_doc":"Splits the path into a list at the path separator.\n\nIf an empty string is given, returns an empty list.\n\nOn Windows, path is split on both `\"\\\"` and `\"/\"` separators\nand the driver letter, if there is one, is always returned\nin lowercase.\n\n## Examples\n\n    iex> Path.split(\"\")\n    []\n\n    iex> Path.split(\"foo\")\n    [\"foo\"]\n\n    iex> Path.split(\"/foo/bar\")\n    [\"/\", \"foo\", \"bar\"]\n\n","title":"Path.split/1","type":"function"},{"doc":"Returns the path type. Examples Unix-like operating systems Path . type ( &quot;/&quot; ) #=&gt; :absolute Path . type ( &quot;/usr/local/bin&quot; ) #=&gt; :absolute Path . type ( &quot;usr/local/bin&quot; ) #=&gt; :relative Path . type ( &quot;../usr/local/bin&quot; ) #=&gt; :relative Path . type ( &quot;~/file&quot; ) #=&gt; :relative Windows Path . type ( &quot;D:/usr/local/bin&quot; ) #=&gt; :absolute Path . type ( &quot;usr/local/bin&quot; ) #=&gt; :relative Path . type ( &quot;D:bar.ex&quot; ) #=&gt; :volumerelative Path . type ( &quot;/bar/foo.ex&quot; ) #=&gt; :volumerelative","ref":"Path.html#type/1","source_doc":"Returns the path type.\n\n## Examples\n\n### Unix-like operating systems\n\n    Path.type(\"/\")                #=> :absolute\n    Path.type(\"/usr/local/bin\")   #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"../usr/local/bin\") #=> :relative\n    Path.type(\"~/file\")           #=> :relative\n\n### Windows\n\n    Path.type(\"D:/usr/local/bin\") #=> :absolute\n    Path.type(\"usr/local/bin\")    #=> :relative\n    Path.type(\"D:bar.ex\")         #=> :volumerelative\n    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n\n","title":"Path.type/1","type":"function"},{"doc":"Traverses paths according to the given glob expression and returns a list of matches. The wildcard looks like an ordinary path, except that the following &quot;wildcard characters&quot; are interpreted in a special way: ? - matches one character. * - matches any number of characters up to the end of the filename, the next dot, or the next slash. ** - two adjacent * 's used as a single pattern will match all files and zero or more directories and subdirectories. [char1,char2,...] - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself. {item1,item2,...} - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself. Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: &quot;a&quot; will not match &quot;A&quot; . Directory separators must always be written as / , even on Windows. You may call Path.expand/1 to normalize the path before invoking this function. A character preceded by loses its special meaning. Note that must be written as \\ in a string literal. For example, &quot;\\?*&quot; will match any filename starting with ?. By default, the patterns * and ? do not match files starting with a dot . . See the :match_dot option in the &quot;Options&quot; section below. Options :match_dot - (boolean) if false , the special wildcard characters * and ? will not match files starting with a dot ( . ). If true , files starting with a . will not be treated specially. Defaults to false . Examples Imagine you have a directory called projects with three Elixir projects inside of it: elixir , ex_doc , and plug . You can find all .beam files inside the ebin directory of each project as follows: Path . wildcard ( &quot;projects/*/ebin/**/*.beam&quot; ) If you want to search for both .beam and .app files, you could do: Path . wildcard ( &quot;projects/*/ebin/**/*.{beam,app}&quot; )","ref":"Path.html#wildcard/2","source_doc":"Traverses paths according to the given `glob` expression and returns a\nlist of matches.\n\nThe wildcard looks like an ordinary path, except that the following\n\"wildcard characters\" are interpreted in a special way:\n\n  * `?` - matches one character.\n\n  * `*` - matches any number of characters up to the end of the filename, the\n    next dot, or the next slash.\n\n  * `**` - two adjacent `*`'s used as a single pattern will match all\n    files and zero or more directories and subdirectories.\n\n  * `[char1,char2,...]` - matches any of the characters listed; two\n    characters separated by a hyphen will match a range of characters.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\n  * `{item1,item2,...}` - matches one of the alternatives.\n    Do not add spaces before and after the comma as it would then match\n    paths containing the space character itself.\n\nOther characters represent themselves. Only paths that have\nexactly the same character in the same position will match. Note\nthat matching is case-sensitive: `\"a\"` will not match `\"A\"`.\n\nDirectory separators must always be written as `/`, even on Windows.\nYou may call `Path.expand/1` to normalize the path before invoking\nthis function.\n\nA character preceded by  loses its special meaning.\nNote that  must be written as \\ in a string literal.\nFor example, \"\\?*\" will match any filename starting with ?.\n\nBy default, the patterns `*` and `?` do not match files starting\nwith a dot `.`. See the `:match_dot` option in the \"Options\" section\nbelow.\n\n## Options\n\n  * `:match_dot` - (boolean) if `false`, the special wildcard characters `*` and `?`\n    will not match files starting with a dot (`.`). If `true`, files starting with\n    a `.` will not be treated specially. Defaults to `false`.\n\n## Examples\n\nImagine you have a directory called `projects` with three Elixir projects\ninside of it: `elixir`, `ex_doc`, and `plug`. You can find all `.beam` files\ninside the `ebin` directory of each project as follows:\n\n    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n\nIf you want to search for both `.beam` and `.app` files, you could do:\n\n    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n\n","title":"Path.wildcard/2","type":"function"},{"doc":"A path.","ref":"Path.html#t:t/0","source_doc":"A path.\n","title":"Path.t/0","type":"type"},{"doc":"Functions for interacting with the external world through ports. Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing. Example iex&gt; port = Port . open ( { :spawn , &quot;cat&quot; } , [ :binary ] ) iex&gt; send ( port , { self ( ) , { :command , &quot;hello&quot; } } ) iex&gt; send ( port , { self ( ) , { :command , &quot;world&quot; } } ) iex&gt; flush ( ) { # Port &lt; 0.1444 &gt; , { :data , &quot;hello&quot; } } { # Port &lt; 0.1444 &gt; , { :data , &quot;world&quot; } } iex&gt; send ( port , { self ( ) , :close } ) :ok iex&gt; flush ( ) { # Port &lt; 0.1464 &gt; , :closed } :ok In the example above, we have created a new port that executes the program cat . cat is a program available on Unix-like operating systems that receives data from multiple inputs and concatenates them in the output. After the port was created, we sent it two commands in the form of messages using send/2 . The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;. After sending those two messages, we invoked the IEx helper flush() , which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Note that the messages are in binary because we passed the :binary option when opening the port in Port.open/2 . Without such option, it would have yielded a list of bytes. Once everything was done, we closed the port. Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below. Message and function APIs There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module. The messages supported by ports and their counterpart function APIs are listed below: {pid, {:command, binary}} - sends the given data to the port. See command/3 . {pid, :close} - closes the port. Unless the port is already closed, the port will reply with {port, :closed} message once it has flushed its buffers and effectively closed. See close/1 . {pid, {:connect, new_pid}} - sets the new_pid as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes new_pid the new connected processes. Unless the port is dead, the port will reply to the old owner with {port, :connected} . See connect/2 . On its turn, the port will send the connected process the following messages: {port, {:data, data}} - data sent by the port {port, :closed} - reply to the {pid, :close} message {port, :connected} - reply to the {pid, {:connect, new_pid}} message {:EXIT, port, reason} - exit signals in case the port crashes. If reason is not :normal , this message will only be received if the owner process is trapping exits Open mechanisms The port can be opened through four main mechanisms. As a short summary, prefer to using the :spawn and :spawn_executable options mentioned below. The other two options, :spawn_driver and :fd are for advanced usage within the VM. Also consider using System.cmd/3 if all you want is to execute a program and retrieve its return value. spawn The :spawn tuple receives a binary that is going to be executed as a full invocation. For example, we can use it to invoke &quot;echo hello&quot; directly: iex&gt; port = Port . open ( { :spawn , &quot;echo hello&quot; } , [ :binary ] ) iex&gt; flush ( ) { # Port &lt; 0.1444 &gt; , { :data , &quot;hello \\n &quot; } } :spawn will retrieve the program name from the argument and traverse your operating system $PATH environment variable looking for a matching program. Although the above is handy, it means it is impossible to invoke an executable that has whitespaces on its name or in any of its arguments. For those reasons, most times it is preferable to execute :spawn_executable . spawn_executable Spawn executable is a more restricted and explicit version of spawn. It expects full file paths to the executable you want to execute. If they are in your $PATH , they can be retrieved by calling System.find_executable/1 : iex&gt; path = System . find_executable ( &quot;echo&quot; ) iex&gt; port = Port . open ( { :spawn_executable , path } , [ :binary , args : [ &quot;hello world&quot; ] ] ) iex&gt; flush ( ) { # Port &lt; 0.1380 &gt; , { :data , &quot;hello world \\n &quot; } } When using :spawn_executable , the list of arguments can be passed via the :args option as done above. For the full list of options, see the documentation for the Erlang function :erlang.open_port/2 . fd The :fd name option allows developers to access in and out file descriptors used by the Erlang VM. You would use those only if you are reimplementing core part of the Runtime System, such as the :user and :shell processes. Zombie operating system processes A port can be closed via the close/1 function or by sending a {pid, :close} message. However, if the VM crashes, a long-running program started by the port will have its stdin and stdout channels closed but it won't be automatically terminated . While most Unix command line tools will exit once its communication channels are closed, not all command line applications will do so. You can easily check this by starting the port and then shutting down the VM and inspecting your operating system to see if the port process is still running. While we encourage graceful termination by detecting if stdin/stdout has been closed, we do not always have control over how third-party software terminates. In those cases, you can wrap the application in a script that checks for stdin. Here is such script that has been verified to work on bash shells: #!/usr/bin/env bash # Start the program in the background exec &quot;$@&quot; &amp; pid1 = $ ! # Silence warnings from here on exec &gt; / dev / null 2 &gt; &amp;1 # Read from stdin in the background and # kill running program when stdin closes exec 0 &lt; &amp;0 $ ( while read ; do : ; done kill - KILL $ pid1 ) &amp; pid2 = $ ! # Clean up wait $ pid1 ret = $ ? kill - KILL $ pid2 exit $ ret Note the program above hijacks stdin, so you won't be able to communicate with the underlying software via stdin (on the positive side, software that reads from stdin typically terminates when stdin closes). Now instead of: Port . open ( { :spawn_executable , &quot;/path/to/program&quot; } , args : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) You may invoke: Port . open ( { :spawn_executable , &quot;/path/to/wrapper&quot; } , args : [ &quot;/path/to/program&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] )","ref":"Port.html","source_doc":"Functions for interacting with the external world through ports.\n\nPorts provide a mechanism to start operating system processes external\nto the Erlang VM and communicate with them via message passing.\n\n## Example\n\n    iex> port = Port.open({:spawn, \"cat\"}, [:binary])\n    iex> send(port, {self(), {:command, \"hello\"}})\n    iex> send(port, {self(), {:command, \"world\"}})\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\"}}\n    {#Port<0.1444>, {:data, \"world\"}}\n    iex> send(port, {self(), :close})\n    :ok\n    iex> flush()\n    {#Port<0.1464>, :closed}\n    :ok\n\nIn the example above, we have created a new port that executes the\nprogram `cat`. `cat` is a program available on Unix-like operating systems that\nreceives data from multiple inputs and concatenates them in the output.\n\nAfter the port was created, we sent it two commands in the form of\nmessages using `send/2`. The first command has the binary payload\nof \"hello\" and the second has \"world\".\n\nAfter sending those two messages, we invoked the IEx helper `flush()`,\nwhich printed all messages received from the port, in this case we got\n\"hello\" and \"world\" back. Note that the messages are in binary because we\npassed the `:binary` option when opening the port in `Port.open/2`. Without\nsuch option, it would have yielded a list of bytes.\n\nOnce everything was done, we closed the port.\n\nElixir provides many conveniences for working with ports and some drawbacks.\nWe will explore those below.\n\n## Message and function APIs\n\nThere are two APIs for working with ports. It can be either asynchronous via\nmessage passing, as in the example above, or by calling the functions on this\nmodule.\n\nThe messages supported by ports and their counterpart function APIs are\nlisted below:\n\n  * `{pid, {:command, binary}}` - sends the given data to the port.\n    See `command/3`.\n\n  * `{pid, :close}` - closes the port. Unless the port is already closed,\n    the port will reply with `{port, :closed}` message once it has flushed\n    its buffers and effectively closed. See `close/1`.\n\n  * `{pid, {:connect, new_pid}}` - sets the `new_pid` as the new owner of\n    the port. Once a port is opened, the port is linked and connected to the\n    caller process and communication to the port only happens through the\n    connected process. This message makes `new_pid` the new connected processes.\n    Unless the port is dead, the port will reply to the old owner with\n    `{port, :connected}`. See `connect/2`.\n\nOn its turn, the port will send the connected process the following messages:\n\n  * `{port, {:data, data}}` - data sent by the port\n  * `{port, :closed}` - reply to the `{pid, :close}` message\n  * `{port, :connected}` - reply to the `{pid, {:connect, new_pid}}` message\n  * `{:EXIT, port, reason}` - exit signals in case the port crashes. If reason\n    is not `:normal`, this message will only be received if the owner process\n    is trapping exits\n\n## Open mechanisms\n\nThe port can be opened through four main mechanisms.\n\nAs a short summary, prefer to using the `:spawn` and `:spawn_executable`\noptions mentioned below. The other two options, `:spawn_driver` and `:fd`\nare for advanced usage within the VM. Also consider using `System.cmd/3`\nif all you want is to execute a program and retrieve its return value.\n\n### spawn\n\nThe `:spawn` tuple receives a binary that is going to be executed as a\nfull invocation. For example, we can use it to invoke \"echo hello\" directly:\n\n    iex> port = Port.open({:spawn, \"echo hello\"}, [:binary])\n    iex> flush()\n    {#Port<0.1444>, {:data, \"hello\\n\"}}\n\n`:spawn` will retrieve the program name from the argument and traverse your\noperating system `$PATH` environment variable looking for a matching program.\n\nAlthough the above is handy, it means it is impossible to invoke an executable\nthat has whitespaces on its name or in any of its arguments. For those reasons,\nmost times it is preferable to execute `:spawn_executable`.\n\n### spawn_executable\n\nSpawn executable is a more restricted and explicit version of spawn. It expects\nfull file paths to the executable you want to execute. If they are in your `$PATH`,\nthey can be retrieved by calling `System.find_executable/1`:\n\n    iex> path = System.find_executable(\"echo\")\n    iex> port = Port.open({:spawn_executable, path}, [:binary, args: [\"hello world\"]])\n    iex> flush()\n    {#Port<0.1380>, {:data, \"hello world\\n\"}}\n\nWhen using `:spawn_executable`, the list of arguments can be passed via\nthe `:args` option as done above. For the full list of options, see the\ndocumentation for the Erlang function `:erlang.open_port/2`.\n\n### fd\n\nThe `:fd` name option allows developers to access `in` and `out` file\ndescriptors used by the Erlang VM. You would use those only if you are\nreimplementing core part of the Runtime System, such as the `:user` and\n`:shell` processes.\n\n## Zombie operating system processes\n\nA port can be closed via the `close/1` function or by sending a `{pid, :close}`\nmessage. However, if the VM crashes, a long-running program started by the port\nwill have its stdin and stdout channels closed but **it won't be automatically\nterminated**.\n\nWhile most Unix command line tools will exit once its communication channels\nare closed, not all command line applications will do so. You can easily check\nthis by starting the port and then shutting down the VM and inspecting your\noperating system to see if the port process is still running.\n\nWhile we encourage graceful termination by detecting if stdin/stdout has been\nclosed, we do not always have control over how third-party software terminates.\nIn those cases, you can wrap the application in a script that checks for stdin.\nHere is such script that has been verified to work on bash shells:\n\n    #!/usr/bin/env bash\n\n    # Start the program in the background\n    exec \"$@\" &\n    pid1=$!\n\n    # Silence warnings from here on\n    exec >/dev/null 2>&1\n\n    # Read from stdin in the background and\n    # kill running program when stdin closes\n    exec 0<&0 $(\n      while read; do :; done\n      kill -KILL $pid1\n    ) &\n    pid2=$!\n\n    # Clean up\n    wait $pid1\n    ret=$?\n    kill -KILL $pid2\n    exit $ret\n\nNote the program above hijacks stdin, so you won't be able to communicate\nwith the underlying software via stdin (on the positive side, software that\nreads from stdin typically terminates when stdin closes).\n\nNow instead of:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/program\"},\n      args: [\"a\", \"b\", \"c\"]\n    )\n\nYou may invoke:\n\n    Port.open(\n      {:spawn_executable, \"/path/to/wrapper\"},\n      args: [\"/path/to/program\", \"a\", \"b\", \"c\"]\n    )\n\n","title":"Port","type":"module"},{"doc":"Closes the port . For more information, see :erlang.port_close/1 . Inlined by the compiler.","ref":"Port.html#close/1","source_doc":"Closes the `port`.\n\nFor more information, see `:erlang.port_close/1`.\n\nInlined by the compiler.\n","title":"Port.close/1","type":"function"},{"doc":"Sends data to the port driver port . For more information, see :erlang.port_command/3 . Inlined by the compiler.","ref":"Port.html#command/3","source_doc":"Sends `data` to the port driver `port`.\n\nFor more information, see `:erlang.port_command/3`.\n\nInlined by the compiler.\n","title":"Port.command/3","type":"function"},{"doc":"Associates the port identifier with a pid . For more information, see :erlang.port_connect/2 . Inlined by the compiler.","ref":"Port.html#connect/2","source_doc":"Associates the `port` identifier with a `pid`.\n\nFor more information, see `:erlang.port_connect/2`.\n\nInlined by the compiler.\n","title":"Port.connect/2","type":"function"},{"doc":"Demonitors the monitor identified by the given reference . If monitor_ref is a reference which the calling process obtained by calling monitor/1 , that monitoring is turned off. If the monitoring is already turned off, nothing happens. See :erlang.demonitor/2 for more information. Inlined by the compiler.","ref":"Port.html#demonitor/2","source_doc":"Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.\n","title":"Port.demonitor/2","type":"function"},{"doc":"Returns information about the port (or nil if the port is closed). For more information, see :erlang.port_info/1 .","ref":"Port.html#info/1","source_doc":"Returns information about the `port` (or `nil` if the port is closed).\n\nFor more information, see `:erlang.port_info/1`.\n","title":"Port.info/1","type":"function"},{"doc":"Returns information about a specific field within the port (or nil if the port is closed). For more information, see :erlang.port_info/2 .","ref":"Port.html#info/2","source_doc":"Returns information about a specific field within\nthe `port` (or `nil` if the port is closed).\n\nFor more information, see `:erlang.port_info/2`.\n","title":"Port.info/2","type":"function"},{"doc":"Returns a list of all ports in the current node. Inlined by the compiler.","ref":"Port.html#list/0","source_doc":"Returns a list of all ports in the current node.\n\nInlined by the compiler.\n","title":"Port.list/0","type":"function"},{"doc":"Starts monitoring the given port from the calling process. Once the monitored port process dies, a message is delivered to the monitoring process in the shape of: { :DOWN , ref , :port , object , reason } where: ref is a monitor reference returned by this function; object is either the port being monitored (when monitoring by port ID) or {name, node} (when monitoring by a port name); reason is the exit reason. See :erlang.monitor/2 for more information. Inlined by the compiler.","ref":"Port.html#monitor/1","source_doc":"Starts monitoring the given `port` from the calling process.\n\nOnce the monitored port process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :port, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either the `port` being monitored (when monitoring by port ID)\n  or `{name, node}` (when monitoring by a port name);\n  * `reason` is the exit reason.\n\nSee `:erlang.monitor/2` for more information.\n\nInlined by the compiler.\n","title":"Port.monitor/1","type":"function"},{"doc":"Opens a port given a tuple name and a list of options . The module documentation above contains documentation and examples for the supported name values, summarized below: {:spawn, command} - runs an external program. command must contain the program name and optionally a list of arguments separated by space. If passing programs or arguments with space in their name, use the next option. {:spawn_executable, filename} - runs the executable given by the absolute file name filename . Arguments can be passed via the :args option. {:spawn_driver, command} - spawns so-called port drivers. {:fd, fd_in, fd_out} - accesses file descriptors, fd_in and fd_out opened by the VM. For more information and the list of options, see :erlang.open_port/2 . Inlined by the compiler.","ref":"Port.html#open/2","source_doc":"Opens a port given a tuple `name` and a list of `options`.\n\nThe module documentation above contains documentation and examples\nfor the supported `name` values, summarized below:\n\n  * `{:spawn, command}` - runs an external program. `command` must contain\n    the program name and optionally a list of arguments separated by space.\n    If passing programs or arguments with space in their name, use the next option.\n  * `{:spawn_executable, filename}` - runs the executable given by the absolute\n    file name `filename`. Arguments can be passed via the `:args` option.\n  * `{:spawn_driver, command}` - spawns so-called port drivers.\n  * `{:fd, fd_in, fd_out}` - accesses file descriptors, `fd_in` and `fd_out`\n    opened by the VM.\n\nFor more information and the list of options, see `:erlang.open_port/2`.\n\nInlined by the compiler.\n","title":"Port.open/2","type":"function"},{"doc":"","ref":"Port.html#t:name/0","source_doc":false,"title":"Port.name/0","type":"type"},{"doc":"Controls an IO device process that wraps a string. A StringIO IO device can be passed as a &quot;device&quot; to most of the functions in the IO module. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;foo&quot; ) iex&gt; IO . read ( pid , 2 ) &quot;fo&quot;","ref":"StringIO.html","source_doc":"Controls an IO device process that wraps a string.\n\nA `StringIO` IO device can be passed as a \"device\" to\nmost of the functions in the `IO` module.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.read(pid, 2)\n    \"fo\"\n\n","title":"StringIO","type":"module"},{"doc":"Stops the IO device and returns the remaining input/output buffers. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;in&quot; ) iex&gt; IO . write ( pid , &quot;out&quot; ) iex&gt; StringIO . close ( pid ) { :ok , { &quot;in&quot; , &quot;out&quot; } }","ref":"StringIO.html#close/1","source_doc":"Stops the IO device and returns the remaining input/output\nbuffers.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.close(pid)\n    {:ok, {\"in\", \"out\"}}\n\n","title":"StringIO.close/1","type":"function"},{"doc":"Returns the current input/output buffers for the given IO device. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;in&quot; ) iex&gt; IO . write ( pid , &quot;out&quot; ) iex&gt; StringIO . contents ( pid ) { &quot;in&quot; , &quot;out&quot; }","ref":"StringIO.html#contents/1","source_doc":"Returns the current input/output buffers for the given IO\ndevice.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.contents(pid)\n    {\"in\", \"out\"}\n\n","title":"StringIO.contents/1","type":"function"},{"doc":"Flushes the output buffer and returns its current contents. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;in&quot; ) iex&gt; IO . write ( pid , &quot;out&quot; ) iex&gt; StringIO . flush ( pid ) &quot;out&quot; iex&gt; StringIO . contents ( pid ) { &quot;in&quot; , &quot;&quot; }","ref":"StringIO.html#flush/1","source_doc":"Flushes the output buffer and returns its current contents.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"in\")\n    iex> IO.write(pid, \"out\")\n    iex> StringIO.flush(pid)\n    \"out\"\n    iex> StringIO.contents(pid)\n    {\"in\", \"\"}\n\n","title":"StringIO.flush/1","type":"function"},{"doc":"Creates an IO device. string will be the initial input of the newly created device. options_or_function can be a keyword list of options or a function. If options are provided, the result will be {:ok, pid} , returning the IO device created. The option :capture_prompt , when set to true , causes prompts (which are specified as arguments to IO.get* functions) to be included in the device's output. If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with :ok and the result of the function. Examples iex&gt; { :ok , pid } = StringIO . open ( &quot;foo&quot; ) iex&gt; IO . gets ( pid , &quot;&gt;&quot; ) &quot;foo&quot; iex&gt; StringIO . contents ( pid ) { &quot;&quot; , &quot;&quot; } iex&gt; { :ok , pid } = StringIO . open ( &quot;foo&quot; , capture_prompt : true ) iex&gt; IO . gets ( pid , &quot;&gt;&quot; ) &quot;foo&quot; iex&gt; StringIO . contents ( pid ) { &quot;&quot; , &quot;&gt;&quot; } iex&gt; StringIO . open ( &quot;foo&quot; , fn pid -&gt; ...&gt; input = IO . gets ( pid , &quot;&gt;&quot; ) ...&gt; IO . write ( pid , &quot;The input was \#{ input } &quot; ) ...&gt; StringIO . contents ( pid ) ...&gt; end ) { :ok , { &quot;&quot; , &quot;The input was foo&quot; } }","ref":"StringIO.html#open/2","source_doc":"Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\n`options_or_function` can be a keyword list of options or\na function.\n\nIf options are provided, the result will be `{:ok, pid}`, returning the\nIO device created. The option `:capture_prompt`, when set to `true`, causes\nprompts (which are specified as arguments to `IO.get*` functions) to be\nincluded in the device's output.\n\nIf a function is provided, the device will be created and sent to the\nfunction. When the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Examples\n\n    iex> {:ok, pid} = StringIO.open(\"foo\")\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \"\"}\n\n    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n    iex> IO.gets(pid, \">\")\n    \"foo\"\n    iex> StringIO.contents(pid)\n    {\"\", \">\"}\n\n    iex> StringIO.open(\"foo\", fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was \#{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n","title":"StringIO.open/2","type":"function"},{"doc":"Creates an IO device. string will be the initial input of the newly created device. The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with :ok and the result of the function. Options :capture_prompt - if set to true , prompts (specified as arguments to IO.get* functions) are captured in the output. Defaults to false . :encoding (since v1.10.0) - encoding of the IO device. Allowed values are :unicode (default) and :latin1 . Examples iex&gt; StringIO . open ( &quot;foo&quot; , [ ] , fn pid -&gt; ...&gt; input = IO . gets ( pid , &quot;&gt;&quot; ) ...&gt; IO . write ( pid , &quot;The input was \#{ input } &quot; ) ...&gt; StringIO . contents ( pid ) ...&gt; end ) { :ok , { &quot;&quot; , &quot;The input was foo&quot; } } iex&gt; StringIO . open ( &quot;foo&quot; , [ capture_prompt : true ] , fn pid -&gt; ...&gt; input = IO . gets ( pid , &quot;&gt;&quot; ) ...&gt; IO . write ( pid , &quot;The input was \#{ input } &quot; ) ...&gt; StringIO . contents ( pid ) ...&gt; end ) { :ok , { &quot;&quot; , &quot;&gt;The input was foo&quot; } }","ref":"StringIO.html#open/3","source_doc":"Creates an IO device.\n\n`string` will be the initial input of the newly created\ndevice.\n\nThe device will be created and sent to the function given.\nWhen the function returns, the device will be closed. The final\nresult will be a tuple with `:ok` and the result of the function.\n\n## Options\n\n  * `:capture_prompt` - if set to `true`, prompts (specified as\n    arguments to `IO.get*` functions) are captured in the output.\n    Defaults to `false`.\n\n  * `:encoding` (since v1.10.0) - encoding of the IO device. Allowed\n    values are `:unicode` (default) and `:latin1`.\n\n## Examples\n\n    iex> StringIO.open(\"foo\", [], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was \#{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \"The input was foo\"}}\n\n    iex> StringIO.open(\"foo\", [capture_prompt: true], fn pid ->\n    ...>   input = IO.gets(pid, \">\")\n    ...>   IO.write(pid, \"The input was \#{input}\")\n    ...>   StringIO.contents(pid)\n    ...> end)\n    {:ok, {\"\", \">The input was foo\"}}\n\n","title":"StringIO.open/3","type":"function"},{"doc":"The System module provides functions that interact directly with the VM or the host system. Time The System module also provides functions that work with time, returning different times kept by the system with support for different time units. One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes &quot;time warps&quot;. In order to understand how such changes may be harmful, imagine the following code: ## DO NOT DO THIS prev = System . os_time ( ) # ... execute some code ... next = System . os_time ( ) diff = next - prev If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via System.monotonic_time/0 which never decreases and does not leap: ## DO THIS prev = System . monotonic_time ( ) # ... execute some code ... next = System . monotonic_time ( ) diff = next - prev Generally speaking, the VM provides three time measurements: os_time/0 - the time reported by the operating system (OS). This time may be adjusted forwards or backwards in time with no limitation; system_time/0 - the VM view of the os_time/0 . The system time and operating system time may not match in case of time warps although the VM works towards aligning them. This time is not monotonic (i.e., it may decrease) as its behaviour is configured by the VM time warp mode ; monotonic_time/0 - a monotonically increasing time provided by the Erlang VM. This is not strictly monotonically increasing. Multiple sequential calls of the function may return the same value. The time functions in this module work in the :native unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the :native unit, to avoid loss of precision, with convert_time_unit/3 being invoked at the end to convert to a specific time unit like :millisecond or :microsecond . See the time_unit/0 type for more information. For a more complete rundown on the VM support for different times, see the chapter on time and time correction in the Erlang docs.","ref":"System.html","source_doc":"The `System` module provides functions that interact directly\nwith the VM or the host system.\n\n## Time\n\nThe `System` module also provides functions that work with time,\nreturning different times kept by the system with support for\ndifferent time units.\n\nOne of the complexities in relying on system times is that they\nmay be adjusted. For example, when you enter and leave daylight\nsaving time, the system clock will be adjusted, often adding\nor removing one hour. We call such changes \"time warps\". In\norder to understand how such changes may be harmful, imagine\nthe following code:\n\n    ## DO NOT DO THIS\n    prev = System.os_time()\n    # ... execute some code ...\n    next = System.os_time()\n    diff = next - prev\n\nIf, while the code is executing, the system clock changes,\nsome code that executed in 1 second may be reported as taking\nover 1 hour! To address such concerns, the VM provides a\nmonotonic time via `System.monotonic_time/0` which never\ndecreases and does not leap:\n\n    ## DO THIS\n    prev = System.monotonic_time()\n    # ... execute some code ...\n    next = System.monotonic_time()\n    diff = next - prev\n\nGenerally speaking, the VM provides three time measurements:\n\n  * `os_time/0` - the time reported by the operating system (OS). This time may be\n    adjusted forwards or backwards in time with no limitation;\n\n  * `system_time/0` - the VM view of the `os_time/0`. The system time and operating\n    system time may not match in case of time warps although the VM works towards\n    aligning them. This time is not monotonic (i.e., it may decrease)\n    as its behaviour is configured [by the VM time warp\n    mode](https://www.erlang.org/doc/apps/erts/time_correction.html#Time_Warp_Modes);\n\n  * `monotonic_time/0` - a monotonically increasing time provided\n    by the Erlang VM. This is not strictly monotonically increasing. Multiple\n    sequential calls of the function may return the same value.\n\nThe time functions in this module work in the `:native` unit\n(unless specified otherwise), which is operating system dependent. Most of\nthe time, all calculations are done in the `:native` unit, to\navoid loss of precision, with `convert_time_unit/3` being\ninvoked at the end to convert to a specific time unit like\n`:millisecond` or `:microsecond`. See the `t:time_unit/0` type for\nmore information.\n\nFor a more complete rundown on the VM support for different\ntimes, see the [chapter on time and time\ncorrection](https://www.erlang.org/doc/apps/erts/time_correction.html)\nin the Erlang docs.\n","title":"System","type":"module"},{"doc":"Lists command line arguments. Returns the list of command line arguments passed to the program.","ref":"System.html#argv/0","source_doc":"Lists command line arguments.\n\nReturns the list of command line arguments passed to the program.\n","title":"System.argv/0","type":"function"},{"doc":"Modifies command line arguments. Changes the list of command line arguments. Use it with caution, as it destroys any previous argv information.","ref":"System.html#argv/1","source_doc":"Modifies command line arguments.\n\nChanges the list of command line arguments. Use it with caution,\nas it destroys any previous argv information.\n","title":"System.argv/1","type":"function"},{"doc":"Registers a program exit handler function. Registers a function that will be invoked at the end of an Elixir script. A script is typically started via the command line via the elixir and mix executables. The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, and others) won't be available by the time the handler function is invoked. The function must receive the exit status code as an argument. If the VM terminates programmatically, via System.stop/1 , System.halt/1 , or exit signals, the at_exit/1 callbacks are not guaranteed to be executed.","ref":"System.html#at_exit/1","source_doc":"Registers a program exit handler function.\n\nRegisters a function that will be invoked at the end of an Elixir script.\nA script is typically started via the command line via the `elixir` and\n`mix` executables.\n\nThe handler always executes in a different process from the one it was\nregistered in. As a consequence, any resources managed by the calling process\n(ETS tables, open files, and others) won't be available by the time the handler\nfunction is invoked.\n\nThe function must receive the exit status code as an argument.\n\nIf the VM terminates programmatically, via `System.stop/1`, `System.halt/1`,\nor exit signals, the `at_exit/1` callbacks are not guaranteed to be executed.\n","title":"System.at_exit/1","type":"function"},{"doc":"Elixir build information. Returns a map with the Elixir version, the Erlang/OTP release it was compiled with, a short Git revision hash and the date and time it was built. Every value in the map is a string, and these are: :build - the Elixir version, short Git revision hash and Erlang/OTP release it was compiled with :date - a string representation of the ISO8601 date and time it was built :otp_release - OTP release it was compiled with :revision - short Git revision hash. If Git was not available at building time, it is set to &quot;&quot; :version - the Elixir version One should not rely on the specific formats returned by each of those fields. Instead one should use specialized functions, such as version/0 to retrieve the Elixir version and otp_release/0 to retrieve the Erlang/OTP release. Examples iex&gt; System . build_info ( ) %{ build : &quot;1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)&quot; , date : &quot;2018-12-24T01:09:21Z&quot; , otp_release : &quot;21&quot; , revision : &quot;772a00a0c&quot; , version : &quot;1.9.0-dev&quot; }","ref":"System.html#build_info/0","source_doc":"Elixir build information.\n\nReturns a map with the Elixir version, the Erlang/OTP release it was compiled\nwith, a short Git revision hash and the date and time it was built.\n\nEvery value in the map is a string, and these are:\n\n  * `:build` - the Elixir version, short Git revision hash and\n    Erlang/OTP release it was compiled with\n  * `:date` - a string representation of the ISO8601 date and time it was built\n  * `:otp_release` - OTP release it was compiled with\n  * `:revision` - short Git revision hash. If Git was not available at building\n    time, it is set to `\"\"`\n  * `:version` - the Elixir version\n\nOne should not rely on the specific formats returned by each of those fields.\nInstead one should use specialized functions, such as `version/0` to retrieve\nthe Elixir version and `otp_release/0` to retrieve the Erlang/OTP release.\n\n## Examples\n\n    iex> System.build_info()\n    %{\n      build: \"1.9.0-dev (772a00a0c) (compiled with Erlang/OTP 21)\",\n      date: \"2018-12-24T01:09:21Z\",\n      otp_release: \"21\",\n      revision: \"772a00a0c\",\n      version: \"1.9.0-dev\"\n    }\n\n","title":"System.build_info/0","type":"function"},{"doc":"Executes the given command with args . command is expected to be an executable available in PATH unless an absolute path is given. args must be a list of binaries which the executable will receive as its arguments as is. This means that: environment variables will not be interpolated wildcard expansion will not happen (unless Path.wildcard/2 is used explicitly) arguments do not need to be escaped or quoted for shell safety This function returns a tuple containing the collected result and the command exit status. Internally, this function uses a Port for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the Port module describes this problem and possible solutions under the &quot;Zombie processes&quot; section. Examples iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello&quot; ] ) { &quot;hello \\n &quot; , 0 } iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello&quot; ] , env : [ { &quot;MIX_ENV&quot; , &quot;test&quot; } ] ) { &quot;hello \\n &quot; , 0 } If you want to stream the output to Standard IO as it arrives: iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello&quot; ] , into : IO . stream ( ) ) hello { % IO.Stream { } , 0 } If you want to read lines: iex&gt; System . cmd ( &quot;echo&quot; , [ &quot;hello \\n world&quot; ] , into : [ ] , lines : 1024 ) { [ &quot;hello&quot; , &quot;world&quot; ] , 0 } Options :into - injects the result into the given collectable, defaults to &quot;&quot; :lines - (since v1.15.0) reads the output by lines instead of in bytes. It expects a number of maximum bytes to buffer internally (1024 is a reasonable default). The collectable will be called with each finished line (regardless of buffer size) and without the EOL character :cd - the directory to run the command in :env - an enumerable of tuples containing environment key-value as binary. The child process inherits all environment variables from its parent process, the Elixir application, except those overwritten or cleared using this option. Specify a value of nil to clear (unset) an environment variable, which is useful for preventing credentials passed to the application from leaking into child processes :arg0 - sets the command arg0 :stderr_to_stdout - redirects stderr to stdout when true :parallelism - when true , the VM will schedule port tasks to improve parallelism in the system. If set to false , the VM will try to perform commands immediately, improving latency at the expense of parallelism. The default is false , and can be set on system startup by passing the +spp flag to --erl . Use :erlang.system_info(:port_parallelism) to check if enabled. Error reasons If invalid arguments are given, ArgumentError is raised by System.cmd/3 . System.cmd/3 also expects a strict set of options and will raise if unknown or invalid options are given. Furthermore, System.cmd/3 may fail with one of the POSIX reasons detailed below: :system_limit - all available ports in the Erlang emulator are in use :enomem - there was not enough memory to create the port :eagain - there are no more available operating system processes :enametoolong - the external command given was too long :emfile - there are no more available file descriptors (for the operating system process that the Erlang emulator runs in) :enfile - the file table is full (for the entire operating system) :eacces - the command does not point to an executable file :enoent - the command does not point to an existing file Shell commands If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check shell/2 .","ref":"System.html#cmd/3","source_doc":"Executes the given `command` with `args`.\n\n`command` is expected to be an executable available in PATH\nunless an absolute path is given.\n\n`args` must be a list of binaries which the executable will receive\nas its arguments as is. This means that:\n\n  * environment variables will not be interpolated\n  * wildcard expansion will not happen (unless `Path.wildcard/2` is used\n    explicitly)\n  * arguments do not need to be escaped or quoted for shell safety\n\nThis function returns a tuple containing the collected result\nand the command exit status.\n\nInternally, this function uses a `Port` for interacting with the\noutside world. However, if you plan to run a long-running program,\nports guarantee stdin/stdout devices will be closed but it does not\nautomatically terminate the program. The documentation for the\n`Port` module describes this problem and possible solutions under\nthe \"Zombie processes\" section.\n\n## Examples\n\n    iex> System.cmd(\"echo\", [\"hello\"])\n    {\"hello\\n\", 0}\n\n    iex> System.cmd(\"echo\", [\"hello\"], env: [{\"MIX_ENV\", \"test\"}])\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.cmd(\"echo\", [\"hello\"], into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\nIf you want to read lines:\n\n    iex> System.cmd(\"echo\", [\"hello\\nworld\"], into: [], lines: 1024)\n    {[\"hello\", \"world\"], 0}\n\n## Options\n\n  * `:into` - injects the result into the given collectable, defaults to `\"\"`\n\n  * `:lines` - (since v1.15.0) reads the output by lines instead of in bytes. It expects a\n    number of maximum bytes to buffer internally (1024 is a reasonable default).\n    The collectable will be called with each finished line (regardless of buffer\n    size) and without the EOL character\n\n  * `:cd` - the directory to run the command in\n\n  * `:env` - an enumerable of tuples containing environment key-value as\n    binary. The child process inherits all environment variables from its\n    parent process, the Elixir application, except those overwritten or\n    cleared using this option. Specify a value of `nil` to clear (unset) an\n    environment variable, which is useful for preventing credentials passed\n    to the application from leaking into child processes\n\n  * `:arg0` - sets the command arg0\n\n  * `:stderr_to_stdout` - redirects stderr to stdout when `true`\n\n  * `:parallelism` - when `true`, the VM will schedule port tasks to improve\n    parallelism in the system. If set to `false`, the VM will try to perform\n    commands immediately, improving latency at the expense of parallelism.\n    The default is `false`, and can be set on system startup by passing the \n    [`+spp`](https://www.erlang.org/doc/man/erl.html#+spp) flag to `--erl`. \n    Use `:erlang.system_info(:port_parallelism)` to check if enabled.\n\n## Error reasons\n\nIf invalid arguments are given, `ArgumentError` is raised by\n`System.cmd/3`. `System.cmd/3` also expects a strict set of\noptions and will raise if unknown or invalid options are given.\n\nFurthermore, `System.cmd/3` may fail with one of the POSIX reasons\ndetailed below:\n\n  * `:system_limit` - all available ports in the Erlang emulator are in use\n\n  * `:enomem` - there was not enough memory to create the port\n\n  * `:eagain` - there are no more available operating system processes\n\n  * `:enametoolong` - the external command given was too long\n\n  * `:emfile` - there are no more available file descriptors\n    (for the operating system process that the Erlang emulator runs in)\n\n  * `:enfile` - the file table is full (for the entire operating system)\n\n  * `:eacces` - the command does not point to an executable file\n\n  * `:enoent` - the command does not point to an existing file\n\n## Shell commands\n\nIf you desire to execute a trusted command inside a shell, with pipes,\nredirecting and so on, please check `shell/2`.\n","title":"System.cmd/3","type":"function"},{"doc":"Returns the endianness the system was compiled with.","ref":"System.html#compiled_endianness/0","source_doc":"Returns the endianness the system was compiled with.\n","title":"System.compiled_endianness/0","type":"function"},{"doc":"Converts time from time unit from_unit to time unit to_unit . The result is rounded via the floor function. convert_time_unit/3 accepts an additional time unit (other than the ones in the time_unit/0 type) called :native . :native is the time unit used by the Erlang runtime system. It's determined when the runtime starts and stays the same until the runtime is stopped, but could differ the next time the runtime is started on the same machine. For this reason, you should use this function to convert :native time units to a predictable unit before you display them to humans. To determine how many seconds the :native unit represents in your current runtime, you can call this function to convert 1 second to the :native time unit: System.convert_time_unit(1, :second, :native) .","ref":"System.html#convert_time_unit/3","source_doc":"Converts `time` from time unit `from_unit` to time unit `to_unit`.\n\nThe result is rounded via the floor function.\n\n`convert_time_unit/3` accepts an additional time unit (other than the\nones in the `t:time_unit/0` type) called `:native`. `:native` is the time\nunit used by the Erlang runtime system. It's determined when the runtime\nstarts and stays the same until the runtime is stopped, but could differ\nthe next time the runtime is started on the same machine. For this reason,\nyou should use this function to convert `:native` time units to a predictable\nunit before you display them to humans.\n\nTo determine how many seconds the `:native` unit represents in your current\nruntime, you can call this function to convert 1 second to the `:native`\ntime unit: `System.convert_time_unit(1, :second, :native)`.\n","title":"System.convert_time_unit/3","type":"function"},{"doc":"Current working directory. Returns the current working directory or nil if one is not available.","ref":"System.html#cwd/0","source_doc":"Current working directory.\n\nReturns the current working directory or `nil` if one\nis not available.\n","title":"System.cwd/0","type":"function"},{"doc":"Current working directory, exception on error. Returns the current working directory or raises RuntimeError .","ref":"System.html#cwd!/0","source_doc":"Current working directory, exception on error.\n\nReturns the current working directory or raises `RuntimeError`.\n","title":"System.cwd!/0","type":"function"},{"doc":"Deletes an environment variable. Removes the variable varname from the environment.","ref":"System.html#delete_env/1","source_doc":"Deletes an environment variable.\n\nRemoves the variable `varname` from the environment.\n","title":"System.delete_env/1","type":"function"},{"doc":"Returns the endianness.","ref":"System.html#endianness/0","source_doc":"Returns the endianness.\n","title":"System.endianness/0","type":"function"},{"doc":"Returns the value of the given environment variable or :error if not found. If the environment variable varname is set, then {:ok, value} is returned where value is a string. If varname is not set, :error is returned. Examples iex&gt; System . fetch_env ( &quot;PORT&quot; ) { :ok , &quot;4000&quot; } iex&gt; System . fetch_env ( &quot;NOT_SET&quot; ) :error","ref":"System.html#fetch_env/1","source_doc":"Returns the value of the given environment variable or `:error` if not found.\n\nIf the environment variable `varname` is set, then `{:ok, value}` is returned\nwhere `value` is a string. If `varname` is not set, `:error` is returned.\n\n## Examples\n\n    iex> System.fetch_env(\"PORT\")\n    {:ok, \"4000\"}\n\n    iex> System.fetch_env(\"NOT_SET\")\n    :error\n\n","title":"System.fetch_env/1","type":"function"},{"doc":"Returns the value of the given environment variable or raises if not found. Same as get_env/1 but raises instead of returning nil when the variable is not set. Examples iex&gt; System . fetch_env! ( &quot;PORT&quot; ) &quot;4000&quot; iex&gt; System . fetch_env! ( &quot;NOT_SET&quot; ) ** (System.EnvError) could not fetch environment variable &quot;NOT_SET&quot; because it is not set","ref":"System.html#fetch_env!/1","source_doc":"Returns the value of the given environment variable or raises if not found.\n\nSame as `get_env/1` but raises instead of returning `nil` when the variable is\nnot set.\n\n## Examples\n\n    iex> System.fetch_env!(\"PORT\")\n    \"4000\"\n\n    iex> System.fetch_env!(\"NOT_SET\")\n    ** (System.EnvError) could not fetch environment variable \"NOT_SET\" because it is not set\n\n","title":"System.fetch_env!/1","type":"function"},{"doc":"Locates an executable on the system. This function looks up an executable program given its name using the environment variable PATH on Windows and Unix-like operating systems. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with .com , .cmd or similar extensions.","ref":"System.html#find_executable/1","source_doc":"Locates an executable on the system.\n\nThis function looks up an executable program given\nits name using the environment variable PATH on Windows and Unix-like\noperating systems. It also considers the proper executable\nextension for each operating system, so for Windows it will try to\nlookup files with `.com`, `.cmd` or similar extensions.\n","title":"System.find_executable/1","type":"function"},{"doc":"Returns all system environment variables. The returned value is a map containing name-value pairs. Variable names and their values are strings.","ref":"System.html#get_env/0","source_doc":"Returns all system environment variables.\n\nThe returned value is a map containing name-value pairs.\nVariable names and their values are strings.\n","title":"System.get_env/0","type":"function"},{"doc":"Returns the value of the given environment variable. The returned value of the environment variable varname is a string. If the environment variable is not set, returns the string specified in default or nil if none is specified. Examples iex&gt; System . get_env ( &quot;PORT&quot; ) &quot;4000&quot; iex&gt; System . get_env ( &quot;NOT_SET&quot; ) nil iex&gt; System . get_env ( &quot;NOT_SET&quot; , &quot;4001&quot; ) &quot;4001&quot;","ref":"System.html#get_env/2","source_doc":"Returns the value of the given environment variable.\n\nThe returned value of the environment variable\n`varname` is a string. If the environment variable\nis not set, returns the string specified in `default` or\n`nil` if none is specified.\n\n## Examples\n\n    iex> System.get_env(\"PORT\")\n    \"4000\"\n\n    iex> System.get_env(\"NOT_SET\")\n    nil\n\n    iex> System.get_env(\"NOT_SET\", \"4001\")\n    \"4001\"\n\n","title":"System.get_env/2","type":"function"},{"doc":"Erlang VM process identifier. Returns the process identifier of the current Erlang emulator in the format most commonly used by the operating system environment. For more information, see :os.getpid/0 .","ref":"System.html#get_pid/0","source_doc":"Erlang VM process identifier.\n\nReturns the process identifier of the current Erlang emulator\nin the format most commonly used by the operating system environment.\n\nFor more information, see `:os.getpid/0`.\n","title":"System.get_pid/0","type":"function"},{"doc":"Immediately halts the Erlang runtime system. Terminates the Erlang runtime system without properly shutting down applications and ports. Please see stop/1 for a careful shutdown of the system. status must be a non-negative integer, the atom :abort or a binary. If an integer, the runtime system exits with the integer value which is returned to the operating system. If :abort , the runtime system aborts producing a core dump, if that is enabled in the operating system. If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1. Note that on many platforms, only the status codes 0-255 are supported by the operating system. For more information, see :erlang.halt/1 . Examples System . halt ( 0 ) System . halt ( 1 ) System . halt ( :abort )","ref":"System.html#halt/1","source_doc":"Immediately halts the Erlang runtime system.\n\nTerminates the Erlang runtime system without properly shutting down\napplications and ports. Please see `stop/1` for a careful shutdown of the\nsystem.\n\n`status` must be a non-negative integer, the atom `:abort` or a binary.\n\n  * If an integer, the runtime system exits with the integer value which\n    is returned to the operating system.\n\n  * If `:abort`, the runtime system aborts producing a core dump, if that is\n    enabled in the operating system.\n\n  * If a string, an Erlang crash dump is produced with status as slogan,\n    and then the runtime system exits with status code 1.\n\nNote that on many platforms, only the status codes 0-255 are supported\nby the operating system.\n\nFor more information, see `:erlang.halt/1`.\n\n## Examples\n\n    System.halt(0)\n    System.halt(1)\n    System.halt(:abort)\n\n","title":"System.halt/1","type":"function"},{"doc":"Returns the current monotonic time in the :native time unit. This time is monotonically increasing and starts in an unspecified point in time. This is not strictly monotonically increasing. Multiple sequential calls of the function may return the same value. Inlined by the compiler.","ref":"System.html#monotonic_time/0","source_doc":"Returns the current monotonic time in the `:native` time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time. This is not strictly monotonically increasing. Multiple\nsequential calls of the function may return the same value.\n\nInlined by the compiler.\n","title":"System.monotonic_time/0","type":"function"},{"doc":"Returns the current monotonic time in the given time unit. This time is monotonically increasing and starts in an unspecified point in time.","ref":"System.html#monotonic_time/1","source_doc":"Returns the current monotonic time in the given time unit.\n\nThis time is monotonically increasing and starts in an unspecified\npoint in time.\n","title":"System.monotonic_time/1","type":"function"},{"doc":"Checks if the system will halt or not at the end of ARGV processing.","ref":"System.html#no_halt/0","source_doc":"Checks if the system will halt or not at the end of ARGV processing.\n","title":"System.no_halt/0","type":"function"},{"doc":"Marks if the system should halt or not at the end of ARGV processing.","ref":"System.html#no_halt/1","source_doc":"Marks if the system should halt or not at the end of ARGV processing.\n","title":"System.no_halt/1","type":"function"},{"doc":"Returns the current operating system (OS) time. The result is returned in the :native time unit. This time may be adjusted forwards or backwards in time with no limitation and is not monotonic. Inlined by the compiler.","ref":"System.html#os_time/0","source_doc":"Returns the current operating system (OS) time.\n\nThe result is returned in the `:native` time unit.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n\nInlined by the compiler.\n","title":"System.os_time/0","type":"function"},{"doc":"Returns the current operating system (OS) time in the given time unit . This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.","ref":"System.html#os_time/1","source_doc":"Returns the current operating system (OS) time in the given time `unit`.\n\nThis time may be adjusted forwards or backwards in time\nwith no limitation and is not monotonic.\n","title":"System.os_time/1","type":"function"},{"doc":"Returns the Erlang/OTP release number.","ref":"System.html#otp_release/0","source_doc":"Returns the Erlang/OTP release number.\n","title":"System.otp_release/0","type":"function"},{"doc":"Returns the operating system PID for the current Erlang runtime system instance. Returns a string containing the (usually) numerical identifier for a process. On Unix-like operating systems, this is typically the return value of the getpid() system call. On Windows, the process ID as returned by the GetCurrentProcessId() system call is used. Examples System . pid ( )","ref":"System.html#pid/0","source_doc":"Returns the operating system PID for the current Erlang runtime system instance.\n\nReturns a string containing the (usually) numerical identifier for a process.\nOn Unix-like operating systems, this is typically the return value of the `getpid()` system call.\nOn Windows, the process ID as returned by the `GetCurrentProcessId()` system\ncall is used.\n\n## Examples\n\n    System.pid()\n\n","title":"System.pid/0","type":"function"},{"doc":"Sets multiple environment variables. Sets a new value for each environment variable corresponding to each {key, value} pair in enum . Keys are automatically converted to strings, values are sent as is. nil values erase the given keys.","ref":"System.html#put_env/1","source_doc":"Sets multiple environment variables.\n\nSets a new value for each environment variable corresponding\nto each `{key, value}` pair in `enum`. Keys are automatically\nconverted to strings, values are sent as is. `nil` values erase\nthe given keys.\n","title":"System.put_env/1","type":"function"},{"doc":"Sets an environment variable value. Sets a new value for the environment variable varname .","ref":"System.html#put_env/2","source_doc":"Sets an environment variable value.\n\nSets a new `value` for the environment variable `varname`.\n","title":"System.put_env/2","type":"function"},{"doc":"Restarts all applications in the Erlang runtime system. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system starts all applications once again. Examples System . restart ( )","ref":"System.html#restart/0","source_doc":"Restarts all applications in the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system starts all applications once again.\n\n## Examples\n\n    System.restart()\n\n","title":"System.restart/0","type":"function"},{"doc":"Returns the number of schedulers in the VM.","ref":"System.html#schedulers/0","source_doc":"Returns the number of schedulers in the VM.\n","title":"System.schedulers/0","type":"function"},{"doc":"Returns the number of schedulers online in the VM.","ref":"System.html#schedulers_online/0","source_doc":"Returns the number of schedulers online in the VM.\n","title":"System.schedulers_online/0","type":"function"},{"doc":"Executes the given command in the OS shell. It uses sh for Unix-like systems and cmd for Windows. Watch out Use this function with care. In particular, never pass untrusted user input to this function , as the user would be able to perform &quot;command injection attacks&quot; by executing any code directly on the machine. Generally speaking, prefer to use cmd/3 over this function. Examples iex&gt; System . shell ( &quot;echo hello&quot; ) { &quot;hello \\n &quot; , 0 } If you want to stream the output to Standard IO as it arrives: iex&gt; System . shell ( &quot;echo hello&quot; , into : IO . stream ( ) ) hello { % IO.Stream { } , 0 } Options It accepts the same options as cmd/3 (except for arg0 ). It also accepts the following exclusive options: :close_stdin (since v1.14.1) - if the stdin should be closed on Unix systems, forcing any command that waits on stdin to immediately terminate. Defaults to false.","ref":"System.html#shell/2","source_doc":"Executes the given `command` in the OS shell.\n\nIt uses `sh` for Unix-like systems and `cmd` for Windows.\n\n> #### Watch out {: .warning}\n>\n> Use this function with care. In particular, **never\n> pass untrusted user input to this function**, as the user would be\n> able to perform \"command injection attacks\" by executing any code\n> directly on the machine. Generally speaking, prefer to use `cmd/3`\n> over this function.\n\n## Examples\n\n    iex> System.shell(\"echo hello\")\n    {\"hello\\n\", 0}\n\nIf you want to stream the output to Standard IO as it arrives:\n\n    iex> System.shell(\"echo hello\", into: IO.stream())\n    hello\n    {%IO.Stream{}, 0}\n\n## Options\n\nIt accepts the same options as `cmd/3` (except for `arg0`).\nIt also accepts the following exclusive options:\n\n  * `:close_stdin` (since v1.14.1) - if the stdin should be closed\n    on Unix systems, forcing any command that waits on stdin to\n    immediately terminate. Defaults to false.\n","title":"System.shell/2","type":"function"},{"doc":"Deprecated mechanism to retrieve the last exception stacktrace. It always return an empty list.","ref":"System.html#stacktrace/0","source_doc":"Deprecated mechanism to retrieve the last exception stacktrace.\n\nIt always return an empty list.\n","title":"System.stacktrace/0","type":"function"},{"doc":"Asynchronously and carefully stops the Erlang runtime system. All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling halt/1 . status must be a non-negative integer or a binary. If an integer, the runtime system exits with the integer value which is returned to the operating system. On many platforms, only the status codes 0-255 are supported by the operating system. If a binary, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1. Note this function is asynchronous and the current process will continue executing after this function is invoked. In case you want to block the current process until the system effectively shuts down, you can invoke Process.sleep(:infinity) . Examples System . stop ( 0 ) System . stop ( 1 )","ref":"System.html#stop/1","source_doc":"Asynchronously and carefully stops the Erlang runtime system.\n\nAll applications are taken down smoothly, all code is unloaded, and all ports\nare closed before the system terminates by calling `halt/1`.\n\n`status` must be a non-negative integer or a binary.\n\n  * If an integer, the runtime system exits with the integer value which is\n    returned to the operating system. On many platforms, only the status codes\n    0-255 are supported by the operating system.\n\n  * If a binary, an Erlang crash dump is produced with status as slogan, and\n    then the runtime system exits with status code 1.\n\nNote this function is asynchronous and the current process will continue\nexecuting after this function is invoked. In case you want to block the\ncurrent process until the system effectively shuts down, you can invoke\n`Process.sleep(:infinity)`.\n\n## Examples\n\n    System.stop(0)\n    System.stop(1)\n\n","title":"System.stop/1","type":"function"},{"doc":"Returns the current system time in the :native time unit. It is the VM view of the os_time/0 . They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic. Inlined by the compiler.","ref":"System.html#system_time/0","source_doc":"Returns the current system time in the `:native` time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n\nInlined by the compiler.\n","title":"System.system_time/0","type":"function"},{"doc":"Returns the current system time in the given time unit. It is the VM view of the os_time/0 . They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.","ref":"System.html#system_time/1","source_doc":"Returns the current system time in the given time unit.\n\nIt is the VM view of the `os_time/0`. They may not match in\ncase of time warps although the VM works towards aligning\nthem. This time is not monotonic.\n","title":"System.system_time/1","type":"function"},{"doc":"Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time. The result is returned in the :native time unit. See time_offset/1 for more information. Inlined by the compiler.","ref":"System.html#time_offset/0","source_doc":"Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the `:native` time unit.\n\nSee `time_offset/1` for more information.\n\nInlined by the compiler.\n","title":"System.time_offset/0","type":"function"},{"doc":"Returns the current time offset between the Erlang VM monotonic time and the Erlang VM system time. The result is returned in the given time unit unit . The returned offset, added to an Erlang monotonic time (for instance, one obtained with monotonic_time/1 ), gives the Erlang system time that corresponds to that monotonic time.","ref":"System.html#time_offset/1","source_doc":"Returns the current time offset between the Erlang VM monotonic\ntime and the Erlang VM system time.\n\nThe result is returned in the given time unit `unit`. The returned\noffset, added to an Erlang monotonic time (for instance, one obtained with\n`monotonic_time/1`), gives the Erlang system time that corresponds\nto that monotonic time.\n","title":"System.time_offset/1","type":"function"},{"doc":"Writable temporary directory. Returns a writable temporary directory. Searches for directories in the following order: the directory named by the TMPDIR environment variable the directory named by the TEMP environment variable the directory named by the TMP environment variable C:\\TMP on Windows or /tmp on Unix-like operating systems as a last resort, the current working directory Returns nil if none of the above are writable.","ref":"System.html#tmp_dir/0","source_doc":"Writable temporary directory.\n\nReturns a writable temporary directory.\nSearches for directories in the following order:\n\n  1. the directory named by the TMPDIR environment variable\n  2. the directory named by the TEMP environment variable\n  3. the directory named by the TMP environment variable\n  4. `C:\\TMP` on Windows or `/tmp` on Unix-like operating systems\n  5. as a last resort, the current working directory\n\nReturns `nil` if none of the above are writable.\n","title":"System.tmp_dir/0","type":"function"},{"doc":"Writable temporary directory, exception on error. Same as tmp_dir/0 but raises RuntimeError instead of returning nil if no temp dir is set.","ref":"System.html#tmp_dir!/0","source_doc":"Writable temporary directory, exception on error.\n\nSame as `tmp_dir/0` but raises `RuntimeError`\ninstead of returning `nil` if no temp dir is set.\n","title":"System.tmp_dir!/0","type":"function"},{"doc":"Traps the given signal to execute the fun . Avoid setting traps in libraries Trapping signals may have strong implications on how a system shuts down and behaves in production and therefore it is extremely discouraged for libraries to set their own traps. Instead, they should redirect users to configure them themselves. The only cases where it is acceptable for libraries to set their own traps is when using Elixir in script mode, such as in .exs files and via Mix tasks. An optional id that uniquely identifies the function can be given, otherwise a unique one is automatically generated. If a previously registered id is given, this function returns an error tuple. The id can be used to remove a registered signal by calling untrap_signal/2 . The given fun receives no arguments and it must return :ok . It returns {:ok, id} in case of success, {:error, :already_registered} in case the id has already been registered for the given signal, or {:error, :not_sup} in case trapping exists is not supported by the current OS. The first time a signal is trapped, it will override the default behaviour from the operating system. If the same signal is trapped multiple times, subsequent functions given to trap_signal will execute first . In other words, you can consider each function is prepended to the signal handler. By default, the Erlang VM register traps to the three signals: :sigstop - gracefully shuts down the VM with stop/0 :sigquit - halts the VM via halt/0 :sigusr1 - halts the VM via status code of 1 Therefore, if you add traps to the signals above, the default behaviour above will be executed after all user signals. Implementation notes All signals run from a single process. Therefore, blocking the fun will block subsequent traps. It is also not possible to add or remove traps from within a trap itself. Internally, this functionality is built on top of :os.set_signal/2 . When you register a trap, Elixir automatically sets it to :handle and it reverts it back to :default once all traps are removed (except for :sigquit , :sigterm , and :sigusr1 which are always handled). If you or a library call :os.set_signal/2 directly, it may disable Elixir traps (or Elixir may override your configuration).","ref":"System.html#trap_signal/3","source_doc":"Traps the given `signal` to execute the `fun`.\n\n> #### Avoid setting traps in libraries {: .warning}\n>\n> Trapping signals may have strong implications\n> on how a system shuts down and behaves in production and\n> therefore it is extremely discouraged for libraries to\n> set their own traps. Instead, they should redirect users\n> to configure them themselves. The only cases where it is\n> acceptable for libraries to set their own traps is when\n> using Elixir in script mode, such as in `.exs` files and\n> via Mix tasks.\n\nAn optional `id` that uniquely identifies the function\ncan be given, otherwise a unique one is automatically\ngenerated. If a previously registered `id` is given,\nthis function returns an error tuple. The `id` can be\nused to remove a registered signal by calling\n`untrap_signal/2`.\n\nThe given `fun` receives no arguments and it must return\n`:ok`.\n\nIt returns `{:ok, id}` in case of success,\n`{:error, :already_registered}` in case the id has already\nbeen registered for the given signal, or `{:error, :not_sup}`\nin case trapping exists is not supported by the current OS.\n\nThe first time a signal is trapped, it will override the\ndefault behaviour from the operating system. If the same\nsignal is trapped multiple times, subsequent functions\ngiven to `trap_signal` will execute *first*. In other\nwords, you can consider each function is prepended to\nthe signal handler.\n\nBy default, the Erlang VM register traps to the three\nsignals:\n\n  * `:sigstop` - gracefully shuts down the VM with `stop/0`\n  * `:sigquit` - halts the VM via `halt/0`\n  * `:sigusr1` - halts the VM via status code of 1\n\nTherefore, if you add traps to the signals above, the\ndefault behaviour above will be executed after all user\nsignals.\n\n## Implementation notes\n\nAll signals run from a single process. Therefore, blocking the\n`fun` will block subsequent traps. It is also not possible to add\nor remove traps from within a trap itself.\n\nInternally, this functionality is built on top of `:os.set_signal/2`.\nWhen you register a trap, Elixir automatically sets it to `:handle`\nand it reverts it back to `:default` once all traps are removed\n(except for `:sigquit`, `:sigterm`, and `:sigusr1` which are always\nhandled). If you or a library call `:os.set_signal/2` directly,\nit may disable Elixir traps (or Elixir may override your configuration).\n","title":"System.trap_signal/3","type":"function"},{"doc":"Generates and returns an integer that is unique in the current runtime instance. &quot;Unique&quot; means that this function, called with the same list of modifiers , will never return the same integer more than once on the current runtime instance. If modifiers is [] , then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer: :positive - the returned integer is guaranteed to be positive. :monotonic - the returned integer is monotonically increasing. This means that, on the same runtime instance (but even on different processes), integers returned using the :monotonic modifier will always be strictly less than integers returned by successive calls with the :monotonic modifier. All modifiers listed above can be combined; repeated modifiers in modifiers will be ignored. Inlined by the compiler.","ref":"System.html#unique_integer/1","source_doc":"Generates and returns an integer that is unique in the current runtime\ninstance.\n\n\"Unique\" means that this function, called with the same list of `modifiers`,\nwill never return the same integer more than once on the current runtime\ninstance.\n\nIf `modifiers` is `[]`, then a unique integer (that can be positive or negative) is returned.\nOther modifiers can be passed to change the properties of the returned integer:\n\n  * `:positive` - the returned integer is guaranteed to be positive.\n  * `:monotonic` - the returned integer is monotonically increasing. This\n    means that, on the same runtime instance (but even on different\n    processes), integers returned using the `:monotonic` modifier will always\n    be strictly less than integers returned by successive calls with the\n    `:monotonic` modifier.\n\nAll modifiers listed above can be combined; repeated modifiers in `modifiers`\nwill be ignored.\n\nInlined by the compiler.\n","title":"System.unique_integer/1","type":"function"},{"doc":"Removes a previously registered signal with id .","ref":"System.html#untrap_signal/2","source_doc":"Removes a previously registered `signal` with `id`.\n","title":"System.untrap_signal/2","type":"function"},{"doc":"User home directory. Returns the user home directory (platform independent).","ref":"System.html#user_home/0","source_doc":"User home directory.\n\nReturns the user home directory (platform independent).\n","title":"System.user_home/0","type":"function"},{"doc":"User home directory, exception on error. Same as user_home/0 but raises RuntimeError instead of returning nil if no user home is set.","ref":"System.html#user_home!/0","source_doc":"User home directory, exception on error.\n\nSame as `user_home/0` but raises `RuntimeError`\ninstead of returning `nil` if no user home is set.\n","title":"System.user_home!/0","type":"function"},{"doc":"Elixir version information. Returns Elixir's version as binary.","ref":"System.html#version/0","source_doc":"Elixir version information.\n\nReturns Elixir's version as binary.\n","title":"System.version/0","type":"function"},{"doc":"Waits until the system boots. Calling this function blocks until all of ARGV is processed. Inside a release, this means the boot script and then ARGV have been processed. This is only useful for those implementing custom shells/consoles on top of Elixir. However, be careful to not invoke this command from within the process that is processing the command line arguments, as doing so would lead to a deadlock.","ref":"System.html#wait_until_booted/0","source_doc":"Waits until the system boots.\n\nCalling this function blocks until all of ARGV is processed.\nInside a release, this means the boot script and then ARGV\nhave been processed. This is only useful for those implementing\ncustom shells/consoles on top of Elixir.\n\nHowever, be careful to not invoke this command from within\nthe process that is processing the command line arguments,\nas doing so would lead to a deadlock.\n","title":"System.wait_until_booted/0","type":"function"},{"doc":"","ref":"System.html#t:signal/0","source_doc":false,"title":"System.signal/0","type":"type"},{"doc":"The time unit to be passed to functions like monotonic_time/1 and others. The :second , :millisecond , :microsecond and :nanosecond time units controls the return value of the functions that accept a time unit. A time unit can also be a strictly positive integer. In this case, it represents the &quot;parts per second&quot;: the time will be returned in 1 / parts_per_second seconds. For example, using the :millisecond time unit is equivalent to using 1000 as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).","ref":"System.html#t:time_unit/0","source_doc":"The time unit to be passed to functions like `monotonic_time/1` and others.\n\nThe `:second`, `:millisecond`, `:microsecond` and `:nanosecond` time\nunits controls the return value of the functions that accept a time unit.\n\nA time unit can also be a strictly positive integer. In this case, it\nrepresents the \"parts per second\": the time will be returned in `1 /\nparts_per_second` seconds. For example, using the `:millisecond` time unit\nis equivalent to using `1000` as the time unit (as the time will be returned\nin 1/1000 seconds - milliseconds).\n","title":"System.time_unit/0","type":"type"},{"doc":"This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir. It defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the calendar features in Elixir is to provide a base for interoperability rather than a full-featured datetime API. For the actual date, time and datetime structs, see Date , Time , NaiveDateTime , and DateTime . Types for year, month, day, and more are overspecified . For example, the month/0 type is specified as an integer instead of 1..12 . This is because different calendars may have a different number of days per month.","ref":"Calendar.html","source_doc":"This module defines the responsibilities for working with\ncalendars, dates, times and datetimes in Elixir.\n\nIt defines types and the minimal implementation\nfor a calendar behaviour in Elixir. The goal of the calendar\nfeatures in Elixir is to provide a base for interoperability\nrather than a full-featured datetime API.\n\nFor the actual date, time and datetime structs, see `Date`,\n`Time`, `NaiveDateTime`, and `DateTime`.\n\nTypes for year, month, day, and more are *overspecified*.\nFor example, the `t:month/0` type is specified as an integer\ninstead of `1..12`. This is because different calendars may\nhave a different number of days per month.\n","title":"Calendar","type":"behaviour"},{"doc":"Returns true if two calendars have the same moment of starting a new day, false otherwise. If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.","ref":"Calendar.html#compatible_calendars?/2","source_doc":"Returns `true` if two calendars have the same moment of starting a new day,\n`false` otherwise.\n\nIf two calendars are not compatible, we can only convert datetimes and times\nbetween them. If they are compatible, this means that we can also convert\ndates as well as naive datetimes between them.\n","title":"Calendar.compatible_calendars?/2","type":"function"},{"doc":"Converts the date into a string according to the calendar.","ref":"Calendar.html#c:date_to_string/3","source_doc":"Converts the date into a string according to the calendar.\n","title":"Calendar.date_to_string/3","type":"callback"},{"doc":"Converts the datetime (with time zone) into a string according to the calendar.","ref":"Calendar.html#c:datetime_to_string/11","source_doc":"Converts the datetime (with time zone) into a string according to the calendar.\n","title":"Calendar.datetime_to_string/11","type":"callback"},{"doc":"Calculates the day and era from the given year , month , and day .","ref":"Calendar.html#c:day_of_era/3","source_doc":"Calculates the day and era from the given `year`, `month`, and `day`.\n","title":"Calendar.day_of_era/3","type":"callback"},{"doc":"Calculates the day of the week from the given year , month , and day . starting_on represents the starting day of the week. All calendars must support at least the :default value. They may also support other values representing their days of the week.","ref":"Calendar.html#c:day_of_week/4","source_doc":"Calculates the day of the week from the given `year`, `month`, and `day`.\n\n`starting_on` represents the starting day of the week. All\ncalendars must support at least the `:default` value. They may\nalso support other values representing their days of the week.\n","title":"Calendar.day_of_week/4","type":"callback"},{"doc":"Calculates the day of the year from the given year , month , and day .","ref":"Calendar.html#c:day_of_year/3","source_doc":"Calculates the day of the year from the given `year`, `month`, and `day`.\n","title":"Calendar.day_of_year/3","type":"callback"},{"doc":"Define the rollover moment for the calendar. This is the moment, in your calendar, when the current day ends and the next day starts. The result of this function is used to check if two calendars roll over at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them. This day fraction should be in its most simplified form possible, to make comparisons fast. Examples If in your calendar a new day starts at midnight, return {0, 1} . If in your calendar a new day starts at sunrise, return {1, 4} . If in your calendar a new day starts at noon, return {1, 2} . If in your calendar a new day starts at sunset, return {3, 4} .","ref":"Calendar.html#c:day_rollover_relative_to_midnight_utc/0","source_doc":"Define the rollover moment for the calendar.\n\nThis is the moment, in your calendar, when the current day ends\nand the next day starts.\n\nThe result of this function is used to check if two calendars roll over at\nthe same time of day. If they do not, we can only convert datetimes and times\nbetween them. If they do, this means that we can also convert dates as well\nas naive datetimes between them.\n\nThis day fraction should be in its most simplified form possible, to make comparisons fast.\n\n## Examples\n\n  * If in your calendar a new day starts at midnight, return `{0, 1}`.\n  * If in your calendar a new day starts at sunrise, return `{1, 4}`.\n  * If in your calendar a new day starts at noon, return `{1, 2}`.\n  * If in your calendar a new day starts at sunset, return `{3, 4}`.\n\n","title":"Calendar.day_rollover_relative_to_midnight_utc/0","type":"callback"},{"doc":"Returns how many days there are in the given month of the given year.","ref":"Calendar.html#c:days_in_month/2","source_doc":"Returns how many days there are in the given month of the given year.\n","title":"Calendar.days_in_month/2","type":"callback"},{"doc":"Gets the current time zone database.","ref":"Calendar.html#get_time_zone_database/0","source_doc":"Gets the current time zone database.\n","title":"Calendar.get_time_zone_database/0","type":"function"},{"doc":"Converts the given iso_days/0 to the first moment of the day.","ref":"Calendar.html#c:iso_days_to_beginning_of_day/1","source_doc":"Converts the given `t:iso_days/0` to the first moment of the day.\n","title":"Calendar.iso_days_to_beginning_of_day/1","type":"callback"},{"doc":"Converts the given iso_days/0 to the last moment of the day.","ref":"Calendar.html#c:iso_days_to_end_of_day/1","source_doc":"Converts the given `t:iso_days/0` to the last moment of the day.\n","title":"Calendar.iso_days_to_end_of_day/1","type":"callback"},{"doc":"Returns true if the given year is a leap year. A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return false if it does not support the concept of leap years.","ref":"Calendar.html#c:leap_year?/1","source_doc":"Returns `true` if the given year is a leap year.\n\nA leap year is a year of a longer length than normal. The exact meaning\nis up to the calendar. A calendar must return `false` if it does not support\nthe concept of leap years.\n","title":"Calendar.leap_year?/1","type":"callback"},{"doc":"Returns how many months there are in the given year.","ref":"Calendar.html#c:months_in_year/1","source_doc":"Returns how many months there are in the given year.\n","title":"Calendar.months_in_year/1","type":"callback"},{"doc":"Converts iso_days/0 to the calendar's datetime format.","ref":"Calendar.html#c:naive_datetime_from_iso_days/1","source_doc":"Converts `t:iso_days/0` to the calendar's datetime format.\n","title":"Calendar.naive_datetime_from_iso_days/1","type":"callback"},{"doc":"Converts the datetime (without time zone) into the iso_days/0 format.","ref":"Calendar.html#c:naive_datetime_to_iso_days/7","source_doc":"Converts the datetime (without time zone) into the `t:iso_days/0` format.\n","title":"Calendar.naive_datetime_to_iso_days/7","type":"callback"},{"doc":"Converts the naive datetime (without time zone) into a string according to the calendar.","ref":"Calendar.html#c:naive_datetime_to_string/7","source_doc":"Converts the naive datetime (without time zone) into a string according to the calendar.\n","title":"Calendar.naive_datetime_to_string/7","type":"callback"},{"doc":"Parses the string representation for a date returned by date_to_string/3 into a date tuple.","ref":"Calendar.html#c:parse_date/1","source_doc":"Parses the string representation for a date returned by `c:date_to_string/3`\ninto a date tuple.\n","title":"Calendar.parse_date/1","type":"callback"},{"doc":"Parses the string representation for a naive datetime returned by naive_datetime_to_string/7 into a naive datetime tuple. The given string may contain a timezone offset but it is ignored.","ref":"Calendar.html#c:parse_naive_datetime/1","source_doc":"Parses the string representation for a naive datetime returned by\n`c:naive_datetime_to_string/7` into a naive datetime tuple.\n\nThe given string may contain a timezone offset but it is ignored.\n","title":"Calendar.parse_naive_datetime/1","type":"callback"},{"doc":"Parses the string representation for a time returned by time_to_string/4 into a time tuple.","ref":"Calendar.html#c:parse_time/1","source_doc":"Parses the string representation for a time returned by `c:time_to_string/4`\ninto a time tuple.\n","title":"Calendar.parse_time/1","type":"callback"},{"doc":"Parses the string representation for a datetime returned by datetime_to_string/11 into a datetime tuple. The returned datetime must be in UTC. The original utc_offset it was written in must be returned in the result.","ref":"Calendar.html#c:parse_utc_datetime/1","source_doc":"Parses the string representation for a datetime returned by\n`c:datetime_to_string/11` into a datetime tuple.\n\nThe returned datetime must be in UTC. The original `utc_offset`\nit was written in must be returned in the result.\n","title":"Calendar.parse_utc_datetime/1","type":"callback"},{"doc":"Sets the current time zone database.","ref":"Calendar.html#put_time_zone_database/1","source_doc":"Sets the current time zone database.\n","title":"Calendar.put_time_zone_database/1","type":"function"},{"doc":"Calculates the quarter of the year from the given year , month , and day .","ref":"Calendar.html#c:quarter_of_year/3","source_doc":"Calculates the quarter of the year from the given `year`, `month`, and `day`.\n","title":"Calendar.quarter_of_year/3","type":"callback"},{"doc":"Formats the given date, time, or datetime into a string. The datetime can be any of the Calendar types ( Time , Date , NaiveDateTime , and DateTime ) or any map, as long as they contain all of the relevant fields necessary for formatting. For example, if you use %Y to format the year, the datetime must have the :year field. Therefore, if you pass a Time , or a map without the :year field to a format that expects %Y , an error will be raised. Examples of common usage: iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%y-%m-%d %I:%M:%S %p&quot; ) &quot;19-08-26 01:52:06 PM&quot; iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%a, %B %d %Y&quot; ) &quot;Mon, August 26 2019&quot; User Options :preferred_datetime - a string for the preferred format to show datetimes, it can't contain the %c format and defaults to &quot;%Y-%m-%d %H:%M:%S&quot; if the option is not received :preferred_date - a string for the preferred format to show dates, it can't contain the %x format and defaults to &quot;%Y-%m-%d&quot; if the option is not received :preferred_time - a string for the preferred format to show times, it can't contain the %X format and defaults to &quot;%H:%M:%S&quot; if the option is not received :am_pm_names - a function that receives either :am or :pm and returns the name of the period of the day, if the option is not received it defaults to a function that returns &quot;am&quot; and &quot;pm&quot; , respectively :month_names - a function that receives a number and returns the name of the corresponding month, if the option is not received it defaults to a function that returns the month names in English :abbreviated_month_names - a function that receives a number and returns the abbreviated name of the corresponding month, if the option is not received it defaults to a function that returns the abbreviated month names in English :day_of_week_names - a function that receives a number and returns the name of the corresponding day of week, if the option is not received it defaults to a function that returns the day of week names in English :abbreviated_day_of_week_names - a function that receives a number and returns the abbreviated name of the corresponding day of week, if the option is not received it defaults to a function that returns the abbreviated day of week names in English Formatting syntax The formatting syntax for the string_format argument is a sequence of characters in the following format: % &lt; padding &gt; &lt; width &gt; &lt; format &gt; where: % : indicates the start of a formatted section &lt;padding&gt; : set the padding (see below) &lt;width&gt; : a number indicating the minimum size of the formatted section &lt;format&gt; : the format itself (see below) Accepted padding options - : no padding, removes all padding from the format _ : pad with spaces 0 : pad with zeroes Accepted string formats The accepted formats for string_format are: Format Description Examples (in ISO) a Abbreviated name of day Mon A Full name of day Monday b Abbreviated month name Jan B Full month name January c Preferred date+time representation 2018-10-17 12:34:56 d Day of the month 01, 31 f Microseconds (does not support width and padding modifiers) 000000, 999999, 0123 H Hour using a 24-hour clock 00, 23 I Hour using a 12-hour clock 01, 12 j Day of the year 001, 366 m Month 01, 12 M Minute 00, 59 p &quot;AM&quot; or &quot;PM&quot; (noon is &quot;PM&quot;, midnight as &quot;AM&quot;) AM, PM P &quot;am&quot; or &quot;pm&quot; (noon is &quot;pm&quot;, midnight as &quot;am&quot;) am, pm q Quarter 1, 2, 3, 4 s Number of seconds since the Epoch, 1970-01-01 00:00:00+0000 (UTC) 1565888877 S Second 00, 59, 60 u Day of the week 1 (Monday), 7 (Sunday) x Preferred date (without time) representation 2018-10-17 X Preferred time (without date) representation 12:34:56 y Year as 2-digits 01, 01, 86, 18 Y Year -0001, 0001, 1986 z +hhmm/-hhmm time zone offset from UTC (empty string if naive) +0300, -0530 Z Time zone abbreviation (empty string if naive) CET, BRST % Literal &quot;%&quot; character % Any other character will be interpreted as an invalid format and raise an error. Examples Without user options: iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%y-%m-%d %I:%M:%S %p&quot; ) &quot;19-08-26 01:52:06 PM&quot; iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%a, %B %d %Y&quot; ) &quot;Mon, August 26 2019&quot; iex&gt; Calendar . strftime ( ~U[2020-04-02 13:52:06.0Z] , &quot;%B %-d, %Y&quot; ) &quot;April 2, 2020&quot; iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%c&quot; ) &quot;2019-08-26 13:52:06&quot; With user options: iex&gt; Calendar . strftime ( ~U[2019-08-26 13:52:06.0Z] , &quot;%c&quot; , preferred_datetime : &quot;%H:%M:%S %d-%m-%y&quot; ) &quot;13:52:06 26-08-19&quot; iex&gt; Calendar . strftime ( ...&gt; ~U[2019-08-26 13:52:06.0Z] , ...&gt; &quot;%A&quot; , ...&gt; day_of_week_names : fn day_of_week -&gt; ...&gt; { &quot;segunda-feira&quot; , &quot;terça-feira&quot; , &quot;quarta-feira&quot; , &quot;quinta-feira&quot; , ...&gt; &quot;sexta-feira&quot; , &quot;sábado&quot; , &quot;domingo&quot; } ...&gt; |&gt; elem ( day_of_week - 1 ) ...&gt; end ...&gt; ) &quot;segunda-feira&quot; iex&gt; Calendar . strftime ( ...&gt; ~U[2019-08-26 13:52:06.0Z] , ...&gt; &quot;%B&quot; , ...&gt; month_names : fn month -&gt; ...&gt; { &quot;січень&quot; , &quot;лютий&quot; , &quot;березень&quot; , &quot;квітень&quot; , &quot;травень&quot; , &quot;червень&quot; , ...&gt; &quot;липень&quot; , &quot;серпень&quot; , &quot;вересень&quot; , &quot;жовтень&quot; , &quot;листопад&quot; , &quot;грудень&quot; } ...&gt; |&gt; elem ( month - 1 ) ...&gt; end ...&gt; ) &quot;серпень&quot;","ref":"Calendar.html#strftime/3","source_doc":"Formats the given date, time, or datetime into a string.\n\nThe datetime can be any of the `Calendar` types (`Time`, `Date`,\n`NaiveDateTime`, and `DateTime`) or any map, as long as they\ncontain all of the relevant fields necessary for formatting.\nFor example, if you use `%Y` to format the year, the datetime\nmust have the `:year` field. Therefore, if you pass a `Time`,\nor a map without the `:year` field to a format that expects `%Y`,\nan error will be raised.\n\nExamples of common usage:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%y-%m-%d %I:%M:%S %p\")\n    \"19-08-26 01:52:06 PM\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%a, %B %d %Y\")\n    \"Mon, August 26 2019\"\n\n## User Options\n\n  * `:preferred_datetime` - a string for the preferred format to show datetimes,\n    it can't contain the `%c` format and defaults to `\"%Y-%m-%d %H:%M:%S\"`\n    if the option is not received\n\n  * `:preferred_date` - a string for the preferred format to show dates,\n    it can't contain the `%x` format and defaults to `\"%Y-%m-%d\"`\n    if the option is not received\n\n  * `:preferred_time` - a string for the preferred format to show times,\n    it can't contain the `%X` format and defaults to `\"%H:%M:%S\"`\n    if the option is not received\n\n  * `:am_pm_names` - a function that receives either `:am` or `:pm` and returns\n    the name of the period of the day, if the option is not received it defaults\n    to a function that returns `\"am\"` and `\"pm\"`, respectively\n\n  *  `:month_names` - a function that receives a number and returns the name of\n    the corresponding month, if the option is not received it defaults to a\n    function that returns the month names in English\n\n  * `:abbreviated_month_names` - a function that receives a number and returns the\n    abbreviated name of the corresponding month, if the option is not received it\n    defaults to a function that returns the abbreviated month names in English\n\n  * `:day_of_week_names` - a function that receives a number and returns the name of\n    the corresponding day of week, if the option is not received it defaults to a\n    function that returns the day of week names in English\n\n  * `:abbreviated_day_of_week_names` - a function that receives a number and returns\n    the abbreviated name of the corresponding day of week, if the option is not received\n    it defaults to a function that returns the abbreviated day of week names in English\n\n## Formatting syntax\n\nThe formatting syntax for the `string_format` argument is a sequence of characters in\nthe following format:\n\n    %<padding><width><format>\n\nwhere:\n\n  * `%`: indicates the start of a formatted section\n  * `<padding>`: set the padding (see below)\n  * `<width>`: a number indicating the minimum size of the formatted section\n  * `<format>`: the format itself (see below)\n\n### Accepted padding options\n\n  * `-`: no padding, removes all padding from the format\n  * `_`: pad with spaces\n  * `0`: pad with zeroes\n\n### Accepted string formats\n\nThe accepted formats for `string_format` are:\n\nFormat | Description                                                             | Examples (in ISO)\n:----- | :-----------------------------------------------------------------------| :------------------------\na      | Abbreviated name of day                                                 | Mon\nA      | Full name of day                                                        | Monday\nb      | Abbreviated month name                                                  | Jan\nB      | Full month name                                                         | January\nc      | Preferred date+time representation                                      | 2018-10-17 12:34:56\nd      | Day of the month                                                        | 01, 31\nf      | Microseconds *(does not support width and padding modifiers)*           | 000000, 999999, 0123\nH      | Hour using a 24-hour clock                                              | 00, 23\nI      | Hour using a 12-hour clock                                              | 01, 12\nj      | Day of the year                                                         | 001, 366\nm      | Month                                                                   | 01, 12\nM      | Minute                                                                  | 00, 59\np      | \"AM\" or \"PM\" (noon is \"PM\", midnight as \"AM\")                           | AM, PM\nP      | \"am\" or \"pm\" (noon is \"pm\", midnight as \"am\")                           | am, pm\nq      | Quarter                                                                 | 1, 2, 3, 4\ns      | Number of seconds since the Epoch, 1970-01-01 00:00:00+0000 (UTC)       | 1565888877\nS      | Second                                                                  | 00, 59, 60\nu      | Day of the week                                                         | 1 (Monday), 7 (Sunday)\nx      | Preferred date (without time) representation                            | 2018-10-17\nX      | Preferred time (without date) representation                            | 12:34:56\ny      | Year as 2-digits                                                        | 01, 01, 86, 18\nY      | Year                                                                    | -0001, 0001, 1986\nz      | +hhmm/-hhmm time zone offset from UTC (empty string if naive)           | +0300, -0530\nZ      | Time zone abbreviation (empty string if naive)                          | CET, BRST\n%      | Literal \"%\" character                                                   | %\n\nAny other character will be interpreted as an invalid format and raise an error.\n\n## Examples\n\nWithout user options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%y-%m-%d %I:%M:%S %p\")\n    \"19-08-26 01:52:06 PM\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%a, %B %d %Y\")\n    \"Mon, August 26 2019\"\n\n    iex> Calendar.strftime(~U[2020-04-02 13:52:06.0Z], \"%B %-d, %Y\")\n    \"April 2, 2020\"\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\")\n    \"2019-08-26 13:52:06\"\n\nWith user options:\n\n    iex> Calendar.strftime(~U[2019-08-26 13:52:06.0Z], \"%c\", preferred_datetime: \"%H:%M:%S %d-%m-%y\")\n    \"13:52:06 26-08-19\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%A\",\n    ...>  day_of_week_names: fn day_of_week ->\n    ...>    {\"segunda-feira\", \"terça-feira\", \"quarta-feira\", \"quinta-feira\",\n    ...>    \"sexta-feira\", \"sábado\", \"domingo\"}\n    ...>    |> elem(day_of_week - 1)\n    ...>  end\n    ...>)\n    \"segunda-feira\"\n\n    iex> Calendar.strftime(\n    ...>  ~U[2019-08-26 13:52:06.0Z],\n    ...>  \"%B\",\n    ...>  month_names: fn month ->\n    ...>    {\"січень\", \"лютий\", \"березень\", \"квітень\", \"травень\", \"червень\",\n    ...>    \"липень\", \"серпень\", \"вересень\", \"жовтень\", \"листопад\", \"грудень\"}\n    ...>    |> elem(month - 1)\n    ...>  end\n    ...>)\n    \"серпень\"\n\n","title":"Calendar.strftime/3","type":"function"},{"doc":"Converts day_fraction/0 to the calendar's time format.","ref":"Calendar.html#c:time_from_day_fraction/1","source_doc":"Converts `t:day_fraction/0` to the calendar's time format.\n","title":"Calendar.time_from_day_fraction/1","type":"callback"},{"doc":"Converts the given time to the day_fraction/0 format.","ref":"Calendar.html#c:time_to_day_fraction/4","source_doc":"Converts the given time to the `t:day_fraction/0` format.\n","title":"Calendar.time_to_day_fraction/4","type":"callback"},{"doc":"Converts the time into a string according to the calendar.","ref":"Calendar.html#c:time_to_string/4","source_doc":"Converts the time into a string according to the calendar.\n","title":"Calendar.time_to_string/4","type":"callback"},{"doc":"Returns a microsecond tuple truncated to a given precision ( :microsecond , :millisecond , or :second ).","ref":"Calendar.html#truncate/2","source_doc":"Returns a microsecond tuple truncated to a given precision (`:microsecond`,\n`:millisecond`, or `:second`).\n","title":"Calendar.truncate/2","type":"function"},{"doc":"Should return true if the given date describes a proper date in the calendar.","ref":"Calendar.html#c:valid_date?/3","source_doc":"Should return `true` if the given date describes a proper date in the calendar.\n","title":"Calendar.valid_date?/3","type":"callback"},{"doc":"Should return true if the given time describes a proper time in the calendar.","ref":"Calendar.html#c:valid_time?/4","source_doc":"Should return `true` if the given time describes a proper time in the calendar.\n","title":"Calendar.valid_time?/4","type":"callback"},{"doc":"Calculates the year and era from the given year .","ref":"Calendar.html#c:year_of_era/3","source_doc":"Calculates the year and era from the given `year`.\n","title":"Calendar.year_of_era/3","type":"callback"},{"doc":"A calendar implementation.","ref":"Calendar.html#t:calendar/0","source_doc":"A calendar implementation.","title":"Calendar.calendar/0","type":"type"},{"doc":"Any map or struct that contains the date fields.","ref":"Calendar.html#t:date/0","source_doc":"Any map or struct that contains the date fields.","title":"Calendar.date/0","type":"type"},{"doc":"Any map or struct that contains the datetime fields.","ref":"Calendar.html#t:datetime/0","source_doc":"Any map or struct that contains the datetime fields.","title":"Calendar.datetime/0","type":"type"},{"doc":"","ref":"Calendar.html#t:day/0","source_doc":false,"title":"Calendar.day/0","type":"type"},{"doc":"The internal time format is used when converting between calendars. It represents time as a fraction of a day (starting from midnight). parts_in_day specifies how much of the day is already passed, while parts_per_day signifies how many parts are there in a day.","ref":"Calendar.html#t:day_fraction/0","source_doc":"The internal time format is used when converting between calendars.\n\nIt represents time as a fraction of a day (starting from midnight).\n`parts_in_day` specifies how much of the day is already passed,\nwhile `parts_per_day` signifies how many parts are there in a day.\n","title":"Calendar.day_fraction/0","type":"type"},{"doc":"A tuple representing the day and the era .","ref":"Calendar.html#t:day_of_era/0","source_doc":"A tuple representing the `day` and the `era`.\n","title":"Calendar.day_of_era/0","type":"type"},{"doc":"","ref":"Calendar.html#t:day_of_week/0","source_doc":false,"title":"Calendar.day_of_week/0","type":"type"},{"doc":"","ref":"Calendar.html#t:era/0","source_doc":false,"title":"Calendar.era/0","type":"type"},{"doc":"","ref":"Calendar.html#t:hour/0","source_doc":false,"title":"Calendar.hour/0","type":"type"},{"doc":"The internal date format that is used when converting between calendars. This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).","ref":"Calendar.html#t:iso_days/0","source_doc":"The internal date format that is used when converting between calendars.\n\nThis is the number of days including the fractional part that has passed of\nthe last day since `0000-01-01+00:00T00:00.000000` in ISO 8601 notation (also\nknown as *midnight 1 January BC 1* of the proleptic Gregorian calendar).\n","title":"Calendar.iso_days/0","type":"type"},{"doc":"Microseconds with stored precision. The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0 , it means microseconds must be skipped.","ref":"Calendar.html#t:microsecond/0","source_doc":"Microseconds with stored precision.\n\nThe precision represents the number of digits that must be used when\nrepresenting the microseconds to external format. If the precision is `0`,\nit means microseconds must be skipped.\n","title":"Calendar.microsecond/0","type":"type"},{"doc":"","ref":"Calendar.html#t:minute/0","source_doc":false,"title":"Calendar.minute/0","type":"type"},{"doc":"","ref":"Calendar.html#t:month/0","source_doc":false,"title":"Calendar.month/0","type":"type"},{"doc":"Any map or struct that contains the naive datetime fields.","ref":"Calendar.html#t:naive_datetime/0","source_doc":"Any map or struct that contains the naive datetime fields.","title":"Calendar.naive_datetime/0","type":"type"},{"doc":"","ref":"Calendar.html#t:second/0","source_doc":false,"title":"Calendar.second/0","type":"type"},{"doc":"The time zone standard offset in seconds (typically not zero in summer times). It must be added to utc_offset/0 to get the total offset from UTC used for &quot;wall time&quot;.","ref":"Calendar.html#t:std_offset/0","source_doc":"The time zone standard offset in seconds (typically not zero in summer times).\n\nIt must be added to `t:utc_offset/0` to get the total offset from UTC used for \"wall time\".\n","title":"Calendar.std_offset/0","type":"type"},{"doc":"Any map or struct that contains the time fields.","ref":"Calendar.html#t:time/0","source_doc":"Any map or struct that contains the time fields.","title":"Calendar.time/0","type":"type"},{"doc":"The time zone ID according to the IANA tz database (for example, Europe/Zurich ).","ref":"Calendar.html#t:time_zone/0","source_doc":"The time zone ID according to the IANA tz database (for example, `Europe/Zurich`).","title":"Calendar.time_zone/0","type":"type"},{"doc":"Specifies the time zone database for calendar operations. Many functions in the DateTime module require a time zone database. By default, this module uses the default time zone database returned by Calendar.get_time_zone_database/0 , which defaults to Calendar.UTCOnlyTimeZoneDatabase . This database only handles Etc/UTC datetimes and returns {:error, :utc_only_time_zone_database} for any other time zone. Other time zone databases (including ones provided by packages) can be configured as default either via configuration: config :elixir , :time_zone_database , CustomTimeZoneDatabase or by calling Calendar.put_time_zone_database/1 . See Calendar.TimeZoneDatabase for more information on custom time zone databases.","ref":"Calendar.html#t:time_zone_database/0","source_doc":"Specifies the time zone database for calendar operations.\n\nMany functions in the `DateTime` module require a time zone database.\nBy default, this module uses the default time zone database returned by\n`Calendar.get_time_zone_database/0`, which defaults to\n`Calendar.UTCOnlyTimeZoneDatabase`. This database only handles `Etc/UTC`\ndatetimes and returns `{:error, :utc_only_time_zone_database}`\nfor any other time zone.\n\nOther time zone databases (including ones provided by packages)\ncan be configured as default either via configuration:\n\n    config :elixir, :time_zone_database, CustomTimeZoneDatabase\n\nor by calling `Calendar.put_time_zone_database/1`.\n\nSee `Calendar.TimeZoneDatabase` for more information on custom\ntime zone databases.\n","title":"Calendar.time_zone_database/0","type":"type"},{"doc":"The time zone UTC offset in seconds for standard time. See also std_offset/0 .","ref":"Calendar.html#t:utc_offset/0","source_doc":"The time zone UTC offset in seconds for standard time.\n\nSee also `t:std_offset/0`.\n","title":"Calendar.utc_offset/0","type":"type"},{"doc":"","ref":"Calendar.html#t:week/0","source_doc":false,"title":"Calendar.week/0","type":"type"},{"doc":"","ref":"Calendar.html#t:year/0","source_doc":false,"title":"Calendar.year/0","type":"type"},{"doc":"The time zone abbreviation (for example, CET or CEST or BST ).","ref":"Calendar.html#t:zone_abbr/0","source_doc":"The time zone abbreviation (for example, `CET` or `CEST` or `BST`).","title":"Calendar.zone_abbr/0","type":"type"},{"doc":"The default calendar implementation, a Gregorian calendar following ISO 8601. This calendar implements a proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted. ISO 8601 compliance The ISO 8601 specification is feature-rich, but allows applications to selectively implement most parts of it. The choices Elixir makes are catalogued below. Features The standard library supports a minimal set of possible ISO 8601 features. Specifically, the parser only supports calendar dates and does not support ordinal and week formats. By default Elixir only parses extended-formatted date/times. You can opt-in to parse basic-formatted date/times. NaiveDateTime.to_iso8601/2 and DateTime.to_iso8601/2 allow you to produce either basic or extended formatted strings, and Calendar.strftime/2 allows you to format datetimes however else you desire. Elixir does not support reduced accuracy formats (for example, a date without the day component) nor decimal precisions in the lowest component (such as 10:01:25,5 ). No functions exist to parse ISO 8601 durations or time intervals. Examples Elixir expects the extended format by default when parsing: iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23T23:50:07&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123T235007&quot; ) { :error , :invalid_format } Parsing can be restricted to basic if desired: iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123T235007Z&quot; , :basic ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123T235007Z&quot; , :extended ) { :error , :invalid_format } Only calendar dates are supported in parsing; ordinal and week dates are not. iex&gt; Calendar.ISO . parse_date ( &quot;2015-04-15&quot; ) { :ok , { 2015 , 4 , 15 } } iex&gt; Calendar.ISO . parse_date ( &quot;2015-105&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015-W16&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015-W016-3&quot; ) { :error , :invalid_format } Years, months, days, hours, minutes, and seconds must be fully specified: iex&gt; Calendar.ISO . parse_date ( &quot;2015-04-15&quot; ) { :ok , { 2015 , 4 , 15 } } iex&gt; Calendar.ISO . parse_date ( &quot;2015-04&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07.0123456&quot; ) { :ok , { 23 , 50 , 7 , { 12345 , 6 } } } iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;23:50&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_time ( &quot;23&quot; ) { :error , :invalid_format } Extensions The parser and formatter adopt one ISO 8601 extension: extended year notation. This allows dates to be prefixed with a + or - sign, extending the range of expressible years from the default ( 0000..9999 ) to -9999..9999 . Elixir still restricts years in this format to four digits. Examples iex&gt; Calendar.ISO . parse_date ( &quot;-2015-01-23&quot; ) { :ok , { - 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_date ( &quot;+2015-01-23&quot; ) { :ok , { 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;-2015-01-23 23:50:07&quot; ) { :ok , { - 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;+2015-01-23 23:50:07&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;-2015-01-23 23:50:07Z&quot; ) { :ok , { - 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;+2015-01-23 23:50:07Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } Additions ISO 8601 does not allow a whitespace instead of T as a separator between date and times, both when parsing and formatting. This is a common enough representation, Elixir allows it during parsing. The formatting of dates in NaiveDateTime.to_iso8601/1 and DateTime.to_iso8601/1 do produce specification-compliant string representations using the T separator. Examples iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07.0123456&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23T23:50:07.0123456&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07.0123456Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23T23:50:07.0123456Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } , 0 }","ref":"Calendar.ISO.html","source_doc":"The default calendar implementation, a Gregorian calendar following ISO 8601.\n\nThis calendar implements a proleptic Gregorian calendar and\nis therefore compatible with the calendar used in most countries\ntoday. The proleptic means the Gregorian rules for leap years are\napplied for all time, consequently the dates give different results\nbefore the year 1583 from when the Gregorian calendar was adopted.\n\n## ISO 8601 compliance\n\nThe ISO 8601 specification is feature-rich, but allows applications\nto selectively implement most parts of it. The choices Elixir makes\nare catalogued below.\n\n### Features\n\nThe standard library supports a minimal set of possible ISO 8601 features.\nSpecifically, the parser only supports calendar dates and does not support\nordinal and week formats.\n\nBy default Elixir only parses extended-formatted date/times. You can opt-in\nto parse basic-formatted date/times.\n\n`NaiveDateTime.to_iso8601/2` and `DateTime.to_iso8601/2` allow you to produce\neither basic or extended formatted strings, and `Calendar.strftime/2` allows\nyou to format datetimes however else you desire.\n\nElixir does not support reduced accuracy formats (for example, a date without\nthe day component) nor decimal precisions in the lowest component (such as\n`10:01:25,5`). No functions exist to parse ISO 8601 durations or time intervals.\n\n#### Examples\n\nElixir expects the extended format by default when parsing:\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23T23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007\")\n    {:error, :invalid_format}\n\nParsing can be restricted to basic if desired:\n\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123T235007Z\", :extended)\n    {:error, :invalid_format}\n\nOnly calendar dates are supported in parsing; ordinal and week dates are not.\n\n    iex> Calendar.ISO.parse_date(\"2015-04-15\")\n    {:ok, {2015, 4, 15}}\n    iex> Calendar.ISO.parse_date(\"2015-105\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-W16\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-W016-3\")\n    {:error, :invalid_format}\n\nYears, months, days, hours, minutes, and seconds must be fully specified:\n\n    iex> Calendar.ISO.parse_date(\"2015-04-15\")\n    {:ok, {2015, 4, 15}}\n    iex> Calendar.ISO.parse_date(\"2015-04\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015\")\n    {:error, :invalid_format}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07.0123456\")\n    {:ok, {23, 50, 7, {12345, 6}}}\n    iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"23:50\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_time(\"23\")\n    {:error, :invalid_format}\n\n### Extensions\n\nThe parser and formatter adopt one ISO 8601 extension: extended year notation.\n\nThis allows dates to be prefixed with a `+` or `-` sign, extending the range of\nexpressible years from the default (`0000..9999`) to `-9999..9999`. Elixir still\nrestricts years in this format to four digits.\n\n#### Examples\n\n    iex> Calendar.ISO.parse_date(\"-2015-01-23\")\n    {:ok, {-2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"+2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"-2015-01-23 23:50:07\")\n    {:ok, {-2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"+2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"-2015-01-23 23:50:07Z\")\n    {:ok, {-2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"+2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n\n### Additions\n\nISO 8601 does not allow a whitespace instead of `T` as a separator\nbetween date and times, both when parsing and formatting.\nThis is a common enough representation, Elixir allows it during parsing.\n\nThe formatting of dates in `NaiveDateTime.to_iso8601/1` and `DateTime.to_iso8601/1`\ndo produce specification-compliant string representations using the `T` separator.\n\n#### Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23T23:50:07.0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07.0123456Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23T23:50:07.0123456Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}, 0}\n\n","title":"Calendar.ISO","type":"module"},{"doc":"Converts the given date into a string. By default, returns dates formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; Calendar.ISO . date_to_string ( 2015 , 2 , 28 ) &quot;2015-02-28&quot; iex&gt; Calendar.ISO . date_to_string ( 2017 , 8 , 1 ) &quot;2017-08-01&quot; iex&gt; Calendar.ISO . date_to_string ( - 99 , 1 , 31 ) &quot;-0099-01-31&quot; iex&gt; Calendar.ISO . date_to_string ( 2015 , 2 , 28 , :basic ) &quot;20150228&quot; iex&gt; Calendar.ISO . date_to_string ( - 99 , 1 , 31 , :basic ) &quot;-00990131&quot;","ref":"Calendar.ISO.html#date_to_string/4","source_doc":"Converts the given date into a string.\n\nBy default, returns dates formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28)\n    \"2015-02-28\"\n    iex> Calendar.ISO.date_to_string(2017, 8, 1)\n    \"2017-08-01\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31)\n    \"-0099-01-31\"\n\n    iex> Calendar.ISO.date_to_string(2015, 2, 28, :basic)\n    \"20150228\"\n    iex> Calendar.ISO.date_to_string(-99, 1, 31, :basic)\n    \"-00990131\"\n\n","title":"Calendar.ISO.date_to_string/4","type":"function"},{"doc":"Converts the datetime (with time zone) into a string. By default, returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; time_zone = &quot;Etc/UTC&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;UTC&quot; , 0 , 0 ) &quot;2017-08-01 01:02:03.00000Z&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;UTC&quot; , 3600 , 0 ) &quot;2017-08-01 01:02:03.00000+01:00&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;UTC&quot; , 3600 , 3600 ) &quot;2017-08-01 01:02:03.00000+02:00&quot; iex&gt; time_zone = &quot;Europe/Berlin&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;CET&quot; , 3600 , 0 ) &quot;2017-08-01 01:02:03.00000+01:00 CET Europe/Berlin&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;CDT&quot; , 3600 , 3600 ) &quot;2017-08-01 01:02:03.00000+02:00 CDT Europe/Berlin&quot; iex&gt; time_zone = &quot;America/Los_Angeles&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;PST&quot; , - 28800 , 0 ) &quot;2015-02-28 01:02:03.00000-08:00 PST America/Los_Angeles&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;PDT&quot; , - 28800 , 3600 ) &quot;2015-02-28 01:02:03.00000-07:00 PDT America/Los_Angeles&quot; iex&gt; time_zone = &quot;Europe/Berlin&quot; iex&gt; Calendar.ISO . datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } , time_zone , &quot;CET&quot; , 3600 , 0 , :basic ) &quot;20170801 010203.00000+0100 CET Europe/Berlin&quot;","ref":"Calendar.ISO.html#datetime_to_string/12","source_doc":"Converts the datetime (with time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> time_zone = \"Etc/UTC\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 0, 0)\n    \"2017-08-01 01:02:03.00000Z\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"UTC\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0)\n    \"2017-08-01 01:02:03.00000+01:00 CET Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CDT\", 3600, 3600)\n    \"2017-08-01 01:02:03.00000+02:00 CDT Europe/Berlin\"\n\n    iex> time_zone = \"America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PST\", -28800, 0)\n    \"2015-02-28 01:02:03.00000-08:00 PST America/Los_Angeles\"\n    iex> Calendar.ISO.datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 5}, time_zone, \"PDT\", -28800, 3600)\n    \"2015-02-28 01:02:03.00000-07:00 PDT America/Los_Angeles\"\n\n    iex> time_zone = \"Europe/Berlin\"\n    iex> Calendar.ISO.datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5}, time_zone, \"CET\", 3600, 0, :basic)\n    \"20170801 010203.00000+0100 CET Europe/Berlin\"\n\n","title":"Calendar.ISO.datetime_to_string/12","type":"function"},{"doc":"Calculates the day and era from the given year , month , and day . Examples iex&gt; Calendar.ISO . day_of_era ( 0 , 1 , 1 ) { 366 , 0 } iex&gt; Calendar.ISO . day_of_era ( 1 , 1 , 1 ) { 1 , 1 } iex&gt; Calendar.ISO . day_of_era ( 0 , 12 , 31 ) { 1 , 0 } iex&gt; Calendar.ISO . day_of_era ( 0 , 12 , 30 ) { 2 , 0 } iex&gt; Calendar.ISO . day_of_era ( - 1 , 12 , 31 ) { 367 , 0 }","ref":"Calendar.ISO.html#day_of_era/3","source_doc":"Calculates the day and era from the given `year`, `month`, and `day`.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_era(0, 1, 1)\n    {366, 0}\n    iex> Calendar.ISO.day_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.day_of_era(0, 12, 31)\n    {1, 0}\n    iex> Calendar.ISO.day_of_era(0, 12, 30)\n    {2, 0}\n    iex> Calendar.ISO.day_of_era(-1, 12, 31)\n    {367, 0}\n\n","title":"Calendar.ISO.day_of_era/3","type":"function"},{"doc":"Calculates the day of the week from the given year , month , and day . It is an integer from 1 to 7, where 1 is the given starting_on weekday. For example, if starting_on is set to :monday , then 1 is Monday and 7 is Sunday. starting_on can also be :default , which is equivalent to :monday . Examples iex&gt; Calendar.ISO . day_of_week ( 2016 , 10 , 31 , :monday ) { 1 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 1 , :monday ) { 2 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 2 , :monday ) { 3 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 3 , :monday ) { 4 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 4 , :monday ) { 5 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 5 , :monday ) { 6 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 6 , :monday ) { 7 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( - 99 , 1 , 31 , :monday ) { 4 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 10 , 31 , :sunday ) { 2 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 1 , :sunday ) { 3 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 2 , :sunday ) { 4 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 3 , :sunday ) { 5 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 4 , :sunday ) { 6 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 5 , :sunday ) { 7 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 11 , 6 , :sunday ) { 1 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( - 99 , 1 , 31 , :sunday ) { 5 , 1 , 7 } iex&gt; Calendar.ISO . day_of_week ( 2016 , 10 , 31 , :saturday ) { 3 , 1 , 7 }","ref":"Calendar.ISO.html#day_of_week/4","source_doc":"Calculates the day of the week from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 7, where 1 is the given `starting_on` weekday.\nFor example, if `starting_on` is set to `:monday`, then 1 is Monday and\n7 is Sunday.\n\n`starting_on` can also be `:default`, which is equivalent to `:monday`.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :monday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :monday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :monday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :monday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :monday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :monday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :monday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :monday)\n    {4, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :sunday)\n    {2, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 1, :sunday)\n    {3, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 2, :sunday)\n    {4, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 3, :sunday)\n    {5, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 4, :sunday)\n    {6, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 5, :sunday)\n    {7, 1, 7}\n    iex> Calendar.ISO.day_of_week(2016, 11, 6, :sunday)\n    {1, 1, 7}\n    iex> Calendar.ISO.day_of_week(-99, 1, 31, :sunday)\n    {5, 1, 7}\n\n    iex> Calendar.ISO.day_of_week(2016, 10, 31, :saturday)\n    {3, 1, 7}\n\n","title":"Calendar.ISO.day_of_week/4","type":"function"},{"doc":"Calculates the day of the year from the given year , month , and day . It is an integer from 1 to 366. Examples iex&gt; Calendar.ISO . day_of_year ( 2016 , 1 , 31 ) 31 iex&gt; Calendar.ISO . day_of_year ( - 99 , 2 , 1 ) 32 iex&gt; Calendar.ISO . day_of_year ( 2018 , 2 , 28 ) 59","ref":"Calendar.ISO.html#day_of_year/3","source_doc":"Calculates the day of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 366.\n\n## Examples\n\n    iex> Calendar.ISO.day_of_year(2016, 1, 31)\n    31\n    iex> Calendar.ISO.day_of_year(-99, 2, 1)\n    32\n    iex> Calendar.ISO.day_of_year(2018, 2, 28)\n    59\n\n","title":"Calendar.ISO.day_of_year/3","type":"function"},{"doc":"See Calendar.day_rollover_relative_to_midnight_utc/0 for documentation.","ref":"Calendar.ISO.html#day_rollover_relative_to_midnight_utc/0","source_doc":"See `c:Calendar.day_rollover_relative_to_midnight_utc/0` for documentation.\n","title":"Calendar.ISO.day_rollover_relative_to_midnight_utc/0","type":"function"},{"doc":"Returns how many days there are in the given year-month. Examples iex&gt; Calendar.ISO . days_in_month ( 1900 , 1 ) 31 iex&gt; Calendar.ISO . days_in_month ( 1900 , 2 ) 28 iex&gt; Calendar.ISO . days_in_month ( 2000 , 2 ) 29 iex&gt; Calendar.ISO . days_in_month ( 2001 , 2 ) 28 iex&gt; Calendar.ISO . days_in_month ( 2004 , 2 ) 29 iex&gt; Calendar.ISO . days_in_month ( 2004 , 4 ) 30 iex&gt; Calendar.ISO . days_in_month ( - 1 , 5 ) 31","ref":"Calendar.ISO.html#days_in_month/2","source_doc":"Returns how many days there are in the given year-month.\n\n## Examples\n\n    iex> Calendar.ISO.days_in_month(1900, 1)\n    31\n    iex> Calendar.ISO.days_in_month(1900, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2000, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2001, 2)\n    28\n    iex> Calendar.ISO.days_in_month(2004, 2)\n    29\n    iex> Calendar.ISO.days_in_month(2004, 4)\n    30\n    iex> Calendar.ISO.days_in_month(-1, 5)\n    31\n\n","title":"Calendar.ISO.days_in_month/2","type":"function"},{"doc":"Converts the Calendar.iso_days/0 to the first moment of the day. Examples iex&gt; Calendar.ISO . iso_days_to_beginning_of_day ( { 0 , { 0 , 86400000000 } } ) { 0 , { 0 , 86400000000 } } iex&gt; Calendar.ISO . iso_days_to_beginning_of_day ( { 730485 , { 43200000000 , 86400000000 } } ) { 730485 , { 0 , 86400000000 } } iex&gt; Calendar.ISO . iso_days_to_beginning_of_day ( { 730485 , { 46800000000 , 86400000000 } } ) { 730485 , { 0 , 86400000000 } }","ref":"Calendar.ISO.html#iso_days_to_beginning_of_day/1","source_doc":"Converts the `t:Calendar.iso_days/0` to the first moment of the day.\n\n## Examples\n\n    iex> Calendar.ISO.iso_days_to_beginning_of_day({0, {0, 86400000000}})\n    {0, {0, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_beginning_of_day({730485, {43200000000, 86400000000}})\n    {730485, {0, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_beginning_of_day({730485, {46800000000, 86400000000}})\n    {730485, {0, 86400000000}}\n\n","title":"Calendar.ISO.iso_days_to_beginning_of_day/1","type":"function"},{"doc":"Converts the Calendar.iso_days/0 to the last moment of the day. Examples iex&gt; Calendar.ISO . iso_days_to_end_of_day ( { 0 , { 0 , 86400000000 } } ) { 0 , { 86399999999 , 86400000000 } } iex&gt; Calendar.ISO . iso_days_to_end_of_day ( { 730485 , { 43200000000 , 86400000000 } } ) { 730485 , { 86399999999 , 86400000000 } } iex&gt; Calendar.ISO . iso_days_to_end_of_day ( { 730485 , { 46800000000 , 86400000000 } } ) { 730485 , { 86399999999 , 86400000000 } }","ref":"Calendar.ISO.html#iso_days_to_end_of_day/1","source_doc":"Converts the `t:Calendar.iso_days/0` to the last moment of the day.\n\n## Examples\n\n    iex> Calendar.ISO.iso_days_to_end_of_day({0, {0, 86400000000}})\n    {0, {86399999999, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_end_of_day({730485, {43200000000, 86400000000}})\n    {730485, {86399999999, 86400000000}}\n    iex> Calendar.ISO.iso_days_to_end_of_day({730485, {46800000000, 86400000000}})\n    {730485, {86399999999, 86400000000}}\n\n","title":"Calendar.ISO.iso_days_to_end_of_day/1","type":"function"},{"doc":"Returns if the given year is a leap year. Examples iex&gt; Calendar.ISO . leap_year? ( 2000 ) true iex&gt; Calendar.ISO . leap_year? ( 2001 ) false iex&gt; Calendar.ISO . leap_year? ( 2004 ) true iex&gt; Calendar.ISO . leap_year? ( 1900 ) false iex&gt; Calendar.ISO . leap_year? ( - 4 ) true","ref":"Calendar.ISO.html#leap_year?/1","source_doc":"Returns if the given year is a leap year.\n\n## Examples\n\n    iex> Calendar.ISO.leap_year?(2000)\n    true\n    iex> Calendar.ISO.leap_year?(2001)\n    false\n    iex> Calendar.ISO.leap_year?(2004)\n    true\n    iex> Calendar.ISO.leap_year?(1900)\n    false\n    iex> Calendar.ISO.leap_year?(-4)\n    true\n\n","title":"Calendar.ISO.leap_year?/1","type":"function"},{"doc":"Returns how many months there are in the given year. Example iex&gt; Calendar.ISO . months_in_year ( 2004 ) 12","ref":"Calendar.ISO.html#months_in_year/1","source_doc":"Returns how many months there are in the given year.\n\n## Example\n\n    iex> Calendar.ISO.months_in_year(2004)\n    12\n\n","title":"Calendar.ISO.months_in_year/1","type":"function"},{"doc":"Converts the Calendar.iso_days/0 format to the datetime format specified by this calendar. Examples iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { 0 , { 0 , 86400 } } ) { 0 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { 730_485 , { 0 , 86400 } } ) { 2000 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { 730_485 , { 43200 , 86400 } } ) { 2000 , 1 , 1 , 12 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . naive_datetime_from_iso_days ( { - 365 , { 0 , 86400000000 } } ) { - 1 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } }","ref":"Calendar.ISO.html#naive_datetime_from_iso_days/1","source_doc":"Converts the `t:Calendar.iso_days/0` format to the datetime format specified by this calendar.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_from_iso_days({0, {0, 86400}})\n    {0, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {0, 86400}})\n    {2000, 1, 1, 0, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({730_485, {43200, 86400}})\n    {2000, 1, 1, 12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.naive_datetime_from_iso_days({-365, {0, 86400000000}})\n    {-1, 1, 1, 0, 0, 0, {0, 6}}\n\n","title":"Calendar.ISO.naive_datetime_from_iso_days/1","type":"function"},{"doc":"Returns the Calendar.iso_days/0 format of the specified date. Examples iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( 0 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } ) { 0 , { 0 , 86400000000 } } iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( 2000 , 1 , 1 , 12 , 0 , 0 , { 0 , 6 } ) { 730485 , { 43200000000 , 86400000000 } } iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( 2000 , 1 , 1 , 13 , 0 , 0 , { 0 , 6 } ) { 730485 , { 46800000000 , 86400000000 } } iex&gt; Calendar.ISO . naive_datetime_to_iso_days ( - 1 , 1 , 1 , 0 , 0 , 0 , { 0 , 6 } ) { - 365 , { 0 , 86400000000 } }","ref":"Calendar.ISO.html#naive_datetime_to_iso_days/7","source_doc":"Returns the `t:Calendar.iso_days/0` format of the specified date.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_to_iso_days(0, 1, 1, 0, 0, 0, {0, 6})\n    {0, {0, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 12, 0, 0, {0, 6})\n    {730485, {43200000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(2000, 1, 1, 13, 0, 0, {0, 6})\n    {730485, {46800000000, 86400000000}}\n    iex> Calendar.ISO.naive_datetime_to_iso_days(-1, 1, 1, 0, 0, 0, {0, 6})\n    {-365, {0, 86400000000}}\n\n","title":"Calendar.ISO.naive_datetime_to_iso_days/7","type":"function"},{"doc":"Converts the datetime (without time zone) into a string. By default, returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; Calendar.ISO . naive_datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 6 } ) &quot;2015-02-28 01:02:03.000004&quot; iex&gt; Calendar.ISO . naive_datetime_to_string ( 2017 , 8 , 1 , 1 , 2 , 3 , { 4 , 5 } ) &quot;2017-08-01 01:02:03.00000&quot; iex&gt; Calendar.ISO . naive_datetime_to_string ( 2015 , 2 , 28 , 1 , 2 , 3 , { 4 , 6 } , :basic ) &quot;20150228 010203.000004&quot;","ref":"Calendar.ISO.html#naive_datetime_to_string/8","source_doc":"Converts the datetime (without time zone) into a string.\n\nBy default, returns datetimes formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6})\n    \"2015-02-28 01:02:03.000004\"\n    iex> Calendar.ISO.naive_datetime_to_string(2017, 8, 1, 1, 2, 3, {4, 5})\n    \"2017-08-01 01:02:03.00000\"\n\n    iex> Calendar.ISO.naive_datetime_to_string(2015, 2, 28, 1, 2, 3, {4, 6}, :basic)\n    \"20150228 010203.000004\"\n\n","title":"Calendar.ISO.naive_datetime_to_string/8","type":"function"},{"doc":"Parses a date string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_date ( &quot;2015-01-23&quot; ) { :ok , { 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_date ( &quot;2015:01:23&quot; ) { :error , :invalid_format } iex&gt; Calendar.ISO . parse_date ( &quot;2015-01-32&quot; ) { :error , :invalid_date }","ref":"Calendar.ISO.html#parse_date/1","source_doc":"Parses a date `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_date(\"2015-01-23\")\n    {:ok, {2015, 1, 23}}\n\n    iex> Calendar.ISO.parse_date(\"2015:01:23\")\n    {:error, :invalid_format}\n    iex> Calendar.ISO.parse_date(\"2015-01-32\")\n    {:error, :invalid_date}\n\n","title":"Calendar.ISO.parse_date/1","type":"function"},{"doc":"Parses a date string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_date ( &quot;20150123&quot; , :basic ) { :ok , { 2015 , 1 , 23 } } iex&gt; Calendar.ISO . parse_date ( &quot;20150123&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_date/2","source_doc":"Parses a date `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_date(\"20150123\", :basic)\n    {:ok, {2015, 1, 23}}\n    iex> Calendar.ISO.parse_date(\"20150123\", :extended)\n    {:error, :invalid_format}\n\n","title":"Calendar.ISO.parse_date/2","type":"function"},{"doc":"Parses a naive datetime string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07-02:30&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07.0&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 1 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;2015-01-23 23:50:07,0123456&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 12345 , 6 } } }","ref":"Calendar.ISO.html#parse_naive_datetime/1","source_doc":"Parses a naive datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07-02:30\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07.0\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 1}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"2015-01-23 23:50:07,0123456\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {12345, 6}}}\n\n","title":"Calendar.ISO.parse_naive_datetime/1","type":"function"},{"doc":"Parses a naive datetime string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123 235007&quot; , :basic ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_naive_datetime ( &quot;20150123 235007&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_naive_datetime/2","source_doc":"Parses a naive datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_naive_datetime(\"20150123 235007\", :extended)\n    {:error, :invalid_format}\n\n","title":"Calendar.ISO.parse_naive_datetime/2","type":"function"},{"doc":"Parses a time string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;23:50:07Z&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;T23:50:07Z&quot; ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } }","ref":"Calendar.ISO.html#parse_time/1","source_doc":"Parses a time `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_time(\"23:50:07\")\n    {:ok, {23, 50, 7, {0, 0}}}\n\n    iex> Calendar.ISO.parse_time(\"23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"T23:50:07Z\")\n    {:ok, {23, 50, 7, {0, 0}}}\n\n","title":"Calendar.ISO.parse_time/1","type":"function"},{"doc":"Parses a time string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_time ( &quot;235007&quot; , :basic ) { :ok , { 23 , 50 , 7 , { 0 , 0 } } } iex&gt; Calendar.ISO . parse_time ( &quot;235007&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_time/2","source_doc":"Parses a time `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_time(\"235007\", :basic)\n    {:ok, {23, 50, 7, {0, 0}}}\n    iex> Calendar.ISO.parse_time(\"235007\", :extended)\n    {:error, :invalid_format}\n\n","title":"Calendar.ISO.parse_time/2","type":"function"},{"doc":"Parses a UTC datetime string in the :extended format. For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07Z&quot; ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07+02:30&quot; ) { :ok , { 2015 , 1 , 23 , 21 , 20 , 7 , { 0 , 0 } } , 9000 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;2015-01-23 23:50:07&quot; ) { :error , :missing_offset }","ref":"Calendar.ISO.html#parse_utc_datetime/1","source_doc":"Parses a UTC datetime `string` in the `:extended` format.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07Z\")\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07+02:30\")\n    {:ok, {2015, 1, 23, 21, 20, 7, {0, 0}}, 9000}\n\n    iex> Calendar.ISO.parse_utc_datetime(\"2015-01-23 23:50:07\")\n    {:error, :missing_offset}\n\n","title":"Calendar.ISO.parse_utc_datetime/1","type":"function"},{"doc":"Parses a UTC datetime string according to a given format . The format can either be :basic or :extended . For more information on supported strings, see how this module implements ISO 8601 . Examples iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;20150123 235007Z&quot; , :basic ) { :ok , { 2015 , 1 , 23 , 23 , 50 , 7 , { 0 , 0 } } , 0 } iex&gt; Calendar.ISO . parse_utc_datetime ( &quot;20150123 235007Z&quot; , :extended ) { :error , :invalid_format }","ref":"Calendar.ISO.html#parse_utc_datetime/2","source_doc":"Parses a UTC datetime `string` according to a given `format`.\n\nThe `format` can either be `:basic` or `:extended`.\n\nFor more information on supported strings, see how this\nmodule implements [ISO 8601](#module-iso-8601-compliance).\n\n## Examples\n\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :basic)\n    {:ok, {2015, 1, 23, 23, 50, 7, {0, 0}}, 0}\n    iex> Calendar.ISO.parse_utc_datetime(\"20150123 235007Z\", :extended)\n    {:error, :invalid_format}\n\n","title":"Calendar.ISO.parse_utc_datetime/2","type":"function"},{"doc":"Calculates the quarter of the year from the given year , month , and day . It is an integer from 1 to 4. Examples iex&gt; Calendar.ISO . quarter_of_year ( 2016 , 1 , 31 ) 1 iex&gt; Calendar.ISO . quarter_of_year ( 2016 , 4 , 3 ) 2 iex&gt; Calendar.ISO . quarter_of_year ( - 99 , 9 , 31 ) 3 iex&gt; Calendar.ISO . quarter_of_year ( 2018 , 12 , 28 ) 4","ref":"Calendar.ISO.html#quarter_of_year/3","source_doc":"Calculates the quarter of the year from the given `year`, `month`, and `day`.\n\nIt is an integer from 1 to 4.\n\n## Examples\n\n    iex> Calendar.ISO.quarter_of_year(2016, 1, 31)\n    1\n    iex> Calendar.ISO.quarter_of_year(2016, 4, 3)\n    2\n    iex> Calendar.ISO.quarter_of_year(-99, 9, 31)\n    3\n    iex> Calendar.ISO.quarter_of_year(2018, 12, 28)\n    4\n\n","title":"Calendar.ISO.quarter_of_year/3","type":"function"},{"doc":"Converts a day fraction to this Calendar's representation of time. Examples iex&gt; Calendar.ISO . time_from_day_fraction ( { 1 , 2 } ) { 12 , 0 , 0 , { 0 , 6 } } iex&gt; Calendar.ISO . time_from_day_fraction ( { 13 , 24 } ) { 13 , 0 , 0 , { 0 , 6 } }","ref":"Calendar.ISO.html#time_from_day_fraction/1","source_doc":"Converts a day fraction to this Calendar's representation of time.\n\n## Examples\n\n    iex> Calendar.ISO.time_from_day_fraction({1, 2})\n    {12, 0, 0, {0, 6}}\n    iex> Calendar.ISO.time_from_day_fraction({13, 24})\n    {13, 0, 0, {0, 6}}\n\n","title":"Calendar.ISO.time_from_day_fraction/1","type":"function"},{"doc":"Returns the normalized day fraction of the specified time. Examples iex&gt; Calendar.ISO . time_to_day_fraction ( 0 , 0 , 0 , { 0 , 6 } ) { 0 , 86400000000 } iex&gt; Calendar.ISO . time_to_day_fraction ( 12 , 34 , 56 , { 123 , 6 } ) { 45296000123 , 86400000000 }","ref":"Calendar.ISO.html#time_to_day_fraction/4","source_doc":"Returns the normalized day fraction of the specified time.\n\n## Examples\n\n    iex> Calendar.ISO.time_to_day_fraction(0, 0, 0, {0, 6})\n    {0, 86400000000}\n    iex> Calendar.ISO.time_to_day_fraction(12, 34, 56, {123, 6})\n    {45296000123, 86400000000}\n\n","title":"Calendar.ISO.time_to_day_fraction/4","type":"function"},{"doc":"Converts the given time into a string. By default, returns times formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the :basic option. Examples iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 6 } ) &quot;02:02:02.000002&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 2 } ) &quot;02:02:02.00&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 0 } ) &quot;02:02:02&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 6 } , :basic ) &quot;020202.000002&quot; iex&gt; Calendar.ISO . time_to_string ( 2 , 2 , 2 , { 2 , 6 } , :extended ) &quot;02:02:02.000002&quot;","ref":"Calendar.ISO.html#time_to_string/5","source_doc":"Converts the given time into a string.\n\nBy default, returns times formatted in the \"extended\" format,\nfor human readability. It also supports the \"basic\" format\nby passing the `:basic` option.\n\n## Examples\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6})\n    \"02:02:02.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 2})\n    \"02:02:02.00\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 0})\n    \"02:02:02\"\n\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :basic)\n    \"020202.000002\"\n    iex> Calendar.ISO.time_to_string(2, 2, 2, {2, 6}, :extended)\n    \"02:02:02.000002\"\n\n","title":"Calendar.ISO.time_to_string/5","type":"function"},{"doc":"Converts a System.time_unit/0 to precision. Integer-based time units always get maximum precision. Examples iex&gt; Calendar.ISO . time_unit_to_precision ( :nanosecond ) 6 iex&gt; Calendar.ISO . time_unit_to_precision ( :second ) 0 iex&gt; Calendar.ISO . time_unit_to_precision ( 1 ) 6","ref":"Calendar.ISO.html#time_unit_to_precision/1","source_doc":"Converts a `t:System.time_unit/0` to precision.\n\nInteger-based time units always get maximum precision.\n\n## Examples\n\n    iex> Calendar.ISO.time_unit_to_precision(:nanosecond)\n    6\n\n    iex> Calendar.ISO.time_unit_to_precision(:second)\n    0\n\n    iex> Calendar.ISO.time_unit_to_precision(1)\n    6\n\n","title":"Calendar.ISO.time_unit_to_precision/1","type":"function"},{"doc":"Determines if the date given is valid according to the proleptic Gregorian calendar. Examples iex&gt; Calendar.ISO . valid_date? ( 2015 , 2 , 28 ) true iex&gt; Calendar.ISO . valid_date? ( 2015 , 2 , 30 ) false iex&gt; Calendar.ISO . valid_date? ( - 1 , 12 , 31 ) true iex&gt; Calendar.ISO . valid_date? ( - 1 , 12 , 32 ) false","ref":"Calendar.ISO.html#valid_date?/3","source_doc":"Determines if the date given is valid according to the proleptic Gregorian calendar.\n\n## Examples\n\n    iex> Calendar.ISO.valid_date?(2015, 2, 28)\n    true\n    iex> Calendar.ISO.valid_date?(2015, 2, 30)\n    false\n    iex> Calendar.ISO.valid_date?(-1, 12, 31)\n    true\n    iex> Calendar.ISO.valid_date?(-1, 12, 32)\n    false\n\n","title":"Calendar.ISO.valid_date?/3","type":"function"},{"doc":"Determines if the date given is valid according to the proleptic Gregorian calendar. Leap seconds are not supported by the built-in Calendar.ISO. Examples iex&gt; Calendar.ISO . valid_time? ( 10 , 50 , 25 , { 3006 , 6 } ) true iex&gt; Calendar.ISO . valid_time? ( 23 , 59 , 60 , { 0 , 0 } ) false iex&gt; Calendar.ISO . valid_time? ( 24 , 0 , 0 , { 0 , 0 } ) false","ref":"Calendar.ISO.html#valid_time?/4","source_doc":"Determines if the date given is valid according to the proleptic Gregorian calendar.\n\nLeap seconds are not supported by the built-in Calendar.ISO.\n\n## Examples\n\n    iex> Calendar.ISO.valid_time?(10, 50, 25, {3006, 6})\n    true\n    iex> Calendar.ISO.valid_time?(23, 59, 60, {0, 0})\n    false\n    iex> Calendar.ISO.valid_time?(24, 0, 0, {0, 0})\n    false\n\n","title":"Calendar.ISO.valid_time?/4","type":"function"},{"doc":"Calculates the year and era from the given year . The ISO calendar has two eras: the &quot;current era&quot; (CE) which starts in year 1 and is defined as era 1 . And &quot;before the current era&quot; (BCE) for those years less than 1 , defined as era 0 . Examples iex&gt; Calendar.ISO . year_of_era ( 1 ) { 1 , 1 } iex&gt; Calendar.ISO . year_of_era ( 2018 ) { 2018 , 1 } iex&gt; Calendar.ISO . year_of_era ( 0 ) { 1 , 0 } iex&gt; Calendar.ISO . year_of_era ( - 1 ) { 2 , 0 }","ref":"Calendar.ISO.html#year_of_era/1","source_doc":"Calculates the year and era from the given `year`.\n\nThe ISO calendar has two eras: the \"current era\" (CE) which\nstarts in year `1` and is defined as era `1`. And \"before the current\nera\" (BCE) for those years less than `1`, defined as era `0`.\n\n## Examples\n\n    iex> Calendar.ISO.year_of_era(1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1)\n    {2, 0}\n\n","title":"Calendar.ISO.year_of_era/1","type":"function"},{"doc":"Calendar callback to compute the year and era from the given year , month and day . In the ISO calendar, the new year coincides with the new era, so the month and day arguments are discarded. If you only have the year available, you can year_of_era/1 instead. Examples iex&gt; Calendar.ISO . year_of_era ( 1 , 1 , 1 ) { 1 , 1 } iex&gt; Calendar.ISO . year_of_era ( 2018 , 12 , 1 ) { 2018 , 1 } iex&gt; Calendar.ISO . year_of_era ( 0 , 1 , 1 ) { 1 , 0 } iex&gt; Calendar.ISO . year_of_era ( - 1 , 12 , 1 ) { 2 , 0 }","ref":"Calendar.ISO.html#year_of_era/3","source_doc":"Calendar callback to compute the year and era from the\ngiven `year`, `month` and `day`.\n\nIn the ISO calendar, the new year coincides with the new era,\nso the `month` and `day` arguments are discarded. If you only\nhave the year available, you can `year_of_era/1` instead.\n\n## Examples\n\n    iex> Calendar.ISO.year_of_era(1, 1, 1)\n    {1, 1}\n    iex> Calendar.ISO.year_of_era(2018, 12, 1)\n    {2018, 1}\n    iex> Calendar.ISO.year_of_era(0, 1, 1)\n    {1, 0}\n    iex> Calendar.ISO.year_of_era(-1, 12, 1)\n    {2, 0}\n\n","title":"Calendar.ISO.year_of_era/3","type":"function"},{"doc":"&quot;Before the Current Era&quot; or &quot;Before the Common Era&quot; (BCE), for those years less than 1 .","ref":"Calendar.ISO.html#t:bce/0","source_doc":"\"Before the Current Era\" or \"Before the Common Era\" (BCE), for those years less than `1`.\n","title":"Calendar.ISO.bce/0","type":"type"},{"doc":"The &quot;Current Era&quot; or the &quot;Common Era&quot; (CE) which starts in year 1 .","ref":"Calendar.ISO.html#t:ce/0","source_doc":"The \"Current Era\" or the \"Common Era\" (CE) which starts in year `1`.\n","title":"Calendar.ISO.ce/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:day/0","source_doc":false,"title":"Calendar.ISO.day/0","type":"type"},{"doc":"Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.","ref":"Calendar.ISO.html#t:day_of_week/0","source_doc":"Integer that represents the day of the week, where 1 is Monday and 7 is Sunday.\n","title":"Calendar.ISO.day_of_week/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:day_of_year/0","source_doc":false,"title":"Calendar.ISO.day_of_year/0","type":"type"},{"doc":"The calendar era. The ISO calendar has two eras: CE - which starts in year 1 and is defined as era 1 . BCE - for those years less than 1 and is defined as era 0 .","ref":"Calendar.ISO.html#t:era/0","source_doc":"The calendar era.\n\nThe ISO calendar has two eras:\n* [CE](`t:ce/0`) - which starts in year `1` and is defined as era `1`.\n* [BCE](`t:bce/0`) - for those years less than `1` and is defined as era `0`.\n","title":"Calendar.ISO.era/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:format/0","source_doc":false,"title":"Calendar.ISO.format/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:hour/0","source_doc":false,"title":"Calendar.ISO.hour/0","type":"type"},{"doc":"Microseconds with stored precision. The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.","ref":"Calendar.ISO.html#t:microsecond/0","source_doc":"Microseconds with stored precision.\n\nThe precision represents the number of digits that must be used when\nrepresenting the microseconds to external format. If the precision is 0,\nit means microseconds must be skipped.\n","title":"Calendar.ISO.microsecond/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:minute/0","source_doc":false,"title":"Calendar.ISO.minute/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:month/0","source_doc":false,"title":"Calendar.ISO.month/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:quarter_of_year/0","source_doc":false,"title":"Calendar.ISO.quarter_of_year/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:second/0","source_doc":false,"title":"Calendar.ISO.second/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:utc_offset/0","source_doc":false,"title":"Calendar.ISO.utc_offset/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:weekday/0","source_doc":false,"title":"Calendar.ISO.weekday/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:year/0","source_doc":false,"title":"Calendar.ISO.year/0","type":"type"},{"doc":"","ref":"Calendar.ISO.html#t:year_of_era/0","source_doc":false,"title":"Calendar.ISO.year_of_era/0","type":"type"},{"doc":"This module defines a behaviour for providing time zone data. IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.","ref":"Calendar.TimeZoneDatabase.html","source_doc":"This module defines a behaviour for providing time zone data.\n\nIANA provides time zone data that includes data about different\nUTC offsets and standard offsets for time zones.\n","title":"Calendar.TimeZoneDatabase","type":"behaviour"},{"doc":"Time zone period for a point in time in UTC for a specific time zone. Takes a time zone name and a point in time for UTC and returns a time_zone_period for that point in time.","ref":"Calendar.TimeZoneDatabase.html#c:time_zone_period_from_utc_iso_days/2","source_doc":"Time zone period for a point in time in UTC for a specific time zone.\n\nTakes a time zone name and a point in time for UTC and returns a\n`time_zone_period` for that point in time.\n","title":"Calendar.TimeZoneDatabase.time_zone_period_from_utc_iso_days/2","type":"callback"},{"doc":"Possible time zone periods for a certain time zone and wall clock date and time. When the provided naive datetime is ambiguous, return a tuple with :ambiguous and the two possible periods. The periods in the tuple must be sorted with the first element being the one that begins first. When the provided naive datetime is in a gap, such as during the &quot;spring forward&quot; when going from winter time to summer time, return a tuple with :gap and two periods with limits in a nested tuple. The first nested two-tuple is the period before the gap and a naive datetime with a limit for when the period ends (wall time). The second nested two-tuple is the period just after the gap and a datetime (wall time) for when the period begins just after the gap. If there is only a single possible period for the provided datetime , then return a tuple with :ok and the time_zone_period .","ref":"Calendar.TimeZoneDatabase.html#c:time_zone_periods_from_wall_datetime/2","source_doc":"Possible time zone periods for a certain time zone and wall clock date and time.\n\nWhen the provided naive datetime is ambiguous, return a tuple with `:ambiguous`\nand the two possible periods. The periods in the tuple must be sorted with the\nfirst element being the one that begins first.\n\nWhen the provided naive datetime is in a gap, such as during the \"spring forward\" when going\nfrom winter time to summer time, return a tuple with `:gap` and two periods with limits\nin a nested tuple. The first nested two-tuple is the period before the gap and a naive datetime\nwith a limit for when the period ends (wall time). The second nested two-tuple is the period\njust after the gap and a datetime (wall time) for when the period begins just after the gap.\n\nIf there is only a single possible period for the provided `datetime`, then return a tuple\nwith `:ok` and the `time_zone_period`.\n","title":"Calendar.TimeZoneDatabase.time_zone_periods_from_wall_datetime/2","type":"callback"},{"doc":"A period where a certain combination of UTC offset, standard offset, and zone abbreviation is in effect. For example, one period could be the summer of 2018 in the Europe/London timezone, where summer time/daylight saving time is in effect and lasts from spring to autumn. In autumn, the std_offset changes along with the zone_abbr so a different period is needed during winter.","ref":"Calendar.TimeZoneDatabase.html#t:time_zone_period/0","source_doc":"A period where a certain combination of UTC offset, standard offset, and zone\nabbreviation is in effect.\n\nFor example, one period could be the summer of 2018 in the `Europe/London` timezone,\nwhere summer time/daylight saving time is in effect and lasts from spring to autumn.\nIn autumn, the `std_offset` changes along with the `zone_abbr` so a different\nperiod is needed during winter.\n","title":"Calendar.TimeZoneDatabase.time_zone_period/0","type":"type"},{"doc":"Limit for when a certain time zone period begins or ends. A beginning is inclusive. An ending is exclusive. For example, if a period is from 2015-03-29 01:00:00 and until 2015-10-25 01:00:00 , the period includes and begins from the beginning of 2015-03-29 01:00:00 and lasts until just before 2015-10-25 01:00:00 . A beginning or end for certain periods are infinite, such as the latest period for time zones without DST or plans to change. However, for the purpose of this behaviour, they are only used for gaps in wall time where the needed period limits are at a certain time.","ref":"Calendar.TimeZoneDatabase.html#t:time_zone_period_limit/0","source_doc":"Limit for when a certain time zone period begins or ends.\n\nA beginning is inclusive. An ending is exclusive. For example, if a period is from\n`2015-03-29 01:00:00` and until `2015-10-25 01:00:00`, the period includes and\nbegins from the beginning of `2015-03-29 01:00:00` and lasts until just before\n`2015-10-25 01:00:00`.\n\nA beginning or end for certain periods are infinite, such as the latest\nperiod for time zones without DST or plans to change. However, for the purpose\nof this behaviour, they are only used for gaps in wall time where the needed\nperiod limits are at a certain time.\n","title":"Calendar.TimeZoneDatabase.time_zone_period_limit/0","type":"type"},{"doc":"Built-in time zone database that works only in the Etc/UTC timezone. For all other time zones, it returns {:error, :utc_only_time_zone_database} .","ref":"Calendar.UTCOnlyTimeZoneDatabase.html","source_doc":"Built-in time zone database that works only in the `Etc/UTC` timezone.\n\nFor all other time zones, it returns `{:error, :utc_only_time_zone_database}`.\n","title":"Calendar.UTCOnlyTimeZoneDatabase","type":"module"},{"doc":"Agents are a simple abstraction around state. Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time. The Agent module provides a basic server implementation that allows state to be retrieved and updated via a simple API. Examples For example, the following agent implements a counter: defmodule Counter do use Agent def start_link ( initial_value ) do Agent . start_link ( fn -&gt; initial_value end , name : __MODULE__ ) end def value do Agent . get ( __MODULE__ , &amp; &amp;1 ) end def increment do Agent . update ( __MODULE__ , &amp; ( &amp;1 + 1 ) ) end end Usage would be: Counter . start_link ( 0 ) #=&gt; {:ok, #PID&lt;0.123.0&gt;} Counter . value ( ) #=&gt; 0 Counter . increment ( ) #=&gt; :ok Counter . increment ( ) #=&gt; :ok Counter . value ( ) #=&gt; 2 Thanks to the agent server process, the counter can be safely incremented concurrently. Agents provide a segregation between the client and server APIs (similar to GenServer s). In particular, the functions passed as arguments to the calls to Agent functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled. Consider these two examples: # Compute in the agent/server def get_something ( agent ) do Agent . get ( agent , fn state -&gt; do_something_expensive ( state ) end ) end # Compute in the agent/client def get_something ( agent ) do Agent . get ( agent , &amp; &amp;1 ) |&gt; do_something_expensive ( ) end The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling do_something_expensive(state) outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values. How to supervise An Agent is most commonly started under a supervision tree. When we invoke use Agent , it automatically defines a child_spec/1 function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do: children = [ { Counter , 0 } ] Supervisor . start_link ( children , strategy : :one_for_all ) While one could also simply pass the Counter as a child to the supervisor, such as: children = [ Counter # Same as {Counter, []} ] Supervisor . start_link ( children , strategy : :one_for_all ) The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example: def start_link ( opts ) do { initial_value , opts } = Keyword . pop ( opts , :initial_value , 0 ) Agent . start_link ( fn -&gt; initial_value end , opts ) end and then you can use Counter , {Counter, name: :my_counter} or even {Counter, initial_value: 0, name: :my_counter} as a child specification. use Agent also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated child_spec/1 can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the child should be restarted, defaults to :permanent :shutdown - how to shut down the child, either immediately or by giving it time to shut down For example: use Agent , restart : :transient , shutdown : 10_000 See the &quot;Child specification&quot; section in the Supervisor module for more detailed information. The @doc annotation immediately preceding use Agent will be attached to the generated child_spec/1 function. Name registration An agent is bound to the same name registration rules as GenServers. Read more about it in the GenServer documentation. A word on distributed agents It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments. In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module. Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by shutting down some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module. The best solution is to simply use the explicit module, function, and arguments APIs when working with distributed agents. Hot code swapping An agent can have its code hot swapped live by simply passing a module, function, and arguments tuple to the update instruction. For example, imagine you have an agent named :sample and you want to convert its inner state from a keyword list to a map. It can be done with the following instruction: { :update , :sample , { :advanced , { Enum , :into , [ %{ } ] } } } The agent's state will be added to the given list of arguments ( [%{}] ) as the first argument.","ref":"Agent.html","source_doc":"Agents are a simple abstraction around state.\n\nOften in Elixir there is a need to share or store state that\nmust be accessed from different processes or by the same process\nat different points in time.\n\nThe `Agent` module provides a basic server implementation that\nallows state to be retrieved and updated via a simple API.\n\n## Examples\n\nFor example, the following agent implements a counter:\n\n    defmodule Counter do\n      use Agent\n\n      def start_link(initial_value) do\n        Agent.start_link(fn -> initial_value end, name: __MODULE__)\n      end\n\n      def value do\n        Agent.get(__MODULE__, & &1)\n      end\n\n      def increment do\n        Agent.update(__MODULE__, &(&1 + 1))\n      end\n    end\n\nUsage would be:\n\n    Counter.start_link(0)\n    #=> {:ok, #PID<0.123.0>}\n\n    Counter.value()\n    #=> 0\n\n    Counter.increment()\n    #=> :ok\n\n    Counter.increment()\n    #=> :ok\n\n    Counter.value()\n    #=> 2\n\nThanks to the agent server process, the counter can be safely incremented\nconcurrently.\n\nAgents provide a segregation between the client and server APIs (similar to\n`GenServer`s). In particular, the functions passed as arguments to the calls to\n`Agent` functions are invoked inside the agent (the server). This distinction\nis important because you may want to avoid expensive operations inside the\nagent, as they will effectively block the agent until the request is\nfulfilled.\n\nConsider these two examples:\n\n    # Compute in the agent/server\n    def get_something(agent) do\n      Agent.get(agent, fn state -> do_something_expensive(state) end)\n    end\n\n    # Compute in the agent/client\n    def get_something(agent) do\n      Agent.get(agent, & &1) |> do_something_expensive()\n    end\n\nThe first function blocks the agent. The second function copies all the state\nto the client and then executes the operation in the client. One aspect to\nconsider is whether the data is large enough to require processing in the server,\nat least initially, or small enough to be sent to the client cheaply. Another\nfactor is whether the data needs to be processed atomically: getting the\nstate and calling `do_something_expensive(state)` outside of the agent means\nthat the agent's state can be updated in the meantime. This is specially\nimportant in case of updates as computing the new state in the client rather\nthan in the server can lead to race conditions if multiple clients are trying\nto update the same state to different values.\n\n## How to supervise\n\nAn `Agent` is most commonly started under a supervision tree.\nWhen we invoke `use Agent`, it automatically defines a `child_spec/1`\nfunction that allows us to start the agent directly under a supervisor.\nTo start an agent under a supervisor with an initial counter of 0,\none may do:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nWhile one could also simply pass the `Counter` as a child to the supervisor,\nsuch as:\n\n    children = [\n      Counter # Same as {Counter, []}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nThe definition above wouldn't work for this particular example,\nas it would attempt to start the counter with an initial value\nof an empty list. However, this may be a viable option in your\nown agents. A common approach is to use a keyword list, as that\nwould allow setting the initial value and giving a name to the\ncounter process, for example:\n\n    def start_link(opts) do\n      {initial_value, opts} = Keyword.pop(opts, :initial_value, 0)\n      Agent.start_link(fn -> initial_value end, opts)\n    end\n\nand then you can use `Counter`, `{Counter, name: :my_counter}` or\neven `{Counter, initial_value: 0, name: :my_counter}` as a child\nspecification.\n\n`use Agent` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use Agent, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use Agent` will be attached to the generated `child_spec/1` function.\n\n## Name registration\n\nAn agent is bound to the same name registration rules as GenServers.\nRead more about it in the `GenServer` documentation.\n\n## A word on distributed agents\n\nIt is important to consider the limitations of distributed agents. Agents\nprovide two APIs, one that works with anonymous functions and another\nthat expects an explicit module, function, and arguments.\n\nIn a distributed setup with multiple nodes, the API that accepts anonymous\nfunctions only works if the caller (client) and the agent have the same\nversion of the caller module.\n\nKeep in mind this issue also shows up when performing \"rolling upgrades\"\nwith agents. By rolling upgrades we mean the following situation: you wish\nto deploy a new version of your software by *shutting down* some of your\nnodes and replacing them with nodes running a new version of the software.\nIn this setup, part of your environment will have one version of a given\nmodule and the other part another version (the newer one) of the same module.\n\nThe best solution is to simply use the explicit module, function, and arguments\nAPIs when working with distributed agents.\n\n## Hot code swapping\n\nAn agent can have its code hot swapped live by simply passing a module,\nfunction, and arguments tuple to the update instruction. For example, imagine\nyou have an agent named `:sample` and you want to convert its inner state\nfrom a keyword list to a map. It can be done with the following\ninstruction:\n\n    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n\nThe agent's state will be added to the given list of arguments (`[%{}]`) as\nthe first argument.\n","title":"Agent","type":"module"},{"doc":"Performs a cast ( fire and forget ) operation on the agent state. The function fun is sent to the agent which invokes the function passing the agent state. The return value of fun becomes the new state of the agent. Note that cast returns :ok immediately, regardless of whether agent (or the node it should live on) exists. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . cast ( pid , fn state -&gt; state + 1 end ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 43","ref":"Agent.html#cast/2","source_doc":"Performs a cast (*fire and forget*) operation on the agent state.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nNote that `cast` returns `:ok` immediately, regardless of whether `agent` (or\nthe node it should live on) exists.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43\n\n","title":"Agent.cast/2","type":"function"},{"doc":"Performs a cast ( fire and forget ) operation on the agent state. Same as cast/2 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . cast ( pid , Kernel , :+ , [ 12 ] ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 54","ref":"Agent.html#cast/4","source_doc":"Performs a cast (*fire and forget*) operation on the agent state.\n\nSame as `cast/2` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.cast(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54\n\n","title":"Agent.cast/4","type":"function"},{"doc":"Returns a specification to start an agent under a supervisor. See the &quot;Child specification&quot; section in the Supervisor module for more detailed information.","ref":"Agent.html#child_spec/1","source_doc":"Returns a specification to start an agent under a supervisor.\n\nSee the \"Child specification\" section in the `Supervisor` module for more detailed information.\n","title":"Agent.child_spec/1","type":"function"},{"doc":"Gets an agent value via the given anonymous function. The function fun is sent to the agent which invokes the function passing the agent state. The result of the function invocation is returned from this function. timeout is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom :infinity to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . get ( pid , fn state -&gt; state end ) 42","ref":"Agent.html#get/3","source_doc":"Gets an agent value via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The result of the function invocation is\nreturned from this function.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n","title":"Agent.get/3","type":"function"},{"doc":"Gets an agent value via the given function. Same as get/3 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments.","ref":"Agent.html#get/5","source_doc":"Gets an agent value via the given function.\n\nSame as `get/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n","title":"Agent.get/5","type":"function"},{"doc":"Gets and updates the agent state in one operation via the given anonymous function. The function fun is sent to the agent which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent. timeout is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom :infinity to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . get_and_update ( pid , fn state -&gt; { state , state + 1 } end ) 42 iex&gt; Agent . get ( pid , fn state -&gt; state end ) 43","ref":"Agent.html#get_and_update/3","source_doc":"Gets and updates the agent state in one operation via the given anonymous\nfunction.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The function must return a tuple with two\nelements, the first being the value to return (that is, the \"get\" value)\nand the second one being the new state of the agent.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get_and_update(pid, fn state -> {state, state + 1} end)\n    42\n    iex> Agent.get(pid, fn state -> state end)\n    43\n\n","title":"Agent.get_and_update/3","type":"function"},{"doc":"Gets and updates the agent state in one operation via the given function. Same as get_and_update/3 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments.","ref":"Agent.html#get_and_update/5","source_doc":"Gets and updates the agent state in one operation via the given function.\n\nSame as `get_and_update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n","title":"Agent.get_and_update/5","type":"function"},{"doc":"Starts an agent process without links (outside of a supervision tree). See start_link/2 for more information. Examples iex&gt; { :ok , pid } = Agent . start ( fn -&gt; 42 end ) iex&gt; Agent . get ( pid , fn state -&gt; state end ) 42","ref":"Agent.html#start/2","source_doc":"Starts an agent process without links (outside of a supervision tree).\n\nSee `start_link/2` for more information.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n","title":"Agent.start/2","type":"function"},{"doc":"Starts an agent without links with the given module, function, and arguments. See start_link/4 for more information.","ref":"Agent.html#start/4","source_doc":"Starts an agent without links with the given module, function, and arguments.\n\nSee `start_link/4` for more information.\n","title":"Agent.start/4","type":"function"},{"doc":"Starts an agent linked to the current process with the given function. This is often used to start the agent as part of a supervision tree. Once the agent is spawned, the given function fun is invoked in the server process, and should return the initial agent state. Note that start_link/2 does not return until the given function has returned. Options The :name option is used for registration as described in the module documentation. If the :timeout option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return {:error, :timeout} . If the :debug option is present, the corresponding function in the :sys module will be invoked. If the :spawn_opt option is present, its value will be passed as options to the underlying process as in Process.spawn/4 . Return values If the server is successfully created and initialized, the function returns {:ok, pid} , where pid is the PID of the server. If an agent with the specified name already exists, the function returns {:error, {:already_started, pid}} with the PID of that process. If the given function callback fails, the function returns {:error, reason} . Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . get ( pid , fn state -&gt; state end ) 42 iex&gt; { :error , { exception , _stacktrace } } = Agent . start ( fn -&gt; raise &quot;oops&quot; end ) iex&gt; exception % RuntimeError { message : &quot;oops&quot; }","ref":"Agent.html#start_link/2","source_doc":"Starts an agent linked to the current process with the given function.\n\nThis is often used to start the agent as part of a supervision tree.\n\nOnce the agent is spawned, the given function `fun` is invoked in the server\nprocess, and should return the initial agent state. Note that `start_link/2`\ndoes not return until the given function has returned.\n\n## Options\n\nThe `:name` option is used for registration as described in the module\ndocumentation.\n\nIf the `:timeout` option is present, the agent is allowed to spend at most\nthe given number of milliseconds on initialization or it will be terminated\nand the start function will return `{:error, :timeout}`.\n\nIf the `:debug` option is present, the corresponding function in the\n[`:sys` module](`:sys`) will be invoked.\n\nIf the `:spawn_opt` option is present, its value will be passed as options\nto the underlying process as in `Process.spawn/4`.\n\n## Return values\n\nIf the server is successfully created and initialized, the function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If an agent with the\nspecified name already exists, the function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the given function callback fails, the function returns `{:error, reason}`.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.get(pid, fn state -> state end)\n    42\n\n    iex> {:error, {exception, _stacktrace}} = Agent.start(fn -> raise \"oops\" end)\n    iex> exception\n    %RuntimeError{message: \"oops\"}\n\n","title":"Agent.start_link/2","type":"function"},{"doc":"Starts an agent linked to the current process. Same as start_link/2 but a module, function, and arguments are expected instead of an anonymous function; fun in module will be called with the given arguments args to initialize the state.","ref":"Agent.html#start_link/4","source_doc":"Starts an agent linked to the current process.\n\nSame as `start_link/2` but a module, function, and arguments are expected\ninstead of an anonymous function; `fun` in `module` will be called with the\ngiven arguments `args` to initialize the state.\n","title":"Agent.start_link/4","type":"function"},{"doc":"Synchronously stops the agent with the given reason . It returns :ok if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report will be logged. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . stop ( pid ) :ok","ref":"Agent.html#stop/3","source_doc":"Synchronously stops the agent with the given `reason`.\n\nIt returns `:ok` if the agent terminates with the given\nreason. If the agent terminates with another reason, the call will\nexit.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report will be logged.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.stop(pid)\n    :ok\n\n","title":"Agent.stop/3","type":"function"},{"doc":"Updates the agent state via the given anonymous function. The function fun is sent to the agent which invokes the function passing the agent state. The return value of fun becomes the new state of the agent. This function always returns :ok . timeout is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom :infinity to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . update ( pid , fn state -&gt; state + 1 end ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 43","ref":"Agent.html#update/3","source_doc":"Updates the agent state via the given anonymous function.\n\nThe function `fun` is sent to the `agent` which invokes the function\npassing the agent state. The return value of `fun` becomes the new\nstate of the agent.\n\nThis function always returns `:ok`.\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds are allowed before the agent executes the function and returns\nthe result value, or the atom `:infinity` to wait indefinitely. If no result\nis received within the specified time, the function call fails and the caller\nexits.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, fn state -> state + 1 end)\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    43\n\n","title":"Agent.update/3","type":"function"},{"doc":"Updates the agent state via the given function. Same as update/3 but a module, function, and arguments are expected instead of an anonymous function. The state is added as first argument to the given list of arguments. Examples iex&gt; { :ok , pid } = Agent . start_link ( fn -&gt; 42 end ) iex&gt; Agent . update ( pid , Kernel , :+ , [ 12 ] ) :ok iex&gt; Agent . get ( pid , fn state -&gt; state end ) 54","ref":"Agent.html#update/5","source_doc":"Updates the agent state via the given function.\n\nSame as `update/3` but a module, function, and arguments are expected\ninstead of an anonymous function. The state is added as first\nargument to the given list of arguments.\n\n## Examples\n\n    iex> {:ok, pid} = Agent.start_link(fn -> 42 end)\n    iex> Agent.update(pid, Kernel, :+, [12])\n    :ok\n    iex> Agent.get(pid, fn state -> state end)\n    54\n\n","title":"Agent.update/5","type":"function"},{"doc":"The agent reference","ref":"Agent.html#t:agent/0","source_doc":"The agent reference","title":"Agent.agent/0","type":"type"},{"doc":"The agent name","ref":"Agent.html#t:name/0","source_doc":"The agent name","title":"Agent.name/0","type":"type"},{"doc":"Return values of start* functions","ref":"Agent.html#t:on_start/0","source_doc":"Return values of `start*` functions","title":"Agent.on_start/0","type":"type"},{"doc":"The agent state","ref":"Agent.html#t:state/0","source_doc":"The agent state","title":"Agent.state/0","type":"type"},{"doc":"A module for working with applications and defining application callbacks. Applications are the idiomatic way to package software in Erlang/OTP. To get the idea, they are similar to the &quot;library&quot; concept common in other programming languages, but with some additional characteristics. An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and life cycle. Applications are loaded , started , and stopped . Each application also has its own environment, which provides a unified API for configuring each application. Developers typically interact with the application environment and its callback module. Therefore those will be the topics we will cover first before jumping into details about the application resource file and life-cycle. The application environment Each application has its own environment. The environment is a keyword list that maps atoms to terms. Note that this environment is unrelated to the operating system environment. By default, the environment of an application is an empty list. In a Mix project's mix.exs file, you can set the :env key in application/0 : def application do [ env : [ db_host : &quot;localhost&quot; ] ] end Now, in your application, you can read this environment by using functions such as fetch_env!/2 and friends: defmodule MyApp.DBClient do def start_link ( ) do SomeLib.DBClient . start_link ( host : db_host ( ) ) end defp db_host do Application . fetch_env! ( :my_app , :db_host ) end end In Mix projects, the environment of the application and its dependencies can be overridden via the config/config.exs and config/runtime.exs files. The former is loaded at build-time, before your code compiles, and the latter at runtime, just before your app starts. For example, someone using your application can override its :db_host environment variable as follows: import Config config :my_app , :db_host , &quot;db.local&quot; See the &quot;Configuration&quot; section in the Mix module for more information. You can also change the application environment dynamically by using functions such as put_env/3 and delete_env/2 . Environment in libraries The config files config/config.exs and config/runtime.exs are rarely used by libraries. Libraries typically define their environment in the application/0 function of their mix.exs . Configuration files are rather used by applications to configure their libraries. Reading the environment of other applications Each application is responsible for its own environment. Do not use the functions in this module for directly accessing or modifying the environment of other applications. Whenever you change the application environment, Elixir's build tool will only recompile the files that belong to that application. So if you read the application environment of another application, there is a chance you will be depending on outdated configuration, as your file won't be recompiled as it changes. Compile-time environment In the previous example, we read the application environment at runtime: defmodule MyApp.DBClient do def start_link ( ) do SomeLib.DBClient . start_link ( host : db_host ( ) ) end defp db_host do Application . fetch_env! ( :my_app , :db_host ) end end In other words, the environment key :db_host for application :my_app will only be read when MyApp.DBClient effectively starts. While reading the application environment at runtime is the preferred approach, in some rare occasions you may want to use the application environment to configure the compilation of a certain project. However, if you try to access Application.fetch_env!/2 outside of a function: defmodule MyApp.DBClient do @db_host Application . fetch_env! ( :my_app , :db_host ) def start_link ( ) do SomeLib.DBClient . start_link ( host : @db_host ) end end You might see warnings and errors: warning : Application . fetch_env! / 2 is discouraged in the module body , use Application . compile_env / 3 instead iex : 3 : MyApp.DBClient ** (ArgumentError) could not fetch application environment :db_host for application :my_app because the application was not loaded nor configured This happens because, when defining modules, the application environment is not yet available. Luckily, the warning tells us how to solve this issue, by using Application.compile_env/3 instead: defmodule MyApp.DBClient do @db_host Application . compile_env ( :my_app , :db_host , &quot;db.local&quot; ) def start_link ( ) do SomeLib.DBClient . start_link ( host : @db_host ) end end The difference here is that compile_env expects the default value to be given as an argument, instead of using the def application function of your mix.exs . Furthermore, by using compile_env/3 , tools like Mix will store the values used during compilation and compare the compilation values with the runtime values whenever your system starts, raising an error in case they differ. In any case, compile-time environments should be avoided. Whenever possible, reading the application environment at runtime should be the first choice. The application callback module Applications can be loaded, started, and stopped. Generally, build tools like Mix take care of starting an application and all of its dependencies for you, but you can also do it manually by calling: { :ok , _ } = Application . ensure_all_started ( :some_app ) When an application starts, developers may configure a callback module that executes custom code. Developers use this callback to start the application supervision tree. The first step to do so is to add a :mod key to the application/0 definition in your mix.exs file. It expects a tuple, with the application callback module and start argument (commonly an empty list): def application do [ mod : { MyApp , [ ] } ] end The MyApp module given to :mod needs to implement the Application behaviour. This can be done by putting use Application in that module and implementing the start/2 callback, for example: defmodule MyApp do use Application def start ( _type , _args ) do children = [ ] Supervisor . start_link ( children , strategy : :one_for_one ) end end The start/2 callback has to spawn and link a supervisor and return {:ok, pid} or {:ok, pid, state} , where pid is the PID of the supervisor, and state is an optional application state. args is the second element of the tuple given to the :mod option. The type argument passed to start/2 is usually :normal unless in a distributed setup where application takeovers and failovers are configured. Distributed applications are beyond the scope of this documentation. When an application is shutting down, its stop/1 callback is called after the supervision tree has been stopped by the runtime. This callback allows the application to do any final cleanup. The argument is the state returned by start/2 , if it did, or [] otherwise. The return value of stop/1 is ignored. By using Application , modules get a default implementation of stop/1 that ignores its argument and returns :ok , but it can be overridden. Application callback modules may also implement the optional callback prep_stop/1 . If present, prep_stop/1 is invoked before the supervision tree is terminated. Its argument is the state returned by start/2 , if it did, or [] otherwise, and its return value is passed to stop/1 . The application resource file In the sections above, we have configured an application in the application/0 section of the mix.exs file. Ultimately, Mix will use this configuration to create an application resource file , which is a file called APP_NAME.app . For example, the application resource file of the OTP application ex_unit is called ex_unit.app . You can learn more about the generation of application resource files in the documentation of Mix.Tasks.Compile.App , available as well by running mix help compile.app . The application life cycle Loading applications Applications are loaded , which means that the runtime finds and processes their resource files: Application . load ( :ex_unit ) #=&gt; :ok When an application is loaded, the environment specified in its resource file is merged with any overrides from config files. Loading an application does not load its modules. In practice, you rarely load applications by hand because that is part of the start process, explained next. Starting applications Applications are also started : Application . start ( :ex_unit ) #=&gt; :ok Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a main procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic. When an application is started, the Application.load/1 is automatically invoked if it hasn't been done yet. Then, it checks if the dependencies listed in the applications key of the resource file are already started. Having at least one dependency not started is an error condition. Functions like ensure_all_started/1 takes care of starting an application and all of its dependencies for you. If the application does not have a callback module configured, starting is done at this point. Otherwise, its start/2 callback is invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any. Stopping applications Started applications are, finally, stopped : Application . stop ( :ex_unit ) #=&gt; :ok Stopping an application without a callback module is defined, but except for some system tracing, it is in practice a no-op. Stopping an application with a callback module has three steps: If present, invoke the optional callback prep_stop/1 . Terminate the top-level supervisor. Invoke the required callback stop/1 . The arguments passed to the callbacks are related to the state optionally returned by start/2 , and are documented in the section about the callback module above. It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The stop/1 callback is invoked only after termination of the whole supervision tree. Shutting down a live system cleanly can be done by calling System.stop/1 . It will shut down every application in the opposite order they had been started. By default, a SIGTERM from the operating system will automatically translate to System.stop/0 . You can also have more explicit control over operating system signals via the :os.set_signal/2 function. Tooling The Mix build tool automates most of the application management tasks. For example, mix test automatically starts your application dependencies and your application itself before your test runs. mix run --no-halt boots your current project and can be used to start a long running system. See mix help run . Developers can also use mix release to build releases . Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring. Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See mix help archive.build and mix help escript.build for more detail. Further information For further details on applications please check the documentation of the :application Erlang module , and the Applications section of the OTP Design Principles User's Guide .","ref":"Application.html","source_doc":"A module for working with applications and defining application callbacks.\n\nApplications are the idiomatic way to package software in Erlang/OTP. To get\nthe idea, they are similar to the \"library\" concept common in other\nprogramming languages, but with some additional characteristics.\n\nAn application is a component implementing some specific functionality, with a\nstandardized directory structure, configuration, and life cycle. Applications\nare *loaded*, *started*, and *stopped*. Each application also has its own\nenvironment, which provides a unified API for configuring each application.\n\nDevelopers typically interact with the application environment and its\ncallback module. Therefore those will be the topics we will cover first\nbefore jumping into details about the application resource file and life-cycle.\n\n## The application environment\n\nEach application has its own environment. The environment is a keyword list\nthat maps atoms to terms. Note that this environment is unrelated to the\noperating system environment.\n\nBy default, the environment of an application is an empty list. In a Mix\nproject's `mix.exs` file, you can set the `:env` key in `application/0`:\n\n    def application do\n      [env: [db_host: \"localhost\"]]\n    end\n\nNow, in your application, you can read this environment by using functions\nsuch as `fetch_env!/2` and friends:\n\n    defmodule MyApp.DBClient do\n      def start_link() do\n        SomeLib.DBClient.start_link(host: db_host())\n      end\n\n      defp db_host do\n        Application.fetch_env!(:my_app, :db_host)\n      end\n    end\n\nIn Mix projects, the environment of the application and its dependencies can\nbe overridden via the `config/config.exs` and `config/runtime.exs` files. The\nformer is loaded at build-time, before your code compiles, and the latter at\nruntime, just before your app starts. For example, someone using your application\ncan override its `:db_host` environment variable as follows:\n\n    import Config\n    config :my_app, :db_host, \"db.local\"\n\nSee the \"Configuration\" section in the `Mix` module for more information.\nYou can also change the application environment dynamically by using functions\nsuch as `put_env/3` and `delete_env/2`.\n\n> #### Environment in libraries {: .tip}\n>\n> The config files `config/config.exs` and `config/runtime.exs`\n> are rarely used by libraries. Libraries typically define their environment\n> in the `application/0` function of their `mix.exs`. Configuration files\n> are rather used by applications to configure their libraries.\n\n> #### Reading the environment of other applications {: .warning}\n>\n> Each application is responsible for its own environment. Do not\n> use the functions in this module for directly accessing or modifying\n> the environment of other applications. Whenever you change the application\n> environment, Elixir's build tool will only recompile the files that\n> belong to that application. So if you read the application environment\n> of another application, there is a chance you will be depending on\n> outdated configuration, as your file won't be recompiled as it changes.\n\n## Compile-time environment\n\nIn the previous example, we read the application environment at runtime:\n\n    defmodule MyApp.DBClient do\n      def start_link() do\n        SomeLib.DBClient.start_link(host: db_host())\n      end\n\n      defp db_host do\n        Application.fetch_env!(:my_app, :db_host)\n      end\n    end\n\nIn other words, the environment key `:db_host` for application `:my_app`\nwill only be read when `MyApp.DBClient` effectively starts. While reading\nthe application environment at runtime is the preferred approach, in some\nrare occasions you may want to use the application environment to configure\nthe compilation of a certain project. However, if you try to access\n`Application.fetch_env!/2` outside of a function:\n\n    defmodule MyApp.DBClient do\n      @db_host Application.fetch_env!(:my_app, :db_host)\n\n      def start_link() do\n        SomeLib.DBClient.start_link(host: @db_host)\n      end\n    end\n\nYou might see warnings and errors:\n\n    warning: Application.fetch_env!/2 is discouraged in the module body,\n    use Application.compile_env/3 instead\n      iex:3: MyApp.DBClient\n\n    ** (ArgumentError) could not fetch application environment :db_host\n    for application :my_app because the application was not loaded nor\n    configured\n\nThis happens because, when defining modules, the application environment\nis not yet available. Luckily, the warning tells us how to solve this\nissue, by using `Application.compile_env/3` instead:\n\n    defmodule MyApp.DBClient do\n      @db_host Application.compile_env(:my_app, :db_host, \"db.local\")\n\n      def start_link() do\n        SomeLib.DBClient.start_link(host: @db_host)\n      end\n    end\n\nThe difference here is that `compile_env` expects the default value to be\ngiven as an argument, instead of using the `def application` function of\nyour `mix.exs`. Furthermore, by using `compile_env/3`, tools like Mix will\nstore the values used during compilation and compare the compilation values\nwith the runtime values whenever your system starts, raising an error in\ncase they differ.\n\nIn any case, compile-time environments should be avoided. Whenever possible,\nreading the application environment at runtime should be the first choice.\n\n## The application callback module\n\nApplications can be loaded, started, and stopped. Generally, build tools\nlike Mix take care of starting an application and all of its dependencies\nfor you, but you can also do it manually by calling:\n\n    {:ok, _} = Application.ensure_all_started(:some_app)\n\nWhen an application starts, developers may configure a callback module\nthat executes custom code. Developers use this callback to start the\napplication supervision tree.\n\nThe first step to do so is to add a `:mod` key to the `application/0`\ndefinition in your `mix.exs` file. It expects a tuple, with the application\ncallback module and start argument (commonly an empty list):\n\n    def application do\n      [mod: {MyApp, []}]\n    end\n\nThe `MyApp` module given to `:mod` needs to implement the `Application` behaviour.\nThis can be done by putting `use Application` in that module and implementing the\n`c:start/2` callback, for example:\n\n    defmodule MyApp do\n      use Application\n\n      def start(_type, _args) do\n        children = []\n        Supervisor.start_link(children, strategy: :one_for_one)\n      end\n    end\n\nThe `c:start/2` callback has to spawn and link a supervisor and return `{:ok,\npid}` or `{:ok, pid, state}`, where `pid` is the PID of the supervisor, and\n`state` is an optional application state. `args` is the second element of the\ntuple given to the `:mod` option.\n\nThe `type` argument passed to `c:start/2` is usually `:normal` unless in a\ndistributed setup where application takeovers and failovers are configured.\nDistributed applications are beyond the scope of this documentation.\n\nWhen an application is shutting down, its `c:stop/1` callback is called after\nthe supervision tree has been stopped by the runtime. This callback allows the\napplication to do any final cleanup. The argument is the state returned by\n`c:start/2`, if it did, or `[]` otherwise. The return value of `c:stop/1` is\nignored.\n\nBy using `Application`, modules get a default implementation of `c:stop/1`\nthat ignores its argument and returns `:ok`, but it can be overridden.\n\nApplication callback modules may also implement the optional callback\n`c:prep_stop/1`. If present, `c:prep_stop/1` is invoked before the supervision\ntree is terminated. Its argument is the state returned by `c:start/2`, if it did,\nor `[]` otherwise, and its return value is passed to `c:stop/1`.\n\n## The application resource file\n\nIn the sections above, we have configured an application in the\n`application/0` section of the `mix.exs` file. Ultimately, Mix will use\nthis configuration to create an [*application resource\nfile*](https://www.erlang.org/doc/man/application.html), which is a file called\n`APP_NAME.app`. For example, the application resource file of the OTP\napplication `ex_unit` is called `ex_unit.app`.\n\nYou can learn more about the generation of application resource files in\nthe documentation of `Mix.Tasks.Compile.App`, available as well by running\n`mix help compile.app`.\n\n## The application life cycle\n\n### Loading applications\n\nApplications are *loaded*, which means that the runtime finds and processes\ntheir resource files:\n\n    Application.load(:ex_unit)\n    #=> :ok\n\nWhen an application is loaded, the environment specified in its resource file\nis merged with any overrides from config files.\n\nLoading an application *does not* load its modules.\n\nIn practice, you rarely load applications by hand because that is part of the\nstart process, explained next.\n\n### Starting applications\n\nApplications are also *started*:\n\n    Application.start(:ex_unit)\n    #=> :ok\n\nOnce your application is compiled, running your system is a matter of starting\nyour current application and its dependencies. Differently from other languages,\nElixir does not have a `main` procedure that is responsible for starting your\nsystem. Instead, you start one or more applications, each with their own\ninitialization and termination logic.\n\nWhen an application is started, the `Application.load/1` is automatically\ninvoked if it hasn't been done yet. Then, it checks if the dependencies listed\nin the `applications` key of the resource file are already started. Having at\nleast one dependency not started is an error condition. Functions like\n`ensure_all_started/1` takes care of starting an application and all of its\ndependencies for you.\n\nIf the application does not have a callback module configured, starting is\ndone at this point. Otherwise, its `c:start/2` callback is invoked. The PID of\nthe top-level supervisor returned by this function is stored by the runtime\nfor later use, and the returned application state is saved too, if any.\n\n### Stopping applications\n\nStarted applications are, finally, *stopped*:\n\n    Application.stop(:ex_unit)\n    #=> :ok\n\nStopping an application without a callback module is defined, but except for\nsome system tracing, it is in practice a no-op.\n\nStopping an application with a callback module has three steps:\n\n  1. If present, invoke the optional callback `c:prep_stop/1`.\n  2. Terminate the top-level supervisor.\n  3. Invoke the required callback `c:stop/1`.\n\nThe arguments passed to the callbacks are related to the state optionally\nreturned by `c:start/2`, and are documented in the section about the callback\nmodule above.\n\nIt is important to highlight that step 2 is a blocking one. Termination of a\nsupervisor triggers a recursive chain of children terminations, therefore\norderly shutting down all descendant processes. The `c:stop/1` callback is\ninvoked only after termination of the whole supervision tree.\n\nShutting down a live system cleanly can be done by calling `System.stop/1`. It\nwill shut down every application in the opposite order they had been started.\n\nBy default, a SIGTERM from the operating system will automatically translate to\n`System.stop/0`. You can also have more explicit control over operating system\nsignals via the `:os.set_signal/2` function.\n\n## Tooling\n\nThe Mix build tool automates most of the application management tasks. For example,\n`mix test` automatically starts your application dependencies and your application\nitself before your test runs. `mix run --no-halt` boots your current project and\ncan be used to start a long running system. See `mix help run`.\n\nDevelopers can also use `mix release` to build **releases**. Releases are able to\npackage all of your source code as well as the Erlang VM into a single directory.\nReleases also give you explicit control over how each application is started and in\nwhich order. They also provide a more streamlined mechanism for starting and\nstopping systems, debugging, logging, as well as system monitoring.\n\nFinally, Elixir provides tools such as escripts and archives, which are\ndifferent mechanisms for packaging your application. Those are typically used\nwhen tools must be shared between developers and not as deployment options.\nSee `mix help archive.build` and `mix help escript.build` for more detail.\n\n## Further information\n\nFor further details on applications please check the documentation of the\n[`:application` Erlang module](`:application`), and the\n[Applications](https://www.erlang.org/doc/design_principles/applications.html)\nsection of the [OTP Design Principles User's\nGuide](https://www.erlang.org/doc/design_principles/users_guide.html).\n","title":"Application","type":"behaviour"},{"doc":"Gets the directory for app. This information is returned based on the code path. Here is an example: File . mkdir_p! ( &quot;foo/ebin&quot; ) Code . prepend_path ( &quot;foo/ebin&quot; ) Application . app_dir ( :foo ) #=&gt; &quot;foo&quot; Even though the directory is empty and there is no .app file it is considered the application directory based on the name &quot;foo/ebin&quot;. The name may contain a dash - which is considered to be the app version and it is removed for the lookup purposes: File . mkdir_p! ( &quot;bar-123/ebin&quot; ) Code . prepend_path ( &quot;bar-123/ebin&quot; ) Application . app_dir ( :bar ) #=&gt; &quot;bar-123&quot; For more information on code paths, check the Code module in Elixir and also Erlang's :code module .","ref":"Application.html#app_dir/1","source_doc":"Gets the directory for app.\n\nThis information is returned based on the code path. Here is an\nexample:\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n    Application.app_dir(:foo)\n    #=> \"foo\"\n\nEven though the directory is empty and there is no `.app` file\nit is considered the application directory based on the name\n\"foo/ebin\". The name may contain a dash `-` which is considered\nto be the app version and it is removed for the lookup purposes:\n\n    File.mkdir_p!(\"bar-123/ebin\")\n    Code.prepend_path(\"bar-123/ebin\")\n    Application.app_dir(:bar)\n    #=> \"bar-123\"\n\nFor more information on code paths, check the `Code` module in\nElixir and also Erlang's [`:code` module](`:code`).\n","title":"Application.app_dir/1","type":"function"},{"doc":"Returns the given path inside app_dir/1 . If path is a string, then it will be used as the path inside app_dir/1 . If path is a list of strings, it will be joined (see Path.join/1 ) and the result will be used as the path inside app_dir/1 . Examples File . mkdir_p! ( &quot;foo/ebin&quot; ) Code . prepend_path ( &quot;foo/ebin&quot; ) Application . app_dir ( :foo , &quot;my_path&quot; ) #=&gt; &quot;foo/my_path&quot; Application . app_dir ( :foo , [ &quot;my&quot; , &quot;nested&quot; , &quot;path&quot; ] ) #=&gt; &quot;foo/my/nested/path&quot;","ref":"Application.html#app_dir/2","source_doc":"Returns the given path inside `app_dir/1`.\n\nIf `path` is a string, then it will be used as the path inside `app_dir/1`. If\n`path` is a list of strings, it will be joined (see `Path.join/1`) and the result\nwill be used as the path inside `app_dir/1`.\n\n## Examples\n\n    File.mkdir_p!(\"foo/ebin\")\n    Code.prepend_path(\"foo/ebin\")\n\n    Application.app_dir(:foo, \"my_path\")\n    #=> \"foo/my_path\"\n\n    Application.app_dir(:foo, [\"my\", \"nested\", \"path\"])\n    #=> \"foo/my/nested/path\"\n\n","title":"Application.app_dir/2","type":"function"},{"doc":"Reads the application environment at compilation time. Similar to get_env/3 , except it must be used to read values at compile time. This allows Elixir to track when configuration values change between compile time and runtime. The first argument is the application name. The second argument key_or_path is either an atom key or a path to traverse in search of the configuration, starting with an atom key. For example, imagine the following configuration: config :my_app , :key , [ foo : [ bar : :baz ] ] We can access it during compile time as: Application . compile_env ( :my_app , :key ) #=&gt; [foo: [bar: :baz]] Application . compile_env ( :my_app , [ :key , :foo ] ) #=&gt; [bar: :baz] Application . compile_env ( :my_app , [ :key , :foo , :bar ] ) #=&gt; :baz A default value can also be given as third argument. If any of the keys in the path along the way is missing, the default value is used: Application . compile_env ( :my_app , [ :unknown , :foo , :bar ] , :default ) #=&gt; :default Application . compile_env ( :my_app , [ :key , :unknown , :bar ] , :default ) #=&gt; :default Application . compile_env ( :my_app , [ :key , :foo , :unknown ] , :default ) #=&gt; :default Giving a path is useful to let Elixir know that only certain paths in a large configuration are compile time dependent.","ref":"Application.html#compile_env/3","source_doc":"Reads the application environment at compilation time.\n\nSimilar to `get_env/3`, except it must be used to read values\nat compile time. This allows Elixir to track when configuration\nvalues change between compile time and runtime.\n\nThe first argument is the application name. The second argument\n`key_or_path` is either an atom key or a path to traverse in\nsearch of the configuration, starting with an atom key.\n\nFor example, imagine the following configuration:\n\n    config :my_app, :key, [foo: [bar: :baz]]\n\nWe can access it during compile time as:\n\n    Application.compile_env(:my_app, :key)\n    #=> [foo: [bar: :baz]]\n\n    Application.compile_env(:my_app, [:key, :foo])\n    #=> [bar: :baz]\n\n    Application.compile_env(:my_app, [:key, :foo, :bar])\n    #=> :baz\n\nA default value can also be given as third argument. If\nany of the keys in the path along the way is missing, the\ndefault value is used:\n\n    Application.compile_env(:my_app, [:unknown, :foo, :bar], :default)\n    #=> :default\n\n    Application.compile_env(:my_app, [:key, :unknown, :bar], :default)\n    #=> :default\n\n    Application.compile_env(:my_app, [:key, :foo, :unknown], :default)\n    #=> :default\n\nGiving a path is useful to let Elixir know that only certain paths\nin a large configuration are compile time dependent.\n","title":"Application.compile_env/3","type":"macro"},{"doc":"Reads the application environment at compilation time from a macro. Typically, developers will use compile_env/3 . This function must only be invoked from macros which aim to read the compilation environment dynamically. It expects a Macro.Env as first argument, where the Macro.Env is typically the __CALLER__ in a macro. It raises if Macro.Env comes from a function.","ref":"Application.html#compile_env/4","source_doc":"Reads the application environment at compilation time from a macro.\n\nTypically, developers will use `compile_env/3`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.\n","title":"Application.compile_env/4","type":"function"},{"doc":"Reads the application environment at compilation time or raises. This is the same as compile_env/3 but it raises an ArgumentError if the configuration is not available.","ref":"Application.html#compile_env!/2","source_doc":"Reads the application environment at compilation time or raises.\n\nThis is the same as `compile_env/3` but it raises an\n`ArgumentError` if the configuration is not available.\n","title":"Application.compile_env!/2","type":"macro"},{"doc":"Reads the application environment at compilation time from a macro or raises. Typically, developers will use compile_env!/2 . This function must only be invoked from macros which aim to read the compilation environment dynamically. It expects a Macro.Env as first argument, where the Macro.Env is typically the __CALLER__ in a macro. It raises if Macro.Env comes from a function.","ref":"Application.html#compile_env!/3","source_doc":"Reads the application environment at compilation time from a macro\nor raises.\n\nTypically, developers will use `compile_env!/2`. This function must\nonly be invoked from macros which aim to read the compilation environment\ndynamically.\n\nIt expects a `Macro.Env` as first argument, where the `Macro.Env` is\ntypically the `__CALLER__` in a macro. It raises if `Macro.Env` comes\nfrom a function.\n","title":"Application.compile_env!/3","type":"function"},{"doc":"Callback invoked after code upgrade, if the application environment has changed. changed is a keyword list of keys and their changed values in the application environment. new is a keyword list with all new keys and their values. removed is a list with all removed keys.","ref":"Application.html#c:config_change/3","source_doc":"Callback invoked after code upgrade, if the application environment\nhas changed.\n\n`changed` is a keyword list of keys and their changed values in the\napplication environment. `new` is a keyword list with all new keys\nand their values. `removed` is a list with all removed keys.\n","title":"Application.config_change/3","type":"callback"},{"doc":"Deletes the key from the given app environment. It receives the same options as put_env/4 . Returns :ok .","ref":"Application.html#delete_env/3","source_doc":"Deletes the `key` from the given `app` environment.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.\n","title":"Application.delete_env/3","type":"function"},{"doc":"Ensures the given app or apps and their child applications are started. Options :type - if the application should be started in :permanent , :temporary , or :transient . See start/2 for more information. :mode - (since v1.15.0) if the applications should be started serially or concurrently. This option requires Erlang/OTP 26+.","ref":"Application.html#ensure_all_started/2","source_doc":"Ensures the given `app` or `apps` and their child applications are started.\n\n## Options\n\n  * `:type` - if the application should be started in `:permanent`,\n    `:temporary`, or `:transient`. See `start/2` for more information.\n\n  * `:mode` - (since v1.15.0) if the applications should be started serially\n    or concurrently. This option requires Erlang/OTP 26+.\n\n","title":"Application.ensure_all_started/2","type":"function"},{"doc":"Ensures the given app is loaded. Same as load/1 but returns :ok if the application was already loaded.","ref":"Application.html#ensure_loaded/1","source_doc":"Ensures the given `app` is loaded.\n\nSame as `load/1` but returns `:ok` if the application was already\nloaded.\n","title":"Application.ensure_loaded/1","type":"function"},{"doc":"Ensures the given app is started. Same as start/2 but returns :ok if the application was already started. Options :type - if the application should be started in :permanent , :temporary , or :transient . See start/2 for more information.","ref":"Application.html#ensure_started/2","source_doc":"Ensures the given `app` is started.\n\nSame as `start/2` but returns `:ok` if the application was already\nstarted.\n\n## Options\n\n  * `:type` - if the application should be started in `:permanent`,\n    `:temporary`, or `:transient`. See `start/2` for more information.\n\n","title":"Application.ensure_started/2","type":"function"},{"doc":"Returns the value for key in app 's environment in a tuple. If the configuration parameter does not exist, the function returns :error . Warning You must use this function to read only your own application environment. Do not read the environment of other applications. Application environment in info If you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our library guidelines .","ref":"Application.html#fetch_env/2","source_doc":"Returns the value for `key` in `app`'s environment in a tuple.\n\nIf the configuration parameter does not exist, the function returns `:error`.\n\n> #### Warning {: .warning}\n>\n> You must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> #### Application environment in info\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n","title":"Application.fetch_env/2","type":"function"},{"doc":"Returns the value for key in app 's environment. If the configuration parameter does not exist, raises ArgumentError . Warning You must use this function to read only your own application environment. Do not read the environment of other applications. Application environment in info If you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our library guidelines .","ref":"Application.html#fetch_env!/2","source_doc":"Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, raises `ArgumentError`.\n\n> #### Warning {: .warning}\n>\n> You must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> #### Application environment in info\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n","title":"Application.fetch_env!/2","type":"function"},{"doc":"Formats the error reason returned by start/2 , ensure_started/2 , stop/1 , load/1 and unload/1 , returns a string.","ref":"Application.html#format_error/1","source_doc":"Formats the error reason returned by `start/2`,\n`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\nreturns a string.\n","title":"Application.format_error/1","type":"function"},{"doc":"Returns all key-value pairs for app .","ref":"Application.html#get_all_env/1","source_doc":"Returns all key-value pairs for `app`.\n","title":"Application.get_all_env/1","type":"function"},{"doc":"Gets the application for the given module. The application is located by analyzing the spec of all loaded applications. Returns nil if the module is not listed in any application spec.","ref":"Application.html#get_application/1","source_doc":"Gets the application for the given module.\n\nThe application is located by analyzing the spec\nof all loaded applications. Returns `nil` if\nthe module is not listed in any application spec.\n","title":"Application.get_application/1","type":"function"},{"doc":"Returns the value for key in app 's environment. If the configuration parameter does not exist, the function returns the default value. Warning You must use this function to read only your own application environment. Do not read the environment of other applications. Application environment in libraries If you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our library guidelines . Examples get_env/3 is commonly used to read the configuration of your OTP applications. Since Mix configurations are commonly used to configure applications, we will use this as a point of illustration. Consider a new application :my_app . :my_app contains a database engine which supports a pool of databases. The database engine needs to know the configuration for each of those databases, and that configuration is supplied by key-value pairs in environment of :my_app . config :my_app , Databases.RepoOne , # A database configuration ip : &quot;localhost&quot; , port : 5433 config :my_app , Databases.RepoTwo , # Another database configuration (for the same OTP app) ip : &quot;localhost&quot; , port : 20717 config :my_app , my_app_databases : [ Databases.RepoOne , Databases.RepoTwo ] Our database engine used by :my_app needs to know what databases exist, and what the database configurations are. The database engine can make a call to Application.get_env(:my_app, :my_app_databases, []) to retrieve the list of databases (specified by module names). The engine can then traverse each repository in the list and call Application.get_env(:my_app, Databases.RepoOne) and so forth to retrieve the configuration of each one. In this case, each configuration will be a keyword list, so you can use the functions in the Keyword module or even the Access module to traverse it, for example: config = Application . get_env ( :my_app , Databases.RepoOne ) config [ :ip ]","ref":"Application.html#get_env/3","source_doc":"Returns the value for `key` in `app`'s environment.\n\nIf the configuration parameter does not exist, the function returns the\n`default` value.\n\n> #### Warning {: .warning}\n>\n> You must use this function to read only your own application\n> environment. Do not read the environment of other applications.\n\n> #### Application environment in libraries {: .info}\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. For more information,\n> read our [library guidelines](library-guidelines.md).\n\n## Examples\n\n`get_env/3` is commonly used to read the configuration of your OTP applications.\nSince Mix configurations are commonly used to configure applications, we will use\nthis as a point of illustration.\n\nConsider a new application `:my_app`. `:my_app` contains a database engine which\nsupports a pool of databases. The database engine needs to know the configuration for\neach of those databases, and that configuration is supplied by key-value pairs in\nenvironment of `:my_app`.\n\n    config :my_app, Databases.RepoOne,\n      # A database configuration\n      ip: \"localhost\",\n      port: 5433\n\n    config :my_app, Databases.RepoTwo,\n      # Another database configuration (for the same OTP app)\n      ip: \"localhost\",\n      port: 20717\n\n    config :my_app, my_app_databases: [Databases.RepoOne, Databases.RepoTwo]\n\nOur database engine used by `:my_app` needs to know what databases exist, and\nwhat the database configurations are. The database engine can make a call to\n`Application.get_env(:my_app, :my_app_databases, [])` to retrieve the list of\ndatabases (specified by module names).\n\nThe engine can then traverse each repository in the list and call\n`Application.get_env(:my_app, Databases.RepoOne)` and so forth to retrieve the\nconfiguration of each one. In this case, each configuration will be a keyword\nlist, so you can use the functions in the `Keyword` module or even the `Access`\nmodule to traverse it, for example:\n\n    config = Application.get_env(:my_app, Databases.RepoOne)\n    config[:ip]\n\n","title":"Application.get_env/3","type":"function"},{"doc":"Loads the given app . In order to be loaded, an .app file must be in the load paths. All :included_applications will also be loaded. Loading the application does not start it nor load its modules, but it does load its environment.","ref":"Application.html#load/1","source_doc":"Loads the given `app`.\n\nIn order to be loaded, an `.app` file must be in the load paths.\nAll `:included_applications` will also be loaded.\n\nLoading the application does not start it nor load its modules, but\nit does load its environment.\n","title":"Application.load/1","type":"function"},{"doc":"Returns a list with information about the applications which have been loaded.","ref":"Application.html#loaded_applications/0","source_doc":"Returns a list with information about the applications which have been loaded.\n","title":"Application.loaded_applications/0","type":"function"},{"doc":"Called before stopping the application. This function is called before the top-level supervisor is terminated. It receives the state returned by start/2 , if it did, or [] otherwise. The return value is later passed to stop/1 .","ref":"Application.html#c:prep_stop/1","source_doc":"Called before stopping the application.\n\nThis function is called before the top-level supervisor is terminated. It\nreceives the state returned by `c:start/2`, if it did, or `[]` otherwise.\nThe return value is later passed to `c:stop/1`.\n","title":"Application.prep_stop/1","type":"callback"},{"doc":"Puts the environment for multiple apps at the same time. The given config should not: have the same application listed more than once have the same key inside the same application listed more than once If those conditions are not met, it will raise. It receives the same options as put_env/4 . Returns :ok .","ref":"Application.html#put_all_env/2","source_doc":"Puts the environment for multiple apps at the same time.\n\nThe given config should not:\n\n  * have the same application listed more than once\n  * have the same key inside the same application listed more than once\n\nIf those conditions are not met, it will raise.\n\nIt receives the same options as `put_env/4`. Returns `:ok`.\n","title":"Application.put_all_env/2","type":"function"},{"doc":"Puts the value in key for the given app . Options :timeout - the timeout for the change (defaults to 5_000 milliseconds) :persistent - persists the given value on application load and reloads If put_env/4 is called before the application is loaded, the application environment values specified in the .app file will override the ones previously set. The :persistent option can be set to true when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.","ref":"Application.html#put_env/4","source_doc":"Puts the `value` in `key` for the given `app`.\n\n## Options\n\n  * `:timeout` - the timeout for the change (defaults to `5_000` milliseconds)\n  * `:persistent` - persists the given value on application load and reloads\n\nIf `put_env/4` is called before the application is loaded, the application\nenvironment values specified in the `.app` file will override the ones\npreviously set.\n\nThe `:persistent` option can be set to `true` when there is a need to guarantee\nparameters set with this function will not be overridden by the ones defined\nin the application resource file on load. This means persistent values will\nstick after the application is loaded and also on application reload.\n","title":"Application.put_env/4","type":"function"},{"doc":"Returns the spec for app . The following keys are returned: :description :id :vsn :modules :maxP :maxT :registered :included_applications :optional_applications :applications :mod :start_phases Note the environment is not returned as it can be accessed via fetch_env/2 . Returns nil if the application is not loaded.","ref":"Application.html#spec/1","source_doc":"Returns the spec for `app`.\n\nThe following keys are returned:\n\n  * `:description`\n  * `:id`\n  * `:vsn`\n  * `:modules`\n  * `:maxP`\n  * `:maxT`\n  * `:registered`\n  * `:included_applications`\n  * `:optional_applications`\n  * `:applications`\n  * `:mod`\n  * `:start_phases`\n\nNote the environment is not returned as it can be accessed via\n`fetch_env/2`. Returns `nil` if the application is not loaded.\n","title":"Application.spec/1","type":"function"},{"doc":"Returns the value for key in app 's specification. See spec/1 for the supported keys. If the given specification parameter does not exist, this function will raise. Returns nil if the application is not loaded.","ref":"Application.html#spec/2","source_doc":"Returns the value for `key` in `app`'s specification.\n\nSee `spec/1` for the supported keys. If the given\nspecification parameter does not exist, this function\nwill raise. Returns `nil` if the application is not loaded.\n","title":"Application.spec/2","type":"function"},{"doc":"Starts the given app . If the app is not loaded, the application will first be loaded using load/1 . Any included application, defined in the :included_applications key of the .app file will also be loaded, but they won't be started. Furthermore, all applications listed in the :applications key must be explicitly started before this application is. If not, {:error, {:not_started, app}} is returned, where app is the name of the missing application. In case you want to automatically load and start all of app 's dependencies, see ensure_all_started/2 . Options :type - specifies the type of the application: :permanent - if app terminates, all other applications and the entire node are also terminated. :transient - if app terminates with :normal reason, it is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire node are also terminated. :temporary - if app terminates, it is reported but no other applications are terminated (the default). Note that it is always possible to stop an application explicitly by calling stop/1 . Regardless of the type of the application, no other applications will be affected. Note also that the :transient type is of little practical use, since when a supervision tree terminates, the reason is set to :shutdown , not :normal .","ref":"Application.html#start/2","source_doc":"Starts the given `app`.\n\nIf the `app` is not loaded, the application will first be loaded using `load/1`.\nAny included application, defined in the `:included_applications` key of the\n`.app` file will also be loaded, but they won't be started.\n\nFurthermore, all applications listed in the `:applications` key must be explicitly\nstarted before this application is. If not, `{:error, {:not_started, app}}` is\nreturned, where `app` is the name of the missing application.\n\nIn case you want to automatically load **and start** all of `app`'s dependencies,\nsee `ensure_all_started/2`.\n\n## Options\n\n  * `:type` - specifies the type of the application:\n\n    * `:permanent` - if `app` terminates, all other applications and the entire\n      node are also terminated.\n\n    * `:transient` - if `app` terminates with `:normal` reason, it is reported\n      but no other applications are terminated. If a transient application\n      terminates abnormally, all other applications and the entire node are\n      also terminated.\n\n    * `:temporary` - if `app` terminates, it is reported but no other\n      applications are terminated (the default).\n\n    Note that it is always possible to stop an application explicitly by calling\n    `stop/1`. Regardless of the type of the application, no other applications will\n    be affected.\n\n    Note also that the `:transient` type is of little practical use, since when a\n    supervision tree terminates, the reason is set to `:shutdown`, not `:normal`.\n","title":"Application.start/2","type":"function"},{"doc":"Called when an application is started. This function is called when an application is started using Application.start/2 (and functions on top of that, such as Application.ensure_started/2 ). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision). start_type defines how the application is started: :normal - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key :start_phases is :undefined . {:takeover, node} - used if the application is distributed and is started on the current node because of a failover on the node node . {:failover, node} - used if the application is distributed and is started on the current node because of a failover on node node , and the application specification key :start_phases is not :undefined . start_args are the arguments passed to the application in the :mod specification key (for example, mod: {MyApp, [:my_args]} ). This function should either return {:ok, pid} or {:ok, pid, state} if startup is successful. pid should be the PID of the top supervisor. state can be an arbitrary term, and if omitted will default to [] ; if the application is later stopped, state is passed to the stop/1 callback (see the documentation for the stop/1 callback for more information). use Application provides no default implementation for the start/2 callback.","ref":"Application.html#c:start/2","source_doc":"Called when an application is started.\n\nThis function is called when an application is started using\n`Application.start/2` (and functions on top of that, such as\n`Application.ensure_started/2`). This function should start the top-level\nprocess of the application (which should be the top supervisor of the\napplication's supervision tree if the application follows the OTP design\nprinciples around supervision).\n\n`start_type` defines how the application is started:\n\n  * `:normal` - used if the startup is a normal startup or if the application\n    is distributed and is started on the current node because of a failover\n    from another node and the application specification key `:start_phases`\n    is `:undefined`.\n  * `{:takeover, node}` - used if the application is distributed and is\n    started on the current node because of a failover on the node `node`.\n  * `{:failover, node}` - used if the application is distributed and is\n    started on the current node because of a failover on node `node`, and the\n    application specification key `:start_phases` is not `:undefined`.\n\n`start_args` are the arguments passed to the application in the `:mod`\nspecification key (for example, `mod: {MyApp, [:my_args]}`).\n\nThis function should either return `{:ok, pid}` or `{:ok, pid, state}` if\nstartup is successful. `pid` should be the PID of the top supervisor. `state`\ncan be an arbitrary term, and if omitted will default to `[]`; if the\napplication is later stopped, `state` is passed to the `stop/1` callback (see\nthe documentation for the `c:stop/1` callback for more information).\n\n`use Application` provides no default implementation for the `start/2`\ncallback.\n","title":"Application.start/2","type":"callback"},{"doc":"Starts an application in synchronous phases. This function is called after start/2 finishes but before Application.start/2 returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.","ref":"Application.html#c:start_phase/3","source_doc":"Starts an application in synchronous phases.\n\nThis function is called after `start/2` finishes but before\n`Application.start/2` returns. It will be called once for every start phase\ndefined in the application's (and any included applications') specification,\nin the order they are listed in.\n","title":"Application.start_phase/3","type":"callback"},{"doc":"Returns a list with information about the applications which are currently running.","ref":"Application.html#started_applications/1","source_doc":"Returns a list with information about the applications which are currently running.\n","title":"Application.started_applications/1","type":"function"},{"doc":"Stops the given app . When stopped, the application is still loaded.","ref":"Application.html#stop/1","source_doc":"Stops the given `app`.\n\nWhen stopped, the application is still loaded.\n","title":"Application.stop/1","type":"function"},{"doc":"Called after an application has been stopped. This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the start/2 callback did, and should perform any necessary cleanup. The return value of this callback is ignored. state is the state returned by start/2 , if it did, or [] otherwise. If the optional callback prep_stop/1 is present, state is its return value instead. use Application defines a default implementation of this function which does nothing and just returns :ok .","ref":"Application.html#c:stop/1","source_doc":"Called after an application has been stopped.\n\nThis function is called after an application has been stopped, i.e., after its\nsupervision tree has been stopped. It should do the opposite of what the\n`c:start/2` callback did, and should perform any necessary cleanup. The return\nvalue of this callback is ignored.\n\n`state` is the state returned by `c:start/2`, if it did, or `[]` otherwise.\nIf the optional callback `c:prep_stop/1` is present, `state` is its return\nvalue instead.\n\n`use Application` defines a default implementation of this function which does\nnothing and just returns `:ok`.\n","title":"Application.stop/1","type":"callback"},{"doc":"Unloads the given app . It will also unload all :included_applications . Note that the function does not purge the application modules.","ref":"Application.html#unload/1","source_doc":"Unloads the given `app`.\n\nIt will also unload all `:included_applications`.\nNote that the function does not purge the application modules.\n","title":"Application.unload/1","type":"function"},{"doc":"","ref":"Application.html#t:app/0","source_doc":false,"title":"Application.app/0","type":"type"},{"doc":"","ref":"Application.html#t:application_key/0","source_doc":false,"title":"Application.application_key/0","type":"type"},{"doc":"","ref":"Application.html#t:key/0","source_doc":false,"title":"Application.key/0","type":"type"},{"doc":"","ref":"Application.html#t:restart_type/0","source_doc":false,"title":"Application.restart_type/0","type":"type"},{"doc":"","ref":"Application.html#t:start_type/0","source_doc":false,"title":"Application.start_type/0","type":"type"},{"doc":"","ref":"Application.html#t:state/0","source_doc":false,"title":"Application.state/0","type":"type"},{"doc":"","ref":"Application.html#t:value/0","source_doc":false,"title":"Application.value/0","type":"type"},{"doc":"A simple keyword-based configuration API. Example This module is most commonly used to define application configuration, typically in config/config.exs : import Config config :some_app , key1 : &quot;value1&quot; , key2 : &quot;value2&quot; import_config &quot; \#{ config_env ( ) } .exs&quot; import Config will import the functions config/2 , config/3 config_env/0 , config_target/0 , and import_config/1 to help you manage your configuration. config/2 and config/3 are used to define key-value configuration for a given application. Once Mix starts, it will automatically evaluate the configuration file and persist the configuration above into :some_app 's application environment, which can be accessed in as follows: &quot;value1&quot; = Application . fetch_env! ( :some_app , :key1 ) Finally, the line import_config &quot;\#{config_env()}.exs&quot; will import other config files based on the current configuration environment, such as config/dev.exs and config/test.exs . Config also provides a low-level API for evaluating and reading configuration, under the Config.Reader module. Avoid application environment in libraries If you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. Also note that the config/config.exs of a library is not evaluated when the library is used as a dependency, as configuration is always meant to configure the current project. For more information, read our library guidelines . Migrating from use Mix.Config The Config module in Elixir was introduced in v1.9 as a replacement to Mix.Config , which was specific to Mix and has been deprecated. You can leverage Config instead of Mix.Config in three steps. The first step is to replace use Mix.Config at the top of your config files by import Config . The second is to make sure your import_config/1 calls do not have a wildcard character. If so, you need to perform the wildcard lookup manually. For example, if you did: import_config &quot;../apps/*/config/config.exs&quot; It has to be replaced by: for config &lt;- &quot;../apps/*/config/config.exs&quot; |&gt; Path . expand ( __DIR__ ) |&gt; Path . wildcard ( ) do import_config config end The last step is to replace all Mix.env() calls in the config files with config_env() . Keep in mind you must also avoid using Mix.env() inside your project files. To check the environment at runtime , you may add a configuration key: # config.exs ... config :my_app , env : config_env ( ) Then, in other scripts and modules, you may get the environment with Application.fetch_env!/2 : # router.exs ... if Application . fetch_env! ( :my_app , :env ) == :prod do ... end The only files where you may access functions from the Mix module are the mix.exs file and inside custom Mix tasks, which always within the Mix.Tasks namespace. config/runtime.exs For runtime configuration, you can use the config/runtime.exs file. It is executed right before applications start in both Mix and releases (assembled with mix release ).","ref":"Config.html","source_doc":"A simple keyword-based configuration API.\n\n## Example\n\nThis module is most commonly used to define application configuration,\ntypically in `config/config.exs`:\n\n    import Config\n\n    config :some_app,\n      key1: \"value1\",\n      key2: \"value2\"\n\n    import_config \"\#{config_env()}.exs\"\n\n`import Config` will import the functions `config/2`, `config/3`\n`config_env/0`, `config_target/0`, and `import_config/1`\nto help you manage your configuration.\n\n`config/2` and `config/3` are used to define key-value configuration\nfor a given application. Once Mix starts, it will automatically\nevaluate the configuration file and persist the configuration above\ninto `:some_app`'s application environment, which can be accessed in\nas follows:\n\n    \"value1\" = Application.fetch_env!(:some_app, :key1)\n\nFinally, the line `import_config \"\#{config_env()}.exs\"` will import\nother config files based on the current configuration environment,\nsuch as `config/dev.exs` and `config/test.exs`.\n\n`Config` also provides a low-level API for evaluating and reading\nconfiguration, under the `Config.Reader` module.\n\n> #### Avoid application environment in libraries {: .info}\n>\n> If you are writing a library to be used by other developers,\n> it is generally recommended to avoid the application environment, as the\n> application environment is effectively a global storage. Also note that\n> the `config/config.exs` of a library is not evaluated when the library is\n> used as a dependency, as configuration is always meant to configure the\n> current project. For more information, read our [library guidelines](library-guidelines.md).\n\n## Migrating from `use Mix.Config`\n\nThe `Config` module in Elixir was introduced in v1.9 as a replacement to\n`Mix.Config`, which was specific to Mix and has been deprecated.\n\nYou can leverage `Config` instead of `Mix.Config` in three steps. The first\nstep is to replace `use Mix.Config` at the top of your config files by\n`import Config`.\n\nThe second is to make sure your `import_config/1` calls do not have a\nwildcard character. If so, you need to perform the wildcard lookup\nmanually. For example, if you did:\n\n    import_config \"../apps/*/config/config.exs\"\n\nIt has to be replaced by:\n\n    for config <- \"../apps/*/config/config.exs\" |> Path.expand(__DIR__) |> Path.wildcard() do\n      import_config config\n    end\n\nThe last step is to replace all `Mix.env()` calls in the config files with `config_env()`.\n\nKeep in mind you must also avoid using `Mix.env()` inside your project files.\nTo check the environment at _runtime_, you may add a configuration key:\n\n    # config.exs\n    ...\n    config :my_app, env: config_env()\n\nThen, in other scripts and modules, you may get the environment with\n`Application.fetch_env!/2`:\n\n    # router.exs\n    ...\n    if Application.fetch_env!(:my_app, :env) == :prod do\n      ...\n    end\n\nThe only files where you may access functions from the `Mix` module are\nthe `mix.exs` file and inside custom Mix tasks, which always within the\n`Mix.Tasks` namespace.\n\n## config/runtime.exs\n\nFor runtime configuration, you can use the `config/runtime.exs` file.\nIt is executed right before applications start in both Mix and releases\n(assembled with `mix release`).\n","title":"Config","type":"module"},{"doc":"Configures the given root_key . Keyword lists are always deep-merged. Examples The given opts are merged into the existing configuration for the given root_key . Conflicting keys are overridden by the ones specified in opts , unless they are keywords, which are deep merged recursively. For example, the application configuration below config :logger , level : :warn , backends : [ :console ] config :logger , level : :info , truncate : 1024 will have a final configuration for :logger of: [ level : :info , backends : [ :console ] , truncate : 1024 ]","ref":"Config.html#config/2","source_doc":"Configures the given `root_key`.\n\nKeyword lists are always deep-merged.\n\n## Examples\n\nThe given `opts` are merged into the existing configuration\nfor the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :logger,\n      level: :warn,\n      backends: [:console]\n\n    config :logger,\n      level: :info,\n      truncate: 1024\n\nwill have a final configuration for `:logger` of:\n\n    [level: :info, backends: [:console], truncate: 1024]\n\n","title":"Config.config/2","type":"function"},{"doc":"Configures the given key for the given root_key . Keyword lists are always deep merged. Examples The given opts are merged into the existing values for key in the given root_key . Conflicting keys are overridden by the ones specified in opts , unless they are keywords, which are deep merged recursively. For example, the application configuration below config :ecto , Repo , log_level : :warn , adapter : Ecto.Adapters.Postgres , metadata : [ read_only : true ] config :ecto , Repo , log_level : :info , pool_size : 10 , metadata : [ replica : true ] will have a final value of the configuration for the Repo key in the :ecto application of: Application . get_env ( :ecto , Repo ) #=&gt; [ #=&gt; log_level: :info, #=&gt; pool_size: 10, #=&gt; adapter: Ecto.Adapters.Postgres, #=&gt; metadata: [read_only: true, replica: true] #=&gt; ]","ref":"Config.html#config/3","source_doc":"Configures the given `key` for the given `root_key`.\n\nKeyword lists are always deep merged.\n\n## Examples\n\nThe given `opts` are merged into the existing values for `key`\nin the given `root_key`. Conflicting keys are overridden by the\nones specified in `opts`, unless they are keywords, which are\ndeep merged recursively. For example, the application configuration\nbelow\n\n    config :ecto, Repo,\n      log_level: :warn,\n      adapter: Ecto.Adapters.Postgres,\n      metadata: [read_only: true]\n\n    config :ecto, Repo,\n      log_level: :info,\n      pool_size: 10,\n      metadata: [replica: true]\n\nwill have a final value of the configuration for the `Repo`\nkey in the `:ecto` application of:\n\n    Application.get_env(:ecto, Repo)\n    #=> [\n    #=>   log_level: :info,\n    #=>   pool_size: 10,\n    #=>   adapter: Ecto.Adapters.Postgres,\n    #=>   metadata: [read_only: true, replica: true]\n    #=> ]\n\n","title":"Config.config/3","type":"function"},{"doc":"Returns the environment this configuration file is executed on. In Mix projects this function returns the environment this configuration file is executed on. In releases, the environment when mix release ran. This is most often used to execute conditional code: if config_env ( ) == :prod do config :my_app , :debug , false end","ref":"Config.html#config_env/0","source_doc":"Returns the environment this configuration file is executed on.\n\nIn Mix projects this function returns the environment this configuration\nfile is executed on. In releases, the environment when `mix release` ran.\n\nThis is most often used to execute conditional code:\n\n    if config_env() == :prod do\n      config :my_app, :debug, false\n    end\n\n","title":"Config.config_env/0","type":"macro"},{"doc":"Returns the target this configuration file is executed on. This is most often used to execute conditional code: if config_target ( ) == :host do config :my_app , :debug , false end","ref":"Config.html#config_target/0","source_doc":"Returns the target this configuration file is executed on.\n\nThis is most often used to execute conditional code:\n\n    if config_target() == :host do\n      config :my_app, :debug, false\n    end\n\n","title":"Config.config_target/0","type":"macro"},{"doc":"Imports configuration from the given file. In case the file doesn't exist, an error is raised. If file is a relative, it will be expanded relatively to the directory the current configuration file is in. Examples This is often used to emulate configuration across environments: import_config &quot; \#{ config_env ( ) } .exs&quot; Note, however, some configuration files, such as config/runtime.exs does not support imports, as they are meant to be copied across systems.","ref":"Config.html#import_config/1","source_doc":"Imports configuration from the given file.\n\nIn case the file doesn't exist, an error is raised.\n\nIf file is a relative, it will be expanded relatively to the\ndirectory the current configuration file is in.\n\n## Examples\n\nThis is often used to emulate configuration across environments:\n\n    import_config \"\#{config_env()}.exs\"\n\nNote, however, some configuration files, such as `config/runtime.exs`\ndoes not support imports, as they are meant to be copied across\nsystems.\n","title":"Config.import_config/1","type":"macro"},{"doc":"Specifies a provider API that loads configuration during boot. Config providers are typically used during releases to load external configuration while the system boots. This is done by starting the VM with the minimum amount of applications running, then invoking all of the providers, and then restarting the system. This requires a mutable configuration file on disk, as the results of the providers are written to the file system. For more information on runtime configuration, see mix release . Multiple config files One common use of config providers is to specify multiple configuration files in a release. Elixir ships with one provider, called Config.Reader , which is capable of handling Elixir's built-in config files. For example, imagine you want to list some basic configuration on Mix's built-in config/runtime.exs file, but you also want to support additional configuration files. To do so, you can add this inside the def project portion of your mix.exs : releases : [ demo : [ config_providers : [ { Config.Reader , { :system , &quot;RELEASE_ROOT&quot; , &quot;/extra_config.exs&quot; } } ] ] ] You can place this extra_config.exs file in your release in multiple ways: If it is available on the host when assembling the release, you can place it on &quot;rel/overlays/extra_config.exs&quot; and it will be automatically copied to the release root If it is available on the target during deployment, you can simply copy it to the release root as a step in your deployment Now once the system boots, it will load both config/runtime.exs and extra_config.exs early in the boot process. You can learn more options on Config.Reader . Custom config provider You can also implement custom config providers, similar to how Config.Reader works. For example, imagine you need to load some configuration from a JSON file and load that into the system. Said configuration provider would look like: defmodule JSONConfigProvider do @behaviour Config.Provider # Let&#39;s pass the path to the JSON file as config @impl true def init ( path ) when is_binary ( path ) , do : path @impl true def load ( config , path ) do # We need to start any app we may depend on. { :ok , _ } = Application . ensure_all_started ( :jason ) json = path |&gt; File . read! ( ) |&gt; Jason . decode! ( ) Config.Reader . merge ( config , my_app : [ some_value : json [ &quot;my_app_some_value&quot; ] , another_value : json [ &quot;my_app_another_value&quot; ] , ] ) end end Then, when specifying your release, you can specify the provider in the release configuration: releases : [ demo : [ config_providers : [ { JSONConfigProvider , &quot;/etc/config.json&quot; } ] ] ]","ref":"Config.Provider.html","source_doc":"Specifies a provider API that loads configuration during boot.\n\nConfig providers are typically used during releases to load\nexternal configuration while the system boots. This is done\nby starting the VM with the minimum amount of applications\nrunning, then invoking all of the providers, and then\nrestarting the system. This requires a mutable configuration\nfile on disk, as the results of the providers are written to\nthe file system. For more information on runtime configuration,\nsee `mix release`.\n\n## Multiple config files\n\nOne common use of config providers is to specify multiple\nconfiguration files in a release. Elixir ships with one provider,\ncalled `Config.Reader`, which is capable of handling Elixir's\nbuilt-in config files.\n\nFor example, imagine you want to list some basic configuration\non Mix's built-in `config/runtime.exs` file, but you also want\nto support additional configuration files. To do so, you can add\nthis inside the `def project` portion of  your `mix.exs`:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {Config.Reader, {:system, \"RELEASE_ROOT\", \"/extra_config.exs\"}}\n        ]\n      ]\n    ]\n\nYou can place this `extra_config.exs` file in your release in\nmultiple ways:\n\n  1. If it is available on the host when assembling the release,\n    you can place it on \"rel/overlays/extra_config.exs\" and it\n    will be automatically copied to the release root\n\n  2. If it is available on the target during deployment, you can\n    simply copy it to the release root as a step in your deployment\n\nNow once the system boots, it will load both `config/runtime.exs`\nand `extra_config.exs` early in the boot process. You can learn\nmore options on `Config.Reader`.\n\n## Custom config provider\n\nYou can also implement custom config providers, similar to how\n`Config.Reader` works. For example, imagine you need to load\nsome configuration from a JSON file and load that into the system.\nSaid configuration provider would look like:\n\n    defmodule JSONConfigProvider do\n      @behaviour Config.Provider\n\n      # Let's pass the path to the JSON file as config\n      @impl true\n      def init(path) when is_binary(path), do: path\n\n      @impl true\n      def load(config, path) do\n        # We need to start any app we may depend on.\n        {:ok, _} = Application.ensure_all_started(:jason)\n\n        json = path |> File.read!() |> Jason.decode!()\n\n        Config.Reader.merge(\n          config,\n          my_app: [\n            some_value: json[\"my_app_some_value\"],\n            another_value: json[\"my_app_another_value\"],\n          ]\n        )\n      end\n    end\n\nThen, when specifying your release, you can specify the provider in\nthe release configuration:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {JSONConfigProvider, \"/etc/config.json\"}\n        ]\n      ]\n    ]\n\n","title":"Config.Provider","type":"behaviour"},{"doc":"Invoked when initializing a config provider. A config provider is typically initialized on the machine where the system is assembled and not on the target machine. The init/1 callback is useful to verify the arguments given to the provider and prepare the state that will be given to load/2 . Furthermore, because the state returned by init/1 can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.","ref":"Config.Provider.html#c:init/1","source_doc":"Invoked when initializing a config provider.\n\nA config provider is typically initialized on the machine\nwhere the system is assembled and not on the target machine.\nThe `c:init/1` callback is useful to verify the arguments\ngiven to the provider and prepare the state that will be\ngiven to `c:load/2`.\n\nFurthermore, because the state returned by `c:init/1` can\nbe written to text-based config files, it should be\nrestricted only to simple data types, such as integers,\nstrings, atoms, tuples, maps, and lists. Entries such as\nPIDs, references, and functions cannot be serialized.\n","title":"Config.Provider.init/1","type":"callback"},{"doc":"Loads configuration (typically during system boot). It receives the current config and the state returned by init/1 . Then, you typically read the extra configuration from an external source and merge it into the received config . Merging should be done with Config.Reader.merge/2 , as it performs deep merge. It should return the updated config. Note that load/2 is typically invoked very early in the boot process, therefore if you need to use an application in the provider, it is your responsibility to start it.","ref":"Config.Provider.html#c:load/2","source_doc":"Loads configuration (typically during system boot).\n\nIt receives the current `config` and the `state` returned by\n`c:init/1`. Then, you typically read the extra configuration\nfrom an external source and merge it into the received `config`.\nMerging should be done with `Config.Reader.merge/2`, as it\nperforms deep merge. It should return the updated config.\n\nNote that `c:load/2` is typically invoked very early in the\nboot process, therefore if you need to use an application\nin the provider, it is your responsibility to start it.\n","title":"Config.Provider.load/2","type":"callback"},{"doc":"Resolves a config_path/0 to an actual path.","ref":"Config.Provider.html#resolve_config_path!/1","source_doc":"Resolves a `t:config_path/0` to an actual path.\n","title":"Config.Provider.resolve_config_path!/1","type":"function"},{"doc":"Validates a config_path/0 .","ref":"Config.Provider.html#validate_config_path!/1","source_doc":"Validates a `t:config_path/0`.\n","title":"Config.Provider.validate_config_path!/1","type":"function"},{"doc":"","ref":"Config.Provider.html#t:config/0","source_doc":false,"title":"Config.Provider.config/0","type":"type"},{"doc":"A path pointing to a configuration file. Since configuration files are often accessed on target machines, it can be expressed either as: a binary representing an absolute path a {:system, system_var, path} tuple where the config is the concatenation of the environment variable system_var with the given path","ref":"Config.Provider.html#t:config_path/0","source_doc":"A path pointing to a configuration file.\n\nSince configuration files are often accessed on target machines,\nit can be expressed either as:\n\n  * a binary representing an absolute path\n\n  * a `{:system, system_var, path}` tuple where the config is the\n    concatenation of the environment variable `system_var` with\n    the given `path`\n\n","title":"Config.Provider.config_path/0","type":"type"},{"doc":"","ref":"Config.Provider.html#t:state/0","source_doc":false,"title":"Config.Provider.state/0","type":"type"},{"doc":"API for reading config files defined with Config . As a provider Config.Reader can also be used as a Config.Provider . A config provider is used during releases to customize how applications are configured. When used as a provider, it expects a single argument: the configuration path (as outlined in Config.Provider.config_path/0 ) for the file to be read and loaded during the system boot. For example, if you expect the target system to have a config file in an absolute path, you can add this inside the def project portion of your mix.exs : releases : [ demo : [ config_providers : [ { Config.Reader , &quot;/etc/config.exs&quot; } ] ] ] Or if you want to read a custom path inside the release: config_providers : [ { Config.Reader , { :system , &quot;RELEASE_ROOT&quot; , &quot;/config.exs&quot; } } ] You can also pass a keyword list of options to the reader, where the :path is a required key: config_providers : [ { Config.Reader , path : &quot;/etc/config.exs&quot; , env : :prod , imports : :disabled } ] Remember Mix already loads config/runtime.exs by default. For more examples and scenarios, see the Config.Provider module.","ref":"Config.Reader.html","source_doc":"API for reading config files defined with `Config`.\n\n## As a provider\n\n`Config.Reader` can also be used as a `Config.Provider`. A config\nprovider is used during releases to customize how applications are\nconfigured. When used as a provider, it expects a single argument:\nthe configuration path (as outlined in `t:Config.Provider.config_path/0`)\nfor the file to be read and loaded during the system boot.\n\nFor example, if you expect the target system to have a config file\nin an absolute path, you can add this inside the `def project` portion\nof  your `mix.exs`:\n\n    releases: [\n      demo: [\n        config_providers: [\n          {Config.Reader, \"/etc/config.exs\"}\n        ]\n      ]\n    ]\n\nOr if you want to read a custom path inside the release:\n\n    config_providers: [{Config.Reader, {:system, \"RELEASE_ROOT\", \"/config.exs\"}}]\n\nYou can also pass a keyword list of options to the reader,\nwhere the `:path` is a required key:\n\n    config_providers: [\n      {Config.Reader,\n       path: \"/etc/config.exs\",\n       env: :prod,\n       imports: :disabled}\n    ]\n\nRemember Mix already loads `config/runtime.exs` by default.\nFor more examples and scenarios, see the `Config.Provider` module.\n","title":"Config.Reader","type":"module"},{"doc":"Evaluates the configuration contents for the given file . Accepts the same options as read!/2 .","ref":"Config.Reader.html#eval!/3","source_doc":"Evaluates the configuration `contents` for the given `file`.\n\nAccepts the same options as `read!/2`.\n","title":"Config.Reader.eval!/3","type":"function"},{"doc":"Merges two configurations. The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them. Examples iex&gt; Config.Reader . merge ( [ app : [ k : :v1 ] ] , [ app : [ k : :v2 ] ] ) [ app : [ k : :v2 ] ] iex&gt; Config.Reader . merge ( [ app : [ k : [ v1 : 1 , v2 : 2 ] ] ] , [ app : [ k : [ v2 : :a , v3 : :b ] ] ] ) [ app : [ k : [ v1 : 1 , v2 : :a , v3 : :b ] ] ] iex&gt; Config.Reader . merge ( [ app1 : [ ] ] , [ app2 : [ ] ] ) [ app1 : [ ] , app2 : [ ] ]","ref":"Config.Reader.html#merge/2","source_doc":"Merges two configurations.\n\nThe configurations are merged together with the values in\nthe second one having higher preference than the first in\ncase of conflicts. In case both values are set to keyword\nlists, it deep merges them.\n\n## Examples\n\n    iex> Config.Reader.merge([app: [k: :v1]], [app: [k: :v2]])\n    [app: [k: :v2]]\n\n    iex> Config.Reader.merge([app: [k: [v1: 1, v2: 2]]], [app: [k: [v2: :a, v3: :b]]])\n    [app: [k: [v1: 1, v2: :a, v3: :b]]]\n\n    iex> Config.Reader.merge([app1: []], [app2: []])\n    [app1: [], app2: []]\n\n","title":"Config.Reader.merge/2","type":"function"},{"doc":"Reads the configuration file. Options :imports - a list of already imported paths or :disabled to disable imports :env - the environment the configuration file runs on. See Config.config_env/0 for sample usage :target - the target the configuration file runs on. See Config.config_target/0 for sample usage","ref":"Config.Reader.html#read!/2","source_doc":"Reads the configuration file.\n\n## Options\n\n  * `:imports` - a list of already imported paths or `:disabled`\n    to disable imports\n\n  * `:env` - the environment the configuration file runs on.\n    See `Config.config_env/0` for sample usage\n\n  * `:target` - the target the configuration file runs on.\n    See `Config.config_target/0` for sample usage\n\n","title":"Config.Reader.read!/2","type":"function"},{"doc":"Reads the given configuration file and returns the configuration with its imports. Accepts the same options as read!/2 . Although note the :imports option cannot be disabled in read_imports!/2 .","ref":"Config.Reader.html#read_imports!/2","source_doc":"Reads the given configuration file and returns the configuration\nwith its imports.\n\nAccepts the same options as `read!/2`. Although note the `:imports`\noption cannot be disabled in `read_imports!/2`.\n","title":"Config.Reader.read_imports!/2","type":"function"},{"doc":"A supervisor optimized to only start children dynamically. The Supervisor module was designed to handle mostly static children that are started in the given order when the supervisor starts. A DynamicSupervisor starts with no children. Instead, children are started on demand via start_child/2 and there is no ordering between children. This allows the DynamicSupervisor to hold millions of children by using efficient data structures and to execute certain operations, such as shutting down, concurrently. Examples A dynamic supervisor is started with no children and often a name: children = [ { DynamicSupervisor , name : MyApp.DynamicSupervisor , strategy : :one_for_one } ] Supervisor . start_link ( children , strategy : :one_for_one ) The options given in the child specification are documented in start_link/1 . Once the dynamic supervisor is running, we can use it to start children on demand. Given this sample GenServer : defmodule Counter do use GenServer def start_link ( initial ) do GenServer . start_link ( __MODULE__ , initial ) end def inc ( pid ) do GenServer . call ( pid , :inc ) end def init ( initial ) do { :ok , initial } end def handle_call ( :inc , _ , count ) do { :reply , count , count + 1 } end end We can use start_child/2 with a child specification to start a Counter server: { :ok , counter1 } = DynamicSupervisor . start_child ( MyApp.DynamicSupervisor , { Counter , 0 } ) Counter . inc ( counter1 ) #=&gt; 0 { :ok , counter2 } = DynamicSupervisor . start_child ( MyApp.DynamicSupervisor , { Counter , 10 } ) Counter . inc ( counter2 ) #=&gt; 10 DynamicSupervisor . count_children ( MyApp.DynamicSupervisor ) #=&gt; %{active: 2, specs: 2, supervisors: 0, workers: 2} Scalability and partitioning The DynamicSupervisor is a single process responsible for starting other processes. In some applications, the DynamicSupervisor may become a bottleneck. To address this, you can start multiple instances of the DynamicSupervisor and then pick a &quot;random&quot; instance to start the child on. Instead of: children = [ { DynamicSupervisor , name : MyApp.DynamicSupervisor } ] and: DynamicSupervisor . start_child ( MyApp.DynamicSupervisor , { Counter , 0 } ) You can do this: children = [ { PartitionSupervisor , child_spec : DynamicSupervisor , name : MyApp.DynamicSupervisors } ] and then: DynamicSupervisor . start_child ( { :via , PartitionSupervisor , { MyApp.DynamicSupervisors , self ( ) } } , { Counter , 0 } ) In the code above, we start a partition supervisor that will by default start a dynamic supervisor for each core in your machine. Then, instead of calling the DynamicSupervisor by name, you call it through the partition supervisor, using self() as the routing key. This means each process will be assigned one of the existing dynamic supervisors. Read the PartitionSupervisor docs for more information. Module-based supervisors Similar to Supervisor , dynamic supervisors also support module-based supervisors. defmodule MyApp.DynamicSupervisor do # Automatically defines child_spec/1 use DynamicSupervisor def start_link ( init_arg ) do DynamicSupervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end @impl true def init ( _init_arg ) do DynamicSupervisor . init ( strategy : :one_for_one ) end end See the Supervisor docs for a discussion of when you may want to use module-based supervisors. A @doc annotation immediately preceding use DynamicSupervisor will be attached to the generated child_spec/1 function. Name registration A supervisor is bound to the same name registration rules as a GenServer . Read more about these rules in the documentation for GenServer . Migrating from Supervisor's :simple_one_for_one In case you were using the deprecated :simple_one_for_one strategy from the Supervisor module, you can migrate to the DynamicSupervisor in few steps. Imagine the given &quot;old&quot; code: defmodule MySupervisor do use Supervisor def start_link ( init_arg ) do Supervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end def start_child ( foo , bar , baz ) do # This will start child by calling MyWorker.start_link(init_arg, foo, bar, baz) Supervisor . start_child ( __MODULE__ , [ foo , bar , baz ] ) end @impl true def init ( init_arg ) do children = [ # Or the deprecated: worker(MyWorker, [init_arg]) %{ id : MyWorker , start : { MyWorker , :start_link , [ init_arg ] } } ] Supervisor . init ( children , strategy : :simple_one_for_one ) end end It can be upgraded to the DynamicSupervisor like this: defmodule MySupervisor do use DynamicSupervisor def start_link ( init_arg ) do DynamicSupervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end def start_child ( foo , bar , baz ) do # If MyWorker is not using the new child specs, we need to pass a map: # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}} spec = { MyWorker , foo : foo , bar : bar , baz : baz } DynamicSupervisor . start_child ( __MODULE__ , spec ) end @impl true def init ( init_arg ) do DynamicSupervisor . init ( strategy : :one_for_one , extra_arguments : [ init_arg ] ) end end The difference is that the DynamicSupervisor expects the child specification at the moment start_child/2 is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as [initial_arg] , it can be given in the :extra_arguments flag on DynamicSupervisor.init/1 .","ref":"DynamicSupervisor.html","source_doc":"A supervisor optimized to only start children dynamically.\n\nThe `Supervisor` module was designed to handle mostly static children\nthat are started in the given order when the supervisor starts. A\n`DynamicSupervisor` starts with no children. Instead, children are\nstarted on demand via `start_child/2` and there is no ordering between\nchildren. This allows the `DynamicSupervisor` to hold millions of\nchildren by using efficient data structures and to execute certain\noperations, such as shutting down, concurrently.\n\n## Examples\n\nA dynamic supervisor is started with no children and often a name:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor, strategy: :one_for_one}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce the dynamic supervisor is running, we can use it to start children\non demand. Given this sample `GenServer`:\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(initial) do\n        GenServer.start_link(__MODULE__, initial)\n      end\n\n      def inc(pid) do\n        GenServer.call(pid, :inc)\n      end\n\n      def init(initial) do\n        {:ok, initial}\n      end\n\n      def handle_call(:inc, _, count) do\n        {:reply, count, count + 1}\n      end\n    end\n\nWe can use `start_child/2` with a child specification to start a `Counter`\nserver:\n\n    {:ok, counter1} = DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Counter, 0})\n    Counter.inc(counter1)\n    #=> 0\n\n    {:ok, counter2} = DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Counter, 10})\n    Counter.inc(counter2)\n    #=> 10\n\n    DynamicSupervisor.count_children(MyApp.DynamicSupervisor)\n    #=> %{active: 2, specs: 2, supervisors: 0, workers: 2}\n\n## Scalability and partitioning\n\nThe `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` and then pick a \"random\" instance to start\nthe child on.\n\nInstead of:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\nand:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Counter, 0})\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Counter, 0}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor, using `self()` as the routing key. This means each\nprocess will be assigned one of the existing dynamic supervisors.\nRead the `PartitionSupervisor` docs for more information.\n\n## Module-based supervisors\n\nSimilar to `Supervisor`, dynamic supervisors also support module-based\nsupervisors.\n\n    defmodule MyApp.DynamicSupervisor do\n      # Automatically defines child_spec/1\n      use DynamicSupervisor\n\n      def start_link(init_arg) do\n        DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        DynamicSupervisor.init(strategy: :one_for_one)\n      end\n    end\n\nSee the `Supervisor` docs for a discussion of when you may want to use\nmodule-based supervisors. A `@doc` annotation immediately preceding\n`use DynamicSupervisor` will be attached to the generated `child_spec/1`\nfunction.\n\n## Name registration\n\nA supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`.\n\n## Migrating from Supervisor's :simple_one_for_one\n\nIn case you were using the deprecated `:simple_one_for_one` strategy from\nthe `Supervisor` module, you can migrate to the `DynamicSupervisor` in\nfew steps.\n\nImagine the given \"old\" code:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      def start_child(foo, bar, baz) do\n        # This will start child by calling MyWorker.start_link(init_arg, foo, bar, baz)\n        Supervisor.start_child(__MODULE__, [foo, bar, baz])\n      end\n\n      @impl true\n      def init(init_arg) do\n        children = [\n          # Or the deprecated: worker(MyWorker, [init_arg])\n          %{id: MyWorker, start: {MyWorker, :start_link, [init_arg]}}\n        ]\n\n        Supervisor.init(children, strategy: :simple_one_for_one)\n      end\n    end\n\nIt can be upgraded to the DynamicSupervisor like this:\n\n    defmodule MySupervisor do\n      use DynamicSupervisor\n\n      def start_link(init_arg) do\n        DynamicSupervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      def start_child(foo, bar, baz) do\n        # If MyWorker is not using the new child specs, we need to pass a map:\n        # spec = %{id: MyWorker, start: {MyWorker, :start_link, [foo, bar, baz]}}\n        spec = {MyWorker, foo: foo, bar: bar, baz: baz}\n        DynamicSupervisor.start_child(__MODULE__, spec)\n      end\n\n      @impl true\n      def init(init_arg) do\n        DynamicSupervisor.init(\n          strategy: :one_for_one,\n          extra_arguments: [init_arg]\n        )\n      end\n    end\n\nThe difference is that the `DynamicSupervisor` expects the child specification\nat the moment `start_child/2` is called, and no longer on the init callback.\nIf there are any initial arguments given on initialization, such as `[initial_arg]`,\nit can be given in the `:extra_arguments` flag on `DynamicSupervisor.init/1`.\n","title":"DynamicSupervisor","type":"behaviour"},{"doc":"Returns a specification to start a dynamic supervisor under a supervisor. It accepts the same options as start_link/1 . See Supervisor for more information about child specifications.","ref":"DynamicSupervisor.html#child_spec/1","source_doc":"Returns a specification to start a dynamic supervisor under a supervisor.\n\nIt accepts the same options as `start_link/1`.\n\nSee `Supervisor` for more information about child specifications.\n","title":"DynamicSupervisor.child_spec/1","type":"function"},{"doc":"Returns a map containing count values for the supervisor. The map contains the following keys: :specs - the number of children processes :active - the count of all actively running child processes managed by this supervisor :supervisors - the count of all supervisors whether or not the child process is still alive :workers - the count of all workers, whether or not the child process is still alive","ref":"DynamicSupervisor.html#count_children/1","source_doc":"Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of children processes\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive\n\n","title":"DynamicSupervisor.count_children/1","type":"function"},{"doc":"Receives a set of options that initializes a dynamic supervisor. This is typically invoked at the end of the init/1 callback of module-based supervisors. See the &quot;Module-based supervisors&quot; section in the module documentation for more information. It accepts the same options as start_link/1 (except for :name ) and it returns a tuple containing the supervisor options. Examples def init ( _arg ) do DynamicSupervisor . init ( max_children : 1000 ) end","ref":"DynamicSupervisor.html#init/1","source_doc":"Receives a set of `options` that initializes a dynamic supervisor.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the \"Module-based supervisors\" section\nin the module documentation for more information.\n\nIt accepts the same `options` as `start_link/1` (except for `:name`)\nand it returns a tuple containing the supervisor options.\n\n## Examples\n\n    def init(_arg) do\n      DynamicSupervisor.init(max_children: 1000)\n    end\n\n","title":"DynamicSupervisor.init/1","type":"function"},{"doc":"Callback invoked to start the supervisor and during hot code upgrades. Developers typically invoke DynamicSupervisor.init/1 at the end of their init callback to return the proper supervision flags.","ref":"DynamicSupervisor.html#c:init/1","source_doc":"Callback invoked to start the supervisor and during hot code upgrades.\n\nDevelopers typically invoke `DynamicSupervisor.init/1` at the end of\ntheir init callback to return the proper supervision flags.\n","title":"DynamicSupervisor.init/1","type":"callback"},{"doc":"Dynamically adds a child specification to supervisor and starts that child. child_spec should be a valid child specification as detailed in the &quot;Child specification&quot; section of the documentation for Supervisor . The child process will be started as defined in the child specification. Note that while the :id field is still required in the spec, the value is ignored and therefore does not need to be unique. If the child process start function returns {:ok, child} or {:ok, child, info} , then child specification and PID are added to the supervisor and this function returns the same value. If the child process start function returns :ignore , then no child is added to the supervision tree and this function returns :ignore too. If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns {:error, error} where error is the error or erroneous value returned from child process start function, or failure reason if it fails. If the supervisor already has N children in a way that N exceeds the amount of :max_children set on the supervisor initialization (see init/1 ), then this function returns {:error, :max_children} .","ref":"DynamicSupervisor.html#start_child/2","source_doc":"Dynamically adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification as detailed in the\n\"Child specification\" section of the documentation for `Supervisor`. The child\nprocess will be started as defined in the child specification. Note that while\nthe `:id` field is still required in the spec, the value is ignored and\ntherefore does not need to be unique.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, then no child is added\nto the supervision tree and this function returns `:ignore` too.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is the error or erroneous value\nreturned from child process start function, or failure reason if it fails.\n\nIf the supervisor already has N children in a way that N exceeds the amount\nof `:max_children` set on the supervisor initialization (see `init/1`), then\nthis function returns `{:error, :max_children}`.\n","title":"DynamicSupervisor.start_child/2","type":"function"},{"doc":"Starts a supervisor with the given options. This function is typically not invoked directly, instead it is invoked when using a DynamicSupervisor as a child of another supervisor: children = [ { DynamicSupervisor , name : MySupervisor } ] If the supervisor is successfully spawned, this function returns {:ok, pid} , where pid is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns {:error, {:already_started, pid}} , where pid is the PID of that process. Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with :normal reason. Options :name - registers the supervisor under the given name. The supported values are described under the &quot;Name registration&quot; section in the GenServer module docs. :strategy - the restart strategy option. The only supported value is :one_for_one which means that no other child is terminated if a child process terminates. You can learn more about strategies in the Supervisor module docs. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . :max_children - the maximum amount of children to be running under this supervisor at the same time. When :max_children is exceeded, start_child/2 returns {:error, :max_children} . Defaults to :infinity . :extra_arguments - arguments that are prepended to the arguments specified in the child spec given to start_child/2 . Defaults to an empty list.","ref":"DynamicSupervisor.html#start_link/1","source_doc":"Starts a supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `DynamicSupervisor` as a child of another supervisor:\n\n    children = [\n      {DynamicSupervisor, name: MySupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - registers the supervisor under the given name.\n    The supported values are described under the \"Name registration\"\n    section in the `GenServer` module docs.\n\n  * `:strategy` - the restart strategy option. The only supported\n    value is `:one_for_one` which means that no other child is\n    terminated if a child process terminates. You can learn more\n    about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:max_children` - the maximum amount of children to be running\n    under this supervisor at the same time. When `:max_children` is\n    exceeded, `start_child/2` returns `{:error, :max_children}`. Defaults\n    to `:infinity`.\n\n  * `:extra_arguments` - arguments that are prepended to the arguments\n    specified in the child spec given to `start_child/2`. Defaults to\n    an empty list.\n\n","title":"DynamicSupervisor.start_link/1","type":"function"},{"doc":"Starts a module-based supervisor process with the given module and init_arg . To start the supervisor, the init/1 callback will be invoked in the given module , with init_arg as its argument. The init/1 callback must return a supervisor specification which can be created with the help of the init/1 function. If the init/1 callback returns :ignore , this function returns :ignore as well and the supervisor terminates with reason :normal . If it fails or returns an incorrect value, this function returns {:error, term} where term is a term with information about the error, and the supervisor terminates with reason term . The :name option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the GenServer module docs. If the supervisor is successfully spawned, this function returns {:ok, pid} , where pid is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns {:error, {:already_started, pid}} , where pid is the PID of that process. Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with :normal reason.","ref":"DynamicSupervisor.html#start_link/3","source_doc":"Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/1`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n","title":"DynamicSupervisor.start_link/3","type":"function"},{"doc":"Synchronously stops the given supervisor with the given reason . It returns :ok if the supervisor terminates with the given reason. If it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"DynamicSupervisor.html#stop/3","source_doc":"Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n","title":"DynamicSupervisor.stop/3","type":"function"},{"doc":"Terminates the given child identified by pid . If successful, this function returns :ok . If there is no process with the given PID, this function returns {:error, :not_found} .","ref":"DynamicSupervisor.html#terminate_child/2","source_doc":"Terminates the given child identified by `pid`.\n\nIf successful, this function returns `:ok`. If there is no process with\nthe given PID, this function returns `{:error, :not_found}`.\n","title":"DynamicSupervisor.terminate_child/2","type":"function"},{"doc":"Returns a list with information about all children. Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception. This function returns a list of tuples containing: id - it is always :undefined for dynamic supervisors child - the PID of the corresponding child process or the atom :restarting if the process is about to be restarted type - :worker or :supervisor as defined in the child specification modules - as defined in the child specification","ref":"DynamicSupervisor.html#which_children/1","source_doc":"Returns a list with information about all children.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.\n\nThis function returns a list of tuples containing:\n\n  * `id` - it is always `:undefined` for dynamic supervisors\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification\n\n","title":"DynamicSupervisor.which_children/1","type":"function"},{"doc":"Options given to start_link and init/1 functions","ref":"DynamicSupervisor.html#t:init_option/0","source_doc":"Options given to `start_link` and `init/1` functions","title":"DynamicSupervisor.init_option/0","type":"type"},{"doc":"Return values of start_child functions","ref":"DynamicSupervisor.html#t:on_start_child/0","source_doc":"Return values of `start_child` functions","title":"DynamicSupervisor.on_start_child/0","type":"type"},{"doc":"Options given to start_link functions","ref":"DynamicSupervisor.html#t:option/0","source_doc":"Options given to `start_link` functions","title":"DynamicSupervisor.option/0","type":"type"},{"doc":"Supported strategies","ref":"DynamicSupervisor.html#t:strategy/0","source_doc":"Supported strategies","title":"DynamicSupervisor.strategy/0","type":"type"},{"doc":"The supervisor flags returned on init","ref":"DynamicSupervisor.html#t:sup_flags/0","source_doc":"The supervisor flags returned on init","title":"DynamicSupervisor.sup_flags/0","type":"type"},{"doc":"A behaviour module for implementing the server of a client-server relation. A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree. Example The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in. Let's start with a code example and then explore the available callbacks. Imagine we want to implement a service with a GenServer that works like a stack, allowing us to push and pop elements. We'll customize a generic GenServer with our own module by implementing three callbacks. init/1 transforms our initial argument to the initial state for the GenServer. handle_call/3 fires when the server receives a synchronous pop message, popping an element from the stack and returning it to the user. handle_cast/2 will fire when the server receives an asynchronous push message, pushing an element onto the stack: defmodule Stack do use GenServer # Callbacks @impl true def init ( elements ) do initial_state = String . split ( elements , &quot;,&quot; , trim : true ) { :ok , initial_state } end @impl true def handle_call ( :pop , _from , state ) do [ to_caller | new_state ] = state { :reply , to_caller , new_state } end @impl true def handle_cast ( { :push , element } , state ) do new_state = [ element | state ] { :noreply , new_state } end end We leave the process machinery of startup, message passing, and the message loop to the GenServer behaviour and focus only on the stack implementation. We can now use the GenServer API to interact with the service by creating a process and sending it messages: # Start the server { :ok , pid } = GenServer . start_link ( Stack , &quot;hello,world&quot; ) # This is the client GenServer . call ( pid , :pop ) #=&gt; &quot;hello&quot; GenServer . cast ( pid , { :push , &quot;elixir&quot; } ) #=&gt; :ok GenServer . call ( pid , :pop ) #=&gt; &quot;elixir&quot; We start our Stack by calling start_link/2 , passing the module with the server implementation and its initial argument with a comma-separated list of elements. The GenServer behaviour calls the init/1 callback to establish the initial GenServer state. From this point on, the GenServer has control so we interact with it by sending two types of messages on the client. call messages expect a reply from the server (and are therefore synchronous) while cast messages do not. Each call to GenServer.call/3 results in a message that must be handled by the handle_call/3 callback in the GenServer. A cast/2 message must be handled by handle_cast/2 . GenServer supports 8 callbacks, but only init/1 is required. Client / Server APIs Although in the example above we have used GenServer.start_link/3 and friends to directly start and communicate with the server, most of the time we don't call the GenServer functions directly. Instead, we wrap the calls in new functions representing the public API of the server. These thin wrappers are called the client API . Here is a better implementation of our Stack module: defmodule Stack do use GenServer # Client def start_link ( default ) when is_binary ( default ) do GenServer . start_link ( __MODULE__ , default ) end def push ( pid , element ) do GenServer . cast ( pid , { :push , element } ) end def pop ( pid ) do GenServer . call ( pid , :pop ) end # Server (callbacks) @impl true def init ( elements ) do initial_state = String . split ( elements , &quot;,&quot; , trim : true ) { :ok , initial_state } end @impl true def handle_call ( :pop , _from , state ) do [ to_caller | new_state ] = state { :reply , to_caller , new_state } end @impl true def handle_cast ( { :push , element } , state ) do new_state = [ element | state ] { :noreply , new_state } end end In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules. How to supervise A GenServer is most commonly started under a supervision tree. When we invoke use GenServer , it automatically defines a child_spec/1 function that allows us to start the Stack directly under a supervisor. To start a default stack of [&quot;hello&quot;, &quot;world&quot;] under a supervisor, we can do: children = [ { Stack , &quot;hello,world&quot; } ] Supervisor . start_link ( children , strategy : :one_for_all ) Note that specifying a module MyServer would be the same as specifying the tuple {MyServer, []} . use GenServer also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated child_spec/1 can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the child should be restarted, defaults to :permanent :shutdown - how to shut down the child, either immediately or by giving it time to shut down For example: use GenServer , restart : :transient , shutdown : 10_000 See the &quot;Child specification&quot; section in the Supervisor module for more detailed information. The @doc annotation immediately preceding use GenServer will be attached to the generated child_spec/1 function. When stopping the GenServer, for example by returning a {:stop, reason, new_state} tuple from a callback, the exit reason is used by the supervisor to determine whether the GenServer needs to be restarted. See the &quot;Exit reasons and restarts&quot; section in the Supervisor module. Name registration Both start_link/3 and start/3 support the GenServer to register a name on start via the :name option. Registered names are also automatically cleaned up on termination. The supported values are: an atom - the GenServer is registered locally (to the current node) with the given name using Process.register/2 . {:global, term} - the GenServer is registered globally with the given term using the functions in the :global module . {:via, module, term} - the GenServer is registered with the given mechanism and name. The :via option expects a module that exports register_name/2 , unregister_name/1 , whereis_name/1 and send/2 . One such example is the :global module which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called Registry for locally storing names that are generated dynamically. For example, we could start and register our Stack server locally as follows: # Start the server and register it locally with name MyStack { :ok , _ } = GenServer . start_link ( Stack , &quot;hello&quot; , name : MyStack ) # Now messages can be sent directly to MyStack GenServer . call ( MyStack , :pop ) #=&gt; &quot;hello&quot; Once the server is started, the remaining functions in this module ( call/3 , cast/2 , and friends) will also accept an atom, or any {:global, ...} or {:via, ...} tuples. In general, the following formats are supported: a PID an atom if the server is locally registered {atom, node} if the server is locally registered at another node {:global, term} if the server is globally registered {:via, module, name} if the server is registered through an alternative registry If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the Registry module. Receiving &quot;regular&quot; messages The goal of a GenServer is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave. Besides the synchronous and asynchronous communication provided by call/3 and cast/2 , &quot;regular&quot; messages sent by functions such as send/2 , Process.send_after/4 and similar, can be handled inside the handle_info/2 callback. handle_info/2 can be used in many situations, such as handling monitor DOWN messages sent by Process.monitor/1 . Another use case for handle_info/2 is to perform periodic work, with the help of Process.send_after/4 : defmodule MyApp.Periodically do use GenServer def start_link ( _ ) do GenServer . start_link ( __MODULE__ , %{ } ) end @impl true def init ( state ) do # Schedule work to be performed on start schedule_work ( ) { :ok , state } end @impl true def handle_info ( :work , state ) do # Do the desired work here # ... # Reschedule once more schedule_work ( ) { :noreply , state } end defp schedule_work do # We schedule the work to happen in 2 hours (written in milliseconds). # Alternatively, one might write :timer.hours(2) Process . send_after ( self ( ) , :work , 2 * 60 * 60 * 1000 ) end end Timeouts The return value of init/1 or any of the handle_* callbacks may include a timeout value in milliseconds; if not, :infinity is assumed. The timeout can be used to detect a lull in incoming messages. The timeout() value is used as follows: If the process has any message already waiting when the timeout() value is returned, the timeout is ignored and the waiting message is handled as usual. This means that even a timeout of 0 milliseconds is not guaranteed to execute (if you want to take another action immediately and unconditionally, use a :continue instruction instead). If any message arrives before the specified number of milliseconds elapse, the timeout is cleared and that message is handled as usual. Otherwise, when the specified number of milliseconds have elapsed with no message arriving, handle_info/2 is called with :timeout as the first argument. When (not) to use a GenServer So far, we have learned that a GenServer can be used as a supervised process that handles sync and async calls. It can also handle system messages, such as periodic messages and monitoring events. GenServer processes may also be named. A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes. In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer: def add ( a , b ) do GenServer . call ( __MODULE__ , { :add , a , b } ) end def subtract ( a , b ) do GenServer . call ( __MODULE__ , { :subtract , a , b } ) end def handle_call ( { :add , a , b } , _from , state ) do { :reply , a + b , state } end def handle_call ( { :subtract , a , b } , _from , state ) do { :reply , a - b , state } end This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly: def add ( a , b ) do a + b end def subtract ( a , b ) do a - b end If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization. Debugging with the :sys module GenServers, as special processes , can be debugged using the :sys module . Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes. Let's explore the basic functions from the :sys module used for debugging: :sys.get_state/2 - allows retrieval of the state of the process. In the case of a GenServer process, it will be the callback module state, as passed into the callback functions as last argument. :sys.get_status/2 - allows retrieval of the status of the process. This status includes the process dictionary, if the process is running or is suspended, the parent PID, the debugger state, and the state of the behaviour module, which includes the callback module state (as returned by :sys.get_state/2 ). It's possible to change how this status is represented by defining the optional GenServer.format_status/2 callback. :sys.trace/3 - prints all the system events to :stdio . :sys.statistics/3 - manages collection of process statistics. :sys.no_debug/2 - turns off all debug handlers for the given process. It is very important to switch off debugging once we're done. Excessive debug handlers or those that should be turned off, but weren't, can seriously damage the performance of the system. :sys.suspend/2 - allows to suspend a process so that it only replies to system messages but no other messages. A suspended process can be reactivated via :sys.resume/2 . Let's see how we could use those functions for debugging the stack server we defined earlier. iex&gt; { :ok , pid } = Stack . start_link ( [ ] ) iex&gt; :sys . statistics ( pid , true ) # turn on collecting process statistics iex&gt; :sys . trace ( pid , true ) # turn on event printing iex&gt; Stack . push ( pid , 1 ) * DBG * &lt; 0.122 . 0 &gt; got cast { push , 1 } * DBG * &lt; 0.122 . 0 &gt; new state [ 1 ] :ok iex&gt; :sys . get_state ( pid ) [ 1 ] iex&gt; Stack . pop ( pid ) * DBG * &lt; 0.122 . 0 &gt; got call pop from &lt; 0.80 . 0 &gt; * DBG * &lt; 0.122 . 0 &gt; sent 1 to &lt; 0.80 . 0 &gt; , new state [ ] 1 iex&gt; :sys . statistics ( pid , :get ) { :ok , [ start_time : { { 2016 , 7 , 16 } , { 12 , 29 , 41 } } , current_time : { { 2016 , 7 , 16 } , { 12 , 29 , 50 } } , reductions : 117 , messages_in : 2 , messages_out : 0 ] } iex&gt; :sys . no_debug ( pid ) # turn off all debug handlers :ok iex&gt; :sys . get_status ( pid ) { :status , # PID &lt; 0 . 122 . 0 &gt; , { :module , :gen_server } , [ [ &quot;$initial_call&quot; : { Stack , :init , 1 } , # process dictionary &quot;$ancestors&quot; : [ # PID &lt; 0 . 80 . 0 &gt; , # PID &lt; 0 . 51 . 0 &gt; ] ] , :running , # :running | :suspended # PID &lt; 0 . 80 . 0 &gt; , # parent [ ] , # debugger state [ header : &#39;Status for generic server &lt;0.122.0&gt;&#39; , # module status data : [ { &#39;Status&#39; , :running } , { &#39;Parent&#39; , # PID &lt; 0 . 80 . 0 &gt; } , { &#39;Logged events&#39; , [ ] } ] , data : [ { &#39;State&#39; , [ 1 ] } ] ] ] } Learn more If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight. GenServer - Elixir's Getting Started Guide :gen_server module documentation gen_server Behaviour - OTP Design Principles Clients and Servers - Learn You Some Erlang for Great Good!","ref":"GenServer.html","source_doc":"A behaviour module for implementing the server of a client-server relation.\n\nA GenServer is a process like any other Elixir process and it can be used\nto keep state, execute code asynchronously and so on. The advantage of using\na generic server process (GenServer) implemented using this module is that it\nwill have a standard set of interface functions and include functionality for\ntracing and error reporting. It will also fit into a supervision tree.\n\n## Example\n\nThe GenServer behaviour abstracts the common client-server interaction.\nDevelopers are only required to implement the callbacks and functionality\nthey are interested in.\n\nLet's start with a code example and then explore the available callbacks.\nImagine we want to implement a service with a GenServer that works\nlike a stack, allowing us to push and pop elements. We'll customize a\ngeneric GenServer with our own module by implementing three callbacks.\n\n`c:init/1` transforms our initial argument to the initial state for the\nGenServer. `c:handle_call/3` fires when the server receives a synchronous\n`pop` message, popping an element from the stack and returning it to the\nuser. `c:handle_cast/2` will fire when the server receives an asynchronous\n`push` message, pushing an element onto the stack:\n\n    defmodule Stack do\n      use GenServer\n\n      # Callbacks\n\n      @impl true\n      def init(elements) do\n        initial_state = String.split(elements, \",\", trim: true)\n        {:ok, initial_state}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, state) do\n        [to_caller | new_state] = state\n        {:reply, to_caller, new_state}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        new_state = [element | state]\n        {:noreply, new_state}\n      end\n    end\n\nWe leave the process machinery of startup, message passing, and the message\nloop to the GenServer behaviour and focus only on the stack\nimplementation. We can now use the GenServer API to interact with\nthe service by creating a process and sending it messages:\n\n    # Start the server\n    {:ok, pid} = GenServer.start_link(Stack, \"hello,world\")\n\n    # This is the client\n    GenServer.call(pid, :pop)\n    #=> \"hello\"\n\n    GenServer.cast(pid, {:push, \"elixir\"})\n    #=> :ok\n\n    GenServer.call(pid, :pop)\n    #=> \"elixir\"\n\nWe start our `Stack` by calling `start_link/2`, passing the module\nwith the server implementation and its initial argument with a\ncomma-separated list of elements. The GenServer behaviour calls the\n`c:init/1` callback to establish the initial GenServer state. From\nthis point on, the GenServer has control so we interact with it by\nsending two types of messages on the client. **call** messages expect\na reply from the server (and are therefore synchronous) while **cast**\nmessages do not.\n\nEach call to `GenServer.call/3` results in a message\nthat must be handled by the `c:handle_call/3` callback in the GenServer.\nA `cast/2` message must be handled by `c:handle_cast/2`. `GenServer`\nsupports 8 callbacks, but only `c:init/1` is required.\n\n## Client / Server APIs\n\nAlthough in the example above we have used `GenServer.start_link/3` and\nfriends to directly start and communicate with the server, most of the\ntime we don't call the `GenServer` functions directly. Instead, we wrap\nthe calls in new functions representing the public API of the server.\nThese thin wrappers are called the **client API**.\n\nHere is a better implementation of our Stack module:\n\n    defmodule Stack do\n      use GenServer\n\n      # Client\n\n      def start_link(default) when is_binary(default) do\n        GenServer.start_link(__MODULE__, default)\n      end\n\n      def push(pid, element) do\n        GenServer.cast(pid, {:push, element})\n      end\n\n      def pop(pid) do\n        GenServer.call(pid, :pop)\n      end\n\n      # Server (callbacks)\n\n      @impl true\n      def init(elements) do\n        initial_state = String.split(elements, \",\", trim: true)\n        {:ok, initial_state}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, state) do\n        [to_caller | new_state] = state\n        {:reply, to_caller, new_state}\n      end\n\n      @impl true\n      def handle_cast({:push, element}, state) do\n        new_state = [element | state]\n        {:noreply, new_state}\n      end\n    end\n\n\nIn practice, it is common to have both server and client functions in\nthe same module. If the server and/or client implementations are growing\ncomplex, you may want to have them in different modules.\n\n## How to supervise\n\nA `GenServer` is most commonly started under a supervision tree.\nWhen we invoke `use GenServer`, it automatically defines a `child_spec/1`\nfunction that allows us to start the `Stack` directly under a supervisor.\nTo start a default stack of `[\"hello\", \"world\"]` under a supervisor,\nwe can do:\n\n    children = [\n      {Stack, \"hello,world\"}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nNote that specifying a module `MyServer` would be the same as specifying\nthe  tuple `{MyServer, []}`.\n\n`use GenServer` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use GenServer, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use GenServer` will be attached to the generated `child_spec/1` function.\n\nWhen stopping the GenServer, for example by returning a `{:stop, reason, new_state}`\ntuple from a callback, the exit reason is used by the supervisor to determine\nwhether the GenServer needs to be restarted. See the \"Exit reasons and restarts\"\nsection in the `Supervisor` module.\n\n## Name registration\n\nBoth `start_link/3` and `start/3` support the `GenServer` to register\na name on start via the `:name` option. Registered names are also\nautomatically cleaned up on termination. The supported values are:\n\n  * an atom - the GenServer is registered locally (to the current node)\n    with the given name using `Process.register/2`.\n\n  * `{:global, term}` - the GenServer is registered globally with the given\n    term using the functions in the [`:global` module](`:global`).\n\n  * `{:via, module, term}` - the GenServer is registered with the given\n    mechanism and name. The `:via` option expects a module that exports\n    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n    One such example is the [`:global` module](`:global`) which uses these functions\n    for keeping the list of names of processes and their associated PIDs\n    that are available globally for a network of Elixir nodes. Elixir also\n    ships with a local, decentralized and scalable registry called `Registry`\n    for locally storing names that are generated dynamically.\n\nFor example, we could start and register our `Stack` server locally as follows:\n\n    # Start the server and register it locally with name MyStack\n    {:ok, _} = GenServer.start_link(Stack, \"hello\", name: MyStack)\n\n    # Now messages can be sent directly to MyStack\n    GenServer.call(MyStack, :pop)\n    #=> \"hello\"\n\nOnce the server is started, the remaining functions in this module (`call/3`,\n`cast/2`, and friends) will also accept an atom, or any `{:global, ...}` or\n`{:via, ...}` tuples. In general, the following formats are supported:\n\n  * a PID\n  * an atom if the server is locally registered\n  * `{atom, node}` if the server is locally registered at another node\n  * `{:global, term}` if the server is globally registered\n  * `{:via, module, name}` if the server is registered through an alternative\n    registry\n\nIf there is an interest to register dynamic names locally, do not use\natoms, as atoms are never garbage-collected and therefore dynamically\ngenerated atoms won't be garbage-collected. For such cases, you can\nset up your own local registry by using the `Registry` module.\n\n## Receiving \"regular\" messages\n\nThe goal of a `GenServer` is to abstract the \"receive\" loop for developers,\nautomatically handling system messages, supporting code change, synchronous\ncalls and more. Therefore, you should never call your own \"receive\" inside\nthe GenServer callbacks as doing so will cause the GenServer to misbehave.\n\nBesides the synchronous and asynchronous communication provided by `call/3`\nand `cast/2`, \"regular\" messages sent by functions such as `send/2`,\n`Process.send_after/4` and similar, can be handled inside the `c:handle_info/2`\ncallback.\n\n`c:handle_info/2` can be used in many situations, such as handling monitor\nDOWN messages sent by `Process.monitor/1`. Another use case for `c:handle_info/2`\nis to perform periodic work, with the help of `Process.send_after/4`:\n\n    defmodule MyApp.Periodically do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, %{})\n      end\n\n      @impl true\n      def init(state) do\n        # Schedule work to be performed on start\n        schedule_work()\n\n        {:ok, state}\n      end\n\n      @impl true\n      def handle_info(:work, state) do\n        # Do the desired work here\n        # ...\n\n        # Reschedule once more\n        schedule_work()\n\n        {:noreply, state}\n      end\n\n      defp schedule_work do\n        # We schedule the work to happen in 2 hours (written in milliseconds).\n        # Alternatively, one might write :timer.hours(2)\n        Process.send_after(self(), :work, 2 * 60 * 60 * 1000)\n      end\n    end\n\n## Timeouts\n\nThe return value of `c:init/1` or any of the `handle_*` callbacks may include\na timeout value in milliseconds; if not, `:infinity` is assumed.\nThe timeout can be used to detect a lull in incoming messages.\n\nThe `timeout()` value is used as follows:\n\n  * If the process has any message already waiting when the `timeout()` value\n    is returned, the timeout is ignored and the waiting message is handled as\n    usual. This means that even a timeout of `0` milliseconds is not guaranteed\n    to execute (if you want to take another action immediately and unconditionally,\n    use a `:continue` instruction instead).\n\n  * If any message arrives before the specified number of milliseconds\n    elapse, the timeout is cleared and that message is handled as usual.\n\n  * Otherwise, when the specified number of milliseconds have elapsed with no\n    message arriving, `handle_info/2` is called with `:timeout` as the first\n    argument.\n\n## When (not) to use a GenServer\n\nSo far, we have learned that a `GenServer` can be used as a supervised process\nthat handles sync and async calls. It can also handle system messages, such as\nperiodic messages and monitoring events. GenServer processes may also be named.\n\nA GenServer, or a process in general, must be used to model runtime characteristics\nof your system. A GenServer must never be used for code organization purposes.\n\nIn Elixir, code organization is done by modules and functions, processes are not\nnecessary. For example, imagine you are implementing a calculator and you decide\nto put all the calculator operations behind a GenServer:\n\n    def add(a, b) do\n      GenServer.call(__MODULE__, {:add, a, b})\n    end\n\n    def subtract(a, b) do\n      GenServer.call(__MODULE__, {:subtract, a, b})\n    end\n\n    def handle_call({:add, a, b}, _from, state) do\n      {:reply, a + b, state}\n    end\n\n    def handle_call({:subtract, a, b}, _from, state) do\n      {:reply, a - b, state}\n    end\n\nThis is an anti-pattern not only because it convolutes the calculator logic but\nalso because you put the calculator logic behind a single process that will\npotentially become a bottleneck in your system, especially as the number of\ncalls grow. Instead just define the functions directly:\n\n    def add(a, b) do\n      a + b\n    end\n\n    def subtract(a, b) do\n      a - b\n    end\n\nIf you don't need a process, then you don't need a process. Use processes only to\nmodel runtime properties, such as mutable state, concurrency and failures, never\nfor code organization.\n\n## Debugging with the :sys module\n\nGenServers, as [special processes](https://www.erlang.org/doc/design_principles/spec_proc.html),\ncan be debugged using the [`:sys` module](`:sys`).\nThrough various hooks, this module allows developers to introspect the state of\nthe process and trace system events that happen during its execution, such as\nreceived messages, sent replies and state changes.\n\nLet's explore the basic functions from the\n[`:sys` module](`:sys`) used for debugging:\n\n  * `:sys.get_state/2` - allows retrieval of the state of the process.\n    In the case of a GenServer process, it will be the callback module state,\n    as passed into the callback functions as last argument.\n  * `:sys.get_status/2` - allows retrieval of the status of the process.\n    This status includes the process dictionary, if the process is running\n    or is suspended, the parent PID, the debugger state, and the state of\n    the behaviour module, which includes the callback module state\n    (as returned by `:sys.get_state/2`). It's possible to change how this\n    status is represented by defining the optional `c:GenServer.format_status/2`\n    callback.\n  * `:sys.trace/3` - prints all the system events to `:stdio`.\n  * `:sys.statistics/3` - manages collection of process statistics.\n  * `:sys.no_debug/2` - turns off all debug handlers for the given process.\n    It is very important to switch off debugging once we're done. Excessive\n    debug handlers or those that should be turned off, but weren't, can\n    seriously damage the performance of the system.\n  * `:sys.suspend/2` - allows to suspend a process so that it only\n    replies to system messages but no other messages. A suspended process\n    can be reactivated via `:sys.resume/2`.\n\nLet's see how we could use those functions for debugging the stack server\nwe defined earlier.\n\n    iex> {:ok, pid} = Stack.start_link([])\n    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n    iex> :sys.trace(pid, true) # turn on event printing\n    iex> Stack.push(pid, 1)\n    *DBG* <0.122.0> got cast {push,1}\n    *DBG* <0.122.0> new state [1]\n    :ok\n\n    iex> :sys.get_state(pid)\n    [1]\n\n    iex> Stack.pop(pid)\n    *DBG* <0.122.0> got call pop from <0.80.0>\n    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n    1\n\n    iex> :sys.statistics(pid, :get)\n    {:ok,\n     [\n       start_time: {{2016, 7, 16}, {12, 29, 41}},\n       current_time: {{2016, 7, 16}, {12, 29, 50}},\n       reductions: 117,\n       messages_in: 2,\n       messages_out: 0\n     ]}\n\n    iex> :sys.no_debug(pid) # turn off all debug handlers\n    :ok\n\n    iex> :sys.get_status(pid)\n    {:status, #PID<0.122.0>, {:module, :gen_server},\n     [\n       [\n         \"$initial_call\": {Stack, :init, 1},            # process dictionary\n         \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]\n       ],\n       :running,                                        # :running | :suspended\n       #PID<0.80.0>,                                    # parent\n       [],                                              # debugger state\n       [\n         header: 'Status for generic server <0.122.0>', # module status\n         data: [\n           {'Status', :running},\n           {'Parent', #PID<0.80.0>},\n           {'Logged events', []}\n         ],\n         data: [{'State', [1]}]\n       ]\n     ]}\n\n## Learn more\n\nIf you wish to find out more about GenServers, the Elixir Getting Started\nguide provides a tutorial-like introduction. The documentation and links\nin Erlang can also provide extra insight.\n\n  * [GenServer - Elixir's Getting Started Guide](https://elixir-lang.org/getting-started/mix-otp/genserver.html)\n  * [`:gen_server` module documentation](`:gen_server`)\n  * [gen_server Behaviour - OTP Design Principles](https://www.erlang.org/doc/design_principles/gen_server_concepts.html)\n  * [Clients and Servers - Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/clients-and-servers)\n\n","title":"GenServer","type":"behaviour"},{"doc":"Casts all servers locally registered as name at the specified nodes. This function returns immediately and ignores nodes that do not exist, or where the server name does not exist. See multi_call/4 for more information.","ref":"GenServer.html#abcast/3","source_doc":"Casts all servers locally registered as `name` at the specified nodes.\n\nThis function returns immediately and ignores nodes that do not exist, or where the\nserver name does not exist.\n\nSee `multi_call/4` for more information.\n","title":"GenServer.abcast/3","type":"function"},{"doc":"Makes a synchronous call to the server and waits for its reply. The client sends the given request to the server and waits until a reply arrives or a timeout occurs. handle_call/3 will be called on the server to handle the request. server can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module. Timeouts timeout is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom :infinity to wait indefinitely. The default value is 5000 . If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.","ref":"GenServer.html#call/3","source_doc":"Makes a synchronous call to the `server` and waits for its reply.\n\nThe client sends the given `request` to the server and waits until a reply\narrives or a timeout occurs. `c:handle_call/3` will be called on the server\nto handle the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.\n\n## Timeouts\n\n`timeout` is an integer greater than zero which specifies how many\nmilliseconds to wait for a reply, or the atom `:infinity` to wait\nindefinitely. The default value is `5000`. If no reply is received within\nthe specified time, the function call fails and the caller exits. If the\ncaller catches the failure and continues running, and the server is just late\nwith the reply, it may arrive at any time later into the caller's message\nqueue. The caller must in this case be prepared for this and discard any such\ngarbage messages that are two-element tuples with a reference as the first\nelement.\n","title":"GenServer.call/3","type":"function"},{"doc":"Casts a request to the server without waiting for a response. This function always returns :ok regardless of whether the destination server (or node) exists. Therefore it is unknown whether the destination server successfully handled the request. server can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module.","ref":"GenServer.html#cast/2","source_doc":"Casts a request to the `server` without waiting for a response.\n\nThis function always returns `:ok` regardless of whether\nthe destination `server` (or node) exists. Therefore it\nis unknown whether the destination `server` successfully\nhandled the request.\n\n`server` can be any of the values described in the \"Name registration\"\nsection of the documentation for this module.\n","title":"GenServer.cast/2","type":"function"},{"doc":"Invoked to change the state of the GenServer when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed. old_vsn is the previous version of the module (defined by the @vsn attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element :down . state is the current state of the GenServer and extra is any extra data required to change the state. Returning {:ok, new_state} changes the state to new_state and the code change is successful. Returning {:error, reason} fails the code change with reason reason and the state remains as the previous state. If code_change/3 raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects. This callback is optional.","ref":"GenServer.html#c:code_change/3","source_doc":"Invoked to change the state of the `GenServer` when a different version of a\nmodule is loaded (hot code swapping) and the state's term structure should be\nchanged.\n\n`old_vsn` is the previous version of the module (defined by the `@vsn`\nattribute) when upgrading. When downgrading the previous version is wrapped in\na 2-tuple with first element `:down`. `state` is the current state of the\n`GenServer` and `extra` is any extra data required to change the state.\n\nReturning `{:ok, new_state}` changes the state to `new_state` and the code\nchange is successful.\n\nReturning `{:error, reason}` fails the code change with reason `reason` and\nthe state remains as the previous state.\n\nIf `c:code_change/3` raises the code change fails and the loop will continue\nwith its previous state. Therefore this callback does not usually contain side effects.\n\nThis callback is optional.\n","title":"GenServer.code_change/3","type":"callback"},{"doc":"Invoked in some cases to retrieve a formatted version of the GenServer status: one of :sys.get_status/1 or :sys.get_status/2 is invoked to get the status of the GenServer ; in such cases, reason is :normal the GenServer terminates abnormally and logs an error; in such cases, reason is :terminate This callback can be useful to control the appearance of the status of the GenServer . For example, it can be used to return a compact representation of the GenServer 's state to avoid having large state terms printed. pdict_and_state is a two-elements list [pdict, state] where pdict is a list of {key, value} tuples representing the current process dictionary of the GenServer and state is the current state of the GenServer .","ref":"GenServer.html#c:format_status/2","source_doc":"Invoked in some cases to retrieve a formatted version of the `GenServer` status:\n\n  * one of `:sys.get_status/1` or `:sys.get_status/2` is invoked to get the\n    status of the `GenServer`; in such cases, `reason` is `:normal`\n\n  * the `GenServer` terminates abnormally and logs an error; in such cases,\n    `reason` is `:terminate`\n\nThis callback can be useful to control the *appearance* of the status of the\n`GenServer`. For example, it can be used to return a compact representation of\nthe `GenServer`'s state to avoid having large state terms printed.\n\n`pdict_and_state` is a two-elements list `[pdict, state]` where `pdict` is a\nlist of `{key, value}` tuples representing the current process dictionary of\nthe `GenServer` and `state` is the current state of the `GenServer`.\n","title":"GenServer.format_status/2","type":"callback"},{"doc":"Invoked to handle synchronous call/3 messages. call/3 will block until a reply is received (unless the call times out or nodes are disconnected). request is the request message sent by a call/3 , from is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and state is the current state of the GenServer . Returning {:reply, reply, new_state} sends the response reply to the caller and continues the loop with new state new_state . Returning {:reply, reply, new_state, timeout} is similar to {:reply, reply, new_state} except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information. Returning {:reply, reply, new_state, :hibernate} is similar to {:reply, reply, new_state} except the process is hibernated and will continue the loop once a message is in its message queue. However, if a message is already in the message queue, the process will continue the loop immediately. Hibernating a GenServer causes garbage collection and leaves a continuous heap that minimises the memory used by the process. Hibernating should not be used aggressively as too much time could be spent garbage collecting, which would delay the processing of incoming messages. Normally it should only be used when you are not expecting new messages to immediately arrive and minimising the memory of the process is shown to be beneficial. Returning {:reply, reply, new_state, {:continue, continue_arg}} is similar to {:reply, reply, new_state} except that handle_continue/2 will be invoked immediately after with continue_arg as the first argument and state as the second one. Returning {:noreply, new_state} does not send a response to the caller and continues the loop with new state new_state . The response must be sent with reply/2 . There are three main use cases for not replying using the return value: To reply before returning from the callback because the response is known before calling a slow function. To reply after returning from the callback because the response is not yet available. To reply from another process, such as a task. When replying from another process the GenServer should exit if the other process exits without replying as the caller will be blocking awaiting a reply. Returning {:noreply, new_state, timeout | :hibernate | {:continue, continue_arg}} is similar to {:noreply, new_state} except a timeout, hibernation or continue occurs as with a :reply tuple. Returning {:stop, reason, reply, new_state} stops the loop and terminate/2 is called with reason reason and state new_state . Then, the reply is sent as the response to call and the process exits with reason reason . Returning {:stop, reason, new_state} is similar to {:stop, reason, reply, new_state} except a reply is not sent. This callback is optional. If one is not implemented, the server will fail if a call is performed against it.","ref":"GenServer.html#c:handle_call/3","source_doc":"Invoked to handle synchronous `call/3` messages. `call/3` will block until a\nreply is received (unless the call times out or nodes are disconnected).\n\n`request` is the request message sent by a `call/3`, `from` is a 2-tuple\ncontaining the caller's PID and a term that uniquely identifies the call, and\n`state` is the current state of the `GenServer`.\n\nReturning `{:reply, reply, new_state}` sends the response `reply` to the\ncaller and continues the loop with new state `new_state`.\n\nReturning `{:reply, reply, new_state, timeout}` is similar to\n`{:reply, reply, new_state}` except that it also sets a timeout.\nSee the \"Timeouts\" section in the module documentation for more information.\n\nReturning `{:reply, reply, new_state, :hibernate}` is similar to\n`{:reply, reply, new_state}` except the process is hibernated and will\ncontinue the loop once a message is in its message queue. However, if a message is\nalready in the message queue, the process will continue the loop immediately.\nHibernating a `GenServer` causes garbage collection and leaves a continuous\nheap that minimises the memory used by the process.\n\nHibernating should not be used aggressively as too much time could be spent\ngarbage collecting, which would delay the processing of incoming messages.\nNormally it should only be used when you are not expecting new messages to\nimmediately arrive and minimising the memory of the process is shown to be\nbeneficial.\n\nReturning `{:reply, reply, new_state, {:continue, continue_arg}}` is similar to\n`{:reply, reply, new_state}` except that `c:handle_continue/2` will be invoked\nimmediately after with `continue_arg` as the first argument and\n`state` as the second one.\n\nReturning `{:noreply, new_state}` does not send a response to the caller and\ncontinues the loop with new state `new_state`. The response must be sent with\n`reply/2`.\n\nThere are three main use cases for not replying using the return value:\n\n  * To reply before returning from the callback because the response is known\n    before calling a slow function.\n  * To reply after returning from the callback because the response is not yet\n    available.\n  * To reply from another process, such as a task.\n\nWhen replying from another process the `GenServer` should exit if the other\nprocess exits without replying as the caller will be blocking awaiting a\nreply.\n\nReturning `{:noreply, new_state, timeout | :hibernate | {:continue, continue_arg}}`\nis similar to `{:noreply, new_state}` except a timeout, hibernation or continue\noccurs as with a `:reply` tuple.\n\nReturning `{:stop, reason, reply, new_state}` stops the loop and `c:terminate/2`\nis called with reason `reason` and state `new_state`. Then, the `reply` is sent\nas the response to call and the process exits with reason `reason`.\n\nReturning `{:stop, reason, new_state}` is similar to\n`{:stop, reason, reply, new_state}` except a reply is not sent.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a call is performed against it.\n","title":"GenServer.handle_call/3","type":"callback"},{"doc":"Invoked to handle asynchronous cast/2 messages. request is the request message sent by a cast/2 and state is the current state of the GenServer . Returning {:noreply, new_state} continues the loop with new state new_state . Returning {:noreply, new_state, timeout} is similar to {:noreply, new_state} except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information. Returning {:noreply, new_state, :hibernate} is similar to {:noreply, new_state} except the process is hibernated before continuing the loop. See handle_call/3 for more information. Returning {:noreply, new_state, {:continue, continue_arg}} is similar to {:noreply, new_state} except handle_continue/2 will be invoked immediately after with continue_arg as the first argument and state as the second one. Returning {:stop, reason, new_state} stops the loop and terminate/2 is called with the reason reason and state new_state . The process exits with reason reason . This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.","ref":"GenServer.html#c:handle_cast/2","source_doc":"Invoked to handle asynchronous `cast/2` messages.\n\n`request` is the request message sent by a `cast/2` and `state` is the current\nstate of the `GenServer`.\n\nReturning `{:noreply, new_state}` continues the loop with new state `new_state`.\n\nReturning `{:noreply, new_state, timeout}` is similar to `{:noreply, new_state}`\nexcept that it also sets a timeout. See the \"Timeouts\" section in the module\ndocumentation for more information.\n\nReturning `{:noreply, new_state, :hibernate}` is similar to\n`{:noreply, new_state}` except the process is hibernated before continuing the\nloop. See `c:handle_call/3` for more information.\n\nReturning `{:noreply, new_state, {:continue, continue_arg}}` is similar to\n`{:noreply, new_state}` except `c:handle_continue/2` will be invoked\nimmediately after with `continue_arg` as the first argument and\n`state` as the second one.\n\nReturning `{:stop, reason, new_state}` stops the loop and `c:terminate/2` is\ncalled with the reason `reason` and state `new_state`. The process exits with\nreason `reason`.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a cast is performed against it.\n","title":"GenServer.handle_cast/2","type":"callback"},{"doc":"Invoked to handle continue instructions. It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way. Return values are the same as handle_cast/2 . This callback is optional. If one is not implemented, the server will fail if a continue instruction is used.","ref":"GenServer.html#c:handle_continue/2","source_doc":"Invoked to handle continue instructions.\n\nIt is useful for performing work after initialization or for splitting the work\nin a callback in multiple steps, updating the process state along the way.\n\nReturn values are the same as `c:handle_cast/2`.\n\nThis callback is optional. If one is not implemented, the server will fail\nif a continue instruction is used.\n","title":"GenServer.handle_continue/2","type":"callback"},{"doc":"Invoked to handle all other messages. msg is the message and state is the current state of the GenServer . When a timeout occurs the message is :timeout . Return values are the same as handle_cast/2 . This callback is optional. If one is not implemented, the received message will be logged.","ref":"GenServer.html#c:handle_info/2","source_doc":"Invoked to handle all other messages.\n\n`msg` is the message and `state` is the current state of the `GenServer`. When\na timeout occurs the message is `:timeout`.\n\nReturn values are the same as `c:handle_cast/2`.\n\nThis callback is optional. If one is not implemented, the received message\nwill be logged.\n","title":"GenServer.handle_info/2","type":"callback"},{"doc":"Invoked when the server is started. start_link/3 or start/3 will block until it returns. init_arg is the argument term (second argument) passed to start_link/3 . Returning {:ok, state} will cause start_link/3 to return {:ok, pid} and the process to enter its loop. Returning {:ok, state, timeout} is similar to {:ok, state} , except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information. Returning {:ok, state, :hibernate} is similar to {:ok, state} except the process is hibernated before entering the loop. See handle_call/3 for more information on hibernation. Returning {:ok, state, {:continue, continue_arg}} is similar to {:ok, state} except that immediately after entering the loop, the handle_continue/2 callback will be invoked with continue_arg as the first argument and state as the second one. Returning :ignore will cause start_link/3 to return :ignore and the process will exit normally without entering the loop or calling terminate/2 . If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the GenServer . The remainder of the supervision tree will be started and so the GenServer should not be required by other processes. It can be started later with Supervisor.restart_child/2 as the child specification is saved in the parent supervisor. The main use cases for this are: The GenServer is disabled by configuration but might be enabled later. An error occurred and it will be handled by a different mechanism than the Supervisor . Likely this approach involves calling Supervisor.restart_child/2 after a delay to attempt a restart. Returning {:stop, reason} will cause start_link/3 to return {:error, reason} and the process to exit with reason reason without entering the loop or calling terminate/2 .","ref":"GenServer.html#c:init/1","source_doc":"Invoked when the server is started. `start_link/3` or `start/3` will\nblock until it returns.\n\n`init_arg` is the argument term (second argument) passed to `start_link/3`.\n\nReturning `{:ok, state}` will cause `start_link/3` to return\n`{:ok, pid}` and the process to enter its loop.\n\nReturning `{:ok, state, timeout}` is similar to `{:ok, state}`,\nexcept that it also sets a timeout. See the \"Timeouts\" section\nin the module documentation for more information.\n\nReturning `{:ok, state, :hibernate}` is similar to `{:ok, state}`\nexcept the process is hibernated before entering the loop. See\n`c:handle_call/3` for more information on hibernation.\n\nReturning `{:ok, state, {:continue, continue_arg}}` is similar to\n`{:ok, state}` except that immediately after entering the loop,\nthe `c:handle_continue/2` callback will be invoked with `continue_arg`\nas the first argument and `state` as the second one.\n\nReturning `:ignore` will cause `start_link/3` to return `:ignore` and\nthe process will exit normally without entering the loop or calling\n`c:terminate/2`. If used when part of a supervision tree the parent\nsupervisor will not fail to start nor immediately try to restart the\n`GenServer`. The remainder of the supervision tree will be started\nand so the `GenServer` should not be required by other processes.\nIt can be started later with `Supervisor.restart_child/2` as the child\nspecification is saved in the parent supervisor. The main use cases for\nthis are:\n\n  * The `GenServer` is disabled by configuration but might be enabled later.\n  * An error occurred and it will be handled by a different mechanism than the\n   `Supervisor`. Likely this approach involves calling `Supervisor.restart_child/2`\n    after a delay to attempt a restart.\n\nReturning `{:stop, reason}` will cause `start_link/3` to return\n`{:error, reason}` and the process to exit with reason `reason` without\nentering the loop or calling `c:terminate/2`.\n","title":"GenServer.init/1","type":"callback"},{"doc":"Calls all servers locally registered as name at the specified nodes . First, the request is sent to every node in nodes ; then, the caller waits for the replies. This function returns a two-element tuple {replies, bad_nodes} where: replies - is a list of {node, reply} tuples where node is the node that replied and reply is its reply bad_nodes - is a list of nodes that either did not exist or where a server with the given name did not exist or did not reply nodes is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node). Examples Assuming the Stack GenServer mentioned in the docs for the GenServer module is registered as Stack in the :&quot;foo@my-machine&quot; and :&quot;bar@my-machine&quot; nodes: GenServer . multi_call ( Stack , :pop ) #=&gt; {[{:&quot;foo@my-machine&quot;, :hello}, {:&quot;bar@my-machine&quot;, :world}], []}","ref":"GenServer.html#multi_call/4","source_doc":"Calls all servers locally registered as `name` at the specified `nodes`.\n\nFirst, the `request` is sent to every node in `nodes`; then, the caller waits\nfor the replies. This function returns a two-element tuple `{replies,\nbad_nodes}` where:\n\n  * `replies` - is a list of `{node, reply}` tuples where `node` is the node\n    that replied and `reply` is its reply\n  * `bad_nodes` - is a list of nodes that either did not exist or where a\n    server with the given `name` did not exist or did not reply\n\n`nodes` is a list of node names to which the request is sent. The default\nvalue is the list of all known nodes (including this node).\n\n## Examples\n\nAssuming the `Stack` GenServer mentioned in the docs for the `GenServer`\nmodule is registered as `Stack` in the `:\"foo@my-machine\"` and\n`:\"bar@my-machine\"` nodes:\n\n    GenServer.multi_call(Stack, :pop)\n    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], []}\n\n","title":"GenServer.multi_call/4","type":"function"},{"doc":"Replies to a client. This function can be used to explicitly send a reply to a client that called call/3 or multi_call/4 when the reply cannot be specified in the return value of handle_call/3 . client must be the from argument (the second argument) accepted by handle_call/3 callbacks. reply is an arbitrary term which will be given back to the client as the return value of the call. Note that reply/2 can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the from argument somehow). This function always returns :ok . Examples def handle_call ( :reply_in_one_second , from , state ) do Process . send_after ( self ( ) , { :reply , from } , 1_000 ) { :noreply , state } end def handle_info ( { :reply , from } , state ) do GenServer . reply ( from , :one_second_has_passed ) { :noreply , state } end","ref":"GenServer.html#reply/2","source_doc":"Replies to a client.\n\nThis function can be used to explicitly send a reply to a client that called\n`call/3` or `multi_call/4` when the reply cannot be specified in the return\nvalue of `c:handle_call/3`.\n\n`client` must be the `from` argument (the second argument) accepted by\n`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be given\nback to the client as the return value of the call.\n\nNote that `reply/2` can be called from any process, not just the GenServer\nthat originally received the call (as long as that GenServer communicated the\n`from` argument somehow).\n\nThis function always returns `:ok`.\n\n## Examples\n\n    def handle_call(:reply_in_one_second, from, state) do\n      Process.send_after(self(), {:reply, from}, 1_000)\n      {:noreply, state}\n    end\n\n    def handle_info({:reply, from}, state) do\n      GenServer.reply(from, :one_second_has_passed)\n      {:noreply, state}\n    end\n\n","title":"GenServer.reply/2","type":"function"},{"doc":"Starts a GenServer process without links (outside of a supervision tree). See start_link/3 for more information.","ref":"GenServer.html#start/3","source_doc":"Starts a `GenServer` process without links (outside of a supervision tree).\n\nSee `start_link/3` for more information.\n","title":"GenServer.start/3","type":"function"},{"doc":"Starts a GenServer process linked to the current process. This is often used to start the GenServer as part of a supervision tree. Once the server is started, the init/1 function of the given module is called with init_arg as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until init/1 has returned. Note that a GenServer started with start_link/3 is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the :normal reasons in case it is configured to trap exits in the init/1 callback. Options :name - used for name registration as described in the &quot;Name registration&quot; section in the documentation for GenServer :timeout - if present, the server is allowed to spend the given number of milliseconds initializing or it will be terminated and the start function will return {:error, :timeout} :debug - if present, the corresponding function in the :sys module is invoked :spawn_opt - if present, its value is passed as options to the underlying process as in Process.spawn/4 :hibernate_after - if present, the GenServer process awaits any message for the given number of milliseconds and if no message is received, the process goes into hibernation automatically (by calling :proc_lib.hibernate/3 ). Return values If the server is successfully created and initialized, this function returns {:ok, pid} , where pid is the PID of the server. If a process with the specified server name already exists, this function returns {:error, {:already_started, pid}} with the PID of that process. If the init/1 callback fails with reason , this function returns {:error, reason} . Otherwise, if it returns {:stop, reason} or :ignore , the process is terminated and this function returns {:error, reason} or :ignore , respectively.","ref":"GenServer.html#start_link/3","source_doc":"Starts a `GenServer` process linked to the current process.\n\nThis is often used to start the `GenServer` as part of a supervision tree.\n\nOnce the server is started, the `c:init/1` function of the given `module` is\ncalled with `init_arg` as its argument to initialize the server. To ensure a\nsynchronized start-up procedure, this function does not return until `c:init/1`\nhas returned.\n\nNote that a `GenServer` started with `start_link/3` is linked to the\nparent process and will exit in case of crashes from the parent. The GenServer\nwill also exit due to the `:normal` reasons in case it is configured to trap\nexits in the `c:init/1` callback.\n\n## Options\n\n  * `:name` - used for name registration as described in the \"Name\n    registration\" section in the documentation for `GenServer`\n\n  * `:timeout` - if present, the server is allowed to spend the given number of\n    milliseconds initializing or it will be terminated and the start function\n    will return `{:error, :timeout}`\n\n  * `:debug` - if present, the corresponding function in the [`:sys` module](`:sys`) is invoked\n\n  * `:spawn_opt` - if present, its value is passed as options to the\n    underlying process as in `Process.spawn/4`\n\n  * `:hibernate_after` - if present, the GenServer process awaits any message for\n    the given number of milliseconds and if no message is received, the process goes\n    into hibernation automatically (by calling `:proc_lib.hibernate/3`).\n\n## Return values\n\nIf the server is successfully created and initialized, this function returns\n`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\nspecified server name already exists, this function returns\n`{:error, {:already_started, pid}}` with the PID of that process.\n\nIf the `c:init/1` callback fails with `reason`, this function returns\n`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\nor `:ignore`, the process is terminated and this function returns\n`{:error, reason}` or `:ignore`, respectively.\n","title":"GenServer.start_link/3","type":"function"},{"doc":"Synchronously stops the server with the given reason . The terminate/2 callback of the given server will be invoked before exiting. This function returns :ok if the server terminates with the given reason; if it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"GenServer.html#stop/3","source_doc":"Synchronously stops the server with the given `reason`.\n\nThe `c:terminate/2` callback of the given `server` will be invoked before\nexiting. This function returns `:ok` if the server terminates with the\ngiven reason; if it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n","title":"GenServer.stop/3","type":"function"},{"doc":"Invoked when the server is about to exit. It should do any cleanup required. reason is exit reason and state is the current state of the GenServer . The return value is ignored. terminate/2 is useful for cleanup that requires access to the GenServer 's state. However, it is not guaranteed that terminate/2 is called when a GenServer exits. Therefore, important cleanup should be done using process links and/or monitors. A monitoring process will receive the same exit reason that would be passed to terminate/2 . terminate/2 is called if: the GenServer traps exits (using Process.flag/2 ) and the parent process (the one which called start_link/1 ) sends an exit signal a callback (except init/1 ) does one of the following: returns a :stop tuple raises (via raise/2 ) or exits (via exit/1 ) returns an invalid value If part of a supervision tree, a GenServer will receive an exit signal from its parent process (its supervisor) when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be: :brutal_kill : the GenServer is killed and so terminate/2 is not called. a timeout value, where the supervisor will send the exit signal :shutdown and the GenServer will have the duration of the timeout to terminate. If after duration of this timeout the process is still alive, it will be killed immediately. For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the Supervisor module. If the GenServer receives an exit signal (that is not :normal ) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call terminate/2 . Note that a process does NOT trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected. terminate/2 is only called after the GenServer finishes processing all messages which arrived in its mailbox prior to the exit signal. If it receives a :kill signal before it finishes processing those, terminate/2 will not be called. If terminate/2 is called, any messages received after the exit signal will still be in the mailbox. There is no cleanup needed when the GenServer controls a port (for example, :gen_tcp.socket ) or File.io_device/0 , because these will be closed on receiving a GenServer 's exit signal and do not need to be closed manually in terminate/2 . If reason is neither :normal , :shutdown , nor {:shutdown, term} an error is logged. This callback is optional.","ref":"GenServer.html#c:terminate/2","source_doc":"Invoked when the server is about to exit. It should do any cleanup required.\n\n`reason` is exit reason and `state` is the current state of the `GenServer`.\nThe return value is ignored.\n\n`c:terminate/2` is useful for cleanup that requires access to the\n`GenServer`'s state. However, it is **not guaranteed** that `c:terminate/2`\nis called when a `GenServer` exits. Therefore, important cleanup should be\ndone using process links and/or monitors. A monitoring process will receive the\nsame exit `reason` that would be passed to `c:terminate/2`.\n\n`c:terminate/2` is called if:\n\n  * the `GenServer` traps exits (using `Process.flag/2`) *and* the parent\n  process (the one which called `start_link/1`) sends an exit signal\n\n  * a callback (except `c:init/1`) does one of the following:\n\n    * returns a `:stop` tuple\n\n    * raises (via `raise/2`) or exits (via `exit/1`)\n\n    * returns an invalid value\n\nIf part of a supervision tree, a `GenServer` will receive an exit signal from\nits parent process (its supervisor) when the tree is shutting down. The exit\nsignal is based on the shutdown strategy in the child's specification, where\nthis value can be:\n\n  * `:brutal_kill`: the `GenServer` is killed and so `c:terminate/2` is not called.\n\n  * a timeout value, where the supervisor will send the exit signal `:shutdown` and\n    the `GenServer` will have the duration of the timeout to terminate.\n    If after duration of this timeout the process is still alive, it will be killed\n    immediately.\n\nFor a more in-depth explanation, please read the \"Shutdown values (:shutdown)\"\nsection in the `Supervisor` module.\n\nIf the `GenServer` receives an exit signal (that is not `:normal`) from any\nprocess when it is not trapping exits it will exit abruptly with the same\nreason and so not call `c:terminate/2`. Note that a process does *NOT* trap\nexits by default and an exit signal is sent when a linked process exits or its\nnode is disconnected.\n\n`c:terminate/2` is only called after the `GenServer` finishes processing all\nmessages which arrived in its mailbox prior to the exit signal. If it\nreceives a `:kill` signal before it finishes processing those,\n`c:terminate/2` will not be called. If `c:terminate/2` is called, any\nmessages received after the exit signal will still be in the mailbox.\n\nThere is no cleanup needed when the `GenServer` controls a `port` (for example,\n`:gen_tcp.socket`) or `t:File.io_device/0`, because these will be closed on\nreceiving a `GenServer`'s exit signal and do not need to be closed manually\nin `c:terminate/2`.\n\nIf `reason` is neither `:normal`, `:shutdown`, nor `{:shutdown, term}` an error is\nlogged.\n\nThis callback is optional.\n","title":"GenServer.terminate/2","type":"callback"},{"doc":"Returns the pid or {name, node} of a GenServer process, nil otherwise. To be precise, nil is returned whenever a pid or {name, node} cannot be returned. Note there is no guarantee the returned pid or {name, node} is alive, as a process could terminate immediately after it is looked up. Examples For example, to lookup a server process, monitor it and send a cast to it: process = GenServer . whereis ( server ) monitor = Process . monitor ( process ) GenServer . cast ( process , :hello )","ref":"GenServer.html#whereis/1","source_doc":"Returns the `pid` or `{name, node}` of a GenServer process, `nil` otherwise.\n\nTo be precise, `nil` is returned whenever a `pid` or `{name, node}` cannot\nbe returned. Note there is no guarantee the returned `pid` or `{name, node}`\nis alive, as a process could terminate immediately after it is looked up.\n\n## Examples\n\nFor example, to lookup a server process, monitor it and send a cast to it:\n\n    process = GenServer.whereis(server)\n    monitor = Process.monitor(process)\n    GenServer.cast(process, :hello)\n\n","title":"GenServer.whereis/1","type":"function"},{"doc":"Debug options supported by the start* functions","ref":"GenServer.html#t:debug/0","source_doc":"Debug options supported by the `start*` functions","title":"GenServer.debug/0","type":"type"},{"doc":"Tuple describing the client of a call request. pid is the PID of the caller and tag is a unique term used to identify the call.","ref":"GenServer.html#t:from/0","source_doc":"Tuple describing the client of a call request.\n\n`pid` is the PID of the caller and `tag` is a unique term used to identify the\ncall.\n","title":"GenServer.from/0","type":"type"},{"doc":"The GenServer name","ref":"GenServer.html#t:name/0","source_doc":"The GenServer name","title":"GenServer.name/0","type":"type"},{"doc":"Return values of start* functions","ref":"GenServer.html#t:on_start/0","source_doc":"Return values of `start*` functions","title":"GenServer.on_start/0","type":"type"},{"doc":"Option values used by the start* functions","ref":"GenServer.html#t:option/0","source_doc":"Option values used by the `start*` functions","title":"GenServer.option/0","type":"type"},{"doc":"Options used by the start* functions","ref":"GenServer.html#t:options/0","source_doc":"Options used by the `start*` functions","title":"GenServer.options/0","type":"type"},{"doc":"The server reference. This is either a plain PID or a value representing a registered name. See the &quot;Name registration&quot; section of this document for more information.","ref":"GenServer.html#t:server/0","source_doc":"The server reference.\n\nThis is either a plain PID or a value representing a registered name.\nSee the \"Name registration\" section of this document for more information.\n","title":"GenServer.server/0","type":"type"},{"doc":"Functions related to VM nodes. Some of the functions in this module are inlined by the compiler, similar to functions in the Kernel module and they are explicitly marked in their docs as &quot;inlined by the compiler&quot;. For more information about inlined functions, check out the Kernel module.","ref":"Node.html","source_doc":"Functions related to VM nodes.\n\nSome of the functions in this module are inlined by the compiler,\nsimilar to functions in the `Kernel` module and they are explicitly\nmarked in their docs as \"inlined by the compiler\". For more information\nabout inlined functions, check out the `Kernel` module.\n","title":"Node","type":"module"},{"doc":"Returns true if the local node is alive. That is, if the node can be part of a distributed system.","ref":"Node.html#alive?/0","source_doc":"Returns `true` if the local node is alive.\n\nThat is, if the node can be part of a distributed system.\n","title":"Node.alive?/0","type":"function"},{"doc":"Establishes a connection to node . Returns true if successful, false if not, and the atom :ignored if the local node is not alive. For more information, see :net_kernel.connect_node/1 .","ref":"Node.html#connect/1","source_doc":"Establishes a connection to `node`.\n\nReturns `true` if successful, `false` if not, and the atom\n`:ignored` if the local node is not alive.\n\nFor more information, see `:net_kernel.connect_node/1`.\n","title":"Node.connect/1","type":"function"},{"doc":"Forces the disconnection of a node. This will appear to the node as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns true if disconnection succeeds, otherwise false . If the local node is not alive, the function returns :ignored . For more information, see :erlang.disconnect_node/1 .","ref":"Node.html#disconnect/1","source_doc":"Forces the disconnection of a node.\n\nThis will appear to the `node` as if the local node has crashed.\nThis function is mainly used in the Erlang network authentication\nprotocols. Returns `true` if disconnection succeeds, otherwise `false`.\nIf the local node is not alive, the function returns `:ignored`.\n\nFor more information, see `:erlang.disconnect_node/1`.\n","title":"Node.disconnect/1","type":"function"},{"doc":"Returns the magic cookie of the local node. Returns the cookie if the node is alive, otherwise :nocookie .","ref":"Node.html#get_cookie/0","source_doc":"Returns the magic cookie of the local node.\n\nReturns the cookie if the node is alive, otherwise `:nocookie`.\n","title":"Node.get_cookie/0","type":"function"},{"doc":"Returns a list of all visible nodes in the system, excluding the local node. Same as list(:visible) . Inlined by the compiler.","ref":"Node.html#list/0","source_doc":"Returns a list of all visible nodes in the system, excluding\nthe local node.\n\nSame as `list(:visible)`.\n\nInlined by the compiler.\n","title":"Node.list/0","type":"function"},{"doc":"Returns a list of nodes according to argument given. The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements. For more information, see :erlang.nodes/1 . Inlined by the compiler.","ref":"Node.html#list/1","source_doc":"Returns a list of nodes according to argument given.\n\nThe result returned when the argument is a list, is the list of nodes\nsatisfying the disjunction(s) of the list elements.\n\nFor more information, see `:erlang.nodes/1`.\n\nInlined by the compiler.\n","title":"Node.list/1","type":"function"},{"doc":"Monitors the status of the node. If flag is true , monitoring is turned on. If flag is false , monitoring is turned off. For more information, see :erlang.monitor_node/2 . For monitoring status changes of all nodes, see :net_kernel.monitor_nodes/2 .","ref":"Node.html#monitor/2","source_doc":"Monitors the status of the node.\n\nIf `flag` is `true`, monitoring is turned on.\nIf `flag` is `false`, monitoring is turned off.\n\nFor more information, see `:erlang.monitor_node/2`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.\n","title":"Node.monitor/2","type":"function"},{"doc":"Behaves as monitor/2 except that it allows an extra option to be given, namely :allow_passive_connect . For more information, see :erlang.monitor_node/3 . For monitoring status changes of all nodes, see :net_kernel.monitor_nodes/2 .","ref":"Node.html#monitor/3","source_doc":"Behaves as `monitor/2` except that it allows an extra\noption to be given, namely `:allow_passive_connect`.\n\nFor more information, see `:erlang.monitor_node/3`.\n\nFor monitoring status changes of all nodes, see `:net_kernel.monitor_nodes/2`.\n","title":"Node.monitor/3","type":"function"},{"doc":"Tries to set up a connection to node. Returns :pang if it fails, or :pong if it is successful. Examples iex&gt; Node . ping ( :unknown_node ) :pang","ref":"Node.html#ping/1","source_doc":"Tries to set up a connection to node.\n\nReturns `:pang` if it fails, or `:pong` if it is successful.\n\n## Examples\n\n    iex> Node.ping(:unknown_node)\n    :pang\n\n","title":"Node.ping/1","type":"function"},{"doc":"Returns the current node. It returns the same as the built-in node() .","ref":"Node.html#self/0","source_doc":"Returns the current node.\n\nIt returns the same as the built-in `node()`.\n","title":"Node.self/0","type":"function"},{"doc":"Sets the magic cookie of node to the atom cookie . The default node is Node.self/0 , the local node. If node is the local node, the function also sets the cookie of all other unknown nodes to cookie . This function will raise FunctionClauseError if the given node is not alive.","ref":"Node.html#set_cookie/2","source_doc":"Sets the magic cookie of `node` to the atom `cookie`.\n\nThe default node is `Node.self/0`, the local node. If `node` is the local node,\nthe function also sets the cookie of all other unknown nodes to `cookie`.\n\nThis function will raise `FunctionClauseError` if the given `node` is not alive.\n","title":"Node.set_cookie/2","type":"function"},{"doc":"Returns the PID of a new process started by the application of fun on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn/2 . Inlined by the compiler.","ref":"Node.html#spawn/2","source_doc":"Returns the PID of a new process started by the application of `fun`\non `node`. If `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/2`.\n\nInlined by the compiler.\n","title":"Node.spawn/2","type":"function"},{"doc":"Returns the PID of a new process started by the application of fun on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn_opt/3 . Inlined by the compiler.","ref":"Node.html#spawn/3","source_doc":"Returns the PID of a new process started by the application of `fun`\non `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn_opt/3`.\n\nInlined by the compiler.\n","title":"Node.spawn/3","type":"function"},{"doc":"Returns the PID of a new process started by the application of module.function(args) on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn/4 . Inlined by the compiler.","ref":"Node.html#spawn/4","source_doc":"Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.\n","title":"Node.spawn/4","type":"function"},{"doc":"Returns the PID of a new process started by the application of module.function(args) on node . If node does not exist, a useless PID is returned. For the list of available options, see :erlang.spawn/4 . Inlined by the compiler.","ref":"Node.html#spawn/5","source_doc":"Returns the PID of a new process started by the application of\n`module.function(args)` on `node`.\n\nIf `node` does not exist, a useless PID is returned.\n\nFor the list of available options, see `:erlang.spawn/4`.\n\nInlined by the compiler.\n","title":"Node.spawn/5","type":"function"},{"doc":"Returns the PID of a new linked process started by the application of fun on node . A link is created between the calling process and the new process, atomically. If node does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason :noconnection will be received). Inlined by the compiler.","ref":"Node.html#spawn_link/2","source_doc":"Returns the PID of a new linked process started by the application of `fun` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.\n","title":"Node.spawn_link/2","type":"function"},{"doc":"Returns the PID of a new linked process started by the application of module.function(args) on node . A link is created between the calling process and the new process, atomically. If node does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason :noconnection will be received). Inlined by the compiler.","ref":"Node.html#spawn_link/4","source_doc":"Returns the PID of a new linked process started by the application of\n`module.function(args)` on `node`.\n\nA link is created between the calling process and the new process, atomically.\nIf `node` does not exist, a useless PID is returned (and due to the link, an exit\nsignal with exit reason `:noconnection` will be received).\n\nInlined by the compiler.\n","title":"Node.spawn_link/4","type":"function"},{"doc":"Spawns the given function on a node, monitors it and returns its PID and monitoring reference. Inlined by the compiler.","ref":"Node.html#spawn_monitor/2","source_doc":"Spawns the given function on a node, monitors it and returns its PID\nand monitoring reference.\n\nInlined by the compiler.\n","title":"Node.spawn_monitor/2","type":"function"},{"doc":"Spawns the given module and function passing the given args on a node, monitors it and returns its PID and monitoring reference. Inlined by the compiler.","ref":"Node.html#spawn_monitor/4","source_doc":"Spawns the given module and function passing the given args on a node,\nmonitors it and returns its PID and monitoring reference.\n\nInlined by the compiler.\n","title":"Node.spawn_monitor/4","type":"function"},{"doc":"Turns a non-distributed node into a distributed node. This functionality starts the :net_kernel and other related processes. This function is rarely invoked in practice. Instead, nodes are named and started via the command line by using the --sname and --name flags. If you need to use this function to dynamically name a node, please make sure the epmd operating system process is running by calling epmd -daemon . Invoking this function when the distribution has already been started, either via the command line interface or dynamically, will return an error. Examples { :ok , pid } = Node . start ( :example , :shortnames , 15000 )","ref":"Node.html#start/3","source_doc":"Turns a non-distributed node into a distributed node.\n\nThis functionality starts the `:net_kernel` and other related\nprocesses.\n\nThis function is rarely invoked in practice. Instead, nodes are\nnamed and started via the command line by using the `--sname` and\n`--name` flags. If you need to use this function to dynamically\nname a node, please make sure the `epmd` operating system process\nis running by calling `epmd -daemon`.\n\nInvoking this function when the distribution has already been started,\neither via the command line interface or dynamically, will return an\nerror.\n\n## Examples\n\n    {:ok, pid} = Node.start(:example, :shortnames, 15000)\n\n","title":"Node.start/3","type":"function"},{"doc":"Turns a distributed node into a non-distributed node. For other nodes in the network, this is the same as the node going down. Only possible when the node was started with Node.start/3 , otherwise returns {:error, :not_allowed} . Returns {:error, :not_found} if the local node is not alive.","ref":"Node.html#stop/0","source_doc":"Turns a distributed node into a non-distributed node.\n\nFor other nodes in the network, this is the same as the node going down.\nOnly possible when the node was started with `Node.start/3`, otherwise\nreturns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\nlocal node is not alive.\n","title":"Node.stop/0","type":"function"},{"doc":"","ref":"Node.html#t:state/0","source_doc":false,"title":"Node.state/0","type":"type"},{"doc":"","ref":"Node.html#t:t/0","source_doc":false,"title":"Node.t/0","type":"type"},{"doc":"A supervisor that starts multiple partitions of the same child. Certain processes may become bottlenecks in large systems. If those processes can have their state trivially partitioned, in a way there is no dependency between them, then they can use the PartitionSupervisor to create multiple isolated and independent partitions. Once the PartitionSupervisor starts, you can dispatch to its children using {:via, PartitionSupervisor, {name, key}} , where name is the name of the PartitionSupervisor and key is used for routing. Simple Example Let's start with an example which is not useful per se, but shows how the partitions are started and how messages are routed to them. Here's a toy GenServer that simply collects the messages it's given. It prints them for easy illustration. defmodule Collector do use GenServer def start_link ( args ) do GenServer . start_link ( __MODULE__ , args ) end def init ( args ) do IO . inspect [ __MODULE__ , &quot; got args &quot; , args , &quot; in &quot; , self ( ) ] { :ok , _initial_state = [ ] } end def collect ( server , msg ) do GenServer . call ( server , { :collect , msg } ) end def handle_call ( { :collect , msg } , _from , state ) do new_state = [ msg | state ] IO . inspect [ &quot;current messages:&quot; , new_state , &quot; in process&quot; , self ( ) ] { :reply , :ok , new_state } end end To run multiple of these, we can start them under a PartitionSupervisor by placing this in our supervision tree: { PartitionSupervisor , child_spec : Collector . child_spec ( [ some : :arg ] ) , name : MyApp.PartitionSupervisor } We can send messages to them using a &quot;via tuple&quot;: # The key is used to route our message to a particular instance. key = 1 Collector . collect ( { :via , PartitionSupervisor , { MyApp.PartitionSupervisor , key } } , :hi ) # [&quot;current messages:&quot;, [:hi], &quot; in process&quot;, #PID&lt;0.602.0&gt;] :ok Collector . collect ( { :via , PartitionSupervisor , { MyApp.PartitionSupervisor , key } } , :ho ) # [&quot;current messages:&quot;, [:ho, :hi], &quot; in process&quot;, #PID&lt;0.602.0&gt;] :ok # With a different key, the message will be routed to a different instance. key = 2 Collector . collect ( { :via , PartitionSupervisor , { MyApp.PartitionSupervisor , key } } , :a ) # [&quot;current messages:&quot;, [:a], &quot; in process&quot;, #PID&lt;0.603.0&gt;] :ok Collector . collect ( { :via , PartitionSupervisor , { MyApp.PartitionSupervisor , key } } , :b ) # [&quot;current messages:&quot;, [:b, :a], &quot; in process&quot;, #PID&lt;0.603.0&gt;] :ok Now let's move on to a useful example. DynamicSupervisor Example The DynamicSupervisor is a single process responsible for starting other processes. In some applications, the DynamicSupervisor may become a bottleneck. To address this, you can start multiple instances of the DynamicSupervisor through a PartitionSupervisor , and then pick a &quot;random&quot; instance to start the child on. Instead of starting a single DynamicSupervisor : children = [ { DynamicSupervisor , name : MyApp.DynamicSupervisor } ] Supervisor . start_link ( children , strategy : :one_for_one ) and starting children on that dynamic supervisor directly: DynamicSupervisor . start_child ( MyApp.DynamicSupervisor , { Agent , fn -&gt; %{ } end } ) You can do start the dynamic supervisors under a PartitionSupervisor : children = [ { PartitionSupervisor , child_spec : DynamicSupervisor , name : MyApp.DynamicSupervisors } ] Supervisor . start_link ( children , strategy : :one_for_one ) and then: DynamicSupervisor . start_child ( { :via , PartitionSupervisor , { MyApp.DynamicSupervisors , self ( ) } } , { Agent , fn -&gt; %{ } end } ) In the code above, we start a partition supervisor that will by default start a dynamic supervisor for each core in your machine. Then, instead of calling the DynamicSupervisor by name, you call it through the partition supervisor using the {:via, PartitionSupervisor, {name, key}} format. We picked self() as the routing key, which means each process will be assigned one of the existing dynamic supervisors. See start_link/1 to see all options supported by the PartitionSupervisor . Implementation notes The PartitionSupervisor uses either an ETS table or a Registry to manage all of the partitions. Under the hood, the PartitionSupervisor generates a child spec for each partition and then acts as a regular supervisor. The ID of each child spec is the partition number. For routing, two strategies are used. If key is an integer, it is routed using rem(abs(key), partitions) where partitions is the number of partitions. Otherwise it uses :erlang.phash2(key, partitions) . The particular routing may change in the future, and therefore must not be relied on. If you want to retrieve a particular PID for a certain key, you can use GenServer.whereis({:via, PartitionSupervisor, {name, key}}) .","ref":"PartitionSupervisor.html","source_doc":"A supervisor that starts multiple partitions of the same child.\n\nCertain processes may become bottlenecks in large systems.\nIf those processes can have their state trivially partitioned,\nin a way there is no dependency between them, then they can use\nthe `PartitionSupervisor` to create multiple isolated and\nindependent partitions.\n\nOnce the `PartitionSupervisor` starts, you can dispatch to its\nchildren using `{:via, PartitionSupervisor, {name, key}}`, where\n`name` is the name of the `PartitionSupervisor` and key is used\nfor routing.\n\n## Simple Example\n\nLet's start with an example which is not useful per se, but shows how the\npartitions are started and how messages are routed to them.\n\nHere's a toy GenServer that simply collects the messages it's given.\nIt prints them for easy illustration.\n\n    defmodule Collector do\n      use GenServer\n\n      def start_link(args) do\n        GenServer.start_link(__MODULE__, args)\n      end\n\n      def init(args) do\n        IO.inspect [__MODULE__, \" got args \", args, \" in \", self()]\n        {:ok, _initial_state = []}\n      end\n\n      def collect(server, msg) do\n        GenServer.call(server, {:collect, msg})\n      end\n\n      def handle_call({:collect, msg}, _from, state) do\n        new_state = [msg | state]\n        IO.inspect [\"current messages:\", new_state, \" in process\", self()]\n        {:reply, :ok, new_state}\n      end\n    end\n\nTo run multiple of these, we can start them under a `PartitionSupervisor` by placing\nthis in our supervision tree:\n\n    {PartitionSupervisor,\n      child_spec: Collector.child_spec([some: :arg]),\n      name: MyApp.PartitionSupervisor\n    }\n\nWe can send messages to them using a \"via tuple\":\n\n    # The key is used to route our message to a particular instance.\n    key = 1\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :hi)\n    # [\"current messages:\", [:hi], \" in process\", #PID<0.602.0>]\n    :ok\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :ho)\n    # [\"current messages:\", [:ho, :hi], \" in process\", #PID<0.602.0>]\n    :ok\n\n    # With a different key, the message will be routed to a different instance.\n    key = 2\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :a)\n    # [\"current messages:\", [:a], \" in process\", #PID<0.603.0>]\n    :ok\n    Collector.collect({:via, PartitionSupervisor, {MyApp.PartitionSupervisor, key}}, :b)\n    # [\"current messages:\", [:b, :a], \" in process\", #PID<0.603.0>]\n    :ok\n\nNow let's move on to a useful example.\n\n## `DynamicSupervisor` Example\n\nThe `DynamicSupervisor` is a single process responsible for starting\nother processes. In some applications, the `DynamicSupervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `DynamicSupervisor` through a `PartitionSupervisor`, and then\npick a \"random\" instance to start the child on.\n\nInstead of starting a single `DynamicSupervisor`:\n\n    children = [\n      {DynamicSupervisor, name: MyApp.DynamicSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand starting children on that dynamic supervisor directly:\n\n    DynamicSupervisor.start_child(MyApp.DynamicSupervisor, {Agent, fn -> %{} end})\n\nYou can do start the dynamic supervisors under a `PartitionSupervisor`:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: DynamicSupervisor,\n       name: MyApp.DynamicSupervisors}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nand then:\n\n    DynamicSupervisor.start_child(\n      {:via, PartitionSupervisor, {MyApp.DynamicSupervisors, self()}},\n      {Agent, fn -> %{} end}\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `DynamicSupervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat. We picked `self()` as the routing key, which means each process\nwill be assigned one of the existing dynamic supervisors. See `start_link/1`\nto see all options supported by the `PartitionSupervisor`.\n\n## Implementation notes\n\nThe `PartitionSupervisor` uses either an ETS table or a `Registry` to\nmanage all of the partitions. Under the hood, the `PartitionSupervisor`\ngenerates a child spec for each partition and then acts as a regular\nsupervisor. The ID of each child spec is the partition number.\n\nFor routing, two strategies are used. If `key` is an integer, it is routed\nusing `rem(abs(key), partitions)` where `partitions` is the number of\npartitions. Otherwise it uses `:erlang.phash2(key, partitions)`.\nThe particular routing may change in the future, and therefore must not\nbe relied on. If you want to retrieve a particular PID for a certain key,\nyou can use `GenServer.whereis({:via, PartitionSupervisor, {name, key}})`.\n","title":"PartitionSupervisor","type":"module"},{"doc":"Returns a map containing count values for the supervisor. The map contains the following keys: :specs - the number of partitions (children processes) :active - the count of all actively running child processes managed by this supervisor :supervisors - the count of all supervisors whether or not the child process is still alive :workers - the count of all workers, whether or not the child process is still alive","ref":"PartitionSupervisor.html#count_children/1","source_doc":"Returns a map containing count values for the supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the number of partitions (children processes)\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not the child\n    process is still alive\n\n  * `:workers` - the count of all workers, whether or not the child process\n    is still alive\n\n","title":"PartitionSupervisor.count_children/1","type":"function"},{"doc":"Returns the number of partitions for the partition supervisor.","ref":"PartitionSupervisor.html#partitions/1","source_doc":"Returns the number of partitions for the partition supervisor.\n","title":"PartitionSupervisor.partitions/1","type":"function"},{"doc":"Starts a partition supervisor with the given options. This function is typically not invoked directly, instead it is invoked when using a PartitionSupervisor as a child of another supervisor: children = [ { PartitionSupervisor , child_spec : SomeChild , name : MyPartitionSupervisor } ] If the supervisor is successfully spawned, this function returns {:ok, pid} , where pid is the PID of the supervisor. If the given name for the partition supervisor is already assigned to a process, the function returns {:error, {:already_started, pid}} , where pid is the PID of that process. Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with :normal reason. Options :name - an atom or via tuple representing the name of the partition supervisor (see name/0 ). :child_spec - the child spec to be used when starting the partitions. :partitions - a positive integer with the number of partitions. Defaults to System.schedulers_online() (typically the number of cores). :strategy - the restart strategy option, defaults to :one_for_one . You can learn more about strategies in the Supervisor module docs. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . :with_arguments - a two-argument anonymous function that allows the partition to be given to the child starting function. See the :with_arguments section below. :with_arguments Sometimes you want each partition to know their partition assigned number. This can be done with the :with_arguments option. This function receives the value of the :child_spec option and an integer for the partition number. It must return a new list of arguments that will be used to start the partition process. For example, most processes are started by calling start_link(opts) , where opts is a keyword list. You could inject the partition into the options given to the child: with_arguments : fn [ opts ] , partition -&gt; [ Keyword . put ( opts , :partition , partition ) ] end","ref":"PartitionSupervisor.html#start_link/1","source_doc":"Starts a partition supervisor with the given options.\n\nThis function is typically not invoked directly, instead it is invoked\nwhen using a `PartitionSupervisor` as a child of another supervisor:\n\n    children = [\n      {PartitionSupervisor, child_spec: SomeChild, name: MyPartitionSupervisor}\n    ]\n\nIf the supervisor is successfully spawned, this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the given name\nfor the partition supervisor is already assigned to a process,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n\n## Options\n\n  * `:name` - an atom or via tuple representing the name of the partition\n    supervisor (see `t:name/0`).\n\n  * `:child_spec` - the child spec to be used when starting the partitions.\n\n  * `:partitions` - a positive integer with the number of partitions.\n    Defaults to `System.schedulers_online()` (typically the number of cores).\n\n  * `:strategy` - the restart strategy option, defaults to `:one_for_one`.\n    You can learn more about strategies in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:with_arguments` - a two-argument anonymous function that allows\n    the partition to be given to the child starting function. See the\n    `:with_arguments` section below.\n\n## `:with_arguments`\n\nSometimes you want each partition to know their partition assigned number.\nThis can be done with the `:with_arguments` option. This function receives\nthe value of the `:child_spec` option and an integer for the partition\nnumber. It must return a new list of arguments that will be used to start the\npartition process.\n\nFor example, most processes are started by calling `start_link(opts)`,\nwhere `opts` is a keyword list. You could inject the partition into the\noptions given to the child:\n\n    with_arguments: fn [opts], partition ->\n      [Keyword.put(opts, :partition, partition)]\n    end\n\n","title":"PartitionSupervisor.start_link/1","type":"function"},{"doc":"Synchronously stops the given partition supervisor with the given reason . It returns :ok if the supervisor terminates with the given reason. If it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"PartitionSupervisor.html#stop/3","source_doc":"Synchronously stops the given partition supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n","title":"PartitionSupervisor.stop/3","type":"function"},{"doc":"Returns a list with information about all children. This function returns a list of tuples containing: id - the partition number child - the PID of the corresponding child process or the atom :restarting if the process is about to be restarted type - :worker or :supervisor as defined in the child specification modules - as defined in the child specification","ref":"PartitionSupervisor.html#which_children/1","source_doc":"Returns a list with information about all children.\n\nThis function returns a list of tuples containing:\n\n  * `id` - the partition number\n\n  * `child` - the PID of the corresponding child process or the\n    atom `:restarting` if the process is about to be restarted\n\n  * `type` - `:worker` or `:supervisor` as defined in the child\n    specification\n\n  * `modules` - as defined in the child specification\n\n","title":"PartitionSupervisor.which_children/1","type":"function"},{"doc":"The name of the PartitionSupervisor .","ref":"PartitionSupervisor.html#t:name/0","source_doc":"The name of the `PartitionSupervisor`.\n","title":"PartitionSupervisor.name/0","type":"type"},{"doc":"Conveniences for working with processes and the process dictionary. Besides the functions available in this module, the Kernel module exposes and auto-imports some basic functionality related to processes available through the following functions: Kernel.spawn/1 and Kernel.spawn/3 Kernel.spawn_link/1 and Kernel.spawn_link/3 Kernel.spawn_monitor/1 and Kernel.spawn_monitor/3 Kernel.self/0 Kernel.send/2 While this module provides low-level conveniences to work with processes, developers typically use abstractions such as Agent , GenServer , Registry , Supervisor and Task for building their systems and resort to this module for gathering information, trapping exits, links and monitoring. Aliases Aliases are a feature introduced in Erlang/OTP 24. An alias is a way to refer to a PID in order to send messages to it. The advantage of using aliases is that they can be deactivated even if the aliased process is still running. If you send a message to a deactivated alias, nothing will happen. This makes request/response scenarios easier to implement. You can use alias/0 or alias/1 to set an alias, and then you can send messages to that alias like you do with PIDs using send/2 . To deactivate an alias, you can use unalias/1 . If you send a message to a deactivated alias, nothing will happen. For example, you could have a process that listens for :ping messages: def server do receive do { :ping , source_alias } -&gt; send ( source_alias , :pong ) server ( ) end end Now, another process might ping this process: server = spawn ( &amp; server / 0 ) source_alias = Process . alias ( ) send ( server , { :ping , source_alias } ) receive do :pong -&gt; :pong end #=&gt; :pong If now you deactivate the source_alias and ping the server again, you won't receive any response since the server will send/2 the :pong response to a deactivated alias. Process . unalias ( source_alias ) send ( server , { :ping , source_alias } ) receive do :pong -&gt; :pong after 1000 -&gt; :timeout end #=&gt; :timeout See also the Process Aliases section of the Erlang reference manual .","ref":"Process.html","source_doc":"Conveniences for working with processes and the process dictionary.\n\nBesides the functions available in this module, the `Kernel` module\nexposes and auto-imports some basic functionality related to processes\navailable through the following functions:\n\n  * `Kernel.spawn/1` and `Kernel.spawn/3`\n  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n  * `Kernel.self/0`\n  * `Kernel.send/2`\n\nWhile this module provides low-level conveniences to work with processes,\ndevelopers typically use abstractions such as `Agent`, `GenServer`,\n`Registry`, `Supervisor` and `Task` for building their systems and\nresort to this module for gathering information, trapping exits, links\nand monitoring.\n\n## Aliases\n\nAliases are a feature introduced in Erlang/OTP 24. An alias is a way\nto refer to a PID in order to send messages to it. The advantage of using\naliases is that they can be deactivated even if the aliased process is still\nrunning. If you send a message to a deactivated alias, nothing will happen.\nThis makes request/response scenarios easier to implement.\n\nYou can use `alias/0` or `alias/1` to set an alias, and then you can send\nmessages to that alias like you do with PIDs using `send/2`. To deactivate\nan alias, you can use `unalias/1`. If you send a message to a deactivated alias,\nnothing will happen.\n\nFor example, you could have a process that listens for `:ping` messages:\n\n    def server do\n      receive do\n        {:ping, source_alias} ->\n          send(source_alias, :pong)\n          server()\n      end\n    end\n\nNow, another process might ping this process:\n\n    server = spawn(&server/0)\n\n    source_alias = Process.alias()\n    send(server, {:ping, source_alias})\n\n    receive do\n      :pong -> :pong\n    end\n    #=> :pong\n\nIf now you deactivate the `source_alias` and ping the server again, you\nwon't receive any response since the server will `send/2` the `:pong` response\nto a deactivated alias.\n\n    Process.unalias(source_alias)\n    send(server, {:ping, source_alias})\n\n    receive do\n      :pong -> :pong\n    after\n      1000 -> :timeout\n    end\n    #=> :timeout\n\nSee also the [Process Aliases\nsection](https://www.erlang.org/doc/reference_manual/processes.html#process-aliases)\nof the *Erlang reference manual*.\n","title":"Process","type":"module"},{"doc":"Creates a process alias. This is the same as calling alias/1 as alias([:explicit_unalias]) . See also :erlang.alias/0 . Inlined by the compiler. Examples alias = Process . alias ( )","ref":"Process.html#alias/0","source_doc":"Creates a process alias.\n\nThis is the same as calling `alias/1` as `alias([:explicit_unalias])`. See\nalso `:erlang.alias/0`.\n\nInlined by the compiler.\n\n## Examples\n\n    alias = Process.alias()\n\n","title":"Process.alias/0","type":"function"},{"doc":"Creates a process alias. See the module documentation for more information about aliases. See also :erlang.alias/1 . Inlined by the compiler. Examples alias = Process . alias ( [ :reply ] )","ref":"Process.html#alias/1","source_doc":"Creates a process alias.\n\nSee [the module documentation](#module-aliases) for more information about aliases.\nSee also `:erlang.alias/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    alias = Process.alias([:reply])\n\n","title":"Process.alias/1","type":"function"},{"doc":"Tells whether the given process is alive on the local node. If the process identified by pid is alive (that is, it's not exiting and has not exited yet) than this function returns true . Otherwise, it returns false . pid must refer to a process running on the local node or ArgumentError is raised. Inlined by the compiler.","ref":"Process.html#alive?/1","source_doc":"Tells whether the given process is alive on the local node.\n\nIf the process identified by `pid` is alive (that is, it's not exiting and has\nnot exited yet) than this function returns `true`. Otherwise, it returns\n`false`.\n\n`pid` must refer to a process running on the local node or `ArgumentError` is raised.\n\nInlined by the compiler.\n","title":"Process.alive?/1","type":"function"},{"doc":"Cancels a timer returned by send_after/3 . When the result is an integer, it represents the time in milliseconds left until the timer would have expired. When the result is false , a timer corresponding to timer_ref could not be found. This can happen either because the timer expired, because it has already been canceled, or because timer_ref never corresponded to a timer. Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet. Inlined by the compiler. Options :async - (boolean) when false , the request for cancellation is synchronous. When true , the request for cancellation is asynchronous, meaning that the request to cancel the timer is issued and :ok is returned right away. Defaults to false . :info - (boolean) whether to return information about the timer being cancelled. When the :async option is false and :info is true , then either an integer or false (like described above) is returned. If :async is false and :info is false , :ok is returned. If :async is true and :info is true , a message in the form {:cancel_timer, timer_ref, result} (where result is an integer or false like described above) is sent to the caller of this function when the cancellation has been performed. If :async is true and :info is false , no message is sent. Defaults to true .","ref":"Process.html#cancel_timer/2","source_doc":"Cancels a timer returned by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer would have expired.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can happen either because the timer expired, because it has\nalready been canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.\n\n## Options\n\n  * `:async` - (boolean) when `false`, the request for cancellation is\n    synchronous. When `true`, the request for cancellation is asynchronous,\n    meaning that the request to cancel the timer is issued and `:ok` is\n    returned right away. Defaults to `false`.\n\n  * `:info` - (boolean) whether to return information about the timer being\n    cancelled. When the `:async` option is `false` and `:info` is `true`, then\n    either an integer or `false` (like described above) is returned. If\n    `:async` is `false` and `:info` is `false`, `:ok` is returned. If `:async`\n    is `true` and `:info` is `true`, a message in the form `{:cancel_timer,\n    timer_ref, result}` (where `result` is an integer or `false` like\n    described above) is sent to the caller of this function when the\n    cancellation has been performed. If `:async` is `true` and `:info` is\n    `false`, no message is sent. Defaults to `true`.\n\n","title":"Process.cancel_timer/2","type":"function"},{"doc":"Deletes the given key from the process dictionary. Returns the value that was under key in the process dictionary, or nil if key was not stored in the process dictionary. Examples iex&gt; Process . put ( :comments , [ &quot;comment&quot; , &quot;other comment&quot; ] ) iex&gt; Process . delete ( :comments ) [ &quot;comment&quot; , &quot;other comment&quot; ] iex&gt; Process . delete ( :comments ) nil","ref":"Process.html#delete/1","source_doc":"Deletes the given `key` from the process dictionary.\n\nReturns the value that was under `key` in the process dictionary,\nor `nil` if `key` was not stored in the process dictionary.\n\n## Examples\n\n    iex> Process.put(:comments, [\"comment\", \"other comment\"])\n    iex> Process.delete(:comments)\n    [\"comment\", \"other comment\"]\n    iex> Process.delete(:comments)\n    nil\n\n","title":"Process.delete/1","type":"function"},{"doc":"Demonitors the monitor identified by the given reference . If monitor_ref is a reference which the calling process obtained by calling monitor/1 , that monitoring is turned off. If the monitoring is already turned off, nothing happens. See :erlang.demonitor/2 for more information. Inlined by the compiler. Examples pid = spawn ( fn -&gt; 1 + 2 end ) ref = Process . monitor ( pid ) Process . demonitor ( ref ) #=&gt; true","ref":"Process.html#demonitor/2","source_doc":"Demonitors the monitor identified by the given `reference`.\n\nIf `monitor_ref` is a reference which the calling process\nobtained by calling `monitor/1`, that monitoring is turned off.\nIf the monitoring is already turned off, nothing happens.\n\nSee `:erlang.demonitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    ref = Process.monitor(pid)\n    Process.demonitor(ref)\n    #=> true\n\n","title":"Process.demonitor/2","type":"function"},{"doc":"Sends an exit signal with the given reason to pid . The following behaviour applies if reason is any term except :normal or :kill : If pid is not trapping exits, pid will exit with the given reason . If pid is trapping exits, the exit signal is transformed into a message {:EXIT, from, reason} and delivered to the message queue of pid . If reason is the atom :normal , pid will not exit (unless pid is the calling process, in which case it will exit with the reason :normal ). If it is trapping exits, the exit signal is transformed into a message {:EXIT, from, :normal} and delivered to its message queue. If reason is the atom :kill , that is if Process.exit(pid, :kill) is called, an untrappable exit signal is sent to pid which will unconditionally exit with reason :killed . Inlined by the compiler. Examples Process . exit ( pid , :kill ) #=&gt; true","ref":"Process.html#exit/2","source_doc":"Sends an exit signal with the given `reason` to `pid`.\n\nThe following behaviour applies if `reason` is any term except `:normal`\nor `:kill`:\n\n  1. If `pid` is not trapping exits, `pid` will exit with the given\n     `reason`.\n\n  2. If `pid` is trapping exits, the exit signal is transformed into a\n     message `{:EXIT, from, reason}` and delivered to the message queue\n     of `pid`.\n\nIf `reason` is the atom `:normal`, `pid` will not exit (unless `pid` is\nthe calling process, in which case it will exit with the reason `:normal`).\nIf it is trapping exits, the exit signal is transformed into a message\n`{:EXIT, from, :normal}` and delivered to its message queue.\n\nIf `reason` is the atom `:kill`, that is if `Process.exit(pid, :kill)` is called,\nan untrappable exit signal is sent to `pid` which will unconditionally exit\nwith reason `:killed`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.exit(pid, :kill)\n    #=> true\n\n","title":"Process.exit/2","type":"function"},{"doc":"Sets the given flag to value for the calling process. Returns the old value of flag . See :erlang.process_flag/2 for more information. Inlined by the compiler.","ref":"Process.html#flag/2","source_doc":"Sets the given `flag` to `value` for the calling process.\n\nReturns the old value of `flag`.\n\nSee `:erlang.process_flag/2` for more information.\n\nInlined by the compiler.\n","title":"Process.flag/2","type":"function"},{"doc":"Sets the given flag to value for the given process pid . Returns the old value of flag . It raises ArgumentError if pid is not a local process. The allowed values for flag are only a subset of those allowed in flag/2 , namely :save_calls . See :erlang.process_flag/3 for more information. Inlined by the compiler.","ref":"Process.html#flag/3","source_doc":"Sets the given `flag` to `value` for the given process `pid`.\n\nReturns the old value of `flag`.\n\nIt raises `ArgumentError` if `pid` is not a local process.\n\nThe allowed values for `flag` are only a subset of those allowed in `flag/2`,\nnamely `:save_calls`.\n\nSee `:erlang.process_flag/3` for more information.\n\nInlined by the compiler.\n","title":"Process.flag/3","type":"function"},{"doc":"Returns all key-value pairs in the process dictionary. Inlined by the compiler.","ref":"Process.html#get/0","source_doc":"Returns all key-value pairs in the process dictionary.\n\nInlined by the compiler.\n","title":"Process.get/0","type":"function"},{"doc":"Returns the value for the given key in the process dictionary, or default if key is not set. Examples # Assuming :locale was not set iex&gt; Process . get ( :locale , &quot;pt&quot; ) &quot;pt&quot; iex&gt; Process . put ( :locale , &quot;fr&quot; ) nil iex&gt; Process . get ( :locale , &quot;pt&quot; ) &quot;fr&quot;","ref":"Process.html#get/2","source_doc":"Returns the value for the given `key` in the process dictionary,\nor `default` if `key` is not set.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.get(:locale, \"pt\")\n    \"pt\"\n    iex> Process.put(:locale, \"fr\")\n    nil\n    iex> Process.get(:locale, \"pt\")\n    \"fr\"\n\n","title":"Process.get/2","type":"function"},{"doc":"Returns all keys in the process dictionary. Inlined by the compiler. Examples # Assuming :locale was not set iex&gt; :locale in Process . get_keys ( ) false iex&gt; Process . put ( :locale , &quot;pt&quot; ) nil iex&gt; :locale in Process . get_keys ( ) true","ref":"Process.html#get_keys/0","source_doc":"Returns all keys in the process dictionary.\n\nInlined by the compiler.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> :locale in Process.get_keys()\n    false\n    iex> Process.put(:locale, \"pt\")\n    nil\n    iex> :locale in Process.get_keys()\n    true\n\n","title":"Process.get_keys/0","type":"function"},{"doc":"Returns all keys in the process dictionary that have the given value . Inlined by the compiler.","ref":"Process.html#get_keys/1","source_doc":"Returns all keys in the process dictionary that have the given `value`.\n\nInlined by the compiler.\n","title":"Process.get_keys/1","type":"function"},{"doc":"Returns the PID of the group leader for the calling process. Inlined by the compiler. Examples Process . group_leader ( ) #=&gt; #PID&lt;0.53.0&gt;","ref":"Process.html#group_leader/0","source_doc":"Returns the PID of the group leader for the calling process.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.group_leader()\n    #=> #PID<0.53.0>\n\n","title":"Process.group_leader/0","type":"function"},{"doc":"Sets the group leader of the given pid to leader . Typically, this is used when a process started from a certain shell should have a group leader other than :init . Inlined by the compiler.","ref":"Process.html#group_leader/2","source_doc":"Sets the group leader of the given `pid` to `leader`.\n\nTypically, this is used when a process started from a certain shell should\nhave a group leader other than `:init`.\n\nInlined by the compiler.\n","title":"Process.group_leader/2","type":"function"},{"doc":"Puts the calling process into a &quot;hibernation&quot; state. The calling process is put into a waiting state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future. See :erlang.hibernate/3 for more information. Inlined by the compiler.","ref":"Process.html#hibernate/3","source_doc":"Puts the calling process into a \"hibernation\" state.\n\nThe calling process is put into a waiting state\nwhere its memory allocation has been reduced as much as possible,\nwhich is useful if the process does not expect to receive any messages\nin the near future.\n\nSee `:erlang.hibernate/3` for more information.\n\nInlined by the compiler.\n","title":"Process.hibernate/3","type":"function"},{"doc":"Returns information about the process identified by pid , or returns nil if the process is not alive. Use this only for debugging information. See :erlang.process_info/1 for more information.","ref":"Process.html#info/1","source_doc":"Returns information about the process identified by `pid`, or returns `nil` if the process\nis not alive.\n\nUse this only for debugging information.\n\nSee `:erlang.process_info/1` for more information.\n","title":"Process.info/1","type":"function"},{"doc":"Returns information about the process identified by pid , or returns nil if the process is not alive. See :erlang.process_info/2 for more information.","ref":"Process.html#info/2","source_doc":"Returns information about the process identified by `pid`,\nor returns `nil` if the process is not alive.\n\nSee `:erlang.process_info/2` for more information.\n","title":"Process.info/2","type":"function"},{"doc":"Creates a link between the calling process and the given item (process or port). Links are bidirectional. Linked processes can be unlinked by using unlink/1 . If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen. When two processes are linked, each one receives exit signals from the other (see also exit/2 ). Let's assume pid1 and pid2 are linked. If pid2 exits with a reason other than :normal (which is also the exit reason used when a process finishes its job) and pid1 is not trapping exits (see flag/2 ), then pid1 will exit with the same reason as pid2 and in turn emit an exit signal to all its other linked processes. The behaviour when pid1 is trapping exits is described in exit/2 . See :erlang.link/1 for more information. Inlined by the compiler.","ref":"Process.html#link/1","source_doc":"Creates a link between the calling process and the given item (process or\nport).\n\nLinks are bidirectional. Linked processes can be unlinked by using `unlink/1`.\n\nIf such a link exists already, this function does nothing since there can only\nbe one link between two given processes. If a process tries to create a link\nto itself, nothing will happen.\n\nWhen two processes are linked, each one receives exit signals from the other\n(see also `exit/2`). Let's assume `pid1` and `pid2` are linked. If `pid2`\nexits with a reason other than `:normal` (which is also the exit reason used\nwhen a process finishes its job) and `pid1` is not trapping exits (see\n`flag/2`), then `pid1` will exit with the same reason as `pid2` and in turn\nemit an exit signal to all its other linked processes. The behaviour when\n`pid1` is trapping exits is described in `exit/2`.\n\nSee `:erlang.link/1` for more information.\n\nInlined by the compiler.\n","title":"Process.link/1","type":"function"},{"doc":"Returns a list of PIDs corresponding to all the processes currently existing on the local node. Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, alive?/1 will return false but its PID will be part of the list of PIDs returned by this function. See :erlang.processes/0 for more information. Inlined by the compiler. Examples Process . list ( ) #=&gt; [#PID&lt;0.0.0&gt;, #PID&lt;0.1.0&gt;, #PID&lt;0.2.0&gt;, #PID&lt;0.3.0&gt;, ...]","ref":"Process.html#list/0","source_doc":"Returns a list of PIDs corresponding to all the\nprocesses currently existing on the local node.\n\nNote that if a process is exiting, it is considered to exist but not be\nalive. This means that for such process, `alive?/1` will return `false` but\nits PID will be part of the list of PIDs returned by this function.\n\nSee `:erlang.processes/0` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.list()\n    #=> [#PID<0.0.0>, #PID<0.1.0>, #PID<0.2.0>, #PID<0.3.0>, ...]\n\n","title":"Process.list/0","type":"function"},{"doc":"Starts monitoring the given item from the calling process. Once the monitored process dies, a message is delivered to the monitoring process in the shape of: { :DOWN , ref , :process , object , reason } where: ref is a monitor reference returned by this function; object is either a pid of the monitored process (if monitoring a PID) or {name, node} (if monitoring a remote or local name); reason is the exit reason. If the process is already dead when calling Process.monitor/1 , a :DOWN message is delivered immediately. See &quot;The need for monitoring&quot; for an example. See :erlang.monitor/2 for more information. Inlined by the compiler. Examples pid = spawn ( fn -&gt; 1 + 2 end ) #=&gt; #PID&lt;0.118.0&gt; Process . monitor ( pid ) #=&gt; #Reference&lt;0.906660723.3006791681.40191&gt; Process . exit ( pid , :kill ) #=&gt; true receive do msg -&gt; msg end #=&gt; {:DOWN, #Reference&lt;0.906660723.3006791681.40191&gt;, :process, #PID&lt;0.118.0&gt;, :noproc}","ref":"Process.html#monitor/1","source_doc":"Starts monitoring the given `item` from the calling process.\n\nOnce the monitored process dies, a message is delivered to the\nmonitoring process in the shape of:\n\n    {:DOWN, ref, :process, object, reason}\n\nwhere:\n\n  * `ref` is a monitor reference returned by this function;\n  * `object` is either a `pid` of the monitored process (if monitoring\n    a PID) or `{name, node}` (if monitoring a remote or local name);\n  * `reason` is the exit reason.\n\nIf the process is already dead when calling `Process.monitor/1`, a\n`:DOWN` message is delivered immediately.\n\nSee [\"The need for monitoring\"](https://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring)\nfor an example. See `:erlang.monitor/2` for more information.\n\nInlined by the compiler.\n\n## Examples\n\n    pid = spawn(fn -> 1 + 2 end)\n    #=> #PID<0.118.0>\n    Process.monitor(pid)\n    #=> #Reference<0.906660723.3006791681.40191>\n    Process.exit(pid, :kill)\n    #=> true\n    receive do\n      msg -> msg\n    end\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}\n\n","title":"Process.monitor/1","type":"function"},{"doc":"Starts monitoring the given item from the calling process. This function is similar to monitor/1 , but accepts options to customize how item is monitored. See :erlang.monitor/3 for documentation on those options. Inlined by the compiler. Examples pid = spawn ( fn -&gt; receive do { :ping , source_alias } -&gt; send ( source_alias , :pong ) end end ) #=&gt; #PID&lt;0.118.0&gt; ref_and_alias = Process . monitor ( pid , alias : :reply_demonitor ) #=&gt; #Reference&lt;0.906660723.3006791681.40191&gt; send ( pid , { :ping , ref_and_alias } ) receive do : msg -&gt; msg #=&gt; :pong receive do : msg -&gt; msg #=&gt; {:DOWN, #Reference&lt;0.906660723.3006791681.40191&gt;, :process, #PID&lt;0.118.0&gt;, :noproc}","ref":"Process.html#monitor/2","source_doc":"Starts monitoring the given `item` from the calling process.\n\nThis function is similar to `monitor/1`, but accepts options to customize how\n`item` is monitored. See `:erlang.monitor/3` for documentation on those\noptions.\n\nInlined by the compiler.\n\n## Examples\n\n    pid =\n      spawn(fn ->\n        receive do\n          {:ping, source_alias} -> send(source_alias, :pong)\n        end\n      end)\n    #=> #PID<0.118.0>\n\n    ref_and_alias = Process.monitor(pid, alias: :reply_demonitor)\n    #=> #Reference<0.906660723.3006791681.40191>\n\n    send(pid, {:ping, ref_and_alias})\n\n    receive do: msg -> msg\n    #=> :pong\n\n    receive do: msg -> msg\n    #=> {:DOWN, #Reference<0.906660723.3006791681.40191>, :process, #PID<0.118.0>, :noproc}\n\n","title":"Process.monitor/2","type":"function"},{"doc":"Stores the given key - value pair in the process dictionary. The return value of this function is the value that was previously stored under key , or nil in case no value was stored under it. Examples # Assuming :locale was not set iex&gt; Process . put ( :locale , &quot;en&quot; ) nil iex&gt; Process . put ( :locale , &quot;fr&quot; ) &quot;en&quot;","ref":"Process.html#put/2","source_doc":"Stores the given `key`-`value` pair in the process dictionary.\n\nThe return value of this function is the value that was previously stored\nunder `key`, or `nil` in case no value was stored under it.\n\n## Examples\n\n    # Assuming :locale was not set\n    iex> Process.put(:locale, \"en\")\n    nil\n    iex> Process.put(:locale, \"fr\")\n    \"en\"\n\n","title":"Process.put/2","type":"function"},{"doc":"Reads a timer created by send_after/3 . When the result is an integer, it represents the time in milliseconds left until the timer will expire. When the result is false , a timer corresponding to timer_ref could not be found. This can be either because the timer expired, because it has already been canceled, or because timer_ref never corresponded to a timer. Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet. Inlined by the compiler.","ref":"Process.html#read_timer/1","source_doc":"Reads a timer created by `send_after/3`.\n\nWhen the result is an integer, it represents the time in milliseconds\nleft until the timer will expire.\n\nWhen the result is `false`, a timer corresponding to `timer_ref` could not be\nfound. This can be either because the timer expired, because it has already\nbeen canceled, or because `timer_ref` never corresponded to a timer.\n\nEven if the timer had expired and the message was sent, this function does not\ntell you if the timeout message has arrived at its destination yet.\n\nInlined by the compiler.\n","title":"Process.read_timer/1","type":"function"},{"doc":"Registers the given pid_or_port under the given name . name must be an atom and can then be used instead of the PID/port identifier when sending messages with Kernel.send/2 . register/2 will fail with ArgumentError in any of the following cases: the PID/Port is not existing locally and alive the name is already registered the pid_or_port is already registered under a different name The following names are reserved and cannot be assigned to processes nor ports: nil false true :undefined Examples Process . register ( self ( ) , :test ) #=&gt; true send ( :test , :hello ) #=&gt; :hello send ( :wrong_name , :hello ) ** (ArgumentError) argument error","ref":"Process.html#register/2","source_doc":"Registers the given `pid_or_port` under the given `name`.\n\n`name` must be an atom and can then be used instead of the\nPID/port identifier when sending messages with `Kernel.send/2`.\n\n`register/2` will fail with `ArgumentError` in any of the following cases:\n\n  * the PID/Port is not existing locally and alive\n  * the name is already registered\n  * the `pid_or_port` is already registered under a different `name`\n\nThe following names are reserved and cannot be assigned to\nprocesses nor ports:\n\n  * `nil`\n  * `false`\n  * `true`\n  * `:undefined`\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    send(:test, :hello)\n    #=> :hello\n    send(:wrong_name, :hello)\n    ** (ArgumentError) argument error\n\n","title":"Process.register/2","type":"function"},{"doc":"Returns a list of names which have been registered using register/2 . Inlined by the compiler. Examples Process . register ( self ( ) , :test ) Process . registered ( ) #=&gt; [:test, :elixir_config, :inet_db, ...]","ref":"Process.html#registered/0","source_doc":"Returns a list of names which have been registered using `register/2`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.registered()\n    #=> [:test, :elixir_config, :inet_db, ...]\n\n","title":"Process.registered/0","type":"function"},{"doc":"Sends a message to the given dest . dest may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node. Inlined by the compiler. Options :noconnect - when used, if sending the message would require an auto-connection to another node the message is not sent and :noconnect is returned. :nosuspend - when used, if sending the message would cause the sender to be suspended the message is not sent and :nosuspend is returned. Otherwise the message is sent and :ok is returned. Examples iex&gt; Process . send ( { :name , :node_that_does_not_exist } , :hi , [ :noconnect ] ) :noconnect","ref":"Process.html#send/3","source_doc":"Sends a message to the given `dest`.\n\n`dest` may be a remote or local PID, a local port, a locally\nregistered name, or a tuple in the form of `{registered_name, node}` for a\nregistered name at another node.\n\nInlined by the compiler.\n\n## Options\n\n  * `:noconnect` - when used, if sending the message would require an\n    auto-connection to another node the message is not sent and `:noconnect` is\n    returned.\n\n  * `:nosuspend` - when used, if sending the message would cause the sender to\n    be suspended the message is not sent and `:nosuspend` is returned.\n\nOtherwise the message is sent and `:ok` is returned.\n\n## Examples\n\n    iex> Process.send({:name, :node_that_does_not_exist}, :hi, [:noconnect])\n    :noconnect\n\n","title":"Process.send/3","type":"function"},{"doc":"Sends msg to dest after time milliseconds. If dest is a PID, it must be the PID of a local process, dead or alive. If dest is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process. The message is not sent immediately. Therefore, dest can receive other messages in-between even when time is 0 . This function returns a timer reference, which can be read with read_timer/1 or canceled with cancel_timer/1 . The timer will be automatically canceled if the given dest is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when dest is an atom (as the atom resolution is done on delivery). Inlined by the compiler. Options :abs - (boolean) when false , time is treated as relative to the current monotonic time. When true , time is the absolute value of the Erlang monotonic time at which msg should be delivered to dest . To read more about Erlang monotonic time and other time-related concepts, look at the documentation for the System module. Defaults to false . Examples timer_ref = Process . send_after ( pid , :hi , 1000 )","ref":"Process.html#send_after/4","source_doc":"Sends `msg` to `dest` after `time` milliseconds.\n\nIf `dest` is a PID, it must be the PID of a local process, dead or alive.\nIf `dest` is an atom, it must be the name of a registered process\nwhich is looked up at the time of delivery. No error is produced if the name does\nnot refer to a process.\n\nThe message is not sent immediately. Therefore, `dest` can receive other messages\nin-between even when `time` is `0`.\n\nThis function returns a timer reference, which can be read with `read_timer/1`\nor canceled with `cancel_timer/1`.\n\nThe timer will be automatically canceled if the given `dest` is a PID\nwhich is not alive or when the given PID exits. Note that timers will not be\nautomatically canceled when `dest` is an atom (as the atom resolution is done\non delivery).\n\nInlined by the compiler.\n\n## Options\n\n  * `:abs` - (boolean) when `false`, `time` is treated as relative to the\n  current monotonic time. When `true`, `time` is the absolute value of the\n  Erlang monotonic time at which `msg` should be delivered to `dest`.\n  To read more about Erlang monotonic time and other time-related concepts,\n  look at the documentation for the `System` module. Defaults to `false`.\n\n## Examples\n\n    timer_ref = Process.send_after(pid, :hi, 1000)\n\n","title":"Process.send_after/4","type":"function"},{"doc":"Sleeps the current process for the given timeout . timeout is either the number of milliseconds to sleep as an integer or the atom :infinity . When :infinity is given, the current process will sleep forever, and not consume or reply to messages. Use this function with extreme care . For almost all situations where you would use sleep/1 in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing. For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages. In other words, do not : Task . start_link ( fn -&gt; do_something ( ) ... end ) # Wait until work is done Process . sleep ( 2000 ) But do : parent = self ( ) Task . start_link ( fn -&gt; do_something ( ) send ( parent , :work_is_done ) ... end ) receive do :work_is_done -&gt; :ok after # Optional timeout 30_000 -&gt; :timeout end For cases like the one above, Task.async/1 and Task.await/2 are preferred. Similarly, if you are waiting for a process to terminate, monitor that process instead of sleeping. Do not : Task . start_link ( fn -&gt; ... end ) # Wait until task terminates Process . sleep ( 2000 ) Instead do : { :ok , pid } = Task . start_link ( fn -&gt; ... end ) ref = Process . monitor ( pid ) receive do { :DOWN , ^ ref , _ , _ , _ } -&gt; :task_is_down after # Optional timeout 30_000 -&gt; :timeout end","ref":"Process.html#sleep/1","source_doc":"Sleeps the current process for the given `timeout`.\n\n`timeout` is either the number of milliseconds to sleep as an\ninteger or the atom `:infinity`. When `:infinity` is given,\nthe current process will sleep forever, and not\nconsume or reply to messages.\n\n**Use this function with extreme care**. For almost all situations\nwhere you would use `sleep/1` in Elixir, there is likely a\nmore correct, faster and precise way of achieving the same with\nmessage passing.\n\nFor example, if you are waiting for a process to perform some\naction, it is better to communicate the progress of such action\nwith messages.\n\nIn other words, **do not**:\n\n    Task.start_link(fn ->\n      do_something()\n      ...\n    end)\n\n    # Wait until work is done\n    Process.sleep(2000)\n\nBut **do**:\n\n    parent = self()\n\n    Task.start_link(fn ->\n      do_something()\n      send(parent, :work_is_done)\n      ...\n    end)\n\n    receive do\n      :work_is_done -> :ok\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\nFor cases like the one above, `Task.async/1` and `Task.await/2` are\npreferred.\n\nSimilarly, if you are waiting for a process to terminate,\nmonitor that process instead of sleeping. **Do not**:\n\n    Task.start_link(fn ->\n      ...\n    end)\n\n    # Wait until task terminates\n    Process.sleep(2000)\n\nInstead **do**:\n\n    {:ok, pid} =\n      Task.start_link(fn ->\n        ...\n      end)\n\n    ref = Process.monitor(pid)\n\n    receive do\n      {:DOWN, ^ref, _, _, _} -> :task_is_down\n    after\n      # Optional timeout\n      30_000 -> :timeout\n    end\n\n","title":"Process.sleep/1","type":"function"},{"doc":"Spawns the given function according to the given options. The result depends on the given options. In particular, if :monitor is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID. More options are available; for the comprehensive list of available options check :erlang.spawn_opt/4 . Inlined by the compiler. Examples Process . spawn ( fn -&gt; 1 + 2 end , [ :monitor ] ) #=&gt; {#PID&lt;0.93.0&gt;, #Reference&lt;0.18808174.1939079169.202418&gt;} Process . spawn ( fn -&gt; 1 + 2 end , [ :link ] ) #=&gt; #PID&lt;0.95.0&gt;","ref":"Process.html#spawn/2","source_doc":"Spawns the given function according to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nMore options are available; for the comprehensive list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.spawn(fn -> 1 + 2 end, [:monitor])\n    #=> {#PID<0.93.0>, #Reference<0.18808174.1939079169.202418>}\n    Process.spawn(fn -> 1 + 2 end, [:link])\n    #=> #PID<0.95.0>\n\n","title":"Process.spawn/2","type":"function"},{"doc":"Spawns the given function fun from module mod , passing the given args according to the given options. The result depends on the given options. In particular, if :monitor is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID. It also accepts extra options, for the list of available options check :erlang.spawn_opt/4 . Inlined by the compiler.","ref":"Process.html#spawn/4","source_doc":"Spawns the given function `fun` from module `mod`, passing the given `args`\naccording to the given options.\n\nThe result depends on the given options. In particular,\nif `:monitor` is given as an option, it will return a tuple\ncontaining the PID and the monitoring reference, otherwise\njust the spawned process PID.\n\nIt also accepts extra options, for the list of available options\ncheck `:erlang.spawn_opt/4`.\n\nInlined by the compiler.\n","title":"Process.spawn/4","type":"function"},{"doc":"Explicitly deactivates a process alias. Returns true if alias was a currently-active alias for current processes, or false otherwise. See the module documentation for more information about aliases. See also :erlang.unalias/1 . Inlined by the compiler. Examples alias = Process . alias ( ) Process . unalias ( alias ) #=&gt; true","ref":"Process.html#unalias/1","source_doc":"Explicitly deactivates a process alias.\n\nReturns `true` if `alias` was a currently-active alias for current processes,\nor `false` otherwise.\n\nSee [the module documentation](#module-aliases) for more information about aliases.\nSee also `:erlang.unalias/1`.\n\nInlined by the compiler.\n\n## Examples\n\n    alias = Process.alias()\n    Process.unalias(alias)\n    #=> true\n\n","title":"Process.unalias/1","type":"function"},{"doc":"Removes the link between the calling process and the given item (process or port). If there is no such link, this function does nothing. If pid_or_port does not exist, this function does not produce any errors and simply does nothing. The return value of this function is always true . See :erlang.unlink/1 for more information. Inlined by the compiler.","ref":"Process.html#unlink/1","source_doc":"Removes the link between the calling process and the given item (process or\nport).\n\nIf there is no such link, this function does nothing. If `pid_or_port` does\nnot exist, this function does not produce any errors and simply does nothing.\n\nThe return value of this function is always `true`.\n\nSee `:erlang.unlink/1` for more information.\n\nInlined by the compiler.\n","title":"Process.unlink/1","type":"function"},{"doc":"Removes the registered name , associated with a PID or a port identifier. Fails with ArgumentError if the name is not registered to any PID or port. Inlined by the compiler. Examples Process . register ( self ( ) , :test ) #=&gt; true Process . unregister ( :test ) #=&gt; true Process . unregister ( :wrong_name ) ** (ArgumentError) argument error","ref":"Process.html#unregister/1","source_doc":"Removes the registered `name`, associated with a PID\nor a port identifier.\n\nFails with `ArgumentError` if the name is not registered\nto any PID or port.\n\nInlined by the compiler.\n\n## Examples\n\n    Process.register(self(), :test)\n    #=> true\n    Process.unregister(:test)\n    #=> true\n    Process.unregister(:wrong_name)\n    ** (ArgumentError) argument error\n\n","title":"Process.unregister/1","type":"function"},{"doc":"Returns the PID or port identifier registered under name or nil if the name is not registered. See :erlang.whereis/1 for more information. Examples Process . register ( self ( ) , :test ) Process . whereis ( :test ) #=&gt; #PID&lt;0.84.0&gt; Process . whereis ( :wrong_name ) #=&gt; nil","ref":"Process.html#whereis/1","source_doc":"Returns the PID or port identifier registered under `name` or `nil` if the\nname is not registered.\n\nSee `:erlang.whereis/1` for more information.\n\n## Examples\n\n    Process.register(self(), :test)\n    Process.whereis(:test)\n    #=> #PID<0.84.0>\n    Process.whereis(:wrong_name)\n    #=> nil\n\n","title":"Process.whereis/1","type":"function"},{"doc":"An alias returned by alias/0 or alias/1 . See the module documentation for more information about aliases.","ref":"Process.html#t:alias/0","source_doc":"An alias returned by `alias/0` or `alias/1`.\n\nSee [the module documentation](#module-aliases) for more information about aliases.\n","title":"Process.alias/0","type":"type"},{"doc":"","ref":"Process.html#t:alias_opt/0","source_doc":false,"title":"Process.alias_opt/0","type":"type"},{"doc":"A process destination. A remote or local PID, a local port, a locally registered name, or a tuple in the form of {registered_name, node} for a registered name at another node.","ref":"Process.html#t:dest/0","source_doc":"A process destination.\n\nA remote or local PID, a local port, a locally registered name, or a tuple in\nthe form of `{registered_name, node}` for a registered name at another node.\n","title":"Process.dest/0","type":"type"},{"doc":"","ref":"Process.html#t:spawn_opt/0","source_doc":false,"title":"Process.spawn_opt/0","type":"type"},{"doc":"","ref":"Process.html#t:spawn_opts/0","source_doc":false,"title":"Process.spawn_opts/0","type":"type"},{"doc":"A local, decentralized and scalable key-value process storage. It allows developers to lookup one or more processes with a given key. If the registry has :unique keys, a key points to 0 or 1 process. If the registry allows :duplicate keys, a single key may point to any number of processes. In both cases, different keys could identify the same process. Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation ( ===/2 ). The registry can be used for different purposes, such as name lookups (using the :via option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below. The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries. Using in :via Once the registry is started with a given name using Registry.start_link/1 , it can be used to register and access named processes using the {:via, Registry, {registry, key}} tuple: { :ok , _ } = Registry . start_link ( keys : :unique , name : Registry.ViaTest ) name = { :via , Registry , { Registry.ViaTest , &quot;agent&quot; } } { :ok , _ } = Agent . start_link ( fn -&gt; 0 end , name : name ) Agent . get ( name , &amp; &amp;1 ) #=&gt; 0 Agent . update ( name , &amp; ( &amp;1 + 1 ) ) Agent . get ( name , &amp; &amp;1 ) #=&gt; 1 In the previous example, we were not interested in associating a value to the process: Registry . lookup ( Registry.ViaTest , &quot;agent&quot; ) #=&gt; [{self(), nil}] However, in some cases it may be desired to associate a value to the process using the alternate {:via, Registry, {registry, key, value}} tuple: { :ok , _ } = Registry . start_link ( keys : :unique , name : Registry.ViaTest ) name = { :via , Registry , { Registry.ViaTest , &quot;agent&quot; , :hello } } { :ok , agent_pid } = Agent . start_link ( fn -&gt; 0 end , name : name ) Registry . lookup ( Registry.ViaTest , &quot;agent&quot; ) #=&gt; [{agent_pid, :hello}] To this point, we have been starting Registry using start_link/1 . Typically the registry is started as part of a supervision tree though: { Registry , keys : :unique , name : Registry.ViaTest } Only registries with unique keys can be used in :via . If the name is already taken, the case-specific start_link function ( Agent.start_link/2 in the example above) will return {:error, {:already_started, current_pid}} . Using as a dispatcher Registry has a dispatch mechanism that allows developers to implement custom dispatch logic triggered from the caller. For example, let's say we have a duplicate registry started as so: { :ok , _ } = Registry . start_link ( keys : :duplicate , name : Registry.DispatcherTest ) By calling register/3 , different processes can register under a given key and associate any value under that key. In this case, let's register the current process under the key &quot;hello&quot; and attach the {IO, :inspect} tuple to it: { :ok , _ } = Registry . register ( Registry.DispatcherTest , &quot;hello&quot; , { IO , :inspect } ) Now, an entity interested in dispatching events for a given key may call dispatch/3 passing in the key and a callback. This callback will be invoked with a list of all the values registered under the requested key, alongside the PID of the process that registered each value, in the form of {pid, value} tuples. In our example, value will be the {module, function} tuple in the code above: Registry . dispatch ( Registry.DispatcherTest , &quot;hello&quot; , fn entries -&gt; for { pid , { module , function } } &lt;- entries , do : apply ( module , function , [ pid ] ) end ) # Prints #PID&lt;...&gt; where the PID is for the process that called register/3 above #=&gt; :ok Dispatching happens in the process that calls dispatch/3 either serially or concurrently in case of multiple partitions (via spawned tasks). The registered processes are not involved in dispatching unless involving them is done explicitly (for example, by sending them a message in the callback). Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors: require Logger Registry . dispatch ( Registry.DispatcherTest , &quot;hello&quot; , fn entries -&gt; for { pid , { module , function } } &lt;- entries do try do apply ( module , function , [ pid ] ) catch kind , reason -&gt; formatted = Exception . format ( kind , reason , __STACKTRACE__ ) Logger . error ( &quot;Registry.dispatch/3 failed with \#{ formatted } &quot; ) end end end ) # Prints #PID&lt;...&gt; #=&gt; :ok You could also replace the whole apply system by explicitly sending messages. That's the example we will see next. Using as a PubSub Registries can also be used to implement a local, non-distributed, scalable PubSub by relying on the dispatch/3 function, similarly to the previous section: in this case, however, we will send messages to each associated process, instead of invoking a given module-function. In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments: { :ok , _ } = Registry . start_link ( keys : :duplicate , name : Registry.PubSubTest , partitions : System . schedulers_online ( ) ) { :ok , _ } = Registry . register ( Registry.PubSubTest , &quot;hello&quot; , [ ] ) Registry . dispatch ( Registry.PubSubTest , &quot;hello&quot; , fn entries -&gt; for { pid , _ } &lt;- entries , do : send ( pid , { :broadcast , &quot;world&quot; } ) end ) #=&gt; :ok The example above broadcasted the message {:broadcast, &quot;world&quot;} to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &quot;hello&quot; . The third argument given to register/3 is a value associated to the current process. While in the previous section we used it when dispatching, in this particular example we are not interested in it, so we have set it to an empty list. You could store a more meaningful value if necessary. Registrations Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation. However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as Process.monitor/1 which will deliver the :DOWN message immediately if the monitored process is already dead and send/2 which acts as a no-op for dead processes. ETS Note that the registry uses one ETS table plus two ETS tables per partition.","ref":"Registry.html","source_doc":"A local, decentralized and scalable key-value process storage.\n\nIt allows developers to lookup one or more processes with a given key.\nIf the registry has `:unique` keys, a key points to 0 or 1 process.\nIf the registry allows `:duplicate` keys, a single key may point to any\nnumber of processes. In both cases, different keys could identify the\nsame process.\n\nEach entry in the registry is associated to the process that has\nregistered the key. If the process crashes, the keys associated to that\nprocess are automatically removed. All key comparisons in the registry\nare done using the match operation (`===/2`).\n\nThe registry can be used for different purposes, such as name lookups (using\nthe `:via` option), storing properties, custom dispatching rules, or a pubsub\nimplementation. We explore some of those use cases below.\n\nThe registry may also be transparently partitioned, which provides\nmore scalable behaviour for running registries on highly concurrent\nenvironments with thousands or millions of entries.\n\n## Using in `:via`\n\nOnce the registry is started with a given name using\n`Registry.start_link/1`, it can be used to register and access named\nprocesses using the `{:via, Registry, {registry, key}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: Registry.ViaTest)\n    name = {:via, Registry, {Registry.ViaTest, \"agent\"}}\n    {:ok, _} = Agent.start_link(fn -> 0 end, name: name)\n    Agent.get(name, & &1)\n    #=> 0\n    Agent.update(name, &(&1 + 1))\n    Agent.get(name, & &1)\n    #=> 1\n\nIn the previous example, we were not interested in associating a value to the\nprocess:\n\n    Registry.lookup(Registry.ViaTest, \"agent\")\n    #=> [{self(), nil}]\n\nHowever, in some cases it may be desired to associate a value to the process\nusing the alternate `{:via, Registry, {registry, key, value}}` tuple:\n\n    {:ok, _} = Registry.start_link(keys: :unique, name: Registry.ViaTest)\n    name = {:via, Registry, {Registry.ViaTest, \"agent\", :hello}}\n    {:ok, agent_pid} = Agent.start_link(fn -> 0 end, name: name)\n    Registry.lookup(Registry.ViaTest, \"agent\")\n    #=> [{agent_pid, :hello}]\n\nTo this point, we have been starting `Registry` using `start_link/1`.\nTypically the registry is started as part of a supervision tree though:\n\n    {Registry, keys: :unique, name: Registry.ViaTest}\n\nOnly registries with unique keys can be used in `:via`. If the name is\nalready taken, the case-specific `start_link` function (`Agent.start_link/2`\nin the example above) will return `{:error, {:already_started, current_pid}}`.\n\n## Using as a dispatcher\n\n`Registry` has a dispatch mechanism that allows developers to implement custom\ndispatch logic triggered from the caller. For example, let's say we have a\nduplicate registry started as so:\n\n    {:ok, _} = Registry.start_link(keys: :duplicate, name: Registry.DispatcherTest)\n\nBy calling `register/3`, different processes can register under a given key\nand associate any value under that key. In this case, let's register the\ncurrent process under the key `\"hello\"` and attach the `{IO, :inspect}` tuple\nto it:\n\n    {:ok, _} = Registry.register(Registry.DispatcherTest, \"hello\", {IO, :inspect})\n\nNow, an entity interested in dispatching events for a given key may call\n`dispatch/3` passing in the key and a callback. This callback will be invoked\nwith a list of all the values registered under the requested key, alongside\nthe PID of the process that registered each value, in the form of `{pid,\nvalue}` tuples. In our example, `value` will be the `{module, function}` tuple\nin the code above:\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries, do: apply(module, function, [pid])\n    end)\n    # Prints #PID<...> where the PID is for the process that called register/3 above\n    #=> :ok\n\nDispatching happens in the process that calls `dispatch/3` either serially or\nconcurrently in case of multiple partitions (via spawned tasks). The\nregistered processes are not involved in dispatching unless involving them is\ndone explicitly (for example, by sending them a message in the callback).\n\nFurthermore, if there is a failure when dispatching, due to a bad\nregistration, dispatching will always fail and the registered process will not\nbe notified. Therefore let's make sure we at least wrap and report those\nerrors:\n\n    require Logger\n\n    Registry.dispatch(Registry.DispatcherTest, \"hello\", fn entries ->\n      for {pid, {module, function}} <- entries do\n        try do\n          apply(module, function, [pid])\n        catch\n          kind, reason ->\n            formatted = Exception.format(kind, reason, __STACKTRACE__)\n            Logger.error(\"Registry.dispatch/3 failed with \#{formatted}\")\n        end\n      end\n    end)\n    # Prints #PID<...>\n    #=> :ok\n\nYou could also replace the whole `apply` system by explicitly sending\nmessages. That's the example we will see next.\n\n## Using as a PubSub\n\nRegistries can also be used to implement a local, non-distributed, scalable\nPubSub by relying on the `dispatch/3` function, similarly to the previous\nsection: in this case, however, we will send messages to each associated\nprocess, instead of invoking a given module-function.\n\nIn this example, we will also set the number of partitions to the number of\nschedulers online, which will make the registry more performant on highly\nconcurrent environments:\n\n    {:ok, _} =\n      Registry.start_link(\n        keys: :duplicate,\n        name: Registry.PubSubTest,\n        partitions: System.schedulers_online()\n      )\n\n    {:ok, _} = Registry.register(Registry.PubSubTest, \"hello\", [])\n\n    Registry.dispatch(Registry.PubSubTest, \"hello\", fn entries ->\n      for {pid, _} <- entries, do: send(pid, {:broadcast, \"world\"})\n    end)\n    #=> :ok\n\nThe example above broadcasted the message `{:broadcast, \"world\"}` to all\nprocesses registered under the \"topic\" (or \"key\" as we called it until now)\n`\"hello\"`.\n\nThe third argument given to `register/3` is a value associated to the\ncurrent process. While in the previous section we used it when dispatching,\nin this particular example we are not interested in it, so we have set it\nto an empty list. You could store a more meaningful value if necessary.\n\n## Registrations\n\nLooking up, dispatching and registering are efficient and immediate at\nthe cost of delayed unsubscription. For example, if a process crashes,\nits keys are automatically removed from the registry but the change may\nnot propagate immediately. This means certain operations may return processes\nthat are already dead. When such may happen, it will be explicitly stated\nin the function documentation.\n\nHowever, keep in mind those cases are typically not an issue. After all, a\nprocess referenced by a PID may crash at any time, including between getting\nthe value from the registry and sending it a message. Many parts of the standard\nlibrary are designed to cope with that, such as `Process.monitor/1` which will\ndeliver the `:DOWN` message immediately if the monitored process is already dead\nand `send/2` which acts as a no-op for dead processes.\n\n## ETS\n\nNote that the registry uses one ETS table plus two ETS tables per partition.\n","title":"Registry","type":"module"},{"doc":"Returns a specification to start a registry under a supervisor. See Supervisor .","ref":"Registry.html#child_spec/1","source_doc":"Returns a specification to start a registry under a supervisor.\n\nSee `Supervisor`.\n","title":"Registry.child_spec/1","type":"function"},{"doc":"Returns the number of registered keys in a registry. It runs in constant time. Examples In the example below we register the current process and ask for the number of keys in the registry: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueCountTest ) iex&gt; Registry . count ( Registry.UniqueCountTest ) 0 iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueCountTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueCountTest , &quot;world&quot; , :world ) iex&gt; Registry . count ( Registry.UniqueCountTest ) 2 The same applies to duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateCountTest ) iex&gt; Registry . count ( Registry.DuplicateCountTest ) 0 iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateCountTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateCountTest , &quot;hello&quot; , :world ) iex&gt; Registry . count ( Registry.DuplicateCountTest ) 2","ref":"Registry.html#count/1","source_doc":"Returns the number of registered keys in a registry.\nIt runs in constant time.\n\n## Examples\nIn the example below we register the current process and ask for the\nnumber of keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueCountTest)\n    iex> Registry.count(Registry.UniqueCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.UniqueCountTest, \"world\", :world)\n    iex> Registry.count(Registry.UniqueCountTest)\n    2\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateCountTest)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    0\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateCountTest, \"hello\", :world)\n    iex> Registry.count(Registry.DuplicateCountTest)\n    2\n\n","title":"Registry.count/1","type":"function"},{"doc":"Returns the number of {pid, value} pairs under the given key in registry that match pattern . Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom :_ can be used to ignore a given value or tuple element, while the atom :&quot;$1&quot; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the $1 &gt; 1 guard condition would be expressed as the {:&gt;, :&quot;$1&quot;, 1} tuple. Please note that guard conditions will work only for assigned variables like :&quot;$1&quot; , :&quot;$2&quot; , and so forth. Avoid usage of special match variables :&quot;$_&quot; and :&quot;$$&quot; , because it might not work as expected. Zero will be returned if there is no match. For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up. Examples In the example below we register the current process under the same key in a duplicate registry but with different values: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.CountMatchTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.CountMatchTest , &quot;hello&quot; , { 1 , :atom , 1 } ) iex&gt; { :ok , _ } = Registry . register ( Registry.CountMatchTest , &quot;hello&quot; , { 2 , :atom , 2 } ) iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { 1 , :_ , :_ } ) 1 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { 2 , :_ , :_ } ) 1 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :_ , :atom , :_ } ) 2 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :&quot;$1&quot; , :_ , :&quot;$1&quot; } ) 2 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :_ , :_ , :&quot;$1&quot; } , [ { :&gt; , :&quot;$1&quot; , 1 } ] ) 1 iex&gt; Registry . count_match ( Registry.CountMatchTest , &quot;hello&quot; , { :_ , :&quot;$1&quot; , :_ } , [ { :is_atom , :&quot;$1&quot; } ] ) 2","ref":"Registry.html#count_match/4","source_doc":"Returns the number of `{pid, value}` pairs under the given `key` in `registry`\nthat match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nZero will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.CountMatchTest)\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.CountMatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {1, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {2, :_, :_})\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :atom, :_})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:\"$1\", :_, :\"$1\"})\n    2\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :_, :\"$1\"}, [{:>, :\"$1\", 1}])\n    1\n    iex> Registry.count_match(Registry.CountMatchTest, \"hello\", {:_, :\"$1\", :_}, [{:is_atom, :\"$1\"}])\n    2\n\n","title":"Registry.count_match/4","type":"function"},{"doc":"Works like select/2 , but only returns the number of matching records. Examples In the example below we register the current process under different keys in a unique registry but with the same value: iex&gt; Registry . start_link ( keys : :unique , name : Registry.CountSelectTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.CountSelectTest , &quot;hello&quot; , :value ) iex&gt; { :ok , _ } = Registry . register ( Registry.CountSelectTest , &quot;world&quot; , :value ) iex&gt; Registry . count_select ( Registry.CountSelectTest , [ { { :_ , :_ , :value } , [ ] , [ true ] } ] ) 2","ref":"Registry.html#count_select/2","source_doc":"Works like `select/2`, but only returns the number of matching records.\n\n## Examples\n\nIn the example below we register the current process under different\nkeys in a unique registry but with the same value:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.CountSelectTest)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.CountSelectTest, \"world\", :value)\n    iex> Registry.count_select(Registry.CountSelectTest, [{{:_, :_, :value}, [], [true]}])\n    2\n","title":"Registry.count_select/2","type":"function"},{"doc":"Deletes registry metadata for the given key in registry . Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.DeleteMetaTest ) iex&gt; Registry . put_meta ( Registry.DeleteMetaTest , :custom_key , &quot;custom_value&quot; ) :ok iex&gt; Registry . meta ( Registry.DeleteMetaTest , :custom_key ) { :ok , &quot;custom_value&quot; } iex&gt; Registry . delete_meta ( Registry.DeleteMetaTest , :custom_key ) :ok iex&gt; Registry . meta ( Registry.DeleteMetaTest , :custom_key ) :error","ref":"Registry.html#delete_meta/2","source_doc":"Deletes registry metadata for the given `key` in `registry`.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.DeleteMetaTest)\n    iex> Registry.put_meta(Registry.DeleteMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.delete_meta(Registry.DeleteMetaTest, :custom_key)\n    :ok\n    iex> Registry.meta(Registry.DeleteMetaTest, :custom_key)\n    :error\n\n","title":"Registry.delete_meta/2","type":"function"},{"doc":"Invokes the callback with all entries under key in each partition for the given registry . The list of entries is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked. If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and parallel: true is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition. See the module documentation for examples of using the dispatch/3 function for building custom dispatching or a pubsub system.","ref":"Registry.html#dispatch/4","source_doc":"Invokes the callback with all entries under `key` in each partition\nfor the given `registry`.\n\nThe list of `entries` is a non-empty list of two-element tuples where\nthe first element is the PID and the second element is the value\nassociated to the PID. If there are no entries for the given key,\nthe callback is never invoked.\n\nIf the registry is partitioned, the callback is invoked multiple times\nper partition. If the registry is partitioned and `parallel: true` is\ngiven as an option, the dispatching happens in parallel. In both cases,\nthe callback is only invoked if there are entries for that partition.\n\nSee the module documentation for examples of using the `dispatch/3`\nfunction for building custom dispatching or a pubsub system.\n","title":"Registry.dispatch/4","type":"function"},{"doc":"Returns the known keys for the given pid in registry in no particular order. If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry. Examples Registering under a unique registry does not allow multiple entries: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueKeysTest ) iex&gt; Registry . keys ( Registry.UniqueKeysTest , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueKeysTest , &quot;hello&quot; , :world ) iex&gt; Registry . register ( Registry.UniqueKeysTest , &quot;hello&quot; , :later ) # registry is :unique { :error , { :already_registered , self ( ) } } iex&gt; Registry . keys ( Registry.UniqueKeysTest , self ( ) ) [ &quot;hello&quot; ] Such is possible for duplicate registries though: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateKeysTest ) iex&gt; Registry . keys ( Registry.DuplicateKeysTest , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateKeysTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateKeysTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.DuplicateKeysTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ]","ref":"Registry.html#keys/2","source_doc":"Returns the known keys for the given `pid` in `registry` in no particular order.\n\nIf the registry is unique, the keys are unique. Otherwise\nthey may contain duplicates if the process was registered\nunder the same key multiple times. The list will be empty\nif the process is dead or it has no keys in this registry.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueKeysTest)\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueKeysTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueKeysTest, \"hello\", :later) # registry is :unique\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueKeysTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateKeysTest)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateKeysTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateKeysTest, self())\n    [\"hello\", \"hello\"]\n\n","title":"Registry.keys/2","type":"function"},{"doc":"Finds the {pid, value} pair for the given key in registry in no particular order. An empty list if there is no match. For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up. Examples In the example below we register the current process and look it up both from itself and other processes: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueLookupTest ) iex&gt; Registry . lookup ( Registry.UniqueLookupTest , &quot;hello&quot; ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . lookup ( Registry.UniqueLookupTest , &quot;hello&quot; ) [ { self ( ) , :world } ] iex&gt; Task . async ( fn -&gt; Registry . lookup ( Registry.UniqueLookupTest , &quot;hello&quot; ) end ) |&gt; Task . await ( ) [ { self ( ) , :world } ] The same applies to duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateLookupTest ) iex&gt; Registry . lookup ( Registry.DuplicateLookupTest , &quot;hello&quot; ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . lookup ( Registry.DuplicateLookupTest , &quot;hello&quot; ) [ { self ( ) , :world } ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :another ) iex&gt; Enum . sort ( Registry . lookup ( Registry.DuplicateLookupTest , &quot;hello&quot; ) ) [ { self ( ) , :another } , { self ( ) , :world } ]","ref":"Registry.html#lookup/2","source_doc":"Finds the `{pid, value}` pair for the given `key` in `registry` in no particular order.\n\nAn empty list if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.UniqueLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> Task.async(fn -> Registry.lookup(Registry.UniqueLookupTest, \"hello\") end) |> Task.await()\n    [{self(), :world}]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.lookup(Registry.DuplicateLookupTest, \"hello\")\n    [{self(), :world}]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.lookup(Registry.DuplicateLookupTest, \"hello\"))\n    [{self(), :another}, {self(), :world}]\n\n","title":"Registry.lookup/2","type":"function"},{"doc":"Returns {pid, value} pairs under the given key in registry that match pattern . Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom :_ can be used to ignore a given value or tuple element, while the atom :&quot;$1&quot; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the $1 &gt; 1 guard condition would be expressed as the {:&gt;, :&quot;$1&quot;, 1} tuple. Please note that guard conditions will work only for assigned variables like :&quot;$1&quot; , :&quot;$2&quot; , and so forth. Avoid usage of special match variables :&quot;$_&quot; and :&quot;$$&quot; , because it might not work as expected. An empty list will be returned if there is no match. For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up. Examples In the example below we register the current process under the same key in a duplicate registry but with different values: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.MatchTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.MatchTest , &quot;hello&quot; , { 1 , :atom , 1 } ) iex&gt; { :ok , _ } = Registry . register ( Registry.MatchTest , &quot;hello&quot; , { 2 , :atom , 2 } ) iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { 1 , :_ , :_ } ) [ { self ( ) , { 1 , :atom , 1 } } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { 2 , :_ , :_ } ) [ { self ( ) , { 2 , :atom , 2 } } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :_ , :atom , :_ } ) |&gt; Enum . sort ( ) [ { self ( ) , { 1 , :atom , 1 } } , { self ( ) , { 2 , :atom , 2 } } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :&quot;$1&quot; , :_ , :&quot;$1&quot; } ) |&gt; Enum . sort ( ) [ { self ( ) , { 1 , :atom , 1 } } , { self ( ) , { 2 , :atom , 2 } } ] iex&gt; guards = [ { :&gt; , :&quot;$1&quot; , 1 } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :_ , :_ , :&quot;$1&quot; } , guards ) [ { self ( ) , { 2 , :atom , 2 } } ] iex&gt; guards = [ { :is_atom , :&quot;$1&quot; } ] iex&gt; Registry . match ( Registry.MatchTest , &quot;hello&quot; , { :_ , :&quot;$1&quot; , :_ } , guards ) |&gt; Enum . sort ( ) [ { self ( ) , { 1 , :atom , 1 } } , { self ( ) , { 2 , :atom , 2 } } ]","ref":"Registry.html#match/4","source_doc":"Returns `{pid, value}` pairs under the given `key` in `registry` that match `pattern`.\n\nPattern must be an atom or a tuple that will match the structure of the\nvalue stored in the registry. The atom `:_` can be used to ignore a given\nvalue or tuple element, while the atom `:\"$1\"` can be used to temporarily assign part\nof pattern to a variable for a subsequent comparison.\n\nOptionally, it is possible to pass a list of guard conditions for more precise matching.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\nAvoid usage of special match variables `:\"$_\"` and `:\"$$\"`, because it might not work as expected.\n\nAn empty list will be returned if there is no match.\n\nFor unique registries, a single partition lookup is necessary. For\nduplicate registries, all partitions must be looked up.\n\n## Examples\n\nIn the example below we register the current process under the same\nkey in a duplicate registry but with different values:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.MatchTest)\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {1, :atom, 1})\n    iex> {:ok, _} = Registry.register(Registry.MatchTest, \"hello\", {2, :atom, 2})\n    iex> Registry.match(Registry.MatchTest, \"hello\", {1, :_, :_})\n    [{self(), {1, :atom, 1}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {2, :_, :_})\n    [{self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :atom, :_}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:\"$1\", :_, :\"$1\"}) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n    iex> guards = [{:>, :\"$1\", 1}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :_, :\"$1\"}, guards)\n    [{self(), {2, :atom, 2}}]\n    iex> guards = [{:is_atom, :\"$1\"}]\n    iex> Registry.match(Registry.MatchTest, \"hello\", {:_, :\"$1\", :_}, guards) |> Enum.sort()\n    [{self(), {1, :atom, 1}}, {self(), {2, :atom, 2}}]\n\n","title":"Registry.match/4","type":"function"},{"doc":"Reads registry metadata given on start_link/1 . Atoms and tuples are allowed as keys. Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.MetaTest , meta : [ custom_key : &quot;custom_value&quot; ] ) iex&gt; Registry . meta ( Registry.MetaTest , :custom_key ) { :ok , &quot;custom_value&quot; } iex&gt; Registry . meta ( Registry.MetaTest , :unknown_key ) :error","ref":"Registry.html#meta/2","source_doc":"Reads registry metadata given on `start_link/1`.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.MetaTest, meta: [custom_key: \"custom_value\"])\n    iex> Registry.meta(Registry.MetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.meta(Registry.MetaTest, :unknown_key)\n    :error\n\n","title":"Registry.meta/2","type":"function"},{"doc":"Stores registry metadata. Atoms and tuples are allowed as keys. Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.PutMetaTest ) iex&gt; Registry . put_meta ( Registry.PutMetaTest , :custom_key , &quot;custom_value&quot; ) :ok iex&gt; Registry . meta ( Registry.PutMetaTest , :custom_key ) { :ok , &quot;custom_value&quot; } iex&gt; Registry . put_meta ( Registry.PutMetaTest , { :tuple , :key } , &quot;tuple_value&quot; ) :ok iex&gt; Registry . meta ( Registry.PutMetaTest , { :tuple , :key } ) { :ok , &quot;tuple_value&quot; }","ref":"Registry.html#put_meta/3","source_doc":"Stores registry metadata.\n\nAtoms and tuples are allowed as keys.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.PutMetaTest)\n    iex> Registry.put_meta(Registry.PutMetaTest, :custom_key, \"custom_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, :custom_key)\n    {:ok, \"custom_value\"}\n    iex> Registry.put_meta(Registry.PutMetaTest, {:tuple, :key}, \"tuple_value\")\n    :ok\n    iex> Registry.meta(Registry.PutMetaTest, {:tuple, :key})\n    {:ok, \"tuple_value\"}\n\n","title":"Registry.put_meta/3","type":"function"},{"doc":"Registers the current process under the given key in registry . A value to be associated with this registration must also be given. This value will be retrieved whenever dispatching or doing a key lookup. This function returns {:ok, owner} or {:error, reason} . The owner is the PID in the registry partition responsible for the PID. The owner is automatically linked to the caller. If the registry has unique keys, it will return {:ok, owner} unless the key is already associated to a PID, in which case it returns {:error, {:already_registered, pid}} . If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed. If the registry has listeners specified via the :listeners option in start_link/1 , those listeners will be notified of the registration and will receive a message of type listener_message/0 . Examples Registering under a unique registry does not allow multiple entries: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueRegisterTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueRegisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . register ( Registry.UniqueRegisterTest , &quot;hello&quot; , :later ) { :error , { :already_registered , self ( ) } } iex&gt; Registry . keys ( Registry.UniqueRegisterTest , self ( ) ) [ &quot;hello&quot; ] Such is possible for duplicate registries though: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateRegisterTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateRegisterTest , &quot;hello&quot; , :world ) iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateRegisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.DuplicateRegisterTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ]","ref":"Registry.html#register/3","source_doc":"Registers the current process under the given `key` in `registry`.\n\nA value to be associated with this registration must also be given.\nThis value will be retrieved whenever dispatching or doing a key\nlookup.\n\nThis function returns `{:ok, owner}` or `{:error, reason}`.\nThe `owner` is the PID in the registry partition responsible for\nthe PID. The owner is automatically linked to the caller.\n\nIf the registry has unique keys, it will return `{:ok, owner}` unless\nthe key is already associated to a PID, in which case it returns\n`{:error, {:already_registered, pid}}`.\n\nIf the registry has duplicate keys, multiple registrations from the\ncurrent process under the same key are allowed.\n\nIf the registry has listeners specified via the `:listeners` option in `start_link/1`,\nthose listeners will be notified of the registration and will receive a\nmessage of type `t:listener_message/0`.\n\n## Examples\n\nRegistering under a unique registry does not allow multiple entries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.UniqueRegisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.UniqueRegisterTest, \"hello\", :later)\n    {:error, {:already_registered, self()}}\n    iex> Registry.keys(Registry.UniqueRegisterTest, self())\n    [\"hello\"]\n\nSuch is possible for duplicate registries though:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateRegisterTest)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> {:ok, _} = Registry.register(Registry.DuplicateRegisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateRegisterTest, self())\n    [\"hello\", \"hello\"]\n\n","title":"Registry.register/3","type":"function"},{"doc":"Select key, pid, and values registered using full match specs. The spec consists of a list of three part tuples, in the shape of [{match_pattern, guards, body}] . The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is {key, pid, value} . The atom :_ can be used to ignore a given value or tuple element, while the atom :&quot;$1&quot; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like {:&quot;$1&quot;, :_, :_} . The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the $1 &gt; 1 guard condition would be expressed as the {:&gt;, :&quot;$1&quot;, 1} tuple. Please note that guard conditions will work only for assigned variables like :&quot;$1&quot; , :&quot;$2&quot; , and so forth. The third part, the body, is a list of shapes of the returned entries. Like guards, you have access to assigned variables like :&quot;$1&quot; , which you can combine with hardcoded values to freely shape entries Note that tuples have to be wrapped in an additional tuple. To get a result format like %{key: key, pid: pid, value: value} , assuming you bound those variables in order in the match part, you would provide a body like [%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}] . Like guards, you can use some operations like :element to modify the output format. Do not use special match variables :&quot;$_&quot; and :&quot;$$&quot; , because they might not work as expected. Note that for large registries with many partitions this will be costly as it builds the result by concatenating all the partitions. Examples This example shows how to get everything from the registry: iex&gt; Registry . start_link ( keys : :unique , name : Registry.SelectAllTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;hello&quot; , :value ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;world&quot; , :value ) iex&gt; Registry . select ( Registry.SelectAllTest , [ { { :&quot;$1&quot; , :&quot;$2&quot; , :&quot;$3&quot; } , [ ] , [ { { :&quot;$1&quot; , :&quot;$2&quot; , :&quot;$3&quot; } } ] } ] ) [ { &quot;world&quot; , self ( ) , :value } , { &quot;hello&quot; , self ( ) , :value } ] Get all keys in the registry: iex&gt; Registry . start_link ( keys : :unique , name : Registry.SelectAllTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;hello&quot; , :value ) iex&gt; { :ok , _ } = Registry . register ( Registry.SelectAllTest , &quot;world&quot; , :value ) iex&gt; Registry . select ( Registry.SelectAllTest , [ { { :&quot;$1&quot; , :_ , :_ } , [ ] , [ :&quot;$1&quot; ] } ] ) [ &quot;world&quot; , &quot;hello&quot; ]","ref":"Registry.html#select/2","source_doc":"Select key, pid, and values registered using full match specs.\n\nThe `spec` consists of a list of three part tuples, in the shape of `[{match_pattern, guards, body}]`.\n\nThe first part, the match pattern, must be a tuple that will match the structure of the\nthe data stored in the registry, which is `{key, pid, value}`. The atom `:_` can be used to\nignore a given value or tuple element, while the atom `:\"$1\"` can be used to temporarily\nassign part of pattern to a variable for a subsequent comparison. This can be combined\nlike `{:\"$1\", :_, :_}`.\n\nThe second part, the guards, is a list of conditions that allow filtering the results.\nEach guard is a tuple, which describes checks that should be passed by assigned part of pattern.\nFor example the `$1 > 1` guard condition would be expressed as the `{:>, :\"$1\", 1}` tuple.\nPlease note that guard conditions will work only for assigned\nvariables like `:\"$1\"`, `:\"$2\"`, and so forth.\n\nThe third part, the body, is a list of shapes of the returned entries. Like guards, you have access to\nassigned variables like `:\"$1\"`, which you can combine with hardcoded values to freely shape entries\nNote that tuples have to be wrapped in an additional tuple. To get a result format like\n`%{key: key, pid: pid, value: value}`, assuming you bound those variables in order in the match part,\nyou would provide a body like `[%{key: :\"$1\", pid: :\"$2\", value: :\"$3\"}]`. Like guards, you can use\nsome operations like `:element` to modify the output format.\n\nDo not use special match variables `:\"$_\"` and `:\"$$\"`, because they might not work as expected.\n\nNote that for large registries with many partitions this will be costly as it builds the result by\nconcatenating all the partitions.\n\n## Examples\n\nThis example shows how to get everything from the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :\"$2\", :\"$3\"}, [], [{{:\"$1\", :\"$2\", :\"$3\"}}]}])\n    [{\"world\", self(), :value}, {\"hello\", self(), :value}]\n\nGet all keys in the registry:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.SelectAllTest)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"hello\", :value)\n    iex> {:ok, _} = Registry.register(Registry.SelectAllTest, \"world\", :value)\n    iex> Registry.select(Registry.SelectAllTest, [{{:\"$1\", :_, :_}, [], [:\"$1\"]}])\n    [\"world\", \"hello\"]\n\n","title":"Registry.select/2","type":"function"},{"doc":"Starts the registry as a supervisor process. Manually it can be started as: Registry . start_link ( keys : :unique , name : MyApp.Registry ) In your supervisor tree, you would write: Supervisor . start_link ( [ { Registry , keys : :unique , name : MyApp.Registry } ] , strategy : :one_for_one ) For intensive workloads, the registry may also be partitioned (by specifying the :partitions option). If partitioning is required then a good default is to set the number of partitions to the number of schedulers available: Registry . start_link ( keys : :unique , name : MyApp.Registry , partitions : System . schedulers_online ( ) ) or: Supervisor . start_link ( [ { Registry , keys : :unique , name : MyApp.Registry , partitions : System . schedulers_online ( ) } ] , strategy : :one_for_one ) Options The registry requires the following keys: :keys - chooses if keys are :unique or :duplicate :name - the name of the registry and its tables The following keys are optional: :partitions - the number of partitions in the registry. Defaults to 1 . :listeners - a list of named processes which are notified of register and unregister events. The registered process must be monitored by the listener if the listener wants to be notified if the registered process crashes. Messages sent to listeners are of type listener_message/0 . :meta - a keyword list of metadata to be attached to the registry.","ref":"Registry.html#start_link/1","source_doc":"Starts the registry as a supervisor process.\n\nManually it can be started as:\n\n    Registry.start_link(keys: :unique, name: MyApp.Registry)\n\nIn your supervisor tree, you would write:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry}\n    ], strategy: :one_for_one)\n\nFor intensive workloads, the registry may also be partitioned (by specifying\nthe `:partitions` option). If partitioning is required then a good default is to\nset the number of partitions to the number of schedulers available:\n\n    Registry.start_link(\n      keys: :unique,\n      name: MyApp.Registry,\n      partitions: System.schedulers_online()\n    )\n\nor:\n\n    Supervisor.start_link([\n      {Registry, keys: :unique, name: MyApp.Registry, partitions: System.schedulers_online()}\n    ], strategy: :one_for_one)\n\n## Options\n\nThe registry requires the following keys:\n\n  * `:keys` - chooses if keys are `:unique` or `:duplicate`\n  * `:name` - the name of the registry and its tables\n\nThe following keys are optional:\n\n  * `:partitions` - the number of partitions in the registry. Defaults to `1`.\n  * `:listeners` - a list of named processes which are notified of register\n    and unregister events. The registered process must be monitored by the\n    listener if the listener wants to be notified if the registered process\n    crashes. Messages sent to listeners are of type `t:listener_message/0`.\n  * `:meta` - a keyword list of metadata to be attached to the registry.\n\n","title":"Registry.start_link/1","type":"function"},{"doc":"Unregisters all entries for the given key associated to the current process in registry . Always returns :ok and automatically unlinks the current process from the owner if there are no more keys associated to the current process. See also register/3 to read more about the &quot;owner&quot;. If the registry has listeners specified via the :listeners option in start_link/1 , those listeners will be notified of the unregistration and will receive a message of type listener_message/0 . Examples For unique registries: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueUnregisterTest ) iex&gt; Registry . register ( Registry.UniqueUnregisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.UniqueUnregisterTest , self ( ) ) [ &quot;hello&quot; ] iex&gt; Registry . unregister ( Registry.UniqueUnregisterTest , &quot;hello&quot; ) :ok iex&gt; Registry . keys ( Registry.UniqueUnregisterTest , self ( ) ) [ ] For duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateUnregisterTest ) iex&gt; Registry . register ( Registry.DuplicateUnregisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . register ( Registry.DuplicateUnregisterTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.DuplicateUnregisterTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ] iex&gt; Registry . unregister ( Registry.DuplicateUnregisterTest , &quot;hello&quot; ) :ok iex&gt; Registry . keys ( Registry.DuplicateUnregisterTest , self ( ) ) [ ]","ref":"Registry.html#unregister/2","source_doc":"Unregisters all entries for the given `key` associated to the current\nprocess in `registry`.\n\nAlways returns `:ok` and automatically unlinks the current process from\nthe owner if there are no more keys associated to the current process. See\nalso `register/3` to read more about the \"owner\".\n\nIf the registry has listeners specified via the `:listeners` option in `start_link/1`,\nthose listeners will be notified of the unregistration and will receive a\nmessage of type `t:listener_message/0`.\n\n## Examples\n\nFor unique registries:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterTest)\n    iex> Registry.register(Registry.UniqueUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    [\"hello\"]\n    iex> Registry.unregister(Registry.UniqueUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterTest)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.register(Registry.DuplicateUnregisterTest, \"hello\", :world)\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.unregister(Registry.DuplicateUnregisterTest, \"hello\")\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterTest, self())\n    []\n\n","title":"Registry.unregister/2","type":"function"},{"doc":"Unregisters entries for keys matching a pattern associated to the current process in registry . Examples For unique registries it can be used to conditionally unregister a key on the basis of whether or not it matches a particular value. iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueUnregisterMatchTest ) iex&gt; Registry . register ( Registry.UniqueUnregisterMatchTest , &quot;hello&quot; , :world ) iex&gt; Registry . keys ( Registry.UniqueUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; ] iex&gt; Registry . unregister_match ( Registry.UniqueUnregisterMatchTest , &quot;hello&quot; , :foo ) :ok iex&gt; Registry . keys ( Registry.UniqueUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; ] iex&gt; Registry . unregister_match ( Registry.UniqueUnregisterMatchTest , &quot;hello&quot; , :world ) :ok iex&gt; Registry . keys ( Registry.UniqueUnregisterMatchTest , self ( ) ) [ ] For duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateUnregisterMatchTest ) iex&gt; Registry . register ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_a ) iex&gt; Registry . register ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_b ) iex&gt; Registry . register ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_c ) iex&gt; Registry . keys ( Registry.DuplicateUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; , &quot;hello&quot; ] iex&gt; Registry . unregister_match ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; , :world_a ) :ok iex&gt; Registry . keys ( Registry.DuplicateUnregisterMatchTest , self ( ) ) [ &quot;hello&quot; , &quot;hello&quot; ] iex&gt; Registry . lookup ( Registry.DuplicateUnregisterMatchTest , &quot;hello&quot; ) [ { self ( ) , :world_b } , { self ( ) , :world_c } ]","ref":"Registry.html#unregister_match/4","source_doc":"Unregisters entries for keys matching a pattern associated to the current\nprocess in `registry`.\n\n## Examples\n\nFor unique registries it can be used to conditionally unregister a key on\nthe basis of whether or not it matches a particular value.\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueUnregisterMatchTest)\n    iex> Registry.register(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :foo)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    [\"hello\"]\n    iex> Registry.unregister_match(Registry.UniqueUnregisterMatchTest, \"hello\", :world)\n    :ok\n    iex> Registry.keys(Registry.UniqueUnregisterMatchTest, self())\n    []\n\nFor duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateUnregisterMatchTest)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_b)\n    iex> Registry.register(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_c)\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\", \"hello\"]\n    iex> Registry.unregister_match(Registry.DuplicateUnregisterMatchTest, \"hello\", :world_a)\n    :ok\n    iex> Registry.keys(Registry.DuplicateUnregisterMatchTest, self())\n    [\"hello\", \"hello\"]\n    iex> Registry.lookup(Registry.DuplicateUnregisterMatchTest, \"hello\")\n    [{self(), :world_b}, {self(), :world_c}]\n\n","title":"Registry.unregister_match/4","type":"function"},{"doc":"Updates the value for key for the current process in the unique registry . Returns a {new_value, old_value} tuple or :error if there is no such key assigned to the current process. If a non-unique registry is given, an error is raised. Examples iex&gt; Registry . start_link ( keys : :unique , name : Registry.UpdateTest ) iex&gt; { :ok , _ } = Registry . register ( Registry.UpdateTest , &quot;hello&quot; , 1 ) iex&gt; Registry . lookup ( Registry.UpdateTest , &quot;hello&quot; ) [ { self ( ) , 1 } ] iex&gt; Registry . update_value ( Registry.UpdateTest , &quot;hello&quot; , &amp; ( &amp;1 + 1 ) ) { 2 , 1 } iex&gt; Registry . lookup ( Registry.UpdateTest , &quot;hello&quot; ) [ { self ( ) , 2 } ]","ref":"Registry.html#update_value/3","source_doc":"Updates the value for `key` for the current process in the unique `registry`.\n\nReturns a `{new_value, old_value}` tuple or `:error` if there\nis no such key assigned to the current process.\n\nIf a non-unique registry is given, an error is raised.\n\n## Examples\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UpdateTest)\n    iex> {:ok, _} = Registry.register(Registry.UpdateTest, \"hello\", 1)\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 1}]\n    iex> Registry.update_value(Registry.UpdateTest, \"hello\", &(&1 + 1))\n    {2, 1}\n    iex> Registry.lookup(Registry.UpdateTest, \"hello\")\n    [{self(), 2}]\n\n","title":"Registry.update_value/3","type":"function"},{"doc":"Reads the values for the given key for pid in registry . For unique registries, it is either an empty list or a list with a single element. For duplicate registries, it is a list with zero, one, or multiple elements. Examples In the example below we register the current process and look it up both from itself and other processes: iex&gt; Registry . start_link ( keys : :unique , name : Registry.UniqueLookupTest ) iex&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.UniqueLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , self ( ) ) [ :world ] iex&gt; Task . async ( fn -&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , self ( ) ) end ) |&gt; Task . await ( ) [ ] iex&gt; parent = self ( ) iex&gt; Task . async ( fn -&gt; Registry . values ( Registry.UniqueLookupTest , &quot;hello&quot; , parent ) end ) |&gt; Task . await ( ) [ :world ] The same applies to duplicate registries: iex&gt; Registry . start_link ( keys : :duplicate , name : Registry.DuplicateLookupTest ) iex&gt; Registry . values ( Registry.DuplicateLookupTest , &quot;hello&quot; , self ( ) ) [ ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :world ) iex&gt; Registry . values ( Registry.DuplicateLookupTest , &quot;hello&quot; , self ( ) ) [ :world ] iex&gt; { :ok , _ } = Registry . register ( Registry.DuplicateLookupTest , &quot;hello&quot; , :another ) iex&gt; Enum . sort ( Registry . values ( Registry.DuplicateLookupTest , &quot;hello&quot; , self ( ) ) ) [ :another , :world ]","ref":"Registry.html#values/3","source_doc":"Reads the values for the given `key` for `pid` in `registry`.\n\nFor unique registries, it is either an empty list or a list\nwith a single element. For duplicate registries, it is a list\nwith zero, one, or multiple elements.\n\n## Examples\n\nIn the example below we register the current process and look it up\nboth from itself and other processes:\n\n    iex> Registry.start_link(keys: :unique, name: Registry.UniqueLookupTest)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.UniqueLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.UniqueLookupTest, \"hello\", self())\n    [:world]\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", self()) end) |> Task.await()\n    []\n    iex> parent = self()\n    iex> Task.async(fn -> Registry.values(Registry.UniqueLookupTest, \"hello\", parent) end) |> Task.await()\n    [:world]\n\nThe same applies to duplicate registries:\n\n    iex> Registry.start_link(keys: :duplicate, name: Registry.DuplicateLookupTest)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    []\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :world)\n    iex> Registry.values(Registry.DuplicateLookupTest, \"hello\", self())\n    [:world]\n    iex> {:ok, _} = Registry.register(Registry.DuplicateLookupTest, \"hello\", :another)\n    iex> Enum.sort(Registry.values(Registry.DuplicateLookupTest, \"hello\", self()))\n    [:another, :world]\n\n","title":"Registry.values/3","type":"function"},{"doc":"A pattern used to representing the output format part of a match spec","ref":"Registry.html#t:body/0","source_doc":"A pattern used to representing the output format part of a match spec","title":"Registry.body/0","type":"type"},{"doc":"A guard to be evaluated when matching on objects in a registry","ref":"Registry.html#t:guard/0","source_doc":"A guard to be evaluated when matching on objects in a registry","title":"Registry.guard/0","type":"type"},{"doc":"A list of guards to be evaluated when matching on objects in a registry","ref":"Registry.html#t:guards/0","source_doc":"A list of guards to be evaluated when matching on objects in a registry","title":"Registry.guards/0","type":"type"},{"doc":"The type of keys allowed on registration","ref":"Registry.html#t:key/0","source_doc":"The type of keys allowed on registration","title":"Registry.key/0","type":"type"},{"doc":"The type of the registry","ref":"Registry.html#t:keys/0","source_doc":"The type of the registry","title":"Registry.keys/0","type":"type"},{"doc":"The message that the registry sends to listeners when a process registers or unregisters. See the :listeners option in start_link/1 .","ref":"Registry.html#t:listener_message/0","source_doc":"The message that the registry sends to listeners when a process registers or unregisters.\n\nSee the `:listeners` option in `start_link/1`.\n","title":"Registry.listener_message/0","type":"type"},{"doc":"A pattern to match on objects in a registry","ref":"Registry.html#t:match_pattern/0","source_doc":"A pattern to match on objects in a registry","title":"Registry.match_pattern/0","type":"type"},{"doc":"The type of registry metadata keys","ref":"Registry.html#t:meta_key/0","source_doc":"The type of registry metadata keys","title":"Registry.meta_key/0","type":"type"},{"doc":"The type of registry metadata values","ref":"Registry.html#t:meta_value/0","source_doc":"The type of registry metadata values","title":"Registry.meta_value/0","type":"type"},{"doc":"The registry identifier","ref":"Registry.html#t:registry/0","source_doc":"The registry identifier","title":"Registry.registry/0","type":"type"},{"doc":"A full match spec used when selecting objects in the registry","ref":"Registry.html#t:spec/0","source_doc":"A full match spec used when selecting objects in the registry","title":"Registry.spec/0","type":"type"},{"doc":"Options used for child_spec/1 and start_link/1","ref":"Registry.html#t:start_option/0","source_doc":"Options used for `child_spec/1` and `start_link/1`","title":"Registry.start_option/0","type":"type"},{"doc":"The type of values allowed on registration","ref":"Registry.html#t:value/0","source_doc":"The type of values allowed on registration","title":"Registry.value/0","type":"type"},{"doc":"A behaviour module for implementing supervisors. A supervisor is a process which supervises other processes, which we refer to as child processes . Supervisors are used to build a hierarchical process structure called a supervision tree . Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown. A supervisor may be started directly with a list of child specifications via start_link/2 or you may define a module-based supervisor that implements the required callbacks. The sections below use start_link/2 to start supervisors in most examples, but it also includes a specific section on module-based ones. Examples In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer , a generic server, that keeps a counter. Other processes can then send messages to this process to read the counter and bump its value. Disclaimer In practice you would not define a counter as a GenServer. Instead, if you need a counter, you would pass it around as inputs and outputs to the functions that need it. The reason we picked a counter in this example is due to its simplicity, as it allows us to focus on how supervisors work. defmodule Counter do use GenServer def start_link ( arg ) when is_integer ( arg ) do GenServer . start_link ( __MODULE__ , arg , name : __MODULE__ ) end ## Callbacks @impl true def init ( counter ) do { :ok , counter } end @impl true def handle_call ( :get , _from , counter ) do { :reply , counter , counter } end def handle_call ( { :bump , value } , _from , counter ) do { :reply , counter , counter + value } end end The Counter receives an argument on start_link . This argument is passed to the init/1 callback which becomes the initial value of the counter. Our counter handles two operations (known as calls): :get , to get the current counter value, and :bump , that bumps the counter by the given value and returns the old counter. We can now start a supervisor that will start and supervise our counter process. The first step is to define a list of child specifications that control how each child behaves. Each child specification is a map, as shown below: children = [ # The Counter is a child started via Counter.start_link(0) %{ id : Counter , start : { Counter , :start_link , [ 0 ] } } ] # Now we start the supervisor with the children and a strategy { :ok , pid } = Supervisor . start_link ( children , strategy : :one_for_one ) # After started, we can query the supervisor for information Supervisor . count_children ( pid ) #=&gt; %{active: 1, specs: 1, supervisors: 0, workers: 1} Note that when starting the GenServer, we are registering it with name Counter via the name: __MODULE__ option. This allows us to call it directly and get its value: GenServer . call ( Counter , :get ) #=&gt; 0 GenServer . call ( Counter , { :bump , 3 } ) #=&gt; 0 GenServer . call ( Counter , :get ) #=&gt; 3 However, there is a bug in our counter server. If we call :bump with a non-numeric value, it is going to crash: GenServer . call ( Counter , { :bump , &quot;oops&quot; } ) ** (exit) exited in: GenServer.call(Counter, {:bump, &quot;oops&quot;}, 5000) Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, reset back to its initial value of 0 : GenServer . call ( Counter , :get ) #=&gt; 0 Supervisors support different strategies; in the example above, we have chosen :one_for_one . Furthermore, each supervisor can have many workers and/or supervisors as children, with each one having its own configuration (as outlined in the &quot;Child specification&quot; section). The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more. Child specification The child specification describes how the supervisor starts, shuts down, and restarts child processes. The child specification is a map containing up to 6 elements. The first two keys in the following list are required, and the remaining ones are optional: :id - any term used to identify the child specification internally by the supervisor; defaults to the given module. This key is required. For supervisors, in the case of conflicting :id values, the supervisor will refuse to initialize and require explicit IDs. This is not the case for dynamic supervisors though. :start - a tuple with the module-function-args to be invoked to start the child process. This key is required. :restart - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below). This key is optional and defaults to :permanent . :shutdown - an integer or atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below). This key is optional and defaults to 5_000 if the type is :worker or :infinity if the type is :supervisor . :type - specifies that the child process is a :worker or a :supervisor . This key is optional and defaults to :worker . :modules - a list of modules used by hot code upgrade mechanisms to determine which processes are using certain modules. It is typically set to the callback module of behaviours like GenServer , Supervisor , and such. It is set automatically based on the :start value and it is rarely changed in practice. :significant - a boolean indicating if the child process should be considered significant with regard to automatic shutdown. Only :transient and :temporary child processes can be marked as significant. This key is optional and defaults to false . See section &quot;Automatic shutdown&quot; below for more details. Let's understand what the :shutdown and :restart options control. Shutdown values (:shutdown) The following shutdown values are supported in the :shutdown option: :brutal_kill - the child process is unconditionally and immediately terminated using Process.exit(child, :kill) . any integer &gt;= 0 - the amount of time in milliseconds that the supervisor will wait for its children to terminate after emitting a Process.exit(child, :shutdown) signal. If the child process is not trapping exits, the initial :shutdown signal will terminate the child process immediately. If the child process is trapping exits, it has the given amount of time to terminate. If it doesn't terminate within the specified time, the child process is unconditionally terminated by the supervisor via Process.exit(child, :kill) . :infinity - works as an integer except the supervisor will wait indefinitely for the child to terminate. If the child process is a supervisor, the recommended value is :infinity to give the supervisor and its children enough time to shut down. This option can be used with regular workers but doing so is discouraged and requires extreme care. If not used carefully, the child process will never terminate, preventing your application from terminating as well. Restart values (:restart) The :restart option controls what the supervisor should consider to be a successful termination or not. If the termination is successful, the supervisor won't restart the child. If the child process crashed, the supervisor will start a new one. The following restart values are supported in the :restart option: :permanent - the child process is always restarted. :temporary - the child process is never restarted, regardless of the supervision strategy: any termination (even abnormal) is considered successful. :transient - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal , :shutdown , or {:shutdown, term} . For a more complete understanding of the exit reasons and their impact, see the &quot;Exit reasons and restarts&quot; section. child_spec/1 function When starting a supervisor, we may pass a list of child specifications. Those specifications are maps that tell how the supervisor should start, stop and restart each of its children: %{ id : Counter , start : { Counter , :start_link , [ 0 ] } } The map above defines a child with :id of Counter that is started by calling Counter.start_link(0) . However, defining the child specification for each child as a map can be quite error prone, as we may change the Counter implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the start_link argument instead of the specification: children = [ { Counter , 0 } ] The supervisor will then invoke Counter.child_spec(0) to retrieve a child specification. Now the Counter module is responsible for building its own specification, for example, we could write: def child_spec ( arg ) do %{ id : Counter , start : { Counter , :start_link , [ arg ] } } end Luckily for us, use GenServer already defines a Counter.child_spec/1 exactly like above, so you don't need to write the definition above yourself. If you want to customize the automatically generated child_spec/1 function, you can pass the options directly to use GenServer : use GenServer , restart : :transient Finally, note it is also possible to simply pass the Counter module as a child: children = [ Counter ] When only the module name is given, it is equivalent to {Counter, []} , which in our case would be invalid, which is why we always pass the initial counter explicitly. By replacing the child specification with {Counter, 0} , we keep it encapsulated in the Counter module. We could now share our Counter implementation with other developers and they can add it directly to their supervision tree without worrying about the low-level details of the counter. Overall, a child specification can be one of the following: a map representing the child specification itself - as outlined in the &quot;Child specification&quot; section a tuple with a module as first element and the start argument as second - such as {Counter, 0} . In this case, Counter.child_spec(0) is called to retrieve the child specification a module - such as Counter . In this case, Counter.child_spec([]) would be called, which is invalid for the counter, but it is useful in many other cases, especially when you want to pass a list of options to the child process If you need to convert a {module, arg} tuple or a module child specification to a child specification or modify a child specification itself, you can use the Supervisor.child_spec/2 function. For example, to run the counter with a different :id and a :shutdown value of 10 seconds (10_000 milliseconds): children = [ Supervisor . child_spec ( { Counter , 0 } , id : MyCounter , shutdown : 10_000 ) ] Supervisor strategies and options So far we have started the supervisor passing a single child as a tuple as well as a strategy called :one_for_one : children = [ { Counter , 0 } ] Supervisor . start_link ( children , strategy : :one_for_one ) The first argument given to start_link/2 is a list of child specifications as defined in the &quot;child_spec/1&quot; section above. The second argument is a keyword list of options: :strategy - the supervision strategy option. It can be either :one_for_one , :rest_for_one or :one_for_all . Required. See the &quot;Strategies&quot; section. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . :auto_shutdown - the automatic shutdown option. It can be :never , :any_significant , or :all_significant . Optional. See the &quot;Automatic shutdown&quot; section. :name - a name to register the supervisor process. Supported values are explained in the &quot;Name registration&quot; section in the documentation for GenServer . Optional. Strategies Supervisors support different supervision strategies (through the :strategy option, as seen above): :one_for_one - if a child process terminates, only that process is restarted. :one_for_all - if a child process terminates, all other child processes are terminated and then all child processes (including the terminated one) are restarted. :rest_for_one - if a child process terminates, the terminated child process and the rest of the children started after it, are terminated and restarted. In the above, process termination refers to unsuccessful termination, which is determined by the :restart option. To efficiently supervise children started dynamically, see DynamicSupervisor . Automatic shutdown Supervisors have the ability to automatically shut themselves down when child processes marked as :significant exit. Supervisors support different automatic shutdown options (through the :auto_shutdown option, as seen above): :never - this is the default, automatic shutdown is disabled. :any_significant - if any significant child process exits, the supervisor will automatically shut down its children, then itself. :all_significant - when all significant child processes have exited, the supervisor will automatically shut down its children, then itself. Only :transient and :temporary child processes can be marked as significant, and this configuration affects the behavior. Significant :transient child processes must exit normally for automatic shutdown to be considered, where :temporary child processes may exit for any reason. Name registration A supervisor is bound to the same name registration rules as a GenServer . Read more about these rules in the documentation for GenServer . Module-based supervisors In the example so far, the supervisor was started by passing the supervision structure to start_link/2 . However, supervisors can also be created by explicitly defining a supervision module: defmodule MyApp.Supervisor do # Automatically defines child_spec/1 use Supervisor def start_link ( init_arg ) do Supervisor . start_link ( __MODULE__ , init_arg , name : __MODULE__ ) end @impl true def init ( _init_arg ) do children = [ { Counter , 0 } ] Supervisor . init ( children , strategy : :one_for_one ) end end The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling Supervisor.start_link/2 with a list of child specifications that are automatically initialized, we manually initialize the children by calling Supervisor.init/2 inside its init/1 callback. Supervisor.init/2 accepts the same :strategy , :max_restarts , and :max_seconds options as start_link/2 . use Supervisor also defines a child_spec/1 function which allows us to run MyApp.Supervisor as a child of another supervisor or at the top of your supervision tree as: children = [ MyApp.Supervisor ] Supervisor . start_link ( children , strategy : :one_for_one ) A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the Application.start/2 callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The child_spec/1 generated automatically by Supervisor can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the supervisor should be restarted, defaults to :permanent The @doc annotation immediately preceding use Supervisor will be attached to the generated child_spec/1 function. Start and shutdown When the supervisor starts, it traverses all child specifications and then starts each child in the order they are defined. This is done by calling the function defined under the :start key in the child specification and typically defaults to start_link/1 . The start_link/1 (or a custom) is then called for each child process. The start_link/1 function must return {:ok, pid} where pid is the process identifier of a new process that is linked to the supervisor. The child process usually starts its work by executing the init/1 callback. Generally speaking, the init callback is where we initialize and configure the child process. The shutdown process happens in reverse order. When a supervisor shuts down, it terminates all children in the opposite order they are listed. The termination happens by sending a shutdown exit signal, via Process.exit(child_pid, :shutdown) , to the child process and then awaiting for a time interval for the child process to terminate. This interval defaults to 5000 milliseconds. If the child process does not terminate in this interval, the supervisor abruptly terminates the child with reason :kill . The shutdown time can be configured in the child specification which is fully detailed in the next section. If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the terminate callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor. In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper :shutdown value, ensuring it terminates within a reasonable interval. Exit reasons and restarts A supervisor restarts a child process depending on its :restart configuration. For example, when :restart is set to :transient , the supervisor does not restart the child in case it exits with reason :normal , :shutdown or {:shutdown, term} . Those exits also impact logging. By default, behaviours such as GenServers do not emit error logs when the exit reason is :normal , :shutdown or {:shutdown, term} . So one may ask: which exit reason should I choose? There are three options: :normal - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes do not exit :shutdown or {:shutdown, term} - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes exit with the same reason unless they're trapping exits any other term - in such cases, the exit will be logged, there are restarts in transient mode, and linked processes exit with the same reason unless they're trapping exits Generally speaking, if you are exiting for expected reasons, you want to use :shutdown or {:shutdown, term} . Note that the supervisor that reaches maximum restart intensity will exit with :shutdown reason. In this case the supervisor will only be restarted if its child specification was defined with the :restart option set to :permanent (the default).","ref":"Supervisor.html","source_doc":"A behaviour module for implementing supervisors.\n\nA supervisor is a process which supervises other processes, which we\nrefer to as *child processes*. Supervisors are used to build a hierarchical\nprocess structure called a *supervision tree*. Supervision trees provide\nfault-tolerance and encapsulate how our applications start and shutdown.\n\nA supervisor may be started directly with a list of child specifications via\n`start_link/2` or you may define a module-based supervisor that implements\nthe required callbacks. The sections below use `start_link/2` to start\nsupervisors in most examples, but it also includes a specific section\non module-based ones.\n\n## Examples\n\nIn order to start a supervisor, we need to first define a child process\nthat will be supervised. As an example, we will define a `GenServer`,\na generic server, that keeps a counter. Other processes can then send\nmessages to this process to read the counter and bump its value.\n\n> #### Disclaimer {: .neutral}\n>\n> In practice you would not define a counter as a GenServer. Instead,\n> if you need a counter, you would pass it around as inputs and outputs to\n> the functions that need it. The reason we picked a counter in this example\n> is due to its simplicity, as it allows us to focus on how supervisors work.\n\n    defmodule Counter do\n      use GenServer\n\n      def start_link(arg) when is_integer(arg) do\n        GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n      end\n\n      ## Callbacks\n\n      @impl true\n      def init(counter) do\n        {:ok, counter}\n      end\n\n      @impl true\n      def handle_call(:get, _from, counter) do\n        {:reply, counter, counter}\n      end\n\n      def handle_call({:bump, value}, _from, counter) do\n        {:reply, counter, counter + value}\n      end\n    end\n\nThe `Counter` receives an argument on `start_link`. This argument\nis passed to the `init/1` callback which becomes the initial value\nof the counter. Our counter handles two operations (known as calls):\n`:get`, to get the current counter value, and `:bump`, that bumps\nthe counter by the given `value` and returns the old counter.\n\nWe can now start a supervisor that will start and supervise our\ncounter process. The first step is to define a list of **child\nspecifications** that control how each child behaves. Each child\nspecification is a map, as shown below:\n\n    children = [\n      # The Counter is a child started via Counter.start_link(0)\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [0]}\n      }\n    ]\n\n    # Now we start the supervisor with the children and a strategy\n    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n\n    # After started, we can query the supervisor for information\n    Supervisor.count_children(pid)\n    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n\nNote that when starting the GenServer, we are registering it\nwith name `Counter` via the `name: __MODULE__` option. This allows\nus to call it directly and get its value:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\n    GenServer.call(Counter, {:bump, 3})\n    #=> 0\n\n    GenServer.call(Counter, :get)\n    #=> 3\n\nHowever, there is a bug in our counter server. If we call `:bump` with\na non-numeric value, it is going to crash:\n\n    GenServer.call(Counter, {:bump, \"oops\"})\n    ** (exit) exited in: GenServer.call(Counter, {:bump, \"oops\"}, 5000)\n\nLuckily, since the server is being supervised by a supervisor, the\nsupervisor will automatically start a new one, reset back to its initial\nvalue of `0`:\n\n    GenServer.call(Counter, :get)\n    #=> 0\n\nSupervisors support different strategies; in the example above, we\nhave chosen `:one_for_one`. Furthermore, each supervisor can have many\nworkers and/or supervisors as children, with each one having its own\nconfiguration (as outlined in the \"Child specification\" section).\n\nThe rest of this document will cover how child processes are specified,\nhow they can be started and stopped, different supervision strategies\nand more.\n\n## Child specification\n\nThe child specification describes how the supervisor starts, shuts down,\nand restarts child processes.\n\nThe child specification is a map containing up to 6 elements. The first two keys\nin the following list are required, and the remaining ones are optional:\n\n  * `:id` - any term used to identify the child specification internally by\n    the supervisor; defaults to the given module. This key is required.\n    For supervisors, in the case of conflicting `:id` values, the supervisor\n    will refuse to initialize and require explicit IDs. This is not the case\n    for [dynamic supervisors](`DynamicSupervisor`) though.\n\n  * `:start` - a tuple with the module-function-args to be invoked\n    to start the child process. This key is required.\n\n  * `:restart` - an atom that defines when a terminated child process\n     should be restarted (see the \"Restart values\" section below).\n     This key is optional and defaults to `:permanent`.\n\n  * `:shutdown` - an integer or atom that defines how a child process should\n    be terminated (see the \"Shutdown values\" section below). This key\n    is optional and defaults to `5_000` if the type is `:worker` or\n    `:infinity` if the type is `:supervisor`.\n\n  * `:type` - specifies that the child process is a `:worker` or a\n    `:supervisor`. This key is optional and defaults to `:worker`.\n\n  * `:modules` - a list of modules used by hot code upgrade mechanisms\n    to determine which processes are using certain modules. It is typically\n    set to the callback module of behaviours like `GenServer`, `Supervisor`,\n    and such. It is set automatically based on the `:start` value and it is rarely\n    changed in practice.\n\n  * `:significant` - a boolean indicating if the child process should be\n    considered significant with regard to automatic shutdown.  Only `:transient`\n    and `:temporary` child processes can be marked as significant. This key is\n    optional and defaults to `false`. See section \"Automatic shutdown\" below\n    for more details.\n\nLet's understand what the `:shutdown` and `:restart` options control.\n\n### Shutdown values (:shutdown)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally and immediately\n    terminated using `Process.exit(child, :kill)`.\n\n  * any integer >= 0 - the amount of time in milliseconds that the\n    supervisor will wait for its children to terminate after emitting a\n    `Process.exit(child, :shutdown)` signal. If the child process is\n    not trapping exits, the initial `:shutdown` signal will terminate\n    the child process immediately. If the child process is trapping\n    exits, it has the given amount of time to terminate.\n    If it doesn't terminate within the specified time, the child process\n    is unconditionally terminated by the supervisor via\n    `Process.exit(child, :kill)`.\n\n  * `:infinity` - works as an integer except the supervisor will wait\n    indefinitely for the child to terminate. If the child process is a\n    supervisor, the recommended value is `:infinity` to give the supervisor\n    and its children enough time to shut down. This option can be used with\n    regular workers but doing so is discouraged and requires extreme care.\n    If not used carefully, the child process will never terminate,\n    preventing your application from terminating as well.\n\n### Restart values (:restart)\n\nThe `:restart` option controls what the supervisor should consider to\nbe a successful termination or not. If the termination is successful,\nthe supervisor won't restart the child. If the child process crashed,\nthe supervisor will start a new one.\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted.\n\n  * `:temporary` - the child process is never restarted, regardless\n    of the supervision strategy: any termination (even abnormal) is\n    considered successful.\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown`, or `{:shutdown, term}`.\n\nFor a more complete understanding of the exit reasons and their\nimpact, see the \"Exit reasons and restarts\" section.\n\n## `child_spec/1` function\n\nWhen starting a supervisor, we may pass a list of child specifications. Those\nspecifications are maps that tell how the supervisor should start, stop and\nrestart each of its children:\n\n    %{\n      id: Counter,\n      start: {Counter, :start_link, [0]}\n    }\n\nThe map above defines a child with `:id` of `Counter` that is started\nby calling `Counter.start_link(0)`.\n\nHowever, defining the child specification for each child as a map can be\nquite error prone, as we may change the `Counter` implementation and forget\nto update its specification. That's why Elixir allows you to pass a tuple with\nthe module name and the `start_link` argument instead of the specification:\n\n    children = [\n      {Counter, 0}\n    ]\n\nThe supervisor will then invoke `Counter.child_spec(0)` to retrieve a child\nspecification. Now the `Counter` module is responsible for building its own\nspecification, for example, we could write:\n\n    def child_spec(arg) do\n      %{\n        id: Counter,\n        start: {Counter, :start_link, [arg]}\n      }\n    end\n\nLuckily for us, `use GenServer` already defines a `Counter.child_spec/1`\nexactly like above, so you don't need to write the definition above yourself.\nIf you want to customize the automatically generated `child_spec/1` function,\nyou can pass the options directly to `use GenServer`:\n\n    use GenServer, restart: :transient\n\nFinally, note it is also possible to simply pass the `Counter` module as\na child:\n\n    children = [\n      Counter\n    ]\n\nWhen only the module name is given, it is equivalent to `{Counter, []}`,\nwhich in our case would be invalid, which is why we always pass the initial\ncounter explicitly.\n\nBy replacing the child specification with `{Counter, 0}`, we keep it\nencapsulated in the `Counter` module. We could now share our\n`Counter` implementation with other developers and they can add it directly\nto their supervision tree without worrying about the low-level details of\nthe counter.\n\nOverall, a child specification can be one of the following:\n\n  * a map representing the child specification itself - as outlined in the\n    \"Child specification\" section\n\n  * a tuple with a module as first element and the start argument as second -\n    such as `{Counter, 0}`. In this case, `Counter.child_spec(0)` is called\n    to retrieve the child specification\n\n  * a module - such as `Counter`. In this case, `Counter.child_spec([])`\n    would be called, which is invalid for the counter, but it is useful in\n    many other cases, especially when you want to pass a list of options\n    to the child process\n\nIf you need to convert a `{module, arg}` tuple or a module child specification to a\n[child specification](`t:child_spec/0`) or modify a child specification itself,\nyou can use the `Supervisor.child_spec/2` function.\nFor example, to run the counter with a different `:id` and a `:shutdown` value of\n10 seconds (10_000 milliseconds):\n\n    children = [\n      Supervisor.child_spec({Counter, 0}, id: MyCounter, shutdown: 10_000)\n    ]\n\n## Supervisor strategies and options\n\nSo far we have started the supervisor passing a single child as a tuple\nas well as a strategy called `:one_for_one`:\n\n    children = [\n      {Counter, 0}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe first argument given to `start_link/2` is a list of child\nspecifications as defined in the \"child_spec/1\" section above.\n\nThe second argument is a keyword list of options:\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one` or `:one_for_all`. Required.\n    See the \"Strategies\" section.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\n  * `:auto_shutdown` - the automatic shutdown option. It can be\n    `:never`, `:any_significant`, or `:all_significant`. Optional.\n    See the \"Automatic shutdown\" section.\n\n  * `:name` - a name to register the supervisor process. Supported values are\n    explained in the \"Name registration\" section in the documentation for\n    `GenServer`. Optional.\n\n### Strategies\n\nSupervisors support different supervision strategies (through the\n`:strategy` option, as seen above):\n\n  * `:one_for_one` - if a child process terminates, only that\n    process is restarted.\n\n  * `:one_for_all` - if a child process terminates, all other child\n    processes are terminated and then all child processes (including\n    the terminated one) are restarted.\n\n  * `:rest_for_one` - if a child process terminates, the terminated child\n    process and the rest of the children started after it, are terminated and\n    restarted.\n\nIn the above, process termination refers to unsuccessful termination, which\nis determined by the `:restart` option.\n\nTo efficiently supervise children started dynamically, see `DynamicSupervisor`.\n\n### Automatic shutdown\n\nSupervisors have the ability to automatically shut themselves down when child\nprocesses marked as `:significant` exit.\n\nSupervisors support different automatic shutdown options (through\nthe `:auto_shutdown` option, as seen above):\n\n  * `:never` - this is the default, automatic shutdown is disabled.\n\n  * `:any_significant` - if any significant child process exits, the supervisor\n  will automatically shut down its children, then itself.\n\n  * `:all_significant` - when all significant child processes have exited,\n  the supervisor will automatically shut down its children, then itself.\n\nOnly `:transient` and `:temporary` child processes can be marked as significant,\nand this configuration affects the behavior. Significant `:transient` child\nprocesses must exit normally for automatic shutdown to be considered, where\n`:temporary` child processes may exit for any reason.\n\n### Name registration\n\nA supervisor is bound to the same name registration rules as a `GenServer`.\nRead more about these rules in the documentation for `GenServer`.\n\n## Module-based supervisors\n\nIn the example so far, the supervisor was started by passing the supervision\nstructure to `start_link/2`. However, supervisors can also be created by\nexplicitly defining a supervision module:\n\n    defmodule MyApp.Supervisor do\n      # Automatically defines child_spec/1\n      use Supervisor\n\n      def start_link(init_arg) do\n        Supervisor.start_link(__MODULE__, init_arg, name: __MODULE__)\n      end\n\n      @impl true\n      def init(_init_arg) do\n        children = [\n          {Counter, 0}\n        ]\n\n        Supervisor.init(children, strategy: :one_for_one)\n      end\n    end\n\nThe difference between the two approaches is that a module-based\nsupervisor gives you more direct control over how the supervisor\nis initialized. Instead of calling `Supervisor.start_link/2` with\na list of child specifications that are automatically initialized, we manually\ninitialize the children by calling `Supervisor.init/2` inside its\n`c:init/1` callback. `Supervisor.init/2` accepts the same `:strategy`,\n`:max_restarts`, and `:max_seconds` options as `start_link/2`.\n\n`use Supervisor` also defines a `child_spec/1` function which allows\nus to run `MyApp.Supervisor` as a child of another supervisor or\nat the top of your supervision tree as:\n\n    children = [\n      MyApp.Supervisor\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nA general guideline is to use the supervisor without a callback\nmodule only at the top of your supervision tree, generally in the\n`c:Application.start/2` callback. We recommend using module-based\nsupervisors for any other supervisor in your application, so they\ncan run as a child of another supervisor in the tree. The `child_spec/1`\ngenerated automatically by `Supervisor` can be customized with the\nfollowing options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the supervisor should be restarted, defaults to `:permanent`\n\nThe `@doc` annotation immediately preceding `use Supervisor` will be\nattached to the generated `child_spec/1` function.\n\n## Start and shutdown\n\nWhen the supervisor starts, it traverses all child specifications and\nthen starts each child in the order they are defined. This is done by\ncalling the function defined under the `:start` key in the child\nspecification and typically defaults to `start_link/1`.\n\nThe `start_link/1` (or a custom) is then called for each child process.\nThe `start_link/1` function must return `{:ok, pid}` where `pid` is the\nprocess identifier of a new process that is linked to the supervisor.\nThe child process usually starts its work by executing the `c:init/1`\ncallback. Generally speaking, the `init` callback is where we initialize\nand configure the child process.\n\nThe shutdown process happens in reverse order.\n\nWhen a supervisor shuts down, it terminates all children in the opposite\norder they are listed. The termination happens by sending a shutdown exit\nsignal, via `Process.exit(child_pid, :shutdown)`, to the child process and\nthen awaiting for a time interval for the child process to terminate. This\ninterval defaults to 5000 milliseconds. If the child process does not\nterminate in this interval, the supervisor abruptly terminates the child\nwith reason `:kill`. The shutdown time can be configured in the child\nspecification which is fully detailed in the next section.\n\nIf the child process is not trapping exits, it will shutdown immediately\nwhen it receives the first exit signal. If the child process is trapping\nexits, then the `terminate` callback is invoked, and the child process\nmust terminate in a reasonable time interval before being abruptly\nterminated by the supervisor.\n\nIn other words, if it is important that a process cleans after itself\nwhen your application or the supervision tree is shutting down, then\nthis process must trap exits and its child specification should specify\nthe proper `:shutdown` value, ensuring it terminates within a reasonable\ninterval.\n\n## Exit reasons and restarts\n\nA supervisor restarts a child process depending on its `:restart` configuration.\nFor example, when `:restart` is set to `:transient`, the supervisor does not\nrestart the child in case it exits with reason `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nThose exits also impact logging. By default, behaviours such as GenServers\ndo not emit error logs when the exit reason is `:normal`, `:shutdown` or\n`{:shutdown, term}`.\n\nSo one may ask: which exit reason should I choose? There are three options:\n\n  * `:normal` - in such cases, the exit won't be logged, there is no restart\n    in transient mode, and linked processes do not exit\n\n  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n    logged, there is no restart in transient mode, and linked processes exit\n    with the same reason unless they're trapping exits\n\n  * any other term - in such cases, the exit will be logged, there are\n    restarts in transient mode, and linked processes exit with the same\n    reason unless they're trapping exits\n\nGenerally speaking, if you are exiting for expected reasons, you want to use\n`:shutdown` or `{:shutdown, term}`.\n\nNote that the supervisor that reaches maximum restart intensity will exit with\n`:shutdown` reason. In this case the supervisor will only be restarted if its\nchild specification was defined with the `:restart` option set to `:permanent`\n(the default).\n","title":"Supervisor","type":"behaviour"},{"doc":"Builds and overrides a child specification. Similar to start_link/2 and init/2 , it expects a module, {module, arg} , or a child specification . If a two-element tuple in the shape of {module, arg} is given, the child specification is retrieved by calling module.child_spec(arg) . If a module is given, the child specification is retrieved by calling module.child_spec([]) . After the child specification is retrieved, the fields on overrides are directly applied on the child spec. If overrides has keys that do not map to any child specification field, an error is raised. See the &quot;Child specification&quot; section in the module documentation for all of the available keys for overriding. Examples This function is often used to set an :id option when the same module needs to be started multiple times in the supervision tree: Supervisor . child_spec ( { Agent , fn -&gt; :ok end } , id : { Agent , 1 } ) #=&gt; %{id: {Agent, 1}, #=&gt; start: {Agent, :start_link, [fn -&gt; :ok end]}}","ref":"Supervisor.html#child_spec/2","source_doc":"Builds and overrides a child specification.\n\nSimilar to `start_link/2` and `init/2`, it expects a module, `{module, arg}`,\nor a [child specification](`t:child_spec/0`).\n\nIf a two-element tuple in the shape of `{module, arg}` is given,\nthe child specification is retrieved by calling `module.child_spec(arg)`.\n\nIf a module is given, the child specification is retrieved by calling\n`module.child_spec([])`.\n\nAfter the child specification is retrieved, the fields on `overrides`\nare directly applied on the child spec. If `overrides` has keys that\ndo not map to any child specification field, an error is raised.\n\nSee the \"Child specification\" section in the module documentation\nfor all of the available keys for overriding.\n\n## Examples\n\nThis function is often used to set an `:id` option when\nthe same module needs to be started multiple times in the\nsupervision tree:\n\n    Supervisor.child_spec({Agent, fn -> :ok end}, id: {Agent, 1})\n    #=> %{id: {Agent, 1},\n    #=>   start: {Agent, :start_link, [fn -> :ok end]}}\n\n","title":"Supervisor.child_spec/2","type":"function"},{"doc":"Returns a map containing count values for the given supervisor. The map contains the following keys: :specs - the total count of children, dead or alive :active - the count of all actively running child processes managed by this supervisor :supervisors - the count of all supervisors whether or not these child supervisors are still alive :workers - the count of all workers, whether or not these child workers are still alive","ref":"Supervisor.html#count_children/1","source_doc":"Returns a map containing count values for the given supervisor.\n\nThe map contains the following keys:\n\n  * `:specs` - the total count of children, dead or alive\n\n  * `:active` - the count of all actively running child processes managed by\n    this supervisor\n\n  * `:supervisors` - the count of all supervisors whether or not these\n    child supervisors are still alive\n\n  * `:workers` - the count of all workers, whether or not these child workers\n    are still alive\n\n","title":"Supervisor.count_children/1","type":"function"},{"doc":"Deletes the child specification identified by child_id . The corresponding child process must not be running; use terminate_child/2 to terminate it if it's running. If successful, this function returns :ok . This function may return an error with an appropriate error tuple if the child_id is not found, or if the current process is running or being restarted.","ref":"Supervisor.html#delete_child/2","source_doc":"Deletes the child specification identified by `child_id`.\n\nThe corresponding child process must not be running; use `terminate_child/2`\nto terminate it if it's running.\n\nIf successful, this function returns `:ok`. This function may return an error\nwith an appropriate error tuple if the `child_id` is not found, or if the\ncurrent process is running or being restarted.\n","title":"Supervisor.delete_child/2","type":"function"},{"doc":"Callback invoked to start the supervisor and during hot code upgrades. Developers typically invoke Supervisor.init/2 at the end of their init callback to return the proper supervision flags.","ref":"Supervisor.html#c:init/1","source_doc":"Callback invoked to start the supervisor and during hot code upgrades.\n\nDevelopers typically invoke `Supervisor.init/2` at the end of their\ninit callback to return the proper supervision flags.\n","title":"Supervisor.init/1","type":"callback"},{"doc":"Receives a list of child specifications to initialize and a set of options . This is typically invoked at the end of the init/1 callback of module-based supervisors. See the sections &quot;Supervisor strategies and options&quot; and &quot;Module-based supervisors&quot; in the module documentation for more information. This function returns a tuple containing the supervisor flags and child specifications. Examples def init ( _init_arg ) do children = [ { Counter , 0 } ] Supervisor . init ( children , strategy : :one_for_one ) end Options :strategy - the supervision strategy option. It can be either :one_for_one , :rest_for_one , or :one_for_all :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in seconds in which :max_restarts applies. Defaults to 5 . :auto_shutdown - the automatic shutdown option. It can be either :never , :any_significant , or :all_significant The :strategy option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the Supervisor module for a detailed description of the available strategies.","ref":"Supervisor.html#init/2","source_doc":"Receives a list of child specifications to initialize and a set of `options`.\n\nThis is typically invoked at the end of the `c:init/1` callback of\nmodule-based supervisors. See the sections \"Supervisor strategies and options\" and\n\"Module-based supervisors\" in the module documentation for more information.\n\nThis function returns a tuple containing the supervisor\nflags and child specifications.\n\n## Examples\n\n    def init(_init_arg) do\n      children = [\n        {Counter, 0}\n      ]\n\n      Supervisor.init(children, strategy: :one_for_one)\n    end\n\n## Options\n\n  * `:strategy` - the supervision strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, or `:one_for_all`\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in seconds in which `:max_restarts`\n    applies. Defaults to `5`.\n\n  * `:auto_shutdown` - the automatic shutdown option. It can be either\n    `:never`, `:any_significant`, or `:all_significant`\n\nThe `:strategy` option is required and by default a maximum of 3 restarts\nis allowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.\n","title":"Supervisor.init/2","type":"function"},{"doc":"Restarts a child process identified by child_id . The child specification must exist and the corresponding child process must not be running. Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children. If the child process start function returns {:ok, child} or {:ok, child, info} , the PID is added to the supervisor and this function returns the same value. If the child process start function returns :ignore , the PID remains set to :undefined and this function returns {:ok, :undefined} . This function may return an error with an appropriate error tuple if the child_id is not found, or if the current process is running or being restarted. If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns {:error, error} .","ref":"Supervisor.html#restart_child/2","source_doc":"Restarts a child process identified by `child_id`.\n\nThe child specification must exist and the corresponding child process must not\nbe running.\n\nNote that for temporary children, the child specification is automatically deleted\nwhen the child terminates, and thus it is not possible to restart such children.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\nthe PID is added to the supervisor and this function returns the same value.\n\nIf the child process start function returns `:ignore`, the PID remains set to\n`:undefined` and this function returns `{:ok, :undefined}`.\n\nThis function may return an error with an appropriate error tuple if the\n`child_id` is not found, or if the current process is running or being\nrestarted.\n\nIf the child process start function returns an error tuple or an erroneous value,\nor if it fails, this function returns `{:error, error}`.\n","title":"Supervisor.restart_child/2","type":"function"},{"doc":"Adds a child specification to supervisor and starts that child. child_spec should be a valid child specification. The child process will be started as defined in the child specification. If a child specification with the specified ID already exists, child_spec is discarded and this function returns an error with :already_started or :already_present if the corresponding child process is running or not, respectively. If the child process start function returns {:ok, child} or {:ok, child, info} , then child specification and PID are added to the supervisor and this function returns the same value. If the child process start function returns :ignore , the child specification is added to the supervisor, the PID is set to :undefined and this function returns {:ok, :undefined} . If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns {:error, error} where error is a term containing information about the error and child specification.","ref":"Supervisor.html#start_child/2","source_doc":"Adds a child specification to `supervisor` and starts that child.\n\n`child_spec` should be a valid child specification. The child process will\nbe started as defined in the child specification.\n\nIf a child specification with the specified ID already exists, `child_spec` is\ndiscarded and this function returns an error with `:already_started` or\n`:already_present` if the corresponding child process is running or not,\nrespectively.\n\nIf the child process start function returns `{:ok, child}` or `{:ok, child,\ninfo}`, then child specification and PID are added to the supervisor and\nthis function returns the same value.\n\nIf the child process start function returns `:ignore`, the child specification\nis added to the supervisor, the PID is set to `:undefined` and this function\nreturns `{:ok, :undefined}`.\n\nIf the child process start function returns an error tuple or an erroneous\nvalue, or if it fails, the child specification is discarded and this function\nreturns `{:error, error}` where `error` is a term containing information about\nthe error and child specification.\n","title":"Supervisor.start_child/2","type":"function"},{"doc":"Starts a supervisor with the given children. children is a list of the following forms: a child specification a module, where module.child_spec([]) will be invoked to retrieve its child specification a two-element tuple in the shape of {module, arg} , where module.child_spec(arg) will be invoked to retrieve its child specification A strategy is required to be provided through the :strategy option. See &quot;Supervisor strategies and options&quot; for examples and other options. The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the GenServer module docs. If the supervisor and all child processes are successfully spawned (if the start function of each child process returns {:ok, child} , {:ok, child, info} , or :ignore ), this function returns {:ok, pid} , where pid is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns {:error, {:already_started, pid}} , where pid is the PID of that process. If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason :shutdown all the child processes that have already been started, and then terminates itself and returns {:error, {:shutdown, reason}} . Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with :normal reason.","ref":"Supervisor.html#start_link/2","source_doc":"Starts a supervisor with the given children.\n\n`children` is a list of the following forms:\n\n  * a [child specification](`t:child_spec/0`)\n\n  * a module, where `module.child_spec([])` will be invoked to retrieve\n    its child specification\n\n  * a two-element tuple in the shape of `{module, arg}`, where `module.child_spec(arg)`\n    will be invoked to retrieve its child specification\n\nA strategy is required to be provided through the `:strategy` option. See\n\"Supervisor strategies and options\" for examples and other options.\n\nThe options can also be used to register a supervisor name.\nThe supported values are described under the \"Name registration\"\nsection in the `GenServer` module docs.\n\nIf the supervisor and all child processes are successfully spawned\n(if the start function of each child process returns `{:ok, child}`,\n`{:ok, child, info}`, or `:ignore`), this function returns\n`{:ok, pid}`, where `pid` is the PID of the supervisor. If the supervisor\nis given a name and a process with the specified name already exists,\nthe function returns `{:error, {:already_started, pid}}`, where `pid`\nis the PID of that process.\n\nIf the start function of any of the child processes fails or returns an error\ntuple or an erroneous value, the supervisor first terminates with reason\n`:shutdown` all the child processes that have already been started, and then\nterminates itself and returns `{:error, {:shutdown, reason}}`.\n\nNote that a supervisor started with this function is linked to the parent\nprocess and exits not only on crashes but also if the parent process exits\nwith `:normal` reason.\n","title":"Supervisor.start_link/2","type":"function"},{"doc":"Starts a module-based supervisor process with the given module and init_arg . To start the supervisor, the init/1 callback will be invoked in the given module , with init_arg as its argument. The init/1 callback must return a supervisor specification which can be created with the help of the init/2 function. If the init/1 callback returns :ignore , this function returns :ignore as well and the supervisor terminates with reason :normal . If it fails or returns an incorrect value, this function returns {:error, term} where term is a term with information about the error, and the supervisor terminates with reason term . The :name option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the GenServer module docs.","ref":"Supervisor.html#start_link/3","source_doc":"Starts a module-based supervisor process with the given `module` and `init_arg`.\n\nTo start the supervisor, the `c:init/1` callback will be invoked in the given\n`module`, with `init_arg` as its argument. The `c:init/1` callback must return a\nsupervisor specification which can be created with the help of the `init/2`\nfunction.\n\nIf the `c:init/1` callback returns `:ignore`, this function returns\n`:ignore` as well and the supervisor terminates with reason `:normal`.\nIf it fails or returns an incorrect value, this function returns\n`{:error, term}` where `term` is a term with information about the\nerror, and the supervisor terminates with reason `term`.\n\nThe `:name` option can also be given in order to register a supervisor\nname, the supported values are described in the \"Name registration\"\nsection in the `GenServer` module docs.\n","title":"Supervisor.start_link/3","type":"function"},{"doc":"Synchronously stops the given supervisor with the given reason . It returns :ok if the supervisor terminates with the given reason. If it terminates with another reason, the call exits. This function keeps OTP semantics regarding error reporting. If the reason is any other than :normal , :shutdown or {:shutdown, _} , an error report is logged.","ref":"Supervisor.html#stop/3","source_doc":"Synchronously stops the given supervisor with the given `reason`.\n\nIt returns `:ok` if the supervisor terminates with the given\nreason. If it terminates with another reason, the call exits.\n\nThis function keeps OTP semantics regarding error reporting.\nIf the reason is any other than `:normal`, `:shutdown` or\n`{:shutdown, _}`, an error report is logged.\n","title":"Supervisor.stop/3","type":"function"},{"doc":"Terminates the given child identified by child_id . The process is terminated, if there's one. The child specification is kept unless the child is temporary. A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling restart_child/2 . Use delete_child/2 to remove the child specification. If successful, this function returns :ok . If there is no child specification for the given child ID, this function returns {:error, :not_found} .","ref":"Supervisor.html#terminate_child/2","source_doc":"Terminates the given child identified by `child_id`.\n\nThe process is terminated, if there's one. The child specification is\nkept unless the child is temporary.\n\nA non-temporary child process may later be restarted by the supervisor.\nThe child process can also be restarted explicitly by calling `restart_child/2`.\nUse `delete_child/2` to remove the child specification.\n\nIf successful, this function returns `:ok`. If there is no child\nspecification for the given child ID, this function returns\n`{:error, :not_found}`.\n","title":"Supervisor.terminate_child/2","type":"function"},{"doc":"Returns a list with information about all children of the given supervisor. Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception. This function returns a list of {id, child, type, modules} tuples, where: id - as defined in the child specification child - the PID of the corresponding child process, :restarting if the process is about to be restarted, or :undefined if there is no such process type - :worker or :supervisor , as specified by the child specification modules - as specified by the child specification","ref":"Supervisor.html#which_children/1","source_doc":"Returns a list with information about all children of the given supervisor.\n\nNote that calling this function when supervising a large number of children\nunder low memory conditions can cause an out of memory exception.\n\nThis function returns a list of `{id, child, type, modules}` tuples, where:\n\n  * `id` - as defined in the child specification\n\n  * `child` - the PID of the corresponding child process, `:restarting` if the\n    process is about to be restarted, or `:undefined` if there is no such\n    process\n\n  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n\n  * `modules` - as specified by the child specification\n\n","title":"Supervisor.which_children/1","type":"function"},{"doc":"Supported automatic shutdown options","ref":"Supervisor.html#t:auto_shutdown/0","source_doc":"Supported automatic shutdown options","title":"Supervisor.auto_shutdown/0","type":"type"},{"doc":"A child process. It can be a PID when the child process was started, or :undefined when the child was created by a dynamic supervisor .","ref":"Supervisor.html#t:child/0","source_doc":"A child process.\n\nIt can be a PID when the child process was started, or `:undefined` when\nthe child was created by a [dynamic supervisor](`DynamicSupervisor`).\n","title":"Supervisor.child/0","type":"type"},{"doc":"The supervisor child specification. It defines how the supervisor should start, stop and restart each of its children.","ref":"Supervisor.html#t:child_spec/0","source_doc":"The supervisor child specification.\n\nIt defines how the supervisor should start, stop and restart each of its children.\n","title":"Supervisor.child_spec/0","type":"type"},{"doc":"Options given to start_link/2 and init/2","ref":"Supervisor.html#t:init_option/0","source_doc":"Options given to `start_link/2` and `init/2`","title":"Supervisor.init_option/0","type":"type"},{"doc":"The supervisor name","ref":"Supervisor.html#t:name/0","source_doc":"The supervisor name","title":"Supervisor.name/0","type":"type"},{"doc":"Return values of start_link functions","ref":"Supervisor.html#t:on_start/0","source_doc":"Return values of `start_link` functions","title":"Supervisor.on_start/0","type":"type"},{"doc":"Return values of start_child functions","ref":"Supervisor.html#t:on_start_child/0","source_doc":"Return values of `start_child` functions","title":"Supervisor.on_start_child/0","type":"type"},{"doc":"Option values used by the start* functions","ref":"Supervisor.html#t:option/0","source_doc":"Option values used by the `start*` functions","title":"Supervisor.option/0","type":"type"},{"doc":"Supported restart options","ref":"Supervisor.html#t:restart/0","source_doc":"Supported restart options","title":"Supervisor.restart/0","type":"type"},{"doc":"Supported shutdown options","ref":"Supervisor.html#t:shutdown/0","source_doc":"Supported shutdown options","title":"Supervisor.shutdown/0","type":"type"},{"doc":"Supported strategies","ref":"Supervisor.html#t:strategy/0","source_doc":"Supported strategies","title":"Supervisor.strategy/0","type":"type"},{"doc":"The supervisor flags returned on init","ref":"Supervisor.html#t:sup_flags/0","source_doc":"The supervisor flags returned on init","title":"Supervisor.sup_flags/0","type":"type"},{"doc":"The supervisor reference","ref":"Supervisor.html#t:supervisor/0","source_doc":"The supervisor reference","title":"Supervisor.supervisor/0","type":"type"},{"doc":"Supervisor type. Whether the supervisor is a worker or a supervisor.","ref":"Supervisor.html#t:type/0","source_doc":"Supervisor type.\n\nWhether the supervisor is a worker or a supervisor.\n","title":"Supervisor.type/0","type":"type"},{"doc":"Conveniences for spawning and awaiting tasks. Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously: task = Task . async ( fn -&gt; do_some_work ( ) end ) res = do_some_other_work ( ) res + Task . await ( task ) Tasks spawned with async can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed. Besides async/1 and await/2 , tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. We will explore these scenarios next. async and await One of the common uses of tasks is to convert sequential code into concurrent code with Task.async/1 while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result. Task.await/2 is used to read the message sent by the task. There are two important things to consider when using async : If you are using async tasks, you must await a reply as they are always sent. If you are not expecting a reply, consider using Task.start_link/1 as detailed below. async tasks link the caller and the spawned process. This means that, if the caller crashes, the task will crash too and vice-versa. This is on purpose: if the process meant to receive the result no longer exists, there is no purpose in completing the computation. If this is not desired, you will want to use supervised tasks, described next. Dynamically supervised tasks The Task.Supervisor module allows developers to dynamically create multiple supervised tasks. A short example is: { :ok , pid } = Task.Supervisor . start_link ( ) task = Task.Supervisor . async ( pid , fn -&gt; # Do something end ) Task . await ( task ) However, in the majority of cases, you want to add the task supervisor to your supervision tree: Supervisor . start_link ( [ { Task.Supervisor , name : MyApp.TaskSupervisor } ] , strategy : :one_for_one ) And now you can use async/await by passing the name of the supervisor instead of the pid: Task.Supervisor . async ( MyApp.TaskSupervisor , fn -&gt; # Do something end ) |&gt; Task . await ( ) We encourage developers to rely on supervised tasks as much as possible. Supervised tasks improve the visibility of how many tasks are running at a given moment and enable a variety of patterns that give you explicit control on how to handle the results, errors, and timeouts. Here is a summary: Using Task.Supervisor.start_child/2 allows you to start a fire-and-forget task when you don't care about its results or if it completes successfully or not. Using Task.Supervisor.async/2 + Task.await/2 allows you to execute tasks concurrently and retrieve its result. If the task fails, the caller will also fail. Using Task.Supervisor.async_nolink/2 + Task.yield/2 + Task.shutdown/2 allows you to execute tasks concurrently and retrieve their results or the reason they failed within a given time frame. If the task fails, the caller won't fail. You will receive the error reason either on yield or shutdown . Furthermore, the supervisor guarantees all tasks terminate within a configurable shutdown period when your application shuts down. See the Task.Supervisor module for details on the supported operations. Distributed tasks With Task.Supervisor , it is easy to dynamically start tasks across nodes: # On the remote node named :remote@local Task.Supervisor . start_link ( name : MyApp.DistSupervisor ) # On the client supervisor = { MyApp.DistSupervisor , :remote@local } Task.Supervisor . async ( supervisor , MyMod , :my_fun , [ arg1 , arg2 , arg3 ] ) Note that, when working with distributed tasks, one should use the Task.Supervisor.async/5 function that expects explicit module, function, and arguments, instead of Task.Supervisor.async/3 that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the Agent module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem. Statically supervised tasks The Task module implements the child_spec/1 function, which allows it to be started directly under a regular Supervisor - instead of a Task.Supervisor - by passing a tuple with a function to run: Supervisor . start_link ( [ { Task , fn -&gt; :some_work end } ] , strategy : :one_for_one ) This is often useful when you need to execute some steps while setting up your supervision tree. For example: to warm up caches, log the initialization status, and such. If you don't want to put the Task code directly under the Supervisor , you can wrap the Task in its own module, similar to how you would do with a GenServer or an Agent : defmodule MyTask do use Task def start_link ( arg ) do Task . start_link ( __MODULE__ , :run , [ arg ] ) end def run ( arg ) do # ... end end And then passing it to the supervisor: Supervisor . start_link ( [ { MyTask , arg } ] , strategy : :one_for_one ) Since these tasks are supervised and not directly linked to the caller, they cannot be awaited on. By default, the functions Task.start/1 and Task.start_link/1 are for fire-and-forget tasks, where you don't care about the results or if it completes successfully or not. use Task defines a child_spec/1 function, allowing the defined module to be put under a supervision tree. The generated child_spec/1 can be customized with the following options: :id - the child specification identifier, defaults to the current module :restart - when the child should be restarted, defaults to :temporary :shutdown - how to shut down the child, either immediately or by giving it time to shut down Opposite to GenServer , Agent and Supervisor , a Task has a default :restart of :temporary . This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do: use Task , restart : :transient If you want the task to always be restarted: use Task , restart : :permanent See the &quot;Child specification&quot; section in the Supervisor module for more detailed information. The @doc annotation immediately preceding use Task will be attached to the generated child_spec/1 function. Ancestor and Caller Tracking Whenever you start a new process, Elixir annotates the parent of that process through the $ancestors key in the process dictionary. This is often used to track the hierarchy inside a supervision tree. For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like Task.Supervisor.start_child(MySupervisor, task_function) . This means that, although your code is the one invoking the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it. To track the relationship between your code and the task, we use the $callers key in the process dictionary. Therefore, assuming the Task.Supervisor call above, we have: [ your code ] -- calls -- &gt; [ supervisor ] -- -- spawns -- &gt; [ task ] Which means we store the following relationships: [ your code ] [ supervisor ] &lt;- - ancestor -- [ task ] ^ | | -- -- -- -- -- -- -- -- -- -- - caller -- -- -- -- -- -- -- -- -- -- - | The list of callers of the current process can be retrieved from the Process dictionary with Process.get(:&quot;$callers&quot;) . This will return either nil or a list [pid_n, ..., pid2, pid1] with at least one entry where pid_n is the PID that called the current process, pid2 called pid_n , and pid2 was called by pid1 . If a task crashes, the callers field is included as part of the log message metadata under the :callers key.","ref":"Task.html","source_doc":"Conveniences for spawning and awaiting tasks.\n\nTasks are processes meant to execute one particular\naction throughout their lifetime, often with little or no\ncommunication with other processes. The most common use case\nfor tasks is to convert sequential code into concurrent code\nby computing a value asynchronously:\n\n    task = Task.async(fn -> do_some_work() end)\n    res = do_some_other_work()\n    res + Task.await(task)\n\nTasks spawned with `async` can be awaited on by their caller\nprocess (and only their caller) as shown in the example above.\nThey are implemented by spawning a process that sends a message\nto the caller once the given computation is performed.\n\nBesides `async/1` and `await/2`, tasks can also be\nstarted as part of a supervision tree and dynamically spawned\non remote nodes. We will explore these scenarios next.\n\n## async and await\n\nOne of the common uses of tasks is to convert sequential code\ninto concurrent code with `Task.async/1` while keeping its semantics.\nWhen invoked, a new process will be created, linked and monitored\nby the caller. Once the task action finishes, a message will be sent\nto the caller with the result.\n\n`Task.await/2` is used to read the message sent by the task.\n\nThere are two important things to consider when using `async`:\n\n  1. If you are using async tasks, you **must await** a reply\n     as they are *always* sent. If you are not expecting a reply,\n     consider using `Task.start_link/1` as detailed below.\n\n  2. async tasks link the caller and the spawned process. This\n     means that, if the caller crashes, the task will crash\n     too and vice-versa. This is on purpose: if the process\n     meant to receive the result no longer exists, there is\n     no purpose in completing the computation.\n\n     If this is not desired, you will want to use supervised\n     tasks, described next.\n\n## Dynamically supervised tasks\n\nThe `Task.Supervisor` module allows developers to dynamically\ncreate multiple supervised tasks.\n\nA short example is:\n\n    {:ok, pid} = Task.Supervisor.start_link()\n\n    task =\n      Task.Supervisor.async(pid, fn ->\n        # Do something\n      end)\n\n    Task.await(task)\n\nHowever, in the majority of cases, you want to add the task supervisor\nto your supervision tree:\n\n    Supervisor.start_link([\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ], strategy: :one_for_one)\n\nAnd now you can use async/await by passing the name of\nthe supervisor instead of the pid:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      # Do something\n    end)\n    |> Task.await()\n\nWe encourage developers to rely on supervised tasks as much as possible.\nSupervised tasks improve the visibility of how many tasks are running\nat a given moment and enable a variety of patterns that give you\nexplicit control on how to handle the results, errors, and timeouts.\nHere is a summary:\n\n  * Using `Task.Supervisor.start_child/2` allows you to start a fire-and-forget\n    task when you don't care about its results or if it completes successfully or not.\n\n  * Using `Task.Supervisor.async/2` + `Task.await/2` allows you to execute\n    tasks concurrently and retrieve its result. If the task fails,\n    the caller will also fail.\n\n  * Using `Task.Supervisor.async_nolink/2` + `Task.yield/2` + `Task.shutdown/2`\n    allows you to execute tasks concurrently and retrieve their results\n    or the reason they failed within a given time frame. If the task fails,\n    the caller won't fail. You will receive the error reason either on\n    `yield` or `shutdown`.\n\nFurthermore, the supervisor guarantees all tasks terminate within a\nconfigurable shutdown period when your application shuts down. See the\n`Task.Supervisor` module for details on the supported operations.\n\n### Distributed tasks\n\nWith `Task.Supervisor`, it is easy to dynamically start tasks across nodes:\n\n    # On the remote node named :remote@local\n    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n\n    # On the client\n    supervisor = {MyApp.DistSupervisor, :remote@local}\n    Task.Supervisor.async(supervisor, MyMod, :my_fun, [arg1, arg2, arg3])\n\nNote that, when working with distributed tasks, one should use the\n`Task.Supervisor.async/5` function that expects explicit module, function,\nand arguments, instead of `Task.Supervisor.async/3` that works with anonymous\nfunctions. That's because anonymous functions expect the same module version\nto exist on all involved nodes. Check the `Agent` module documentation for\nmore information on distributed processes as the limitations described there\napply to the whole ecosystem.\n\n## Statically supervised tasks\n\nThe `Task` module implements the `child_spec/1` function, which\nallows it to be started directly under a regular `Supervisor` -\ninstead of a `Task.Supervisor` - by passing a tuple with a function\nto run:\n\n    Supervisor.start_link([\n      {Task, fn -> :some_work end}\n    ], strategy: :one_for_one)\n\nThis is often useful when you need to execute some steps while\nsetting up your supervision tree. For example: to warm up caches,\nlog the initialization status, and such.\n\nIf you don't want to put the Task code directly under the `Supervisor`,\nyou can wrap the `Task` in its own module, similar to how you would\ndo with a `GenServer` or an `Agent`:\n\n    defmodule MyTask do\n      use Task\n\n      def start_link(arg) do\n        Task.start_link(__MODULE__, :run, [arg])\n      end\n\n      def run(arg) do\n        # ...\n      end\n    end\n\nAnd then passing it to the supervisor:\n\n    Supervisor.start_link([\n      {MyTask, arg}\n    ], strategy: :one_for_one)\n\nSince these tasks are supervised and not directly linked to the caller,\nthey cannot be awaited on. By default, the functions `Task.start/1`\nand `Task.start_link/1` are for fire-and-forget tasks, where you don't\ncare about the results or if it completes successfully or not.\n\n`use Task` defines a `child_spec/1` function, allowing the\ndefined module to be put under a supervision tree. The generated\n`child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:restart` - when the child should be restarted, defaults to `:temporary`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nOpposite to `GenServer`, `Agent` and `Supervisor`, a Task has\na default `:restart` of `:temporary`. This means the task will\nnot be restarted even if it crashes. If you desire the task to\nbe restarted for non-successful exits, do:\n\n    use Task, restart: :transient\n\nIf you want the task to always be restarted:\n\n    use Task, restart: :permanent\n\nSee the \"Child specification\" section in the `Supervisor` module\nfor more detailed information. The `@doc` annotation immediately\npreceding `use Task` will be attached to the generated `child_spec/1`\nfunction.\n\n## Ancestor and Caller Tracking\n\nWhenever you start a new process, Elixir annotates the parent of that process\nthrough the `$ancestors` key in the process dictionary. This is often used to\ntrack the hierarchy inside a supervision tree.\n\nFor example, we recommend developers to always start tasks under a supervisor.\nThis provides more visibility and allows you to control how those tasks are\nterminated when a node shuts down. That might look something like\n`Task.Supervisor.start_child(MySupervisor, task_function)`. This means\nthat, although your code is the one invoking the task, the actual ancestor of\nthe task is the supervisor, as the supervisor is the one effectively starting it.\n\nTo track the relationship between your code and the task, we use the `$callers`\nkey in the process dictionary. Therefore, assuming the `Task.Supervisor` call\nabove, we have:\n\n    [your code] -- calls --> [supervisor] ---- spawns --> [task]\n\nWhich means we store the following relationships:\n\n    [your code]              [supervisor] <-- ancestor -- [task]\n        ^                                                  |\n        |--------------------- caller ---------------------|\n\nThe list of callers of the current process can be retrieved from the Process\ndictionary with `Process.get(:\"$callers\")`. This will return either `nil` or\na list `[pid_n, ..., pid2, pid1]` with at least one entry where `pid_n` is\nthe PID that called the current process, `pid2` called `pid_n`, and `pid2` was\ncalled by `pid1`.\n\nIf a task crashes, the callers field is included as part of the log message\nmetadata under the `:callers` key.\n","title":"Task","type":"module"},{"doc":"The Task struct. It contains these fields: :mfa - a three-element tuple containing the module, function name, and arity invoked to start the task in async/1 and async/3 :owner - the PID of the process that started the task :pid - the PID of the task process; nil if there is no process specifically assigned for the task :ref - an opaque term used as the task monitor reference","ref":"Task.html#__struct__/0","source_doc":"The Task struct.\n\nIt contains these fields:\n\n  * `:mfa` - a three-element tuple containing the module, function name,\n    and arity invoked to start the task in `async/1` and `async/3`\n\n  * `:owner` - the PID of the process that started the task\n\n  * `:pid` - the PID of the task process; `nil` if there is no process\n    specifically assigned for the task\n\n  * `:ref` - an opaque term used as the task monitor reference\n\n","title":"Task.__struct__/0","type":"function"},{"doc":"Starts a task that must be awaited on. fun must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A Task struct is returned containing the relevant information. If you start an async , you must await . This is either done by calling Task.await/2 or Task.yield/2 followed by Task.shutdown/2 on the returned task. Alternatively, if you spawn a task inside a GenServer , then the GenServer will automatically await for you and call GenServer.handle_info/2 with the task response and associated :DOWN message. Read the Task module documentation for more information about the general usage of async tasks. Linking This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this: x = heavy_fun ( ) y = some_fun ( ) x + y Now you want to make the heavy_fun() async: x = Task . async ( &amp; heavy_fun / 0 ) y = some_fun ( ) Task . await ( x ) + y As before, if heavy_fun/0 fails, the whole computation will fail, including the caller process. If you don't want the task to fail then you must change the heavy_fun/0 code in the same way you would achieve it if you didn't have the async call. For example, to either return {:ok, val} | :error results or, in more extreme cases, by using try/rescue . In other words, an asynchronous task should be thought of as an extension of the caller process rather than a mechanism to isolate it from all errors. If you don't want to link the caller to the task, then you must use a supervised task with Task.Supervisor and call Task.Supervisor.async_nolink/2 . In any case, avoid any of the following: Setting :trap_exit to true - trapping exits should be used only in special circumstances as it would make your process immune to not only exits from the task but from any other processes. Moreover, even when trapping exits, calling await will still exit if the task has terminated without sending its result back. Unlinking the task process started with async / await . If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the caller process dies. Metadata The task created with this function stores :erlang.apply/2 in its :mfa metadata field, which is used internally to apply the anonymous function. Use async/3 if you want another function to be used as metadata.","ref":"Task.html#async/1","source_doc":"Starts a task that must be awaited on.\n\n`fun` must be a zero-arity anonymous function. This function\nspawns a process that is linked to and monitored by the caller\nprocess. A `Task` struct is returned containing the relevant\ninformation.\n\nIf you start an `async`, you **must await**. This is either done\nby calling `Task.await/2` or `Task.yield/2` followed by\n`Task.shutdown/2` on the returned task. Alternatively, if you\nspawn a task inside a `GenServer`, then the `GenServer` will\nautomatically await for you and call `c:GenServer.handle_info/2`\nwith the task response and associated `:DOWN` message.\n\nRead the `Task` module documentation for more information about\nthe general usage of async tasks.\n\n## Linking\n\nThis function spawns a process that is linked to and monitored\nby the caller process. The linking part is important because it\naborts the task if the parent process dies. It also guarantees\nthe code before async/await has the same properties after you\nadd the async call. For example, imagine you have this:\n\n    x = heavy_fun()\n    y = some_fun()\n    x + y\n\nNow you want to make the `heavy_fun()` async:\n\n    x = Task.async(&heavy_fun/0)\n    y = some_fun()\n    Task.await(x) + y\n\nAs before, if `heavy_fun/0` fails, the whole computation will\nfail, including the caller process. If you don't want the task\nto fail then you must change the `heavy_fun/0` code in the\nsame way you would achieve it if you didn't have the async call.\nFor example, to either return `{:ok, val} | :error` results or,\nin more extreme cases, by using `try/rescue`. In other words,\nan asynchronous task should be thought of as an extension of the\ncaller process rather than a mechanism to isolate it from all errors.\n\nIf you don't want to link the caller to the task, then you\nmust use a supervised task with `Task.Supervisor` and call\n`Task.Supervisor.async_nolink/2`.\n\nIn any case, avoid any of the following:\n\n  * Setting `:trap_exit` to `true` - trapping exits should be\n    used only in special circumstances as it would make your\n    process immune to not only exits from the task but from\n    any other processes.\n\n    Moreover, even when trapping exits, calling `await` will\n    still exit if the task has terminated without sending its\n    result back.\n\n  * Unlinking the task process started with `async`/`await`.\n    If you unlink the processes and the task does not belong\n    to any supervisor, you may leave dangling tasks in case\n    the caller process dies.\n\n## Metadata\n\nThe task created with this function stores `:erlang.apply/2` in\nits `:mfa` metadata field, which is used internally to apply\nthe anonymous function. Use `async/3` if you want another function\nto be used as metadata.\n","title":"Task.async/1","type":"function"},{"doc":"Starts a task that must be awaited on. Similar to async/1 except the function to be started is specified by the given module , function_name , and args . The module , function_name , and its arity are stored as a tuple in the :mfa field for reflection purposes.","ref":"Task.html#async/3","source_doc":"Starts a task that must be awaited on.\n\nSimilar to `async/1` except the function to be started is\nspecified by the given `module`, `function_name`, and `args`.\nThe `module`, `function_name`, and its arity are stored as\na tuple in the `:mfa` field for reflection purposes.\n","title":"Task.async/3","type":"function"},{"doc":"Returns a stream that runs the given function fun concurrently on each element in enumerable . Works the same as async_stream/5 but with an anonymous function instead of a module-function-arguments tuple. fun must be a one-arity anonymous function. Each enumerable element is passed as argument to the given function fun and processed by its own task. The tasks will be linked to the caller process, similarly to async/1 . Example Count the code points in each string asynchronously, then add the counts together using reduce. iex&gt; strings = [ &quot;long string&quot; , &quot;longer string&quot; , &quot;there are many of these&quot; ] iex&gt; stream = Task . async_stream ( strings , fn text -&gt; text |&gt; String . codepoints ( ) |&gt; Enum . count ( ) end ) iex&gt; Enum . reduce ( stream , 0 , fn { :ok , num } , acc -&gt; num + acc end ) 47 See async_stream/5 for discussion, options, and more examples.","ref":"Task.html#async_stream/3","source_doc":"Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nWorks the same as `async_stream/5` but with an anonymous function instead of a\nmodule-function-arguments tuple. `fun` must be a one-arity anonymous function.\n\nEach `enumerable` element is passed as argument to the given function `fun` and\nprocessed by its own task. The tasks will be linked to the caller process, similarly\nto `async/1`.\n\n## Example\n\nCount the code points in each string asynchronously, then add the counts together using reduce.\n\n    iex> strings = [\"long string\", \"longer string\", \"there are many of these\"]\n    iex> stream = Task.async_stream(strings, fn text -> text |> String.codepoints() |> Enum.count() end)\n    iex> Enum.reduce(stream, 0, fn {:ok, num}, acc -> num + acc end)\n    47\n\nSee `async_stream/5` for discussion, options, and more examples.\n","title":"Task.async_stream/3","type":"function"},{"doc":"Returns a stream where the given function ( module and function_name ) is mapped concurrently on each element in enumerable . Each element of enumerable will be prepended to the given args and processed by its own task. Those tasks will be linked to an intermediate process that is then linked to the caller process. This means a failure in a task terminates the caller process and a failure in the caller process terminates all tasks. When streamed, each task will emit {:ok, value} upon successful completion or {:exit, reason} if the caller is trapping exits. It's possible to have {:exit, {element, reason}} for exits using the :zip_input_on_exit option. The order of results depends on the value of the :ordered option. The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below). Consider using Task.Supervisor.async_stream/6 to start tasks under a supervisor. If you find yourself trapping exits to ensure errors in the tasks do not terminate the caller process, consider using Task.Supervisor.async_stream_nolink/6 to start tasks that are not linked to the caller process. Options :max_concurrency - sets the maximum number of tasks to run at the same time. Defaults to System.schedulers_online/0 . :ordered - whether the results should be returned in the same order as the input stream. When the output is ordered, Elixir may need to buffer results to emit them in the original order. Setting this option to false disables the need to buffer at the cost of removing ordering. This is also useful when you're using the tasks only for the side effects. Note that regardless of what :ordered is set to, the tasks will process asynchronously. If you need to process elements in order, consider using Enum.map/2 or Enum.each/2 instead. Defaults to true . :timeout - the maximum amount of time (in milliseconds or :infinity ) each task is allowed to execute for. Defaults to 5000 . :on_timeout - what to do when a task times out. The possible values are: :exit (default) - the caller (the process that spawned the tasks) exits. :kill_task - the task that timed out is killed. The value emitted for that task is {:exit, :timeout} . :zip_input_on_exit - (since v1.14.0) adds the original input to :exit tuples. The value emitted for that task is {:exit, {input, reason}} , where input is the collection element that caused an exited during processing. Defaults to false . Example Let's build a stream and then enumerate it: stream = Task . async_stream ( collection , Mod , :expensive_fun , [ ] ) Enum . to_list ( stream ) The concurrency can be increased or decreased using the :max_concurrency option. For example, if the tasks are IO heavy, the value can be increased: max_concurrency = System . schedulers_online ( ) * 2 stream = Task . async_stream ( collection , Mod , :expensive_fun , [ ] , max_concurrency : max_concurrency ) Enum . to_list ( stream ) If you do not care about the results of the computation, you can run the stream with Stream.run/1 . Also set ordered: false , as you don't care about the order of the results either: stream = Task . async_stream ( collection , Mod , :expensive_fun , [ ] , ordered : false ) Stream . run ( stream ) First async tasks to complete You can also use async_stream/3 to execute M tasks and find the N tasks to complete. For example: [ &amp; heavy_call_1 / 0 , &amp; heavy_call_2 / 0 , &amp; heavy_call_3 / 0 ] |&gt; Task . async_stream ( fn fun -&gt; fun . ( ) end , ordered : false , max_concurrency : 3 ) |&gt; Stream . filter ( &amp; match? ( { :ok , _ } , &amp;1 ) ) |&gt; Enum . take ( 2 ) In the example above, we are executing three tasks and waiting for the first 2 to complete. We use Stream.filter/2 to restrict ourselves only to successfully completed tasks, and then use Enum.take/2 to retrieve N items. Note it is important to set both ordered: false and max_concurrency: M , where M is the number of tasks, to make sure all calls execute concurrently. Attention: unbound async + take If you want to potentially process a high number of items and keep only part of the results, you may end-up processing more items than desired. Let's see an example: 1 .. 100 |&gt; Task . async_stream ( fn i -&gt; Process . sleep ( 100 ) IO . puts ( to_string ( i ) ) end ) |&gt; Enum . take ( 10 ) Running the example above in a machine with 8 cores will process 16 items, even though you want only 10 elements, since async_stream/3 process items concurrently. That's because it will process 8 elements at once. Then all 8 elements complete at roughly the same time, causing 8 elements to be kicked off for processing. Out of these extra 8, only 2 will be used, and the rest will be terminated. Depending on the problem, you can filter or limit the number of elements upfront: 1 .. 100 |&gt; Stream . take ( 10 ) |&gt; Task . async_stream ( fn i -&gt; Process . sleep ( 100 ) IO . puts ( to_string ( i ) ) end ) |&gt; Enum . to_list ( ) In other cases, you likely want to tweak :max_concurrency to limit how many elements may be over processed at the cost of reducing concurrency. You can also set the number of elements to take to be a multiple of :max_concurrency . For instance, setting max_concurrency: 5 in the example above.","ref":"Task.html#async_stream/5","source_doc":"Returns a stream where the given function (`module` and `function_name`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element of `enumerable` will be prepended to the given `args` and\nprocessed by its own task. Those tasks will be linked to an intermediate\nprocess that is then linked to the caller process. This means a failure\nin a task terminates the caller process and a failure in the caller\nprocess terminates all tasks.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nIt's possible to have `{:exit, {element, reason}}` for exits\nusing the `:zip_input_on_exit` option. The order of results depends\non the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nConsider using `Task.Supervisor.async_stream/6` to start tasks\nunder a supervisor. If you find yourself trapping exits to ensure\nerrors in the tasks do not terminate the caller process, consider\nusing `Task.Supervisor.async_stream_nolink/6` to start tasks that\nare not linked to the caller process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. When the output is ordered, Elixir may need to\n    buffer results to emit them in the original order. Setting this option\n    to false disables the need to buffer at the cost of removing ordering.\n    This is also useful when you're using the tasks only for the side effects.\n    Note that regardless of what `:ordered` is set to, the tasks will\n    process asynchronously. If you need to process elements in order,\n    consider using `Enum.map/2` or `Enum.each/2` instead. Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:exit` (default) - the caller (the process that spawned the tasks) exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:zip_input_on_exit` - (since v1.14.0) adds the original\n    input to `:exit` tuples. The value emitted for that task is\n    `{:exit, {input, reason}}`, where `input` is the collection element\n    that caused an exited during processing. Defaults to `false`.\n\n## Example\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\nThe concurrency can be increased or decreased using the `:max_concurrency`\noption. For example, if the tasks are IO heavy, the value can be increased:\n\n    max_concurrency = System.schedulers_online() * 2\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], max_concurrency: max_concurrency)\n    Enum.to_list(stream)\n\nIf you do not care about the results of the computation, you can run\nthe stream with `Stream.run/1`. Also set `ordered: false`, as you don't\ncare about the order of the results either:\n\n    stream = Task.async_stream(collection, Mod, :expensive_fun, [], ordered: false)\n    Stream.run(stream)\n\n## First async tasks to complete\n\nYou can also use `async_stream/3` to execute M tasks and find the N tasks\nto complete. For example:\n\n    [\n      &heavy_call_1/0,\n      &heavy_call_2/0,\n      &heavy_call_3/0\n    ]\n    |> Task.async_stream(fn fun -> fun.() end, ordered: false, max_concurrency: 3)\n    |> Stream.filter(&match?({:ok, _}, &1))\n    |> Enum.take(2)\n\nIn the example above, we are executing three tasks and waiting for the\nfirst 2 to complete. We use `Stream.filter/2` to restrict ourselves only\nto successfully completed tasks, and then use `Enum.take/2` to retrieve\nN items. Note it is important to set both `ordered: false` and\n`max_concurrency: M`, where M is the number of tasks, to make sure all\ncalls execute concurrently.\n\n### Attention: unbound async + take\n\nIf you want to potentially process a high number of items and keep only\npart of the results, you may end-up processing more items than desired.\nLet's see an example:\n\n    1..100\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.take(10)\n\nRunning the example above in a machine with 8 cores will process 16 items,\neven though you want only 10 elements, since `async_stream/3` process items\nconcurrently. That's because it will process 8 elements at once. Then all 8\nelements complete at roughly the same time, causing 8 elements to be kicked\noff for processing. Out of these extra 8, only 2 will be used, and the rest\nwill be terminated.\n\nDepending on the problem, you can filter or limit the number of elements\nupfront:\n\n    1..100\n    |> Stream.take(10)\n    |> Task.async_stream(fn i ->\n      Process.sleep(100)\n      IO.puts(to_string(i))\n    end)\n    |> Enum.to_list()\n\nIn other cases, you likely want to tweak `:max_concurrency` to limit how\nmany elements may be over processed at the cost of reducing concurrency.\nYou can also set the number of elements to take to be a multiple of\n`:max_concurrency`. For instance, setting `max_concurrency: 5` in the\nexample above.\n","title":"Task.async_stream/5","type":"function"},{"doc":"Awaits a task reply and returns it. In case the task process dies, the caller process will exit with the same reason as the task. A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . If the timeout is exceeded, then the caller process will exit. If the task process is linked to the caller process which is the case when a task is started with async , then the task process will also exit. If the task process is trapping exits or not linked to the caller process, then it will continue to run. This function assumes the task's monitor is still active or the monitor's :DOWN message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message. This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use yield/2 instead. Examples iex&gt; task = Task . async ( fn -&gt; 1 + 1 end ) iex&gt; Task . await ( task ) 2 Compatibility with OTP behaviours It is not recommended to await a long-running task inside an OTP behaviour such as GenServer . Instead, you should match on the message coming from a task inside your GenServer.handle_info/2 callback. A GenServer will receive two messages on handle_info/2 : {ref, result} - the reply message where ref is the monitor reference returned by the task.ref and result is the task result {:DOWN, ref, :process, pid, reason} - since all tasks are also monitored, you will also receive the :DOWN message delivered by Process.monitor/1 . If you receive the :DOWN message without a a reply, it means the task crashed Another consideration to have in mind is that tasks started by Task.async/1 are always linked to their callers and you may not want the GenServer to crash if the task crashes. Therefore, it is preferable to instead use Task.Supervisor.async_nolink/3 inside OTP behaviours. For completeness, here is an example of a GenServer that start tasks and handles their results: defmodule GenServerTaskExample do use GenServer def start_link ( opts ) do GenServer . start_link ( __MODULE__ , :ok , opts ) end def init ( _opts ) do # We will keep all running tasks in a map { :ok , %{ tasks : %{ } } } end # Imagine we invoke a task from the GenServer to access a URL... def handle_call ( :some_message , _from , state ) do url = ... task = Task.Supervisor . async_nolink ( MyApp.TaskSupervisor , fn -&gt; fetch_url ( url ) end ) # After we start the task, we store its reference and the url it is fetching state = put_in ( state . tasks [ task . ref ] , url ) { :reply , :ok , state } end # If the task succeeds... def handle_info ( { ref , result } , state ) do # The task succeed so we can demonitor its reference Process . demonitor ( ref , [ :flush ] ) { url , state } = pop_in ( state . tasks [ ref ] ) IO . puts &quot;Got \#{ inspect ( result ) } for URL \#{ inspect url } &quot; { :noreply , state } end # If the task fails... def handle_info ( { :DOWN , ref , _ , _ , reason } , state ) do { url , state } = pop_in ( state . tasks [ ref ] ) IO . puts &quot;URL \#{ inspect url } failed with reason \#{ inspect ( reason ) } &quot; { :noreply , state } end end With the server defined, you will want to start the task supervisor above and the GenServer in your supervision tree: children = [ { Task.Supervisor , name : MyApp.TaskSupervisor } , { GenServerTaskExample , name : MyApp.GenServerTaskExample } ] Supervisor . start_link ( children , strategy : :one_for_one )","ref":"Task.html#await/2","source_doc":"Awaits a task reply and returns it.\n\nIn case the task process dies, the caller process will exit with the same\nreason as the task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nIf the task process is linked to the caller process which is the case when\na task is started with `async`, then the task process will also exit. If the\ntask process is trapping exits or not linked to the caller process, then it\nwill continue to run.\n\nThis function assumes the task's monitor is still active or the monitor's\n`:DOWN` message is in the message queue. If it has been demonitored, or the\nmessage already received, this function will wait for the duration of the\ntimeout awaiting the message.\n\nThis function can only be called once for any given task. If you want\nto be able to check multiple times if a long-running task has finished\nits computation, use `yield/2` instead.\n\n## Examples\n\n    iex> task = Task.async(fn -> 1 + 1 end)\n    iex> Task.await(task)\n    2\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` a long-running task inside an OTP\nbehaviour such as `GenServer`. Instead, you should match on the message\ncoming from a task inside your `c:GenServer.handle_info/2` callback.\n\nA GenServer will receive two messages on `handle_info/2`:\n\n  * `{ref, result}` - the reply message where `ref` is the monitor\n    reference returned by the `task.ref` and `result` is the task\n    result\n\n  * `{:DOWN, ref, :process, pid, reason}` - since all tasks are also\n    monitored, you will also receive the `:DOWN` message delivered by\n    `Process.monitor/1`. If you receive the `:DOWN` message without a\n    a reply, it means the task crashed\n\nAnother consideration to have in mind is that tasks started by `Task.async/1`\nare always linked to their callers and you may not want the GenServer to\ncrash if the task crashes. Therefore, it is preferable to instead use\n`Task.Supervisor.async_nolink/3` inside OTP behaviours. For completeness, here\nis an example of a GenServer that start tasks and handles their results:\n\n    defmodule GenServerTaskExample do\n      use GenServer\n\n      def start_link(opts) do\n        GenServer.start_link(__MODULE__, :ok, opts)\n      end\n\n      def init(_opts) do\n        # We will keep all running tasks in a map\n        {:ok, %{tasks: %{}}}\n      end\n\n      # Imagine we invoke a task from the GenServer to access a URL...\n      def handle_call(:some_message, _from, state) do\n        url = ...\n        task = Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn -> fetch_url(url) end)\n\n        # After we start the task, we store its reference and the url it is fetching\n        state = put_in(state.tasks[task.ref], url)\n\n        {:reply, :ok, state}\n      end\n\n      # If the task succeeds...\n      def handle_info({ref, result}, state) do\n        # The task succeed so we can demonitor its reference\n        Process.demonitor(ref, [:flush])\n\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"Got \#{inspect(result)} for URL \#{inspect url}\"\n        {:noreply, state}\n      end\n\n      # If the task fails...\n      def handle_info({:DOWN, ref, _, _, reason}, state) do\n        {url, state} = pop_in(state.tasks[ref])\n        IO.puts \"URL \#{inspect url} failed with reason \#{inspect(reason)}\"\n        {:noreply, state}\n      end\n    end\n\nWith the server defined, you will want to start the task supervisor\nabove and the GenServer in your supervision tree:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor},\n      {GenServerTaskExample, name: MyApp.GenServerTaskExample}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\n","title":"Task.await/2","type":"function"},{"doc":"Awaits replies from multiple tasks and returns them. This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of the results, in the same order as the tasks supplied in the tasks input argument. If any of the task processes dies, the caller process will exit with the same reason as that task. A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . If the timeout is exceeded, then the caller process will exit. Any task processes that are linked to the caller process (which is the case when a task is started with async ) will also exit. Any task processes that are trapping exits or not linked to the caller process will continue to run. This function assumes the tasks' monitors are still active or the monitor's :DOWN message is in the message queue. If any tasks have been demonitored, or the message already received, this function will wait for the duration of the timeout. This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use yield_many/2 instead. Compatibility with OTP behaviours It is not recommended to await long-running tasks inside an OTP behaviour such as GenServer . See await/2 for more information. Examples iex&gt; tasks = [ ...&gt; Task . async ( fn -&gt; 1 + 1 end ) , ...&gt; Task . async ( fn -&gt; 2 + 3 end ) ...&gt; ] iex&gt; Task . await_many ( tasks ) [ 2 , 5 ]","ref":"Task.html#await_many/2","source_doc":"Awaits replies from multiple tasks and returns them.\n\nThis function receives a list of tasks and waits for their replies in the\ngiven time interval. It returns a list of the results, in the same order as\nthe tasks supplied in the `tasks` input argument.\n\nIf any of the task processes dies, the caller process will exit with the same\nreason as that task.\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the timeout is exceeded, then the caller process will exit.\nAny task processes that are linked to the caller process (which is the case\nwhen a task is started with `async`) will also exit. Any task processes that\nare trapping exits or not linked to the caller process will continue to run.\n\nThis function assumes the tasks' monitors are still active or the monitor's\n`:DOWN` message is in the message queue. If any tasks have been demonitored,\nor the message already received, this function will wait for the duration of\nthe timeout.\n\nThis function can only be called once for any given task. If you want to be\nable to check multiple times if a long-running task has finished its\ncomputation, use `yield_many/2` instead.\n\n## Compatibility with OTP behaviours\n\nIt is not recommended to `await` long-running tasks inside an OTP behaviour\nsuch as `GenServer`. See `await/2` for more information.\n\n## Examples\n\n    iex> tasks = [\n    ...>   Task.async(fn -> 1 + 1 end),\n    ...>   Task.async(fn -> 2 + 3 end)\n    ...> ]\n    iex> Task.await_many(tasks)\n    [2, 5]\n\n","title":"Task.await_many/2","type":"function"},{"doc":"Returns a specification to start a task under a supervisor. arg is passed as the argument to Task.start_link/1 in the :start field of the spec. For more information, see the Supervisor module, the Supervisor.child_spec/2 function and the Supervisor.child_spec/0 type.","ref":"Task.html#child_spec/1","source_doc":"Returns a specification to start a task under a supervisor.\n\n`arg` is passed as the argument to `Task.start_link/1` in the `:start` field\nof the spec.\n\nFor more information, see the `Supervisor` module,\nthe `Supervisor.child_spec/2` function and the `t:Supervisor.child_spec/0` type.\n","title":"Task.child_spec/1","type":"function"},{"doc":"Starts a task that immediately completes with the given result . Unlike async/1 , this task does not spawn a linked process. It can be awaited or yielded like any other task. Usage In some cases, it is useful to create a &quot;completed&quot; task that represents a task that has already run and generated a result. For example, when processing data you may be able to determine that certain inputs are invalid before dispatching them for further processing: def process ( data ) do tasks = for entry &lt;- data do if invalid_input? ( entry ) do Task . completed ( { :error , :invalid_input } ) else Task . async ( fn -&gt; further_process ( entry ) end ) end end Task . await_many ( tasks ) end In many cases, Task.completed/1 may be avoided in favor of returning the result directly. You should generally only require this variant when working with mixed asynchrony, when a group of inputs will be handled partially synchronously and partially asynchronously.","ref":"Task.html#completed/1","source_doc":"Starts a task that immediately completes with the given `result`.\n\nUnlike `async/1`, this task does not spawn a linked process. It can\nbe awaited or yielded like any other task.\n\n## Usage\n\nIn some cases, it is useful to create a \"completed\" task that represents\na task that has already run and generated a result. For example, when\nprocessing data you may be able to determine that certain inputs are\ninvalid before dispatching them for further processing:\n\n    def process(data) do\n      tasks =\n        for entry <- data do\n          if invalid_input?(entry) do\n            Task.completed({:error, :invalid_input})\n          else\n            Task.async(fn -> further_process(entry) end)\n          end\n        end\n\n      Task.await_many(tasks)\n    end\n\nIn many cases, `Task.completed/1` may be avoided in favor of returning the\nresult directly.  You should generally only require this variant when working\nwith mixed asynchrony, when a group of inputs will be handled partially\nsynchronously and partially asynchronously.\n","title":"Task.completed/1","type":"function"},{"doc":"Ignores an existing task. This means the task will continue running, but it will be unlinked and you can no longer yield, await or shut it down. Returns {:ok, reply} if the reply is received before ignoring the task, {:exit, reason} if the task died before ignoring it, otherwise nil . Important: avoid using Task.async/1,3 and then immediately ignoring the task. If you want to start tasks you don't care about their results, use Task.Supervisor.start_child/2 instead.","ref":"Task.html#ignore/1","source_doc":"Ignores an existing task.\n\nThis means the task will continue running, but it will be unlinked\nand you can no longer yield, await or shut it down.\n\nReturns `{:ok, reply}` if the reply is received before ignoring the task,\n`{:exit, reason}` if the task died before ignoring it, otherwise `nil`.\n\nImportant: avoid using [`Task.async/1,3`](`async/1`) and then immediately ignoring\nthe task. If you want to start tasks you don't care about their\nresults, use `Task.Supervisor.start_child/2` instead.\n","title":"Task.ignore/1","type":"function"},{"doc":"Unlinks and shuts down the task, and then checks for a reply. Returns {:ok, reply} if the reply is received while shutting down the task, {:exit, reason} if the task died, otherwise nil . Once shut down, you can no longer await or yield it. The second argument is either a timeout or :brutal_kill . In case of a timeout, a :shutdown exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With :brutal_kill the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason. It is not required to call this function when terminating the caller, unless exiting with reason :normal or if the task is trapping exits. If the caller is exiting with a reason other than :normal and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason :shutdown to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages. If there is no process linked to the task, such as tasks started by Task.completed/1 , we check for a response or error accordingly, but without shutting a process down. If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return {:exit, :noproc} as the result or exit reason can not be determined.","ref":"Task.html#shutdown/2","source_doc":"Unlinks and shuts down the task, and then checks for a reply.\n\nReturns `{:ok, reply}` if the reply is received while shutting down the task,\n`{:exit, reason}` if the task died, otherwise `nil`. Once shut down,\nyou can no longer await or yield it.\n\nThe second argument is either a timeout or `:brutal_kill`. In case\nof a timeout, a `:shutdown` exit signal is sent to the task process\nand if it does not exit within the timeout, it is killed. With `:brutal_kill`\nthe task is killed straight away. In case the task terminates abnormally\n(possibly killed by another process), this function will exit with the same reason.\n\nIt is not required to call this function when terminating the caller, unless\nexiting with reason `:normal` or if the task is trapping exits. If the caller is\nexiting with a reason other than `:normal` and the task is not trapping exits, the\ncaller's exit signal will stop the task. The caller can exit with reason\n`:shutdown` to shut down all of its linked processes, including tasks, that\nare not trapping exits without generating any log messages.\n\nIf there is no process linked to the task, such as tasks started by\n`Task.completed/1`, we check for a response or error accordingly, but without\nshutting a process down.\n\nIf a task's monitor has already been demonitored or received and there is not\na response waiting in the message queue this function will return\n`{:exit, :noproc}` as the result or exit reason can not be determined.\n","title":"Task.shutdown/2","type":"function"},{"doc":"Starts a task. fun must be a zero-arity anonymous function. This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully. If the current node is shutdown, the node will terminate even if the task was not completed. For this reason, we recommend to use Task.Supervisor.start_child/2 instead, which allows you to control the shutdown time via the :shutdown option.","ref":"Task.html#start/1","source_doc":"Starts a task.\n\n`fun` must be a zero-arity anonymous function.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.\n","title":"Task.start/1","type":"function"},{"doc":"Starts a task. This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully. If the current node is shutdown, the node will terminate even if the task was not completed. For this reason, we recommend to use Task.Supervisor.start_child/2 instead, which allows you to control the shutdown time via the :shutdown option.","ref":"Task.html#start/3","source_doc":"Starts a task.\n\nThis should only used when the task is used for side-effects\n(like I/O) and you have no interest on its results nor if it\ncompletes successfully.\n\nIf the current node is shutdown, the node will terminate even\nif the task was not completed. For this reason, we recommend\nto use `Task.Supervisor.start_child/2` instead, which allows\nyou to control the shutdown time via the `:shutdown` option.\n","title":"Task.start/3","type":"function"},{"doc":"Starts a task as part of a supervision tree with the given fun . fun must be a zero-arity anonymous function. This is used to start a statically supervised task under a supervision tree.","ref":"Task.html#start_link/1","source_doc":"Starts a task as part of a supervision tree with the given `fun`.\n\n`fun` must be a zero-arity anonymous function.\n\nThis is used to start a statically supervised task under a supervision tree.\n","title":"Task.start_link/1","type":"function"},{"doc":"Starts a task as part of a supervision tree with the given module , function , and args . This is used to start a statically supervised task under a supervision tree.","ref":"Task.html#start_link/3","source_doc":"Starts a task as part of a supervision tree with the given\n`module`, `function`, and `args`.\n\nThis is used to start a statically supervised task under a supervision tree.\n","title":"Task.start_link/3","type":"function"},{"doc":"Temporarily blocks the caller process waiting for a task reply. Returns {:ok, reply} if the reply is received, nil if no reply has arrived, or {:exit, reason} if the task has already exited. Keep in mind that normally a task failure also causes the process owning the task to exit. Therefore this function can return {:exit, reason} if at least one of the conditions below apply: the task process exited with the reason :normal the task isn't linked to the caller (the task was started with Task.Supervisor.async_nolink/2 or Task.Supervisor.async_nolink/4 ) the caller is trapping exits A timeout, in milliseconds or :infinity , can be given with a default value of 5000 . If the time runs out before a message from the task is received, this function will return nil and the monitor will remain active. Therefore yield/2 can be called multiple times on the same task. This function assumes the task's monitor is still active or the monitor's :DOWN message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message. If you intend to shut the task down if it has not responded within timeout milliseconds, you should chain this together with shutdown/1 , like so: case Task . yield ( task , timeout ) || Task . shutdown ( task ) do { :ok , result } -&gt; result nil -&gt; Logger . warning ( &quot;Failed to get a result in \#{ timeout } ms&quot; ) nil end If you intend to check on the task but leave it running after the timeout, you can chain this together with ignore/1 , like so: case Task . yield ( task , timeout ) || Task . ignore ( task ) do { :ok , result } -&gt; result nil -&gt; Logger . warning ( &quot;Failed to get a result in \#{ timeout } ms&quot; ) nil end That ensures that if the task completes after the timeout but before shutdown/1 has been called, you will still get the result, since shutdown/1 is designed to handle this case and return the result.","ref":"Task.html#yield/2","source_doc":"Temporarily blocks the caller process waiting for a task reply.\n\nReturns `{:ok, reply}` if the reply is received, `nil` if\nno reply has arrived, or `{:exit, reason}` if the task has already\nexited. Keep in mind that normally a task failure also causes\nthe process owning the task to exit. Therefore this function can\nreturn `{:exit, reason}` if at least one of the conditions below apply:\n\n  * the task process exited with the reason `:normal`\n  * the task isn't linked to the caller (the task was started\n    with `Task.Supervisor.async_nolink/2` or `Task.Supervisor.async_nolink/4`)\n  * the caller is trapping exits\n\nA timeout, in milliseconds or `:infinity`, can be given with a default value\nof `5000`. If the time runs out before a message from the task is received,\nthis function will return `nil` and the monitor will remain active. Therefore\n`yield/2` can be called multiple times on the same task.\n\nThis function assumes the task's monitor is still active or the\nmonitor's `:DOWN` message is in the message queue. If it has been\ndemonitored or the message already received, this function will wait\nfor the duration of the timeout awaiting the message.\n\nIf you intend to shut the task down if it has not responded within `timeout`\nmilliseconds, you should chain this together with `shutdown/1`, like so:\n\n    case Task.yield(task, timeout) || Task.shutdown(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warning(\"Failed to get a result in \#{timeout}ms\")\n        nil\n    end\n\nIf you intend to check on the task but leave it running after the timeout,\nyou can chain this together with `ignore/1`, like so:\n\n    case Task.yield(task, timeout) || Task.ignore(task) do\n      {:ok, result} ->\n        result\n\n      nil ->\n        Logger.warning(\"Failed to get a result in \#{timeout}ms\")\n        nil\n    end\n\nThat ensures that if the task completes after the `timeout` but before `shutdown/1`\nhas been called, you will still get the result, since `shutdown/1` is designed to\nhandle this case and return the result.\n","title":"Task.yield/2","type":"function"},{"doc":"Yields to multiple tasks in the given time interval. This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the tasks input argument. Similarly to yield/2 , each task's result will be {:ok, term} if the task has successfully reported its result back in the given time interval {:exit, reason} if the task has died nil if the task keeps running past the timeout Check yield/2 for more information. Example Task.yield_many/2 allows developers to spawn multiple tasks and retrieve the results received in a given timeframe. If we combine it with Task.shutdown/2 (or Task.ignore/1 ), it allows us to gather those results and cancel (or ignore) the tasks that have not replied in time. Let's see an example. tasks = for i &lt;- 1 .. 10 do Task . async ( fn -&gt; Process . sleep ( i * 1000 ) i end ) end tasks_with_results = Task . yield_many ( tasks , timeout : 5000 ) results = Enum . map ( tasks_with_results , fn { task , res } -&gt; # Shut down the tasks that did not reply nor exit res || Task . shutdown ( task , :brutal_kill ) end ) # Here we are matching only on {:ok, value} and # ignoring {:exit, _} (crashed tasks) and `nil` (no replies) for { :ok , value } &lt;- results do IO . inspect ( value ) end In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the Task.shutdown/2 call. As a convenience, you can achieve a similar behaviour to above by specifying the :on_timeout option to be :kill_task (or :ignore ). See Task.await_many/2 if you would rather exit the caller process on timeout. Options The second argument is either a timeout or options, which defaults to this: :timeout - the maximum amount of time (in milliseconds or :infinity ) each task is allowed to execute for. Defaults to 5000 . :on_timeout - what to do when a task times out. The possible values are: :nothing - do nothing (default). The tasks can still be awaited on, yielded on, ignored, or shut down later. :ignore - the results of the task will be ignored. :kill_task - the task that timed out is killed.","ref":"Task.html#yield_many/2","source_doc":"Yields to multiple tasks in the given time interval.\n\nThis function receives a list of tasks and waits for their\nreplies in the given time interval. It returns a list\nof two-element tuples, with the task as the first element\nand the yielded result as the second. The tasks in the returned\nlist will be in the same order as the tasks supplied in the `tasks`\ninput argument.\n\nSimilarly to `yield/2`, each task's result will be\n\n  * `{:ok, term}` if the task has successfully reported its\n    result back in the given time interval\n  * `{:exit, reason}` if the task has died\n  * `nil` if the task keeps running past the timeout\n\nCheck `yield/2` for more information.\n\n## Example\n\n`Task.yield_many/2` allows developers to spawn multiple tasks\nand retrieve the results received in a given timeframe.\nIf we combine it with `Task.shutdown/2` (or `Task.ignore/1`),\nit allows us to gather those results and cancel (or ignore)\nthe tasks that have not replied in time.\n\nLet's see an example.\n\n    tasks =\n      for i <- 1..10 do\n        Task.async(fn ->\n          Process.sleep(i * 1000)\n          i\n        end)\n      end\n\n    tasks_with_results = Task.yield_many(tasks, timeout: 5000)\n\n    results =\n      Enum.map(tasks_with_results, fn {task, res} ->\n        # Shut down the tasks that did not reply nor exit\n        res || Task.shutdown(task, :brutal_kill)\n      end)\n\n    # Here we are matching only on {:ok, value} and\n    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n    for {:ok, value} <- results do\n      IO.inspect(value)\n    end\n\nIn the example above, we create tasks that sleep from 1\nup to 10 seconds and return the number of seconds they slept for.\nIf you execute the code all at once, you should see 1 up to 5\nprinted, as those were the tasks that have replied in the\ngiven time. All other tasks will have been shut down using\nthe `Task.shutdown/2` call.\n\nAs a convenience, you can achieve a similar behaviour to above\nby specifying the `:on_timeout` option to be `:kill_task` (or\n`:ignore`). See `Task.await_many/2` if you would rather exit\nthe caller process on timeout.\n\n## Options\n\nThe second argument is either a timeout or options, which defaults\nto this:\n\n  * `:timeout` - the maximum amount of time (in milliseconds or `:infinity`)\n    each task is allowed to execute for. Defaults to `5000`.\n\n  * `:on_timeout` - what to do when a task times out. The possible\n    values are:\n    * `:nothing` - do nothing (default). The tasks can still be\n      awaited on, yielded on, ignored, or shut down later.\n    * `:ignore` - the results of the task will be ignored.\n    * `:kill_task` - the task that timed out is killed.\n","title":"Task.yield_many/2","type":"function"},{"doc":"The task opaque reference.","ref":"Task.html#t:ref/0","source_doc":"The task opaque reference.\n","title":"Task.ref/0","type":"opaque"},{"doc":"The Task type. See %Task{} for information about each field of the structure.","ref":"Task.html#t:t/0","source_doc":"The Task type.\n\nSee [`%Task{}`](`__struct__/0`) for information about each field of the structure.\n","title":"Task.t/0","type":"type"},{"doc":"A task supervisor. This module defines a supervisor which can be used to dynamically supervise tasks. A task supervisor is started with no children, often under a supervisor and a name: children = [ { Task.Supervisor , name : MyApp.TaskSupervisor } ] Supervisor . start_link ( children , strategy : :one_for_one ) The options given in the child specification are documented in start_link/1 . Once started, you can start tasks directly under the supervisor, for example: task = Task.Supervisor . async ( MyApp.TaskSupervisor , fn -&gt; :do_some_work end ) See the Task module for more examples. Scalability and partitioning The Task.Supervisor is a single process responsible for starting other processes. In some applications, the Task.Supervisor may become a bottleneck. To address this, you can start multiple instances of the Task.Supervisor and then pick a random instance to start the task on. Instead of: children = [ { Task.Supervisor , name : MyApp.TaskSupervisor } ] and: Task.Supervisor . async ( MyApp.TaskSupervisor , fn -&gt; :do_some_work end ) You can do this: children = [ { PartitionSupervisor , child_spec : Task.Supervisor , name : MyApp.TaskSupervisors } ] and then: Task.Supervisor . async ( { :via , PartitionSupervisor , { MyApp.TaskSupervisors , self ( ) } } , fn -&gt; :do_some_work end ) In the code above, we start a partition supervisor that will by default start a dynamic supervisor for each core in your machine. Then, instead of calling the Task.Supervisor by name, you call it through the partition supervisor using the {:via, PartitionSupervisor, {name, key}} format, where name is the name of the partition supervisor and key is the routing key. We picked self() as the routing key, which means each process will be assigned one of the existing task supervisors. Read the PartitionSupervisor docs for more information. Name registration A Task.Supervisor is bound to the same name registration rules as a GenServer . Read more about them in the GenServer docs.","ref":"Task.Supervisor.html","source_doc":"A task supervisor.\n\nThis module defines a supervisor which can be used to dynamically\nsupervise tasks.\n\nA task supervisor is started with no children, often under a\nsupervisor and a name:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nThe options given in the child specification are documented in `start_link/1`.\n\nOnce started, you can start tasks directly under the supervisor, for example:\n\n    task = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n      :do_some_work\n    end)\n\nSee the `Task` module for more examples.\n\n## Scalability and partitioning\n\nThe `Task.Supervisor` is a single process responsible for starting\nother processes. In some applications, the `Task.Supervisor` may\nbecome a bottleneck. To address this, you can start multiple instances\nof the `Task.Supervisor` and then pick a random instance to start\nthe task on.\n\nInstead of:\n\n    children = [\n      {Task.Supervisor, name: MyApp.TaskSupervisor}\n    ]\n\nand:\n\n    Task.Supervisor.async(MyApp.TaskSupervisor, fn -> :do_some_work end)\n\nYou can do this:\n\n    children = [\n      {PartitionSupervisor,\n       child_spec: Task.Supervisor,\n       name: MyApp.TaskSupervisors}\n    ]\n\nand then:\n\n    Task.Supervisor.async(\n      {:via, PartitionSupervisor, {MyApp.TaskSupervisors, self()}},\n      fn -> :do_some_work end\n    )\n\nIn the code above, we start a partition supervisor that will by default\nstart a dynamic supervisor for each core in your machine. Then, instead\nof calling the `Task.Supervisor` by name, you call it through the\npartition supervisor using the `{:via, PartitionSupervisor, {name, key}}`\nformat, where `name` is the name of the partition supervisor and `key`\nis the routing key. We picked `self()` as the routing key, which means\neach process will be assigned one of the existing task supervisors.\nRead the `PartitionSupervisor` docs for more information.\n\n## Name registration\n\nA `Task.Supervisor` is bound to the same name registration rules as a\n`GenServer`. Read more about them in the `GenServer` docs.\n","title":"Task.Supervisor","type":"module"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task will still be linked to the caller, see Task.async/3 for more information and async_nolink/3 for a non-linked variant. Raises an error if supervisor has reached the maximum number of children. Options :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.","ref":"Task.Supervisor.html#async/3","source_doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n","title":"Task.Supervisor.async/3","type":"function"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task will still be linked to the caller, see Task.async/3 for more information and async_nolink/3 for a non-linked variant. Raises an error if supervisor has reached the maximum number of children. Options :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.","ref":"Task.Supervisor.html#async/5","source_doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task will still be linked to the caller, see `Task.async/3` for\nmore information and `async_nolink/3` for a non-linked variant.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n","title":"Task.Supervisor.async/5","type":"function"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task won't be linked to the caller, see Task.async/3 for more information. Raises an error if supervisor has reached the maximum number of children. Note this function requires the task supervisor to have :temporary as the :restart option (the default), as async_nolink/3 keeps a direct reference to the task which is lost if the task is restarted. Options :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds. Compatibility with OTP behaviours If you create a task using async_nolink inside an OTP behaviour like GenServer , you should match on the message coming from the task inside your GenServer.handle_info/2 callback. The reply sent by the task will be in the format {ref, result} , where ref is the monitor reference held by the task struct and result is the return value of the task function. Keep in mind that, regardless of how the task created with async_nolink terminates, the caller's process will always receive a :DOWN message with the same ref value that is held by the task struct. If the task terminates normally, the reason in the :DOWN message will be :normal . Examples Typically, you use async_nolink/3 when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a GenServer is meant to run a single task and track its status: defmodule MyApp.Server do use GenServer # ... def start_task do GenServer . call ( __MODULE__ , :start_task ) end # In this case the task is already running, so we just return :ok. def handle_call ( :start_task , _from , %{ ref : ref } = state ) when is_reference ( ref ) do { :reply , :ok , state } end # The task is not running yet, so let&#39;s start it. def handle_call ( :start_task , _from , %{ ref : nil } = state ) do task = Task.Supervisor . async_nolink ( MyApp.TaskSupervisor , fn -&gt; ... end ) # We return :ok and the server will continue running { :reply , :ok , %{ state | ref : task . ref } } end # The task completed successfully def handle_info ( { ref , answer } , %{ ref : ref } = state ) do # We don&#39;t care about the DOWN message now, so let&#39;s demonitor and flush it Process . demonitor ( ref , [ :flush ] ) # Do something with the result and then return { :noreply , %{ state | ref : nil } } end # The task failed def handle_info ( { :DOWN , ref , :process , _pid , _reason } , %{ ref : ref } = state ) do # Log and possibly restart the task... { :noreply , %{ state | ref : nil } } end end","ref":"Task.Supervisor.html#async_nolink/3","source_doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/3` keeps a\ndirect reference to the task which is lost if the task is restarted.\n\n## Options\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n## Compatibility with OTP behaviours\n\nIf you create a task using `async_nolink` inside an OTP behaviour\nlike `GenServer`, you should match on the message coming from the\ntask inside your `c:GenServer.handle_info/2` callback.\n\nThe reply sent by the task will be in the format `{ref, result}`,\nwhere `ref` is the monitor reference held by the task struct\nand `result` is the return value of the task function.\n\nKeep in mind that, regardless of how the task created with `async_nolink`\nterminates, the caller's process will always receive a `:DOWN` message\nwith the same `ref` value that is held by the task struct. If the task\nterminates normally, the reason in the `:DOWN` message will be `:normal`.\n\n## Examples\n\nTypically, you use `async_nolink/3` when there is a reasonable expectation that\nthe task may fail, and you don't want it to take down the caller. Let's see an\nexample where a `GenServer` is meant to run a single task and track its status:\n\n    defmodule MyApp.Server do\n      use GenServer\n\n      # ...\n\n      def start_task do\n        GenServer.call(__MODULE__, :start_task)\n      end\n\n      # In this case the task is already running, so we just return :ok.\n      def handle_call(:start_task, _from, %{ref: ref} = state) when is_reference(ref) do\n        {:reply, :ok, state}\n      end\n\n      # The task is not running yet, so let's start it.\n      def handle_call(:start_task, _from, %{ref: nil} = state) do\n        task =\n          Task.Supervisor.async_nolink(MyApp.TaskSupervisor, fn ->\n            ...\n          end)\n\n        # We return :ok and the server will continue running\n        {:reply, :ok, %{state | ref: task.ref}}\n      end\n\n      # The task completed successfully\n      def handle_info({ref, answer}, %{ref: ref} = state) do\n        # We don't care about the DOWN message now, so let's demonitor and flush it\n        Process.demonitor(ref, [:flush])\n        # Do something with the result and then return\n        {:noreply, %{state | ref: nil}}\n      end\n\n      # The task failed\n      def handle_info({:DOWN, ref, :process, _pid, _reason}, %{ref: ref} = state) do\n        # Log and possibly restart the task...\n        {:noreply, %{state | ref: nil}}\n      end\n    end\n\n","title":"Task.Supervisor.async_nolink/3","type":"function"},{"doc":"Starts a task that can be awaited on. The supervisor must be a reference as defined in Supervisor . The task won't be linked to the caller, see Task.async/3 for more information. Raises an error if supervisor has reached the maximum number of children. Note this function requires the task supervisor to have :temporary as the :restart option (the default), as async_nolink/5 keeps a direct reference to the task which is lost if the task is restarted.","ref":"Task.Supervisor.html#async_nolink/5","source_doc":"Starts a task that can be awaited on.\n\nThe `supervisor` must be a reference as defined in `Supervisor`.\nThe task won't be linked to the caller, see `Task.async/3` for\nmore information.\n\nRaises an error if `supervisor` has reached the maximum number of\nchildren.\n\nNote this function requires the task supervisor to have `:temporary`\nas the `:restart` option (the default), as `async_nolink/5` keeps a\ndirect reference to the task which is lost if the task is restarted.\n","title":"Task.Supervisor.async_nolink/5","type":"function"},{"doc":"Returns a stream that runs the given function fun concurrently on each element in enumerable . Each element in enumerable is passed as argument to the given function fun and processed by its own task. The tasks will be spawned under the given supervisor and linked to the caller process, similarly to async/3 . See async_stream/6 for discussion, options, and examples.","ref":"Task.Supervisor.html#async_stream/4","source_doc":"Returns a stream that runs the given function `fun` concurrently\non each element in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and linked to the caller process, similarly to `async/3`.\n\nSee `async_stream/6` for discussion, options, and examples.\n","title":"Task.Supervisor.async_stream/4","type":"function"},{"doc":"Returns a stream where the given function ( module and function ) is mapped concurrently on each element in enumerable . Each element will be prepended to the given args and processed by its own task. The tasks will be spawned under the given supervisor and linked to the caller process, similarly to async/5 . When streamed, each task will emit {:ok, value} upon successful completion or {:exit, reason} if the caller is trapping exits. The order of results depends on the value of the :ordered option. The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below). If you find yourself trapping exits to handle exits inside the async stream, consider using async_stream_nolink/6 to start tasks that are not linked to the calling process. Options :max_concurrency - sets the maximum number of tasks to run at the same time. Defaults to System.schedulers_online/0 . :ordered - whether the results should be returned in the same order as the input stream. This option is useful when you have large streams and don't want to buffer results before they are delivered. This is also useful when you're using the tasks for side effects. Defaults to true . :timeout - the maximum amount of time to wait (in milliseconds) without receiving a task reply (across all running tasks). Defaults to 5000 . :on_timeout - what do to when a task times out. The possible values are: :exit (default) - the process that spawned the tasks exits. :kill_task - the task that timed out is killed. The value emitted for that task is {:exit, :timeout} . :shutdown - :brutal_kill if the tasks must be killed directly on shutdown or an integer indicating the timeout value. Defaults to 5000 milliseconds. Examples Let's build a stream and then enumerate it: stream = Task.Supervisor . async_stream ( MySupervisor , collection , Mod , :expensive_fun , [ ] ) Enum . to_list ( stream )","ref":"Task.Supervisor.html#async_stream/6","source_doc":"Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element will be prepended to the given `args` and processed by its\nown task. The tasks will be spawned under the given `supervisor` and\nlinked to the caller process, similarly to `async/5`.\n\nWhen streamed, each task will emit `{:ok, value}` upon successful\ncompletion or `{:exit, reason}` if the caller is trapping exits.\nThe order of results depends on the value of the `:ordered` option.\n\nThe level of concurrency and the time tasks are allowed to run can\nbe controlled via options (see the \"Options\" section below).\n\nIf you find yourself trapping exits to handle exits inside\nthe async stream, consider using `async_stream_nolink/6` to start tasks\nthat are not linked to the calling process.\n\n## Options\n\n  * `:max_concurrency` - sets the maximum number of tasks to run\n    at the same time. Defaults to `System.schedulers_online/0`.\n\n  * `:ordered` - whether the results should be returned in the same order\n    as the input stream. This option is useful when you have large\n    streams and don't want to buffer results before they are delivered.\n    This is also useful when you're using the tasks for side effects.\n    Defaults to `true`.\n\n  * `:timeout` - the maximum amount of time to wait (in milliseconds)\n    without receiving a task reply (across all running tasks).\n    Defaults to `5000`.\n\n  * `:on_timeout` - what do to when a task times out. The possible\n    values are:\n    * `:exit` (default) - the process that spawned the tasks exits.\n    * `:kill_task` - the task that timed out is killed. The value\n      emitted for that task is `{:exit, :timeout}`.\n\n  * `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n    or an integer indicating the timeout value. Defaults to `5000` milliseconds.\n\n## Examples\n\nLet's build a stream and then enumerate it:\n\n    stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])\n    Enum.to_list(stream)\n\n","title":"Task.Supervisor.async_stream/6","type":"function"},{"doc":"Returns a stream that runs the given function concurrently on each element in enumerable . Each element in enumerable is passed as argument to the given function fun and processed by its own task. The tasks will be spawned under the given supervisor and will not be linked to the caller process, similarly to async_nolink/3 . See async_stream/6 for discussion and examples.","ref":"Task.Supervisor.html#async_stream_nolink/4","source_doc":"Returns a stream that runs the given `function` concurrently on each\nelement in `enumerable`.\n\nEach element in `enumerable` is passed as argument to the given function `fun`\nand processed by its own task. The tasks will be spawned under the given\n`supervisor` and will not be linked to the caller process, similarly\nto `async_nolink/3`.\n\nSee `async_stream/6` for discussion and examples.\n","title":"Task.Supervisor.async_stream_nolink/4","type":"function"},{"doc":"Returns a stream where the given function ( module and function ) is mapped concurrently on each element in enumerable . Each element in enumerable will be prepended to the given args and processed by its own task. The tasks will be spawned under the given supervisor and will not be linked to the caller process, similarly to async_nolink/5 . See async_stream/6 for discussion, options, and examples.","ref":"Task.Supervisor.html#async_stream_nolink/6","source_doc":"Returns a stream where the given function (`module` and `function`)\nis mapped concurrently on each element in `enumerable`.\n\nEach element in `enumerable` will be prepended to the given `args` and processed\nby its own task. The tasks will be spawned under the given `supervisor` and\nwill not be linked to the caller process, similarly to `async_nolink/5`.\n\nSee `async_stream/6` for discussion, options, and examples.\n","title":"Task.Supervisor.async_stream_nolink/6","type":"function"},{"doc":"Returns all children PIDs except those that are restarting. Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.","ref":"Task.Supervisor.html#children/1","source_doc":"Returns all children PIDs except those that are restarting.\n\nNote that calling this function when supervising a large number\nof children under low memory conditions can cause an out of memory\nexception.\n","title":"Task.Supervisor.children/1","type":"function"},{"doc":"Starts a task as a child of the given supervisor . Task.Supervisor . start_child ( MyTaskSupervisor , fn -&gt; IO . puts &quot;I am running in a task&quot; end ) Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and you have no interest in its results nor if it completes successfully. Options :restart - the restart strategy, may be :temporary (the default), :transient or :permanent . :temporary means the task is never restarted, :transient means it is restarted if the exit is not :normal , :shutdown or {:shutdown, reason} . A :permanent restart strategy means it is always restarted. :shutdown - :brutal_kill if the task must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.","ref":"Task.Supervisor.html#start_child/3","source_doc":"Starts a task as a child of the given `supervisor`.\n\n    Task.Supervisor.start_child(MyTaskSupervisor, fn ->\n      IO.puts \"I am running in a task\"\n    end)\n\nNote that the spawned process is not linked to the caller, but\nonly to the supervisor. This command is useful in case the\ntask needs to perform side-effects (like I/O) and you have no\ninterest in its results nor if it completes successfully.\n\n## Options\n\n  * `:restart` - the restart strategy, may be `:temporary` (the default),\n    `:transient` or `:permanent`. `:temporary` means the task is never\n    restarted, `:transient` means it is restarted if the exit is not\n    `:normal`, `:shutdown` or `{:shutdown, reason}`. A `:permanent` restart\n    strategy means it is always restarted.\n\n  * `:shutdown` - `:brutal_kill` if the task must be killed directly on shutdown\n    or an integer indicating the timeout value, defaults to 5000 milliseconds.\n\n","title":"Task.Supervisor.start_child/3","type":"function"},{"doc":"Starts a task as a child of the given supervisor . Similar to start_child/3 except the task is specified by the given module , fun and args .","ref":"Task.Supervisor.html#start_child/5","source_doc":"Starts a task as a child of the given `supervisor`.\n\nSimilar to `start_child/3` except the task is specified\nby the given `module`, `fun` and `args`.\n","title":"Task.Supervisor.start_child/5","type":"function"},{"doc":"Starts a new supervisor. Examples A task supervisor is typically started under a supervision tree using the tuple format: { Task.Supervisor , name : MyApp.TaskSupervisor } You can also start it by calling start_link/1 directly: Task.Supervisor . start_link ( name : MyApp.TaskSupervisor ) But this is recommended only for scripting and should be avoided in production code. Generally speaking, processes should always be started inside supervision trees. Options :name - used to register a supervisor name, the supported values are described under the Name Registration section in the GenServer module docs; :max_restarts , :max_seconds , and :max_children - as specified in DynamicSupervisor ; This function could also receive :restart and :shutdown as options but those two options have been deprecated and it is now preferred to give them directly to start_child .","ref":"Task.Supervisor.html#start_link/1","source_doc":"Starts a new supervisor.\n\n## Examples\n\nA task supervisor is typically started under a supervision tree using\nthe tuple format:\n\n    {Task.Supervisor, name: MyApp.TaskSupervisor}\n\nYou can also start it by calling `start_link/1` directly:\n\n    Task.Supervisor.start_link(name: MyApp.TaskSupervisor)\n\nBut this is recommended only for scripting and should be avoided in\nproduction code. Generally speaking, processes should always be started\ninside supervision trees.\n\n## Options\n\n  * `:name` - used to register a supervisor name, the supported values are\n    described under the `Name Registration` section in the `GenServer` module\n    docs;\n\n  * `:max_restarts`, `:max_seconds`, and `:max_children` - as specified in\n    `DynamicSupervisor`;\n\nThis function could also receive `:restart` and `:shutdown` as options\nbut those two options have been deprecated and it is now preferred to\ngive them directly to `start_child`.\n","title":"Task.Supervisor.start_link/1","type":"function"},{"doc":"Terminates the child with the given pid .","ref":"Task.Supervisor.html#terminate_child/2","source_doc":"Terminates the child with the given `pid`.\n","title":"Task.Supervisor.terminate_child/2","type":"function"},{"doc":"Option values used by start_link","ref":"Task.Supervisor.html#t:option/0","source_doc":"Option values used by `start_link`","title":"Task.Supervisor.option/0","type":"type"},{"doc":"A protocol to traverse data structures. The Enum.into/2 function uses this protocol to insert an enumerable into a collection: iex&gt; Enum . into ( [ a : 1 , b : 2 ] , %{ } ) %{ a : 1 , b : 2 } Why Collectable? The Enumerable protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the Enumerable protocol do not keep shape. For example, passing a map to Enum.map/2 always returns a list. This design is intentional. Enumerable was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a Range , as it has a fixed shape where only the range limits and step are stored. The Collectable module was designed to fill the gap left by the Enumerable protocol. Collectable.into/1 can be seen as the opposite of Enumerable.reduce/3 . If the functions in Enumerable are about taking values out, then Collectable.into/1 is about collecting those values into a structure. Examples To show how to manually use the Collectable protocol, let's play with a simplified implementation for MapSet . iex&gt; { initial_acc , collector_fun } = Collectable . into ( MapSet . new ( ) ) iex&gt; updated_acc = Enum . reduce ( [ 1 , 2 , 3 ] , initial_acc , fn elem , acc -&gt; ...&gt; collector_fun . ( acc , { :cont , elem } ) ...&gt; end ) iex&gt; collector_fun . ( updated_acc , :done ) MapSet . new ( [ 1 , 2 , 3 ] ) To show how the protocol can be implemented, we can again look at the simplified implementation for MapSet . In this implementation &quot;collecting&quot; elements simply means inserting them in the set through MapSet.put/2 . defimpl Collectable , for : MapSet do def into ( map_set ) do collector_fun = fn map_set_acc , { :cont , elem } -&gt; MapSet . put ( map_set_acc , elem ) map_set_acc , :done -&gt; map_set_acc _map_set_acc , :halt -&gt; :ok end initial_acc = map_set { initial_acc , collector_fun } end end So now we can call Enum.into/2 : iex&gt; Enum . into ( [ 1 , 2 , 3 ] , MapSet . new ( ) ) MapSet . new ( [ 1 , 2 , 3 ] )","ref":"Collectable.html","source_doc":"A protocol to traverse data structures.\n\nThe `Enum.into/2` function uses this protocol to insert an\nenumerable into a collection:\n\n    iex> Enum.into([a: 1, b: 2], %{})\n    %{a: 1, b: 2}\n\n## Why Collectable?\n\nThe `Enumerable` protocol is useful to take values out of a collection.\nIn order to support a wide range of values, the functions provided by\nthe `Enumerable` protocol do not keep shape. For example, passing a\nmap to `Enum.map/2` always returns a list.\n\nThis design is intentional. `Enumerable` was designed to support infinite\ncollections, resources and other structures with fixed shape. For example,\nit doesn't make sense to insert values into a `Range`, as it has a\nfixed shape where only the range limits and step are stored.\n\nThe `Collectable` module was designed to fill the gap left by the\n`Enumerable` protocol. `Collectable.into/1` can be seen as the opposite of\n`Enumerable.reduce/3`. If the functions in `Enumerable` are about taking values out,\nthen `Collectable.into/1` is about collecting those values into a structure.\n\n## Examples\n\nTo show how to manually use the `Collectable` protocol, let's play with a\nsimplified implementation for `MapSet`.\n\n    iex> {initial_acc, collector_fun} = Collectable.into(MapSet.new())\n    iex> updated_acc = Enum.reduce([1, 2, 3], initial_acc, fn elem, acc ->\n    ...>   collector_fun.(acc, {:cont, elem})\n    ...> end)\n    iex> collector_fun.(updated_acc, :done)\n    MapSet.new([1, 2, 3])\n\nTo show how the protocol can be implemented, we can again look at the\nsimplified implementation for `MapSet`. In this implementation \"collecting\" elements\nsimply means inserting them in the set through `MapSet.put/2`.\n\n    defimpl Collectable, for: MapSet do\n      def into(map_set) do\n        collector_fun = fn\n          map_set_acc, {:cont, elem} ->\n            MapSet.put(map_set_acc, elem)\n\n          map_set_acc, :done ->\n            map_set_acc\n\n          _map_set_acc, :halt ->\n            :ok\n        end\n\n        initial_acc = map_set\n\n        {initial_acc, collector_fun}\n      end\n    end\n\nSo now we can call `Enum.into/2`:\n\n    iex> Enum.into([1, 2, 3], MapSet.new())\n    MapSet.new([1, 2, 3])\n\n","title":"Collectable","type":"protocol"},{"doc":"Returns an initial accumulator and a &quot;collector&quot; function. Receives a collectable which can be used as the initial accumulator that will be passed to the function. The collector function receives a term and a command and injects the term into the collectable accumulator on every {:cont, term} command. :done is passed as a command when no further values will be injected. This is useful when there's a need to close resources or normalizing values. A collectable must be returned when the command is :done . If injection is suddenly interrupted, :halt is passed and the function can return any value as it won't be used. For examples on how to use the Collectable protocol and into/1 see the module documentation.","ref":"Collectable.html#into/1","source_doc":"Returns an initial accumulator and a \"collector\" function.\n\nReceives a `collectable` which can be used as the initial accumulator that will\nbe passed to the function.\n\nThe collector function receives a term and a command and injects the term into\nthe collectable accumulator on every `{:cont, term}` command.\n\n`:done` is passed as a command when no further values will be injected. This\nis useful when there's a need to close resources or normalizing values. A\ncollectable must be returned when the command is `:done`.\n\nIf injection is suddenly interrupted, `:halt` is passed and the function\ncan return any value as it won't be used.\n\nFor examples on how to use the `Collectable` protocol and `into/1` see the\nmodule documentation.\n","title":"Collectable.into/1","type":"function"},{"doc":"","ref":"Collectable.html#t:command/0","source_doc":false,"title":"Collectable.command/0","type":"type"},{"doc":"All the types that implement this protocol.","ref":"Collectable.html#t:t/0","source_doc":"All the types that implement this protocol.\n","title":"Collectable.t/0","type":"type"},{"doc":"Enumerable protocol used by Enum and Stream modules. When you invoke a function in the Enum module, the first argument is usually a collection that must implement this protocol. For example, the expression Enum.map([1, 2, 3], &amp;(&amp;1 * 2)) invokes Enumerable.reduce/3 to perform the reducing operation that builds a mapped list by calling the mapping function &amp;(&amp;1 * 2) on every element in the collection and consuming the element with an accumulated list. Internally, Enum.map/2 is implemented as follows: def map ( enumerable , fun ) do reducer = fn x , acc -&gt; { :cont , [ fun . ( x ) | acc ] } end Enumerable . reduce ( enumerable , { :cont , [ ] } , reducer ) |&gt; elem ( 1 ) |&gt; :lists . reverse ( ) end Note that the user-supplied function is wrapped into a reducer/0 function. The reducer/0 function must return a tagged tuple after each step, as described in the acc/0 type. At the end, Enumerable.reduce/3 returns result/0 . This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the zip/1 and zip/2 functions). This protocol requires four functions to be implemented, reduce/3 , count/1 , member?/2 , and slice/1 . The core of the protocol is the reduce/3 function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.","ref":"Enumerable.html","source_doc":"Enumerable protocol used by `Enum` and `Stream` modules.\n\nWhen you invoke a function in the `Enum` module, the first argument\nis usually a collection that must implement this protocol.\nFor example, the expression `Enum.map([1, 2, 3], &(&1 * 2))`\ninvokes `Enumerable.reduce/3` to perform the reducing operation that\nbuilds a mapped list by calling the mapping function `&(&1 * 2)` on\nevery element in the collection and consuming the element with an\naccumulated list.\n\nInternally, `Enum.map/2` is implemented as follows:\n\n    def map(enumerable, fun) do\n      reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end\n      Enumerable.reduce(enumerable, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n    end\n\nNote that the user-supplied function is wrapped into a `t:reducer/0` function.\nThe `t:reducer/0` function must return a tagged tuple after each step,\nas described in the `t:acc/0` type. At the end, `Enumerable.reduce/3`\nreturns `t:result/0`.\n\nThis protocol uses tagged tuples to exchange information between the\nreducer function and the data type that implements the protocol. This\nallows enumeration of resources, such as files, to be done efficiently\nwhile also guaranteeing the resource will be closed at the end of the\nenumeration. This protocol also allows suspension of the enumeration,\nwhich is useful when interleaving between many enumerables is required\n(as in the `zip/1` and `zip/2` functions).\n\nThis protocol requires four functions to be implemented, `reduce/3`,\n`count/1`, `member?/2`, and `slice/1`. The core of the protocol is the\n`reduce/3` function. All other functions exist as optimizations paths\nfor data structures that can implement certain properties in better\nthan linear time.\n","title":"Enumerable","type":"protocol"},{"doc":"Retrieves the number of elements in the enumerable . It should return {:ok, count} if you can count the number of elements in enumerable in a faster way than fully traversing it. Otherwise it should return {:error, __MODULE__} and a default algorithm built on top of reduce/3 that runs in linear time will be used.","ref":"Enumerable.html#count/1","source_doc":"Retrieves the number of elements in the `enumerable`.\n\nIt should return `{:ok, count}` if you can count the number of elements\nin `enumerable` in a faster way than fully traversing it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.\n","title":"Enumerable.count/1","type":"function"},{"doc":"Checks if an element exists within the enumerable . It should return {:ok, boolean} if you can check the membership of a given element in enumerable with ===/2 without traversing the whole of it. Otherwise it should return {:error, __MODULE__} and a default algorithm built on top of reduce/3 that runs in linear time will be used. When called outside guards, the in and not in operators work by using this function.","ref":"Enumerable.html#member?/2","source_doc":"Checks if an `element` exists within the `enumerable`.\n\nIt should return `{:ok, boolean}` if you can check the membership of a\ngiven element in `enumerable` with `===/2` without traversing the whole\nof it.\n\nOtherwise it should return `{:error, __MODULE__}` and a default algorithm\nbuilt on top of `reduce/3` that runs in linear time will be used.\n\nWhen called outside guards, the [`in`](`in/2`) and [`not in`](`in/2`)\noperators work by using this function.\n","title":"Enumerable.member?/2","type":"function"},{"doc":"Reduces the enumerable into an element. Most of the operations in Enum are implemented in terms of reduce. This function should apply the given reducer/0 function to each element in the enumerable and proceed as expected by the returned accumulator. See the documentation of the types result/0 and acc/0 for more information. Examples As an example, here is the implementation of reduce for lists: def reduce ( _list , { :halt , acc } , _fun ) , do : { :halted , acc } def reduce ( list , { :suspend , acc } , fun ) , do : { :suspended , acc , &amp; reduce ( list , &amp;1 , fun ) } def reduce ( [ ] , { :cont , acc } , _fun ) , do : { :done , acc } def reduce ( [ head | tail ] , { :cont , acc } , fun ) , do : reduce ( tail , fun . ( head , acc ) , fun )","ref":"Enumerable.html#reduce/3","source_doc":"Reduces the `enumerable` into an element.\n\nMost of the operations in `Enum` are implemented in terms of reduce.\nThis function should apply the given `t:reducer/0` function to each\nelement in the `enumerable` and proceed as expected by the returned\naccumulator.\n\nSee the documentation of the types `t:result/0` and `t:acc/0` for\nmore information.\n\n## Examples\n\nAs an example, here is the implementation of `reduce` for lists:\n\n    def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}\n    def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n    def reduce([], {:cont, acc}, _fun), do: {:done, acc}\n    def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)\n\n","title":"Enumerable.reduce/3","type":"function"},{"doc":"Returns a function that slices the data structure contiguously. It should return either: {:ok, size, slicing_fun} - if the enumerable has a known bound and can access a position in the enumerable without traversing all previous elements. The slicing_fun will receive a start position, the amount of elements to fetch, and a step . {:ok, size, to_list_fun} - if the enumerable has a known bound and can access a position in the enumerable by first converting it to a list via to_list_fun . {:error, __MODULE__} - the enumerable cannot be sliced efficiently and a default algorithm built on top of reduce/3 that runs in linear time will be used. Differences to count/1 The size value returned by this function is used for boundary checks, therefore it is extremely important that this function only returns :ok if retrieving the size of the enumerable is cheap, fast, and takes constant time. Otherwise the simplest of operations, such as Enum.at(enumerable, 0) , will become too expensive. On the other hand, the count/1 function in this protocol should be implemented whenever you can count the number of elements in the collection without traversing it.","ref":"Enumerable.html#slice/1","source_doc":"Returns a function that slices the data structure contiguously.\n\nIt should return either:\n\n  * `{:ok, size, slicing_fun}` - if the `enumerable` has a known\n    bound and can access a position in the `enumerable` without\n    traversing all previous elements. The `slicing_fun` will receive\n    a `start` position, the `amount` of elements to fetch, and a\n    `step`.\n\n  * `{:ok, size, to_list_fun}` - if the `enumerable` has a known bound\n    and can access a position in the `enumerable` by first converting\n    it to a list via `to_list_fun`.\n\n  * `{:error, __MODULE__}` - the enumerable cannot be sliced efficiently\n    and a default algorithm built on top of `reduce/3` that runs in\n    linear time will be used.\n\n## Differences to `count/1`\n\nThe `size` value returned by this function is used for boundary checks,\ntherefore it is extremely important that this function only returns `:ok`\nif retrieving the `size` of the `enumerable` is cheap, fast, and takes\nconstant time. Otherwise the simplest of operations, such as\n`Enum.at(enumerable, 0)`, will become too expensive.\n\nOn the other hand, the `count/1` function in this protocol should be\nimplemented whenever you can count the number of elements in the collection\nwithout traversing it.\n","title":"Enumerable.slice/1","type":"function"},{"doc":"The accumulator value for each step. It must be a tagged tuple with one of the following &quot;tags&quot;: :cont - the enumeration should continue :halt - the enumeration should halt immediately :suspend - the enumeration should be suspended immediately Depending on the accumulator value, the result returned by Enumerable.reduce/3 will change. Please check the result/0 type documentation for more information. In case a reducer/0 function returns a :suspend accumulator, it must be explicitly handled by the caller and never leak.","ref":"Enumerable.html#t:acc/0","source_doc":"The accumulator value for each step.\n\nIt must be a tagged tuple with one of the following \"tags\":\n\n  * `:cont`    - the enumeration should continue\n  * `:halt`    - the enumeration should halt immediately\n  * `:suspend` - the enumeration should be suspended immediately\n\nDepending on the accumulator value, the result returned by\n`Enumerable.reduce/3` will change. Please check the `t:result/0`\ntype documentation for more information.\n\nIn case a `t:reducer/0` function returns a `:suspend` accumulator,\nit must be explicitly handled by the caller and never leak.\n","title":"Enumerable.acc/0","type":"type"},{"doc":"A partially applied reduce function. The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result. A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.","ref":"Enumerable.html#t:continuation/0","source_doc":"A partially applied reduce function.\n\nThe continuation is the closure returned as a result when\nthe enumeration is suspended. When invoked, it expects\na new accumulator and it returns the result.\n\nA continuation can be trivially implemented as long as the reduce\nfunction is defined in a tail recursive fashion. If the function\nis tail recursive, all the state is passed as arguments, so\nthe continuation is the reducing function partially applied.\n","title":"Enumerable.continuation/0","type":"type"},{"doc":"The reducer function. Should be called with the enumerable element and the accumulator contents. Returns the accumulator for the next enumeration step.","ref":"Enumerable.html#t:reducer/0","source_doc":"The reducer function.\n\nShould be called with the `enumerable` element and the\naccumulator contents.\n\nReturns the accumulator for the next enumeration step.\n","title":"Enumerable.reducer/0","type":"type"},{"doc":"The result of the reduce operation. It may be done when the enumeration is finished by reaching its end, or halted / suspended when the enumeration was halted or suspended by the tagged accumulator. In case the tagged :halt accumulator is given, the :halted tuple with the accumulator must be returned. Functions like Enum.take_while/2 use :halt underneath and can be used to test halting enumerables. In case the tagged :suspend accumulator is given, the caller must return the :suspended tuple with the accumulator and a continuation. The caller is then responsible of managing the continuation and the caller must always call the continuation, eventually halting or continuing until the end. Enum.zip/2 uses suspension, so it can be used to test whether your implementation handles suspension correctly. You can also use Stream.zip/2 with Enum.take_while/2 to test the combination of :suspend with :halt .","ref":"Enumerable.html#t:result/0","source_doc":"The result of the reduce operation.\n\nIt may be *done* when the enumeration is finished by reaching\nits end, or *halted*/*suspended* when the enumeration was halted\nor suspended by the tagged accumulator.\n\nIn case the tagged `:halt` accumulator is given, the `:halted` tuple\nwith the accumulator must be returned. Functions like `Enum.take_while/2`\nuse `:halt` underneath and can be used to test halting enumerables.\n\nIn case the tagged `:suspend` accumulator is given, the caller must\nreturn the `:suspended` tuple with the accumulator and a continuation.\nThe caller is then responsible of managing the continuation and the\ncaller must always call the continuation, eventually halting or continuing\nuntil the end. `Enum.zip/2` uses suspension, so it can be used to test\nwhether your implementation handles suspension correctly. You can also use\n`Stream.zip/2` with `Enum.take_while/2` to test the combination of\n`:suspend` with `:halt`.\n","title":"Enumerable.result/0","type":"type"},{"doc":"A slicing function that receives the initial position, the number of elements in the slice, and the step. The start position is a number &gt;= 0 and guaranteed to exist in the enumerable . The length is a number &gt;= 1 in a way that start + length * step &lt;= count , where count is the maximum amount of elements in the enumerable. The function should return a non empty list where the amount of elements is equal to length .","ref":"Enumerable.html#t:slicing_fun/0","source_doc":"A slicing function that receives the initial position,\nthe number of elements in the slice, and the step.\n\nThe `start` position is a number `>= 0` and guaranteed to\nexist in the `enumerable`. The length is a number `>= 1`\nin a way that `start + length * step <= count`, where\n`count` is the maximum amount of elements in the enumerable.\n\nThe function should return a non empty list where\nthe amount of elements is equal to `length`.\n","title":"Enumerable.slicing_fun/0","type":"type"},{"doc":"All the types that implement this protocol.","ref":"Enumerable.html#t:t/0","source_doc":"All the types that implement this protocol.\n","title":"Enumerable.t/0","type":"type"},{"doc":"An enumerable of elements of type element . This type is equivalent to t/0 but is especially useful for documentation. For example, imagine you define a function that expects an enumerable of integers and returns an enumerable of strings: @spec integers_to_strings ( Enumerable . t ( integer ( ) ) ) :: Enumerable . t ( String . t ( ) ) def integers_to_strings ( integers ) do Stream . map ( integers , &amp; Integer . to_string / 1 ) end","ref":"Enumerable.html#t:t/1","source_doc":"An enumerable of elements of type `element`.\n\nThis type is equivalent to `t:t/0` but is especially useful for documentation.\n\nFor example, imagine you define a function that expects an enumerable of\nintegers and returns an enumerable of strings:\n\n    @spec integers_to_strings(Enumerable.t(integer())) :: Enumerable.t(String.t())\n    def integers_to_strings(integers) do\n      Stream.map(integers, &Integer.to_string/1)\n    end\n\n","title":"Enumerable.t/1","type":"type"},{"doc":"Receives an enumerable and returns a list.","ref":"Enumerable.html#t:to_list_fun/0","source_doc":"Receives an enumerable and returns a list.\n","title":"Enumerable.to_list_fun/0","type":"type"},{"doc":"The Inspect protocol converts an Elixir data structure into an algebra document. This is typically done when you want to customize how your own structs are inspected in logs and the terminal. This documentation refers to implementing the Inspect protocol for your own data structures. To learn more about using inspect, see Kernel.inspect/2 and IO.inspect/2 . Inspect representation There are typically three choices of inspect representation. In order to understand them, let's imagine we have the following User struct: defmodule User do defstruct [ :id , :name , :address ] end Our choices are: Print the struct using Elixir's struct syntax, for example: %User{address: &quot;Earth&quot;, id: 13, name: &quot;Jane&quot;} . This is the default representation and best choice if all struct fields are public. Print using the #User&lt;...&gt; notation, for example: #User&lt;id: 13, name: &quot;Jane&quot;, ...&gt; . This notation does not emit valid Elixir code and is typically used when the struct has private fields (for example, you may want to hide the field :address to redact person identifiable information). Print the struct using the expression syntax, for example: User.new(13, &quot;Jane&quot;, &quot;Earth&quot;) . This assumes there is a User.new/3 function. This option is mostly used as an alternative to option 2 for representing custom data structures, such as MapSet , Date.Range , and others. You can implement the Inspect protocol for your own structs while adhering to the conventions above. Option 1 is the default representation and you can quickly achieve option 2 by deriving the Inspect protocol. For option 3, you need your custom implementation. Deriving The Inspect protocol can be derived to customize the order of fields (the default is alphabetical) and hide certain fields from structs, so they don't show up in logs, inspects and similar. The latter is especially useful for fields containing private information. The supported options are: :only - only include the given fields when inspecting. :except - remove the given fields when inspecting. :optional - (since v1.14.0) do not include a field if it matches its default value. This can be used to simplify the struct representation at the cost of hiding information. Whenever :only or :except are used to restrict fields, the struct will be printed using the #User&lt;...&gt; notation, as the struct can no longer be copy and pasted as valid Elixir code. Let's see an example: defmodule User do @derive { Inspect , only : [ :id , :name ] } defstruct [ :id , :name , :address ] end inspect ( % User { id : 1 , name : &quot;Jane&quot; , address : &quot;Earth&quot; } ) #=&gt; #User&lt;id: 1, name: &quot;Jane&quot;, ...&gt; If you use only the :optional option, the struct will still be printed as %User{...} . Custom implementation You can also define your custom protocol implementation by defining the inspect/2 function. The function receives the entity to be inspected followed by the inspecting options, represented by the struct Inspect.Opts . Building of the algebra document is done with Inspect.Algebra . Many times, inspecting a structure can be implemented in function of existing entities. For example, here is MapSet 's inspect/2 implementation: defimpl Inspect , for : MapSet do import Inspect.Algebra def inspect ( map_set , opts ) do concat ( [ &quot;MapSet.new(&quot; , Inspect.List . inspect ( MapSet . to_list ( map_set ) , opts ) , &quot;)&quot; ] ) end end The concat/1 function comes from Inspect.Algebra and it concatenates algebra documents together. In the example above it is concatenating the string &quot;MapSet.new(&quot; , the document returned by Inspect.Algebra.to_doc/2 , and the final string &quot;)&quot; . Therefore, the MapSet with the numbers 1, 2, and 3 will be printed as: iex&gt; MapSet . new ( [ 1 , 2 , 3 ] , fn x -&gt; x * 2 end ) MapSet . new ( [ 2 , 4 , 6 ] ) In other words, MapSet 's inspect representation returns an expression that, when evaluated, builds the MapSet itself. Error handling In case there is an error while your structure is being inspected, Elixir will raise an ArgumentError error and will automatically fall back to a raw representation for printing the structure. You can, however, access the underlying error by invoking the Inspect implementation directly. For example, to test Inspect.MapSet above, you can invoke it as: Inspect.MapSet . inspect ( MapSet . new ( ) , % Inspect.Opts { } )","ref":"Inspect.html","source_doc":"The `Inspect` protocol converts an Elixir data structure into an\nalgebra document.\n\nThis is typically done when you want to customize how your own\nstructs are inspected in logs and the terminal.\n\nThis documentation refers to implementing the `Inspect` protocol\nfor your own data structures. To learn more about using inspect,\nsee `Kernel.inspect/2` and `IO.inspect/2`.\n\n## Inspect representation\n\nThere are typically three choices of inspect representation. In order\nto understand them, let's imagine we have the following `User` struct:\n\n    defmodule User do\n      defstruct [:id, :name, :address]\n    end\n\nOur choices are:\n\n  1. Print the struct using Elixir's struct syntax, for example:\n     `%User{address: \"Earth\", id: 13, name: \"Jane\"}`. This is the\n     default representation and best choice if all struct fields\n     are public.\n\n  2. Print using the `#User<...>` notation, for example: `#User<id: 13, name: \"Jane\", ...>`.\n     This notation does not emit valid Elixir code and is typically\n     used when the struct has private fields (for example, you may want\n     to hide the field `:address` to redact person identifiable information).\n\n  3. Print the struct using the expression syntax, for example:\n     `User.new(13, \"Jane\", \"Earth\")`. This assumes there is a `User.new/3`\n     function. This option is mostly used as an alternative to option 2\n     for representing custom data structures, such as `MapSet`, `Date.Range`,\n     and others.\n\nYou can implement the Inspect protocol for your own structs while\nadhering to the conventions above. Option 1 is the default representation\nand you can quickly achieve option 2 by deriving the `Inspect` protocol.\nFor option 3, you need your custom implementation.\n\n## Deriving\n\nThe `Inspect` protocol can be derived to customize the order of fields\n(the default is alphabetical) and hide certain fields from structs,\nso they don't show up in logs, inspects and similar. The latter is\nespecially useful for fields containing private information.\n\nThe supported options are:\n\n  * `:only` - only include the given fields when inspecting.\n\n  * `:except` - remove the given fields when inspecting.\n\n  * `:optional` - (since v1.14.0) do not include a field if it\n    matches its default value. This can be used to simplify the\n    struct representation at the cost of hiding information.\n\nWhenever `:only` or `:except` are used to restrict fields,\nthe struct will be printed using the `#User<...>` notation,\nas the struct can no longer be copy and pasted as valid Elixir\ncode. Let's see an example:\n\n    defmodule User do\n      @derive {Inspect, only: [:id, :name]}\n      defstruct [:id, :name, :address]\n    end\n\n    inspect(%User{id: 1, name: \"Jane\", address: \"Earth\"})\n    #=> #User<id: 1, name: \"Jane\", ...>\n\nIf you use only the `:optional` option, the struct will still be\nprinted as `%User{...}`.\n\n## Custom implementation\n\nYou can also define your custom protocol implementation by\ndefining the `inspect/2` function. The function receives the\nentity to be inspected followed by the inspecting options,\nrepresented by the struct `Inspect.Opts`. Building of the\nalgebra document is done with `Inspect.Algebra`.\n\nMany times, inspecting a structure can be implemented in function\nof existing entities. For example, here is `MapSet`'s `inspect/2`\nimplementation:\n\n    defimpl Inspect, for: MapSet do\n      import Inspect.Algebra\n\n      def inspect(map_set, opts) do\n        concat([\"MapSet.new(\", Inspect.List.inspect(MapSet.to_list(map_set), opts), \")\"])\n      end\n    end\n\nThe [`concat/1`](`Inspect.Algebra.concat/1`) function comes from\n`Inspect.Algebra` and it concatenates algebra documents together.\nIn the example above it is concatenating the string `\"MapSet.new(\"`,\nthe document returned by `Inspect.Algebra.to_doc/2`, and the final\nstring `\")\"`. Therefore, the MapSet with the numbers 1, 2, and 3\nwill be printed as:\n\n    iex> MapSet.new([1, 2, 3], fn x -> x * 2 end)\n    MapSet.new([2, 4, 6])\n\nIn other words, `MapSet`'s inspect representation returns an expression\nthat, when evaluated, builds the `MapSet` itself.\n\n### Error handling\n\nIn case there is an error while your structure is being inspected,\nElixir will raise an `ArgumentError` error and will automatically fall back\nto a raw representation for printing the structure.\n\nYou can, however, access the underlying error by invoking the `Inspect`\nimplementation directly. For example, to test `Inspect.MapSet` above,\nyou can invoke it as:\n\n    Inspect.MapSet.inspect(MapSet.new(), %Inspect.Opts{})\n\n","title":"Inspect","type":"protocol"},{"doc":"Converts term into an algebra document. This function shouldn't be invoked directly, unless when implementing a custom inspect_fun to be given to Inspect.Opts . Everywhere else, Inspect.Algebra.to_doc/2 should be preferred as it handles structs and exceptions.","ref":"Inspect.html#inspect/2","source_doc":"Converts `term` into an algebra document.\n\nThis function shouldn't be invoked directly, unless when implementing\na custom `inspect_fun` to be given to `Inspect.Opts`. Everywhere else,\n`Inspect.Algebra.to_doc/2` should be preferred as it handles structs\nand exceptions.\n","title":"Inspect.inspect/2","type":"function"},{"doc":"All the types that implement this protocol.","ref":"Inspect.html#t:t/0","source_doc":"All the types that implement this protocol.\n","title":"Inspect.t/0","type":"type"},{"doc":"A set of functions for creating and manipulating algebra documents. This module implements the functionality described in &quot;Strictly Pretty&quot; (2000) by Christian Lindig with small additions, like support for binary nodes and a break mode that maximises use of horizontal space. iex&gt; Inspect.Algebra . empty ( ) :doc_nil iex&gt; &quot;foo&quot; &quot;foo&quot; With the functions in this module, we can concatenate different elements together and render them: iex&gt; doc = Inspect.Algebra . concat ( Inspect.Algebra . empty ( ) , &quot;foo&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;foo&quot; ] The functions nest/2 , space/2 and line/2 help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like glue/3 and group/1 . A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it: iex&gt; doc = Inspect.Algebra . glue ( &quot;a&quot; , &quot; &quot; , &quot;b&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;a&quot; , &quot; &quot; , &quot;b&quot; ] Note that the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline: iex&gt; doc = Inspect.Algebra . glue ( String . duplicate ( &quot;a&quot; , 20 ) , &quot; &quot; , &quot;b&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 10 ) [ &quot;aaaaaaaaaaaaaaaaaaaa&quot; , &quot; \\n &quot; , &quot;b&quot; ] This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in string/1 , which then relies on String.length/1 to precompute the document size. Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, such as to_doc/2 . Implementation details The implementation of Inspect.Algebra is based on the Strictly Pretty paper by Lindig which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines). This implementation provides two types of breaks: :strict and :flex . When a group does not fit, all strict breaks are treated as newlines. Flex breaks, however, are re-evaluated on every occurrence and may still be rendered flat. See break/1 and flex_break/1 for more information. This implementation also adds force_unfit/1 and next_break_fits/2 which give more control over the document fitting.","ref":"Inspect.Algebra.html","source_doc":"A set of functions for creating and manipulating algebra\ndocuments.\n\nThis module implements the functionality described in\n[\"Strictly Pretty\" (2000) by Christian Lindig][0] with small\nadditions, like support for binary nodes and a break mode that\nmaximises use of horizontal space.\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil\n\n    iex> \"foo\"\n    \"foo\"\n\nWith the functions in this module, we can concatenate different\nelements together and render them:\n\n    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty(), \"foo\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"foo\"]\n\nThe functions `nest/2`, `space/2` and `line/2` help you put the\ndocument together into a rigid structure. However, the document\nalgebra gets interesting when using functions like `glue/3` and\n`group/1`. A glue inserts a break between two documents. A group\nindicates a document that must fit the current line, otherwise\nbreaks are rendered as new lines. Let's glue two docs together\nwith a break, group it and then render it:\n\n    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \" \", \"b\"]\n\nNote that the break was represented as is, because we haven't reached\na line limit. Once we do, it is replaced by a newline:\n\n    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n\nThis module uses the byte size to compute how much space there is\nleft. If your document contains strings, then those need to be\nwrapped in `string/1`, which then relies on `String.length/1` to\nprecompute the document size.\n\nFinally, this module also contains Elixir related functions, a bit\ntied to Elixir formatting, such as `to_doc/2`.\n\n## Implementation details\n\nThe implementation of `Inspect.Algebra` is based on the Strictly Pretty\npaper by [Lindig][0] which builds on top of previous pretty printing\nalgorithms but is tailored to strict languages, such as Elixir.\nThe core idea in the paper is the use of explicit document groups which\nare rendered as flat (breaks as spaces) or as break (breaks as newlines).\n\nThis implementation provides two types of breaks: `:strict` and `:flex`.\nWhen a group does not fit, all strict breaks are treated as newlines.\nFlex breaks, however, are re-evaluated on every occurrence and may still\nbe rendered flat. See `break/1` and `flex_break/1` for more information.\n\nThis implementation also adds `force_unfit/1` and `next_break_fits/2` which\ngive more control over the document fitting.\n\n  [0]: https://lindig.github.io/papers/strictly-pretty-2000.pdf\n\n","title":"Inspect.Algebra","type":"module"},{"doc":"Returns a break document based on the given string . This break can be rendered as a linebreak or as the given string , depending on the mode of the chosen layout. Examples Let's create a document by concatenating two strings with a break between them: iex&gt; doc = Inspect.Algebra . concat ( [ &quot;a&quot; , Inspect.Algebra . break ( &quot; \\t &quot; ) , &quot;b&quot; ] ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;a&quot; , &quot; \\t &quot; , &quot;b&quot; ] Note that the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline: iex&gt; break = Inspect.Algebra . break ( &quot; \\t &quot; ) iex&gt; doc = Inspect.Algebra . concat ( [ String . duplicate ( &quot;a&quot; , 20 ) , break , &quot;b&quot; ] ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 10 ) [ &quot;aaaaaaaaaaaaaaaaaaaa&quot; , &quot; \\n &quot; , &quot;b&quot; ]","ref":"Inspect.Algebra.html#break/1","source_doc":"Returns a break document based on the given `string`.\n\nThis break can be rendered as a linebreak or as the given `string`,\ndepending on the `mode` of the chosen layout.\n\n## Examples\n\nLet's create a document by concatenating two strings with a break between\nthem:\n\n    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t\"), \"b\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"\\t\", \"b\"]\n\nNote that the break was represented with the given string, because we didn't\nreach a line limit. Once we do, it is replaced by a newline:\n\n    iex> break = Inspect.Algebra.break(\"\\t\")\n    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, \"b\"])\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 10)\n    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n\n","title":"Inspect.Algebra.break/1","type":"function"},{"doc":"Collapse any new lines and whitespace following this node, emitting up to max new lines.","ref":"Inspect.Algebra.html#collapse_lines/1","source_doc":"Collapse any new lines and whitespace following this\nnode, emitting up to `max` new lines.\n","title":"Inspect.Algebra.collapse_lines/1","type":"function"},{"doc":"Colors a document if the color_key has a color in the options.","ref":"Inspect.Algebra.html#color/3","source_doc":"Colors a document if the `color_key` has a color in the options.\n","title":"Inspect.Algebra.color/3","type":"function"},{"doc":"Concatenates a list of documents returning a new document. Examples iex&gt; doc = Inspect.Algebra . concat ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ]","ref":"Inspect.Algebra.html#concat/1","source_doc":"Concatenates a list of documents returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"a\", \"b\", \"c\"]\n\n","title":"Inspect.Algebra.concat/1","type":"function"},{"doc":"Concatenates two document entities returning a new document. Examples iex&gt; doc = Inspect.Algebra . concat ( &quot;hello&quot; , &quot;world&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;hello&quot; , &quot;world&quot; ]","ref":"Inspect.Algebra.html#concat/2","source_doc":"Concatenates two document entities returning a new document.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"world\"]\n\n","title":"Inspect.Algebra.concat/2","type":"function"},{"doc":"Wraps collection in left and right according to limit and contents. It uses the given left and right documents as surrounding and the separator document separator to separate items in docs . If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit. The limit in the given inspect_opts is respected and when reached this function stops processing and outputs &quot;...&quot; instead. Options :separator - the separator used between each doc :break - If :strict , always break between each element. If :flex , breaks only when necessary. If :maybe , chooses :flex only if all elements are text-based, otherwise is :strict Examples iex&gt; inspect_opts = % Inspect.Opts { limit : :infinity } iex&gt; fun = fn i , _opts -&gt; to_string ( i ) end iex&gt; doc = Inspect.Algebra . container_doc ( &quot;[&quot; , Enum . to_list ( 1 .. 5 ) , &quot;]&quot; , inspect_opts , fun ) iex&gt; Inspect.Algebra . format ( doc , 5 ) |&gt; IO . iodata_to_binary ( ) &quot;[1, \\n 2, \\n 3, \\n 4, \\n 5]&quot; iex&gt; inspect_opts = % Inspect.Opts { limit : 3 } iex&gt; fun = fn i , _opts -&gt; to_string ( i ) end iex&gt; doc = Inspect.Algebra . container_doc ( &quot;[&quot; , Enum . to_list ( 1 .. 5 ) , &quot;]&quot; , inspect_opts , fun ) iex&gt; Inspect.Algebra . format ( doc , 20 ) |&gt; IO . iodata_to_binary ( ) &quot;[1, 2, 3, ...]&quot; iex&gt; inspect_opts = % Inspect.Opts { limit : 3 } iex&gt; fun = fn i , _opts -&gt; to_string ( i ) end iex&gt; opts = [ separator : &quot;!&quot; ] iex&gt; doc = Inspect.Algebra . container_doc ( &quot;[&quot; , Enum . to_list ( 1 .. 5 ) , &quot;]&quot; , inspect_opts , fun , opts ) iex&gt; Inspect.Algebra . format ( doc , 20 ) |&gt; IO . iodata_to_binary ( ) &quot;[1! 2! 3! ...]&quot;","ref":"Inspect.Algebra.html#container_doc/6","source_doc":"Wraps `collection` in `left` and `right` according to limit and contents.\n\nIt uses the given `left` and `right` documents as surrounding and the\nseparator document `separator` to separate items in `docs`. If all entries\nin the collection are simple documents (texts or strings), then this function\nattempts to put as much as possible on the same line. If they are not simple,\nonly one entry is shown per line if they do not fit.\n\nThe limit in the given `inspect_opts` is respected and when reached this\nfunction stops processing and outputs `\"...\"` instead.\n\n## Options\n\n  * `:separator` - the separator used between each doc\n  * `:break` - If `:strict`, always break between each element. If `:flex`,\n    breaks only when necessary. If `:maybe`, chooses `:flex` only if all\n    elements are text-based, otherwise is `:strict`\n\n## Examples\n\n    iex> inspect_opts = %Inspect.Opts{limit: :infinity}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary()\n    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1, 2, 3, ...]\"\n\n    iex> inspect_opts = %Inspect.Opts{limit: 3}\n    iex> fun = fn i, _opts -> to_string(i) end\n    iex> opts = [separator: \"!\"]\n    iex> doc = Inspect.Algebra.container_doc(\"[\", Enum.to_list(1..5), \"]\", inspect_opts, fun, opts)\n    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary()\n    \"[1! 2! 3! ...]\"\n\n","title":"Inspect.Algebra.container_doc/6","type":"function"},{"doc":"Returns a document entity used to represent nothingness. Examples iex&gt; Inspect.Algebra . empty ( ) :doc_nil","ref":"Inspect.Algebra.html#empty/0","source_doc":"Returns a document entity used to represent nothingness.\n\n## Examples\n\n    iex> Inspect.Algebra.empty()\n    :doc_nil\n\n","title":"Inspect.Algebra.empty/0","type":"function"},{"doc":"Returns a flex break document based on the given string . A flex break still causes a group to break, like break/1 , but it is re-evaluated when the documented is rendered. For example, take a group document represented as [1, 2, 3] where the space after every comma is a break. When the document above does not fit a single line, all breaks are enabled, causing the document to be rendered as: [ 1 , 2 , 3 ] However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as: [ 1 , 2 , 3 ] Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated. This function is used by container_doc/6 and friends to the maximum number of entries on the same line.","ref":"Inspect.Algebra.html#flex_break/1","source_doc":"Returns a flex break document based on the given `string`.\n\nA flex break still causes a group to break, like `break/1`,\nbut it is re-evaluated when the documented is rendered.\n\nFor example, take a group document represented as `[1, 2, 3]`\nwhere the space after every comma is a break. When the document\nabove does not fit a single line, all breaks are enabled,\ncausing the document to be rendered as:\n\n    [1,\n     2,\n     3]\n\nHowever, if flex breaks are used, then each break is re-evaluated\nwhen rendered, so the document could be possible rendered as:\n\n    [1, 2,\n     3]\n\nHence the name \"flex\". they are more flexible when it comes\nto the document fitting. On the other hand, they are more expensive\nsince each break needs to be re-evaluated.\n\nThis function is used by `container_doc/6` and friends to the\nmaximum number of entries on the same line.\n","title":"Inspect.Algebra.flex_break/1","type":"function"},{"doc":"Glues two documents ( doc1 and doc2 ) inserting a flex_break/1 given by break_string between them. This function is used by container_doc/6 and friends to the maximum number of entries on the same line.","ref":"Inspect.Algebra.html#flex_glue/3","source_doc":"Glues two documents (`doc1` and `doc2`) inserting a\n`flex_break/1` given by `break_string` between them.\n\nThis function is used by `container_doc/6` and friends\nto the maximum number of entries on the same line.\n","title":"Inspect.Algebra.flex_glue/3","type":"function"},{"doc":"Folds a list of documents into a document using the given folder function. The list of documents is folded &quot;from the right&quot;; in that, this function is similar to List.foldr/3 , except that it doesn't expect an initial accumulator and uses the last element of docs as the initial accumulator. Examples iex&gt; docs = [ &quot;A&quot; , &quot;B&quot; , &quot;C&quot; ] iex&gt; docs = ...&gt; Inspect.Algebra . fold_doc ( docs , fn doc , acc -&gt; ...&gt; Inspect.Algebra . concat ( [ doc , &quot;!&quot; , acc ] ) ...&gt; end ) iex&gt; Inspect.Algebra . format ( docs , 80 ) [ &quot;A&quot; , &quot;!&quot; , &quot;B&quot; , &quot;!&quot; , &quot;C&quot; ]","ref":"Inspect.Algebra.html#fold_doc/2","source_doc":"Folds a list of documents into a document using the given folder function.\n\nThe list of documents is folded \"from the right\"; in that, this function is\nsimilar to `List.foldr/3`, except that it doesn't expect an initial\naccumulator and uses the last element of `docs` as the initial accumulator.\n\n## Examples\n\n    iex> docs = [\"A\", \"B\", \"C\"]\n    iex> docs =\n    ...>   Inspect.Algebra.fold_doc(docs, fn doc, acc ->\n    ...>     Inspect.Algebra.concat([doc, \"!\", acc])\n    ...>   end)\n    iex> Inspect.Algebra.format(docs, 80)\n    [\"A\", \"!\", \"B\", \"!\", \"C\"]\n\n","title":"Inspect.Algebra.fold_doc/2","type":"function"},{"doc":"Forces the current group to be unfit.","ref":"Inspect.Algebra.html#force_unfit/1","source_doc":"Forces the current group to be unfit.\n","title":"Inspect.Algebra.force_unfit/1","type":"function"},{"doc":"Formats a given document for a given width. Takes the maximum width and a document to print as its arguments and returns an IO data representation of the best layout for the document to fit in the given width. The document starts flat (without breaks) until a group is found. Examples iex&gt; doc = Inspect.Algebra . glue ( &quot;hello&quot; , &quot; &quot; , &quot;world&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; doc |&gt; Inspect.Algebra . format ( 30 ) |&gt; IO . iodata_to_binary ( ) &quot;hello world&quot; iex&gt; doc |&gt; Inspect.Algebra . format ( 10 ) |&gt; IO . iodata_to_binary ( ) &quot;hello \\n world&quot;","ref":"Inspect.Algebra.html#format/2","source_doc":"Formats a given document for a given width.\n\nTakes the maximum width and a document to print as its arguments\nand returns an IO data representation of the best layout for the\ndocument to fit in the given width.\n\nThe document starts flat (without breaks) until a group is found.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> doc |> Inspect.Algebra.format(30) |> IO.iodata_to_binary()\n    \"hello world\"\n    iex> doc |> Inspect.Algebra.format(10) |> IO.iodata_to_binary()\n    \"hello\\nworld\"\n\n","title":"Inspect.Algebra.format/2","type":"function"},{"doc":"Glues two documents ( doc1 and doc2 ) inserting the given break break_string between them. For more information on how the break is inserted, see break/1 . Examples iex&gt; doc = Inspect.Algebra . glue ( &quot;hello&quot; , &quot;world&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;hello&quot; , &quot; &quot; , &quot;world&quot; ] iex&gt; doc = Inspect.Algebra . glue ( &quot;hello&quot; , &quot; \\t &quot; , &quot;world&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;hello&quot; , &quot; \\t &quot; , &quot;world&quot; ]","ref":"Inspect.Algebra.html#glue/3","source_doc":"Glues two documents (`doc1` and `doc2`) inserting the given\nbreak `break_string` between them.\n\nFor more information on how the break is inserted, see `break/1`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \" \", \"world\"]\n\n    iex> doc = Inspect.Algebra.glue(\"hello\", \"\\t\", \"world\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"hello\", \"\\t\", \"world\"]\n\n","title":"Inspect.Algebra.glue/3","type":"function"},{"doc":"Returns a group containing the specified document doc . Documents in a group are attempted to be rendered together to the best of the renderer ability. The group mode can also be set to :inherit , which means it automatically breaks if the parent group has broken too. Examples iex&gt; doc = ...&gt; Inspect.Algebra . group ( ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . group ( ...&gt; Inspect.Algebra . concat ( ...&gt; &quot;Hello,&quot; , ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . break ( ) , ...&gt; &quot;A&quot; ...&gt; ) ...&gt; ) ...&gt; ) , ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . break ( ) , ...&gt; &quot;B&quot; ...&gt; ) ...&gt; ) ...&gt; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;Hello,&quot; , &quot; &quot; , &quot;A&quot; , &quot; &quot; , &quot;B&quot; ] iex&gt; Inspect.Algebra . format ( doc , 6 ) [ &quot;Hello,&quot; , &quot; \\n &quot; , &quot;A&quot; , &quot; \\n &quot; , &quot;B&quot; ]","ref":"Inspect.Algebra.html#group/2","source_doc":"Returns a group containing the specified document `doc`.\n\nDocuments in a group are attempted to be rendered together\nto the best of the renderer ability.\n\nThe group mode can also be set to `:inherit`, which means it\nautomatically breaks if the parent group has broken too.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.group(\n    ...>     Inspect.Algebra.concat(\n    ...>       Inspect.Algebra.group(\n    ...>         Inspect.Algebra.concat(\n    ...>           \"Hello,\",\n    ...>           Inspect.Algebra.concat(\n    ...>             Inspect.Algebra.break(),\n    ...>             \"A\"\n    ...>           )\n    ...>         )\n    ...>       ),\n    ...>       Inspect.Algebra.concat(\n    ...>         Inspect.Algebra.break(),\n    ...>         \"B\"\n    ...>       )\n    ...>     )\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n    iex> Inspect.Algebra.format(doc, 6)\n    [\"Hello,\", \"\\n\", \"A\", \"\\n\", \"B\"]\n\n","title":"Inspect.Algebra.group/2","type":"function"},{"doc":"","ref":"Inspect.Algebra.html#is_doc/1","source_doc":false,"title":"Inspect.Algebra.is_doc/1","type":"macro"},{"doc":"A mandatory linebreak. A group with linebreaks will fit if all lines in the group fit. Examples iex&gt; doc = ...&gt; Inspect.Algebra . concat ( ...&gt; Inspect.Algebra . concat ( ...&gt; &quot;Hughes&quot; , ...&gt; Inspect.Algebra . line ( ) ...&gt; ) , ...&gt; &quot;Wadler&quot; ...&gt; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;Hughes&quot; , &quot; \\n &quot; , &quot;Wadler&quot; ]","ref":"Inspect.Algebra.html#line/0","source_doc":"A mandatory linebreak.\n\nA group with linebreaks will fit if all lines in the group fit.\n\n## Examples\n\n    iex> doc =\n    ...>   Inspect.Algebra.concat(\n    ...>     Inspect.Algebra.concat(\n    ...>       \"Hughes\",\n    ...>       Inspect.Algebra.line()\n    ...>     ),\n    ...>     \"Wadler\"\n    ...>   )\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]\n\n","title":"Inspect.Algebra.line/0","type":"function"},{"doc":"Inserts a mandatory linebreak between two documents. See line/0 . Examples iex&gt; doc = Inspect.Algebra . line ( &quot;Hughes&quot; , &quot;Wadler&quot; ) iex&gt; Inspect.Algebra . format ( doc , 80 ) [ &quot;Hughes&quot; , &quot; \\n &quot; , &quot;Wadler&quot; ]","ref":"Inspect.Algebra.html#line/2","source_doc":"Inserts a mandatory linebreak between two documents.\n\nSee `line/0`.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 80)\n    [\"Hughes\", \"\\n\", \"Wadler\"]\n\n","title":"Inspect.Algebra.line/2","type":"function"},{"doc":"Nests the given document at the given level . If level is an integer, that's the indentation appended to line breaks whenever they occur. If the level is :cursor , the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is :reset , it is set back to 0. mode can be :always , which means nesting always happen, or :break , which means nesting only happens inside a group that has been broken. Examples iex&gt; doc = Inspect.Algebra . nest ( Inspect.Algebra . glue ( &quot;hello&quot; , &quot;world&quot; ) , 5 ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 5 ) [ &quot;hello&quot; , &quot; \\n &quot; , &quot;world&quot; ]","ref":"Inspect.Algebra.html#nest/3","source_doc":"Nests the given document at the given `level`.\n\nIf `level` is an integer, that's the indentation appended\nto line breaks whenever they occur. If the level is `:cursor`,\nthe current position of the \"cursor\" in the document becomes\nthe nesting. If the level is `:reset`, it is set back to 0.\n\n`mode` can be `:always`, which means nesting always happen,\nor `:break`, which means nesting only happens inside a group\nthat has been broken.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"hello\", \"\\n     \", \"world\"]\n\n","title":"Inspect.Algebra.nest/3","type":"function"},{"doc":"Considers the next break as fit. mode can be :enabled or :disabled . When :enabled , it will consider the document as fit as soon as it finds the next break, effectively cancelling the break. It will also ignore any force_unfit/1 in search of the next break. When disabled, it behaves as usual and it will ignore any further next_break_fits/2 instruction. Examples This is used by Elixir's code formatter to avoid breaking code at some specific locations. For example, consider this code: some_function_call ( %{ ... , key : value , ... } ) Now imagine that this code does not fit its line. The code formatter introduces breaks inside ( and ) and inside %{ and } . Therefore the document would break as: some_function_call ( %{ ... , key : value , ... } ) The formatter wraps the algebra document representing the map in next_break_fits/1 so the code is formatted as: some_function_call ( %{ ... , key : value , ... } )","ref":"Inspect.Algebra.html#next_break_fits/2","source_doc":"Considers the next break as fit.\n\n`mode` can be `:enabled` or `:disabled`. When `:enabled`,\nit will consider the document as fit as soon as it finds\nthe next break, effectively cancelling the break. It will\nalso ignore any `force_unfit/1` in search of the next break.\n\nWhen disabled, it behaves as usual and it will ignore\nany further `next_break_fits/2` instruction.\n\n## Examples\n\nThis is used by Elixir's code formatter to avoid breaking\ncode at some specific locations. For example, consider this\ncode:\n\n    some_function_call(%{..., key: value, ...})\n\nNow imagine that this code does not fit its line. The code\nformatter introduces breaks inside `(` and `)` and inside\n`%{` and `}`. Therefore the document would break as:\n\n    some_function_call(\n      %{\n        ...,\n        key: value,\n        ...\n      }\n    )\n\nThe formatter wraps the algebra document representing the\nmap in `next_break_fits/1` so the code is formatted as:\n\n    some_function_call(%{\n      ...,\n      key: value,\n      ...\n    })\n\n","title":"Inspect.Algebra.next_break_fits/2","type":"function"},{"doc":"","ref":"Inspect.Algebra.html#no_limit/1","source_doc":false,"title":"Inspect.Algebra.no_limit/1","type":"function"},{"doc":"Inserts a mandatory single space between two documents. Examples iex&gt; doc = Inspect.Algebra . space ( &quot;Hughes&quot; , &quot;Wadler&quot; ) iex&gt; Inspect.Algebra . format ( doc , 5 ) [ &quot;Hughes&quot; , &quot; &quot; , &quot;Wadler&quot; ]","ref":"Inspect.Algebra.html#space/2","source_doc":"Inserts a mandatory single space between two documents.\n\n## Examples\n\n    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n    iex> Inspect.Algebra.format(doc, 5)\n    [\"Hughes\", \" \", \"Wadler\"]\n\n","title":"Inspect.Algebra.space/2","type":"function"},{"doc":"Creates a document represented by string. While Inspect.Algebra accepts binaries as documents, those are counted by binary size. On the other hand, string documents are measured in terms of graphemes towards the document size. Examples The following document has 10 bytes and therefore it does not format to width 9 without breaks: iex&gt; doc = Inspect.Algebra . glue ( &quot;olá&quot; , &quot; &quot; , &quot;mundo&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 9 ) [ &quot;olá&quot; , &quot; \\n &quot; , &quot;mundo&quot; ] However, if we use string , then the string length is used, instead of byte size, correctly fitting: iex&gt; string = Inspect.Algebra . string ( &quot;olá&quot; ) iex&gt; doc = Inspect.Algebra . glue ( string , &quot; &quot; , &quot;mundo&quot; ) iex&gt; doc = Inspect.Algebra . group ( doc ) iex&gt; Inspect.Algebra . format ( doc , 9 ) [ &quot;olá&quot; , &quot; &quot; , &quot;mundo&quot; ]","ref":"Inspect.Algebra.html#string/1","source_doc":"Creates a document represented by string.\n\nWhile `Inspect.Algebra` accepts binaries as documents,\nthose are counted by binary size. On the other hand,\n`string` documents are measured in terms of graphemes\ntowards the document size.\n\n## Examples\n\nThe following document has 10 bytes and therefore it\ndoes not format to width 9 without breaks:\n\n    iex> doc = Inspect.Algebra.glue(\"olá\", \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olá\", \"\\n\", \"mundo\"]\n\nHowever, if we use `string`, then the string length is\nused, instead of byte size, correctly fitting:\n\n    iex> string = Inspect.Algebra.string(\"olá\")\n    iex> doc = Inspect.Algebra.glue(string, \" \", \"mundo\")\n    iex> doc = Inspect.Algebra.group(doc)\n    iex> Inspect.Algebra.format(doc, 9)\n    [\"olá\", \" \", \"mundo\"]\n\n","title":"Inspect.Algebra.string/1","type":"function"},{"doc":"Converts an Elixir term to an algebra document according to the Inspect protocol.","ref":"Inspect.Algebra.html#to_doc/2","source_doc":"Converts an Elixir term to an algebra document\naccording to the `Inspect` protocol.\n","title":"Inspect.Algebra.to_doc/2","type":"function"},{"doc":"","ref":"Inspect.Algebra.html#t:t/0","source_doc":false,"title":"Inspect.Algebra.t/0","type":"type"},{"doc":"Defines the options used by the Inspect protocol. The following fields are available: :base - prints integers and binaries as :binary , :octal , :decimal , or :hex . Defaults to :decimal . :binaries - when :as_binaries all binaries will be printed in bit syntax. When :as_strings all binaries will be printed as strings, non-printable bytes will be escaped. When the default :infer , the binary will be printed as a string if :base is :decimal and if it is printable, otherwise in bit syntax. See String.printable?/1 to learn when a string is printable. :charlists - when :as_charlists all lists will be printed as charlists, non-printable elements will be escaped. When :as_lists all lists will be printed as lists. When the default :infer , the list will be printed as a charlist if it is printable, otherwise as list. See List.ascii_printable?/1 to learn when a charlist is printable. :custom_options (since v1.9.0) - a keyword list storing custom user-defined options. Useful when implementing the Inspect protocol for nested structs to pass the custom options through. It supports some pre-defined keys: :sort_maps (since v1.14.4) - if set to true , sorts key-value pairs in maps. This can be helpful to make map inspection deterministic for testing, given maps key order is random. :inspect_fun (since v1.9.0) - a function to build algebra documents. Defaults to Inspect.Opts.default_inspect_fun/0 . :limit - limits the number of items that are inspected for tuples, bitstrings, maps, lists and any other collection of items, with the exception of printable strings and printable charlists which use the :printable_limit option. If you don't want to limit the number of items to a particular number, use :infinity . It accepts a positive integer or :infinity . Defaults to 50 . :pretty - if set to true enables pretty printing. Defaults to false . :printable_limit - limits the number of characters that are inspected on printable strings and printable charlists. You can use String.printable?/1 and List.ascii_printable?/1 to check if a given string or charlist is printable. If you don't want to limit the number of characters to a particular number, use :infinity . It accepts a positive integer or :infinity . Defaults to 4096 . :safe - when false , failures while inspecting structs will be raised as errors instead of being wrapped in the Inspect.Error exception. This is useful when debugging failures and crashes for custom inspect implementations. Defaults to true . :structs - when false , structs are not formatted by the inspect protocol, they are instead printed as maps. Defaults to true . :syntax_colors - when set to a keyword list of colors the output is colorized. The keys are types and the values are the colors to use for each type (for example, [number: :red, atom: :blue] ). Types can include :atom , :binary , :boolean , :list , :map , :number , :regex , :string , :tuple , or some types to represent AST like :variable , :call , and :operator . Custom data types may provide their own options. Colors can be any IO.ANSI.ansidata/0 as accepted by IO.ANSI.format/1 . A default list of colors can be retrieved from IO.ANSI.syntax_colors/0 . :width - number of characters per line used when pretty is true or when printing to IO devices. Set to 0 to force each item to be printed on its own line. If you don't want to limit the number of items to a particular number, use :infinity . Defaults to 80 .","ref":"Inspect.Opts.html","source_doc":"Defines the options used by the `Inspect` protocol.\n\nThe following fields are available:\n\n  * `:base` - prints integers and binaries as `:binary`, `:octal`, `:decimal`,\n    or `:hex`. Defaults to `:decimal`.\n\n  * `:binaries` - when `:as_binaries` all binaries will be printed in bit\n    syntax.\n\n    When `:as_strings` all binaries will be printed as strings, non-printable\n    bytes will be escaped.\n\n    When the default `:infer`, the binary will be printed as a string if `:base`\n    is `:decimal` and if it is printable, otherwise in bit syntax. See\n    `String.printable?/1` to learn when a string is printable.\n\n  * `:charlists` - when `:as_charlists` all lists will be printed as charlists,\n    non-printable elements will be escaped.\n\n    When `:as_lists` all lists will be printed as lists.\n\n    When the default `:infer`, the list will be printed as a charlist if it\n    is printable, otherwise as list. See `List.ascii_printable?/1` to learn\n    when a charlist is printable.\n\n  * `:custom_options` (since v1.9.0) - a keyword list storing custom user-defined\n    options. Useful when implementing the `Inspect` protocol for nested structs\n    to pass the custom options through.\n\n    It supports some pre-defined keys:\n\n    - `:sort_maps` (since v1.14.4) - if set to `true`, sorts key-value pairs\n      in maps. This can be helpful to make map inspection deterministic for\n      testing, given maps key order is random.\n\n  * `:inspect_fun` (since v1.9.0) - a function to build algebra documents.\n    Defaults to `Inspect.Opts.default_inspect_fun/0`.\n\n  * `:limit` - limits the number of items that are inspected for tuples,\n    bitstrings, maps, lists and any other collection of items, with the exception of\n    printable strings and printable charlists which use the `:printable_limit` option.\n    If you don't want to limit the number of items to a particular number,\n    use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `50`.\n\n  * `:pretty` - if set to `true` enables pretty printing. Defaults to `false`.\n\n  * `:printable_limit` - limits the number of characters that are inspected\n    on printable strings and printable charlists. You can use `String.printable?/1`\n    and `List.ascii_printable?/1` to check if a given string or charlist is\n    printable. If you don't want to limit the number of characters to a particular\n    number, use `:infinity`. It accepts a positive integer or `:infinity`.\n    Defaults to `4096`.\n\n  * `:safe` - when `false`, failures while inspecting structs will be raised\n    as errors instead of being wrapped in the `Inspect.Error` exception. This\n    is useful when debugging failures and crashes for custom inspect\n    implementations. Defaults to `true`.\n\n  * `:structs` - when `false`, structs are not formatted by the inspect\n    protocol, they are instead printed as maps. Defaults to `true`.\n\n  * `:syntax_colors` - when set to a keyword list of colors the output is\n    colorized. The keys are types and the values are the colors to use for\n    each type (for example, `[number: :red, atom: :blue]`). Types can include\n    `:atom`, `:binary`, `:boolean`, `:list`, `:map`, `:number`, `:regex`,\n    `:string`, `:tuple`, or some types to represent AST like `:variable`,\n    `:call`, and `:operator`.\n    Custom data types may provide their own options.\n    Colors can be any `t:IO.ANSI.ansidata/0` as accepted by `IO.ANSI.format/1`.\n    A default list of colors can be retrieved from `IO.ANSI.syntax_colors/0`.\n\n  * `:width` - number of characters per line used when pretty is `true` or when\n    printing to IO devices. Set to `0` to force each item to be printed on its\n    own line. If you don't want to limit the number of items to a particular\n    number, use `:infinity`. Defaults to `80`.\n\n","title":"Inspect.Opts","type":"module"},{"doc":"Returns the default inspect function.","ref":"Inspect.Opts.html#default_inspect_fun/0","source_doc":"Returns the default inspect function.\n","title":"Inspect.Opts.default_inspect_fun/0","type":"function"},{"doc":"Sets the default inspect function. Set this option with care as it will change how all values in the system are inspected. The main use of this functionality is to provide an entry point to filter inspected values, in order for entities to comply with rules and legislations on data security and data privacy. It is extremely discouraged for libraries to set their own function as this must be controlled by applications. Libraries should instead define their own structs with custom inspect implementations. If a library must change the default inspect function, then it is best to define to ask users of your library to explicitly call default_inspect_fun/1 with your function of choice. The default is Inspect.inspect/2 . Examples previous_fun = Inspect.Opts . default_inspect_fun ( ) Inspect.Opts . default_inspect_fun ( fn %{ address : _ } = map , opts -&gt; previous_fun . ( %{ map | address : &quot;[REDACTED]&quot; } , opts ) value , opts -&gt; previous_fun . ( value , opts ) end )","ref":"Inspect.Opts.html#default_inspect_fun/1","source_doc":"Sets the default inspect function.\n\nSet this option with care as it will change how all values\nin the system are inspected. The main use of this functionality\nis to provide an entry point to filter inspected values,\nin order for entities to comply with rules and legislations\non data security and data privacy.\n\nIt is **extremely discouraged** for libraries to set their own\nfunction as this must be controlled by applications. Libraries\nshould instead define their own structs with custom inspect\nimplementations. If a library must change the default inspect\nfunction, then it is best to define to ask users of your library\nto explicitly call `default_inspect_fun/1` with your function of\nchoice.\n\nThe default is `Inspect.inspect/2`.\n\n## Examples\n\n    previous_fun = Inspect.Opts.default_inspect_fun()\n\n    Inspect.Opts.default_inspect_fun(fn\n      %{address: _} = map, opts ->\n        previous_fun.(%{map | address: \"[REDACTED]\"}, opts)\n\n      value, opts ->\n        previous_fun.(value, opts)\n    end)\n\n","title":"Inspect.Opts.default_inspect_fun/1","type":"function"},{"doc":"Builds an Inspect.Opts struct.","ref":"Inspect.Opts.html#new/1","source_doc":"Builds an `Inspect.Opts` struct.\n","title":"Inspect.Opts.new/1","type":"function"},{"doc":"","ref":"Inspect.Opts.html#t:color_key/0","source_doc":false,"title":"Inspect.Opts.color_key/0","type":"type"},{"doc":"","ref":"Inspect.Opts.html#t:t/0","source_doc":false,"title":"Inspect.Opts.t/0","type":"type"},{"doc":"The List.Chars protocol is responsible for converting a structure to a charlist (only if applicable). The only function that must be implemented is to_charlist/1 which does the conversion. The to_charlist/1 function automatically imported by Kernel invokes this protocol.","ref":"List.Chars.html","source_doc":"The `List.Chars` protocol is responsible for\nconverting a structure to a charlist (only if applicable).\n\nThe only function that must be implemented is\n`to_charlist/1` which does the conversion.\n\nThe `to_charlist/1` function automatically imported\nby `Kernel` invokes this protocol.\n","title":"List.Chars","type":"protocol"},{"doc":"Converts term to a charlist.","ref":"List.Chars.html#to_charlist/1","source_doc":"Converts `term` to a charlist.\n","title":"List.Chars.to_charlist/1","type":"function"},{"doc":"All the types that implement this protocol.","ref":"List.Chars.html#t:t/0","source_doc":"All the types that implement this protocol.\n","title":"List.Chars.t/0","type":"type"},{"doc":"Reference and functions for working with protocols. A protocol specifies an API that should be defined by its implementations. A protocol is defined with Kernel.defprotocol/2 and its implementations with Kernel.defimpl/3 . A real case In Elixir, we have two nouns for checking how many items there are in a data structure: length and size . length means the information must be computed. For example, length(list) needs to traverse the whole list to calculate its length. On the other hand, tuple_size(tuple) and byte_size(binary) do not depend on the tuple and binary size as the size information is precomputed in the data structure. Although Elixir includes specific functions such as tuple_size , binary_size and map_size , sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows: defprotocol Size do @doc &quot;Calculates the size (and not the length!) of a data structure&quot; def size ( data ) end Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for: defimpl Size , for : BitString do def size ( binary ) , do : byte_size ( binary ) end defimpl Size , for : Map do def size ( map ) , do : map_size ( map ) end defimpl Size , for : Tuple do def size ( tuple ) , do : tuple_size ( tuple ) end Finally, we can use the Size protocol to call the correct implementation: Size . size ( { 1 , 2 } ) # =&gt; 2 Size . size ( %{ key : :value } ) # =&gt; 1 Note that we didn't implement it for lists as we don't have the size information on lists, rather its value needs to be computed with length . The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol. It is possible to implement protocols for all Elixir types: Structs (see the &quot;Protocols and Structs&quot; section below) Tuple Atom List BitString Integer Float Function PID Map Port Reference Any (see the &quot;Fallback to Any &quot; section below) Protocols and Structs The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like MapSet . We can implement the Size protocol for those types as well: defimpl Size , for : MapSet do def size ( map_set ) , do : MapSet . size ( map_set ) end When implementing a protocol for a struct, the :for option can be omitted if the defimpl/3 call is inside the module that defines the struct: defmodule User do defstruct [ :email , :name ] defimpl Size do # two fields def size ( % User { } ) , do : 2 end end If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to Any . Conveniences for building implementations on top of existing ones are also available, look at defstruct/1 for more information about deriving protocols. Fallback to Any In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the @fallback_to_any attribute to true in the protocol definition: defprotocol Size do @fallback_to_any true def size ( data ) end The Size protocol can now be implemented for Any : defimpl Size , for : Any do def size ( _ ) , do : 0 end Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integer have a size of 0 . That's one of the reasons why @fallback_to_any is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour. Multiple implementations Protocols can also be implemented for multiple types at once: defprotocol Reversible do def reverse ( term ) end defimpl Reversible , for : [ Map , List ] do def reverse ( term ) , do : Enum . reverse ( term ) end Inside defimpl/3 , you can use @protocol to access the protocol being implemented and @for to access the module it is being defined for. Types Defining a protocol automatically defines a zero-arity type named t , which can be used as follows: @spec print_size ( Size . t ( ) ) :: :ok def print_size ( data ) do result = case Size . size ( data ) do 0 -&gt; &quot;data has no items&quot; 1 -&gt; &quot;data has one item&quot; n -&gt; &quot;data has \#{ n } items&quot; end IO . puts ( result ) end The @spec above expresses that all types allowed to implement the given protocol are valid argument types for the given function. Reflection Any protocol module contains three extra functions: __protocol__/1 - returns the protocol information. The function takes one of the following atoms: :consolidated? - returns whether the protocol is consolidated :functions - returns a keyword list of protocol functions and their arities :impls - if consolidated, returns {:consolidated, modules} with the list of modules implementing the protocol, otherwise :not_consolidated :module - the protocol module atom name impl_for/1 - returns the module that implements the protocol for the given argument, nil otherwise impl_for!/1 - same as above but raises Protocol.UndefinedError if an implementation is not found For example, for the Enumerable protocol we have: iex&gt; Enumerable . __protocol__ ( :functions ) [ count : 1 , member? : 2 , reduce : 3 , slice : 1 ] iex&gt; Enumerable . impl_for ( [ ] ) Enumerable.List iex&gt; Enumerable . impl_for ( 42 ) nil In addition, every protocol implementation module contains the __impl__/1 function. The function takes one of the following atoms: :for - returns the module responsible for the data structure of the protocol implementation :protocol - returns the protocol module for which this implementation is provided For example, the module implementing the Enumerable protocol for lists is Enumerable.List . Therefore, we can invoke __impl__/1 on this module: iex(1)&gt; Enumerable.List . __impl__ ( :for ) List iex(2)&gt; Enumerable.List . __impl__ ( :protocol ) Enumerable Consolidation In order to speed up protocol dispatching, whenever all protocol implementations are known up-front, typically after all Elixir code in a project is compiled, Elixir provides a feature called protocol consolidation . Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions. Protocol consolidation is applied by default to all Mix projects during compilation. This may be an issue during test. For instance, if you want to implement a protocol during test, the implementation will have no effect, as the protocol has already been consolidated. One possible solution is to include compilation directories that are specific to your test environment in your mix.exs: def project do ... elixirc_paths : elixirc_paths ( Mix . env ( ) ) ... end defp elixirc_paths ( :test ) , do : [ &quot;lib&quot; , &quot;test/support&quot; ] defp elixirc_paths ( _ ) , do : [ &quot;lib&quot; ] And then you can define the implementations specific to the test environment inside test/support/some_file.ex . Another approach is to disable protocol consolidation during tests in your mix.exs: def project do ... consolidate_protocols : Mix . env ( ) != :test ... end If you are using Mix.install/2 , you can do by passing the consolidate_protocols option: Mix . install ( deps , consolidate_protocols : false ) Although doing so is not recommended as it may affect the performance of your code. Finally, note all protocols are compiled with debug_info set to true , regardless of the option set by the elixirc compiler. The debug info is used for consolidation and it is removed after consolidation unless globally set.","ref":"Protocol.html","source_doc":"Reference and functions for working with protocols.\n\nA protocol specifies an API that should be defined by its\nimplementations. A protocol is defined with `Kernel.defprotocol/2`\nand its implementations with `Kernel.defimpl/3`.\n\n## A real case\n\nIn Elixir, we have two nouns for checking how many items there\nare in a data structure: `length` and `size`.  `length` means the\ninformation must be computed. For example, `length(list)` needs to\ntraverse the whole list to calculate its length. On the other hand,\n`tuple_size(tuple)` and `byte_size(binary)` do not depend on the\ntuple and binary size as the size information is precomputed in\nthe data structure.\n\nAlthough Elixir includes specific functions such as `tuple_size`,\n`binary_size` and `map_size`, sometimes we want to be able to\nretrieve the size of a data structure regardless of its type.\nIn Elixir we can write polymorphic code, i.e. code that works\nwith different shapes/types, by using protocols. A size protocol\ncould be implemented as follows:\n\n    defprotocol Size do\n      @doc \"Calculates the size (and not the length!) of a data structure\"\n      def size(data)\n    end\n\nNow that the protocol can be implemented for every data structure\nthe protocol may have a compliant implementation for:\n\n    defimpl Size, for: BitString do\n      def size(binary), do: byte_size(binary)\n    end\n\n    defimpl Size, for: Map do\n      def size(map), do: map_size(map)\n    end\n\n    defimpl Size, for: Tuple do\n      def size(tuple), do: tuple_size(tuple)\n    end\n\nFinally, we can use the `Size` protocol to call the correct implementation:\n\n    Size.size({1, 2})\n    # => 2\n    Size.size(%{key: :value})\n    # => 1\n\nNote that we didn't implement it for lists as we don't have the\n`size` information on lists, rather its value needs to be\ncomputed with `length`.\n\nThe data structure you are implementing the protocol for\nmust be the first argument to all functions defined in the\nprotocol.\n\nIt is possible to implement protocols for all Elixir types:\n\n  * Structs (see the \"Protocols and Structs\" section below)\n  * `Tuple`\n  * `Atom`\n  * `List`\n  * `BitString`\n  * `Integer`\n  * `Float`\n  * `Function`\n  * `PID`\n  * `Map`\n  * `Port`\n  * `Reference`\n  * `Any` (see the \"Fallback to `Any`\" section below)\n\n## Protocols and Structs\n\nThe real benefit of protocols comes when mixed with structs.\nFor instance, Elixir ships with many data types implemented as\nstructs, like `MapSet`. We can implement the `Size` protocol\nfor those types as well:\n\n    defimpl Size, for: MapSet do\n      def size(map_set), do: MapSet.size(map_set)\n    end\n\nWhen implementing a protocol for a struct, the `:for` option can\nbe omitted if the `defimpl/3` call is inside the module that defines\nthe struct:\n\n    defmodule User do\n      defstruct [:email, :name]\n\n      defimpl Size do\n        # two fields\n        def size(%User{}), do: 2\n      end\n    end\n\nIf a protocol implementation is not found for a given type,\ninvoking the protocol will raise unless it is configured to\nfall back to `Any`. Conveniences for building implementations\non top of existing ones are also available, look at `defstruct/1`\nfor more information about deriving\nprotocols.\n\n## Fallback to `Any`\n\nIn some cases, it may be convenient to provide a default\nimplementation for all types. This can be achieved by setting\nthe `@fallback_to_any` attribute to `true` in the protocol\ndefinition:\n\n    defprotocol Size do\n      @fallback_to_any true\n      def size(data)\n    end\n\nThe `Size` protocol can now be implemented for `Any`:\n\n    defimpl Size, for: Any do\n      def size(_), do: 0\n    end\n\nAlthough the implementation above is arguably not a reasonable\none. For example, it makes no sense to say a PID or an integer\nhave a size of `0`. That's one of the reasons why `@fallback_to_any`\nis an opt-in behaviour. For the majority of protocols, raising\nan error when a protocol is not implemented is the proper behaviour.\n\n## Multiple implementations\n\nProtocols can also be implemented for multiple types at once:\n\n    defprotocol Reversible do\n      def reverse(term)\n    end\n\n    defimpl Reversible, for: [Map, List] do\n      def reverse(term), do: Enum.reverse(term)\n    end\n\nInside `defimpl/3`, you can use `@protocol` to access the protocol\nbeing implemented and `@for` to access the module it is being\ndefined for.\n\n## Types\n\nDefining a protocol automatically defines a zero-arity type named `t`, which\ncan be used as follows:\n\n    @spec print_size(Size.t()) :: :ok\n    def print_size(data) do\n      result =\n        case Size.size(data) do\n          0 -> \"data has no items\"\n          1 -> \"data has one item\"\n          n -> \"data has \#{n} items\"\n        end\n\n      IO.puts(result)\n    end\n\nThe `@spec` above expresses that all types allowed to implement the\ngiven protocol are valid argument types for the given function.\n\n## Reflection\n\nAny protocol module contains three extra functions:\n\n  * `__protocol__/1` - returns the protocol information. The function takes\n    one of the following atoms:\n\n    * `:consolidated?` - returns whether the protocol is consolidated\n\n    * `:functions` - returns a keyword list of protocol functions and their arities\n\n    * `:impls` - if consolidated, returns `{:consolidated, modules}` with the list of modules\n      implementing the protocol, otherwise `:not_consolidated`\n\n    * `:module` - the protocol module atom name\n\n  * `impl_for/1` - returns the module that implements the protocol for the given argument,\n    `nil` otherwise\n\n  * `impl_for!/1` - same as above but raises `Protocol.UndefinedError` if an implementation is\n    not found\n\nFor example, for the `Enumerable` protocol we have:\n\n    iex> Enumerable.__protocol__(:functions)\n    [count: 1, member?: 2, reduce: 3, slice: 1]\n\n    iex> Enumerable.impl_for([])\n    Enumerable.List\n\n    iex> Enumerable.impl_for(42)\n    nil\n\nIn addition, every protocol implementation module contains the `__impl__/1`\nfunction. The function takes one of the following atoms:\n\n  * `:for` - returns the module responsible for the data structure of the\n    protocol implementation\n\n  * `:protocol` - returns the protocol module for which this implementation\n  is provided\n\nFor example, the module implementing the `Enumerable` protocol for lists is\n`Enumerable.List`. Therefore, we can invoke `__impl__/1` on this module:\n\n    iex(1)> Enumerable.List.__impl__(:for)\n    List\n\n    iex(2)> Enumerable.List.__impl__(:protocol)\n    Enumerable\n\n## Consolidation\n\nIn order to speed up protocol dispatching, whenever all protocol implementations\nare known up-front, typically after all Elixir code in a project is compiled,\nElixir provides a feature called *protocol consolidation*. Consolidation directly\nlinks protocols to their implementations in a way that invoking a function from a\nconsolidated protocol is equivalent to invoking two remote functions.\n\nProtocol consolidation is applied by default to all Mix projects during compilation.\nThis may be an issue during test. For instance, if you want to implement a protocol\nduring test, the implementation will have no effect, as the protocol has already been\nconsolidated. One possible solution is to include compilation directories that are\nspecific to your test environment in your mix.exs:\n\n    def project do\n      ...\n      elixirc_paths: elixirc_paths(Mix.env())\n      ...\n    end\n\n    defp elixirc_paths(:test), do: [\"lib\", \"test/support\"]\n    defp elixirc_paths(_), do: [\"lib\"]\n\nAnd then you can define the implementations specific to the test environment\ninside `test/support/some_file.ex`.\n\nAnother approach is to disable protocol consolidation during tests in your\nmix.exs:\n\n    def project do\n      ...\n      consolidate_protocols: Mix.env() != :test\n      ...\n    end\n\nIf you are using `Mix.install/2`, you can do by passing the `consolidate_protocols`\noption:\n\n    Mix.install(\n      deps,\n      consolidate_protocols: false\n    )\n\nAlthough doing so is not recommended as it may affect the performance of\nyour code.\n\nFinally, note all protocols are compiled with `debug_info` set to `true`,\nregardless of the option set by the `elixirc` compiler. The debug info is\nused for consolidation and it is removed after consolidation unless\nglobally set.\n","title":"Protocol","type":"module"},{"doc":"Checks if the given module is loaded and is an implementation of the given protocol. Returns :ok if so, otherwise raises ArgumentError .","ref":"Protocol.html#assert_impl!/2","source_doc":"Checks if the given module is loaded and is an implementation\nof the given protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.\n","title":"Protocol.assert_impl!/2","type":"function"},{"doc":"Checks if the given module is loaded and is protocol. Returns :ok if so, otherwise raises ArgumentError .","ref":"Protocol.html#assert_protocol!/1","source_doc":"Checks if the given module is loaded and is protocol.\n\nReturns `:ok` if so, otherwise raises `ArgumentError`.\n","title":"Protocol.assert_protocol!/1","type":"function"},{"doc":"Receives a protocol and a list of implementations and consolidates the given protocol. Consolidation happens by changing the protocol impl_for in the abstract format to have fast lookup rules. Usually the list of implementations to use during consolidation are retrieved with the help of extract_impls/2 . It returns the updated version of the protocol bytecode. If the first element of the tuple is :ok , it means the protocol was consolidated. A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute: Protocol . consolidated? ( Enumerable ) This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However, each implementation must be available and it will be loaded.","ref":"Protocol.html#consolidate/2","source_doc":"Receives a protocol and a list of implementations and\nconsolidates the given protocol.\n\nConsolidation happens by changing the protocol `impl_for`\nin the abstract format to have fast lookup rules. Usually\nthe list of implementations to use during consolidation\nare retrieved with the help of `extract_impls/2`.\n\nIt returns the updated version of the protocol bytecode.\nIf the first element of the tuple is `:ok`, it means\nthe protocol was consolidated.\n\nA given bytecode or protocol implementation can be checked\nto be consolidated or not by analyzing the protocol\nattribute:\n\n    Protocol.consolidated?(Enumerable)\n\nThis function does not load the protocol at any point\nnor loads the new bytecode for the compiled module.\nHowever, each implementation must be available and\nit will be loaded.\n","title":"Protocol.consolidate/2","type":"function"},{"doc":"Returns true if the protocol was consolidated.","ref":"Protocol.html#consolidated?/1","source_doc":"Returns `true` if the protocol was consolidated.\n","title":"Protocol.consolidated?/1","type":"function"},{"doc":"Derives the protocol for module with the given options. If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as __deriving__(module, struct, options) to get the options that were passed. Examples defprotocol Derivable do def ok ( arg ) end defimpl Derivable , for : Any do defmacro __deriving__ ( module , struct , options ) do quote do defimpl Derivable , for : unquote ( module ) do def ok ( arg ) do { :ok , arg , unquote ( Macro . escape ( struct ) ) , unquote ( options ) } end end end end def ok ( arg ) do { :ok , arg } end end defmodule ImplStruct do @derive [ Derivable ] defstruct a : 0 , b : 0 end Derivable . ok ( % ImplStruct { } ) #=&gt; {:ok, %ImplStruct{a: 0, b: 0}, %ImplStruct{a: 0, b: 0}, []} Explicit derivations can now be called via __deriving__/3 : # Explicitly derived via `__deriving__/3` Derivable . ok ( % ImplStruct { a : 1 , b : 1 } ) #=&gt; {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, []} # Explicitly derived by API via `__deriving__/3` require Protocol Protocol . derive ( Derivable , ImplStruct , :oops ) Derivable . ok ( % ImplStruct { a : 1 , b : 1 } ) #=&gt; {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, :oops}","ref":"Protocol.html#derive/3","source_doc":"Derives the `protocol` for `module` with the given options.\n\nIf your implementation passes options or if you are generating\ncustom code based on the struct, you will also need to implement\na macro defined as `__deriving__(module, struct, options)`\nto get the options that were passed.\n\n## Examples\n\n    defprotocol Derivable do\n      def ok(arg)\n    end\n\n    defimpl Derivable, for: Any do\n      defmacro __deriving__(module, struct, options) do\n        quote do\n          defimpl Derivable, for: unquote(module) do\n            def ok(arg) do\n              {:ok, arg, unquote(Macro.escape(struct)), unquote(options)}\n            end\n          end\n        end\n      end\n\n      def ok(arg) do\n        {:ok, arg}\n      end\n    end\n\n    defmodule ImplStruct do\n      @derive [Derivable]\n      defstruct a: 0, b: 0\n    end\n\n    Derivable.ok(%ImplStruct{})\n    #=> {:ok, %ImplStruct{a: 0, b: 0}, %ImplStruct{a: 0, b: 0}, []}\n\nExplicit derivations can now be called via `__deriving__/3`:\n\n    # Explicitly derived via `__deriving__/3`\n    Derivable.ok(%ImplStruct{a: 1, b: 1})\n    #=> {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, []}\n\n    # Explicitly derived by API via `__deriving__/3`\n    require Protocol\n    Protocol.derive(Derivable, ImplStruct, :oops)\n    Derivable.ok(%ImplStruct{a: 1, b: 1})\n    #=> {:ok, %ImplStruct{a: 1, b: 1}, %ImplStruct{a: 0, b: 0}, :oops}\n\n","title":"Protocol.derive/3","type":"macro"},{"doc":"Extracts all types implemented for the given protocol from the given paths. The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion. Does not load any of the implementations. Examples # Get Elixir&#39;s ebin directory path and retrieve all protocols iex&gt; path = :code . lib_dir ( :elixir , :ebin ) iex&gt; mods = Protocol . extract_impls ( Enumerable , [ path ] ) iex&gt; List in mods true","ref":"Protocol.html#extract_impls/2","source_doc":"Extracts all types implemented for the given protocol from\nthe given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the implementations.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_impls(Enumerable, [path])\n    iex> List in mods\n    true\n\n","title":"Protocol.extract_impls/2","type":"function"},{"doc":"Extracts all protocols from the given paths. The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion. Does not load any of the protocols. Examples # Get Elixir&#39;s ebin directory path and retrieve all protocols iex&gt; path = :code . lib_dir ( :elixir , :ebin ) iex&gt; mods = Protocol . extract_protocols ( [ path ] ) iex&gt; Enumerable in mods true","ref":"Protocol.html#extract_protocols/1","source_doc":"Extracts all protocols from the given paths.\n\nThe paths can be either a charlist or a string. Internally\nthey are worked on as charlists, so passing them as lists\navoid extra conversion.\n\nDoes not load any of the protocols.\n\n## Examples\n\n    # Get Elixir's ebin directory path and retrieve all protocols\n    iex> path = :code.lib_dir(:elixir, :ebin)\n    iex> mods = Protocol.extract_protocols([path])\n    iex> Enumerable in mods\n    true\n\n","title":"Protocol.extract_protocols/1","type":"function"},{"doc":"The String.Chars protocol is responsible for converting a structure to a binary (only if applicable). The only function required to be implemented is to_string/1 , which does the conversion. The to_string/1 function automatically imported by Kernel invokes this protocol. String interpolation also invokes to_string/1 in its arguments. For example, &quot;foo\#{bar}&quot; is the same as &quot;foo&quot; &lt;&gt; to_string(bar) .","ref":"String.Chars.html","source_doc":"The `String.Chars` protocol is responsible for\nconverting a structure to a binary (only if applicable).\n\nThe only function required to be implemented is\n`to_string/1`, which does the conversion.\n\nThe `to_string/1` function automatically imported\nby `Kernel` invokes this protocol. String\ninterpolation also invokes `to_string/1` in its\narguments. For example, `\"foo\#{bar}\"` is the same\nas `\"foo\" <> to_string(bar)`.\n","title":"String.Chars","type":"protocol"},{"doc":"Converts term to a string.","ref":"String.Chars.html#to_string/1","source_doc":"Converts `term` to a string.\n","title":"String.Chars.to_string/1","type":"function"},{"doc":"All the types that implement this protocol.","ref":"String.Chars.html#t:t/0","source_doc":"All the types that implement this protocol.\n","title":"String.Chars.t/0","type":"type"},{"doc":"Utilities for managing code compilation, code evaluation, and code loading. This module complements Erlang's :code module to add behaviour which is specific to Elixir. For functions to manipulate Elixir's AST (rather than evaluating it), see the Macro module. Working with files This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour: require_file/2 - compiles a file and tracks its name. It does not compile the file again if it has been previously required. compile_file/2 - compiles a file without tracking its name. Compiles the file multiple times when invoked multiple times. eval_file/2 - evaluates the file contents without tracking its name. It returns the result of the last expression in the file, instead of the modules defined in it. Evaluated files do not trigger the compilation tracers described in the next section. In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts. compile_file/2 must be used when you are interested in the modules defined in a file, without tracking. eval_file/2 should be used when you are interested in the result of evaluating the file rather than the modules it defines. The functions above work with Elixir source. If you want to work with modules compiled to bytecode, which have the .beam extension and are typically found below the _build directory of a Mix project, see the functions in Erlang's :code module. Code loading on the Erlang VM Erlang has two modes to load code: interactive and embedded. By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly. You can use ensure_loaded/1 (as well as ensure_loaded?/1 and ensure_loaded!/1 ) to check if a module is loaded before using it and act. ensure_compiled/1 and ensure_compiled!/1 Elixir also includes ensure_compiled/1 and ensure_compiled!/1 functions that are a superset of ensure_loaded/1 . Since Elixir's compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can't even be loaded. When invoked, ensure_compiled/1 and ensure_compiled!/1 halt the compilation of the caller until the module becomes available. Note that the distinction between ensure_compiled/1 and ensure_compiled!/1 is important: if you are using ensure_compiled!/1 , you are indicating to the compiler that you can only continue if said module is available. If you are using Code.ensure_compiled/1 , you are implying you may continue without the module and therefore Elixir may return {:error, :unavailable} for cases where the module is not yet available (but may be available later on). For those reasons, developers must typically use Code.ensure_compiled!/1 . In particular, do not do this: case Code . ensure_compiled ( module ) do { :module , _ } -&gt; module { :error , _ } -&gt; raise ... end Finally, note you only need ensure_compiled!/1 to check for modules being defined within the same project. It does not apply to modules from dependencies as dependencies are always compiled upfront. In most cases, ensure_loaded/1 is enough. ensure_compiled!/1 must be used in rare cases, usually involving macros that need to invoke a module for callback information. The use of ensure_compiled/1 is even less likely. Compilation tracers Elixir supports compilation tracers, which allow modules to observe constructs handled by the Elixir compiler when compiling files. A tracer is a module that implements the trace/2 function. The function receives the event name as first argument and Macro.Env as second and it must return :ok . It is very important for a tracer to do as little work as possible synchronously and dispatch the bulk of the work to a separate process. Slow tracers will slow down compilation . You can configure your list of tracers via put_compiler_option/2 . The following events are available to tracers: :start - (since v1.11.0) invoked whenever the compiler starts to trace a new lexical context. A lexical context is started when compiling a new file or when defining a module within a function. Note evaluated code does not start a new lexical context (because they don't track unused aliases, imports, etc) but defining a module inside evaluated code will. Note this event may be emitted in parallel, where multiple files/modules invoke :start and run at the same time. The value of the lexical_tracker of the macro environment, albeit opaque, can be used to uniquely identify the environment. :stop - (since v1.11.0) invoked whenever the compiler stops tracing a new lexical context, such as a new file. {:import, meta, module, opts} - traced whenever module is imported. meta is the import AST metadata and opts are the import options. {:imported_function, meta, module, name, arity} and {:imported_macro, meta, module, name, arity} - traced whenever an imported function or macro is invoked. meta is the call AST metadata, module is the module the import is from, followed by the name and arity of the imported function/macro. A :remote_function/:remote_macro event may still be emitted for the imported module/name/arity. {:alias, meta, alias, as, opts} - traced whenever alias is aliased to as . meta is the alias AST metadata and opts are the alias options. {:alias_expansion, meta, as, alias} traced whenever there is an alias expansion for a previously defined alias , i.e. when the user writes as which is expanded to alias . meta is the alias expansion AST metadata. {:alias_reference, meta, module} - traced whenever there is an alias in the code, i.e. whenever the user writes MyModule.Foo.Bar in the code, regardless if it was expanded or not. {:require, meta, module, opts} - traced whenever module is required. meta is the require AST metadata and opts are the require options. If the meta option contains the :from_macro , then module was called from within a macro and therefore must be treated as a compile-time dependency. {:struct_expansion, meta, module, keys} - traced whenever module 's struct is expanded. meta is the struct AST metadata and keys are the keys being used by expansion {:remote_function, meta, module, name, arity} and {:remote_macro, meta, module, name, arity} - traced whenever a remote function or macro is referenced. meta is the call AST metadata, module is the invoked module, followed by the name and arity . {:local_function, meta, name, arity} and {:local_macro, meta, name, arity} - traced whenever a local function or macro is referenced. meta is the call AST metadata, followed by the name and arity . {:compile_env, app, path, return} - traced whenever Application.compile_env/3 or Application.compile_env!/2 are called. app is an atom, path is a list of keys to traverse in the application environment and return is either {:ok, value} or :error . {:on_module, bytecode, _ignore} - (since v1.13.0) traced whenever a module is defined. This is equivalent to the @after_compile callback and invoked after any @after_compile in the given module. The third element is currently :none but it may provide more metadata in the future. It is best to ignore it at the moment. Note that Module functions expecting not yet compiled modules (such as Module.definitions_in/1 ) are still available at the time this event is emitted. The :tracers compiler option can be combined with the :parser_options compiler option to enrich the metadata of the traced events above. New events may be added at any time in the future, therefore it is advised for the trace/2 function to have a &quot;catch-all&quot; clause. Below is an example tracer that prints all remote function invocations: defmodule MyTracer do def trace ( { :remote_function , _meta , module , name , arity } , env ) do IO . puts &quot; \#{ env . file } : \#{ env . line } \#{ inspect ( module ) } . \#{ name } / \#{ arity } &quot; :ok end def trace ( _event , _env ) do :ok end end","ref":"Code.html","source_doc":"Utilities for managing code compilation, code evaluation, and code loading.\n\nThis module complements Erlang's [`:code` module](`:code`)\nto add behaviour which is specific to Elixir. For functions to\nmanipulate Elixir's AST (rather than evaluating it), see the\n`Macro` module.\n\n## Working with files\n\nThis module contains three functions for compiling and evaluating files.\nHere is a summary of them and their behaviour:\n\n  * `require_file/2` - compiles a file and tracks its name. It does not\n    compile the file again if it has been previously required.\n\n  * `compile_file/2` - compiles a file without tracking its name. Compiles the\n    file multiple times when invoked multiple times.\n\n  * `eval_file/2` - evaluates the file contents without tracking its name. It\n    returns the result of the last expression in the file, instead of the modules\n    defined in it. Evaluated files do not trigger the compilation tracers described\n    in the next section.\n\nIn a nutshell, the first must be used when you want to keep track of the files\nhandled by the system, to avoid the same file from being compiled multiple\ntimes. This is common in scripts.\n\n`compile_file/2` must be used when you are interested in the modules defined in a\nfile, without tracking. `eval_file/2` should be used when you are interested in\nthe result of evaluating the file rather than the modules it defines.\n\nThe functions above work with Elixir source. If you want to work\nwith modules compiled to bytecode, which have the `.beam` extension\nand are typically found below the _build directory of a Mix project,\nsee the functions in Erlang's [`:code`](`:code`) module.\n\n## Code loading on the Erlang VM\n\nErlang has two modes to load code: interactive and embedded.\n\nBy default, the Erlang VM runs in interactive mode, where modules\nare loaded as needed. In embedded mode the opposite happens, as all\nmodules need to be loaded upfront or explicitly.\n\nYou can use `ensure_loaded/1` (as well as `ensure_loaded?/1` and\n`ensure_loaded!/1`) to check if a module is loaded before using it and\nact.\n\n## `ensure_compiled/1` and `ensure_compiled!/1`\n\nElixir also includes `ensure_compiled/1` and `ensure_compiled!/1`\nfunctions that are a superset of `ensure_loaded/1`.\n\nSince Elixir's compilation happens in parallel, in some situations\nyou may need to use a module that was not yet compiled, therefore\nit can't even be loaded.\n\nWhen invoked, `ensure_compiled/1` and `ensure_compiled!/1` halt the\ncompilation of the caller until the module becomes available. Note that\nthe distinction between `ensure_compiled/1` and `ensure_compiled!/1`\nis important: if you are using `ensure_compiled!/1`, you are\nindicating to the compiler that you can only continue if said module\nis available.\n\nIf you are using `Code.ensure_compiled/1`, you are implying you may\ncontinue without the module and therefore Elixir may return\n`{:error, :unavailable}` for cases where the module is not yet available\n(but may be available later on).\n\nFor those reasons, developers must typically use `Code.ensure_compiled!/1`.\nIn particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nFinally, note you only need `ensure_compiled!/1` to check for modules\nbeing defined within the same project. It does not apply to modules from\ndependencies as dependencies are always compiled upfront.\n\nIn most cases, `ensure_loaded/1` is enough. `ensure_compiled!/1`\nmust be used in rare cases, usually involving macros that need to\ninvoke a module for callback information. The use of `ensure_compiled/1`\nis even less likely.\n\n## Compilation tracers\n\nElixir supports compilation tracers, which allow modules to observe constructs\nhandled by the Elixir compiler when compiling files. A tracer is a module\nthat implements the `trace/2` function. The function receives the event name\nas first argument and `Macro.Env` as second and it must return `:ok`. It is\nvery important for a tracer to do as little work as possible synchronously\nand dispatch the bulk of the work to a separate process. **Slow tracers will\nslow down compilation**.\n\nYou can configure your list of tracers via `put_compiler_option/2`. The\nfollowing events are available to tracers:\n\n  * `:start` - (since v1.11.0) invoked whenever the compiler starts to trace\n    a new lexical context. A lexical context is started when compiling a new\n    file or when defining a module within a function. Note evaluated code\n    does not start a new lexical context (because they don't track unused\n    aliases, imports, etc) but defining a module inside evaluated code will.\n\n    Note this event may be emitted in parallel, where multiple files/modules\n    invoke `:start` and run at the same time. The value of the `lexical_tracker`\n    of the macro environment, albeit opaque, can be used to uniquely identify\n    the environment.\n\n  * `:stop` - (since v1.11.0) invoked whenever the compiler stops tracing a\n    new lexical context, such as a new file.\n\n  * `{:import, meta, module, opts}` - traced whenever `module` is imported.\n    `meta` is the import AST metadata and `opts` are the import options.\n\n  * `{:imported_function, meta, module, name, arity}` and\n    `{:imported_macro, meta, module, name, arity}` - traced whenever an\n    imported function or macro is invoked. `meta` is the call AST metadata,\n    `module` is the module the import is from, followed by the `name` and `arity`\n    of the imported function/macro. A :remote_function/:remote_macro event\n    may still be emitted for the imported module/name/arity.\n\n  * `{:alias, meta, alias, as, opts}` - traced whenever `alias` is aliased\n    to `as`. `meta` is the alias AST metadata and `opts` are the alias options.\n\n  * `{:alias_expansion, meta, as, alias}` traced whenever there is an alias\n    expansion for a previously defined `alias`, i.e. when the user writes `as`\n    which is expanded to `alias`. `meta` is the alias expansion AST metadata.\n\n  * `{:alias_reference, meta, module}` - traced whenever there is an alias\n    in the code, i.e. whenever the user writes `MyModule.Foo.Bar` in the code,\n    regardless if it was expanded or not.\n\n  * `{:require, meta, module, opts}` - traced whenever `module` is required.\n    `meta` is the require AST metadata and `opts` are the require options.\n    If the `meta` option contains the `:from_macro`, then module was called\n    from within a macro and therefore must be treated as a compile-time dependency.\n\n  * `{:struct_expansion, meta, module, keys}` - traced whenever `module`'s struct\n    is expanded. `meta` is the struct AST metadata and `keys` are the keys being\n    used by expansion\n\n  * `{:remote_function, meta, module, name, arity}` and\n    `{:remote_macro, meta, module, name, arity}` - traced whenever a remote\n    function or macro is referenced. `meta` is the call AST metadata, `module`\n    is the invoked module, followed by the `name` and `arity`.\n\n  * `{:local_function, meta, name, arity}` and\n    `{:local_macro, meta, name, arity}` - traced whenever a local\n    function or macro is referenced. `meta` is the call AST metadata, followed by\n    the `name` and `arity`.\n\n  * `{:compile_env, app, path, return}` - traced whenever `Application.compile_env/3`\n    or `Application.compile_env!/2` are called. `app` is an atom, `path` is a list\n    of keys to traverse in the application environment and `return` is either\n    `{:ok, value}` or `:error`.\n\n  * `{:on_module, bytecode, _ignore}` - (since v1.13.0) traced whenever a module\n    is defined. This is equivalent to the `@after_compile` callback and invoked\n    after any `@after_compile` in the given module. The third element is currently\n    `:none` but it may provide more metadata in the future. It is best to ignore\n    it at the moment. Note that `Module` functions expecting not yet compiled modules\n    (such as `Module.definitions_in/1`) are still available at the time this event\n    is emitted.\n\nThe `:tracers` compiler option can be combined with the `:parser_options`\ncompiler option to enrich the metadata of the traced events above.\n\nNew events may be added at any time in the future, therefore it is advised\nfor the `trace/2` function to have a \"catch-all\" clause.\n\nBelow is an example tracer that prints all remote function invocations:\n\n    defmodule MyTracer do\n      def trace({:remote_function, _meta, module, name, arity}, env) do\n        IO.puts \"\#{env.file}:\#{env.line} \#{inspect(module)}.\#{name}/\#{arity}\"\n        :ok\n      end\n\n      def trace(_event, _env) do\n        :ok\n      end\n    end\n","title":"Code","type":"module"},{"doc":"Appends a path to the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The list of files is managed per Erlang VM node. The path is expanded with Path.expand/1 before being appended. It requires the path to exist. Returns a boolean indicating if the path was successfully added. Examples Code . append_path ( &quot;.&quot; ) #=&gt; true Code . append_path ( &quot;/does_not_exist&quot; ) #=&gt; false Options :cache - (since v1.15.0) when true, the code path is cached the first time it is traversed in order to reduce file system operations. It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#append_path/2","source_doc":"Appends a path to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nThe path is expanded with `Path.expand/1` before being appended.\nIt requires the path to exist. Returns a boolean indicating if\nthe path was successfully added.\n\n## Examples\n\n    Code.append_path(\".\")\n    #=> true\n\n    Code.append_path(\"/does_not_exist\")\n    #=> false\n\n## Options\n\n  * `:cache` - (since v1.15.0) when true, the code path is cached\n    the first time it is traversed in order to reduce file system\n    operations. It requires Erlang/OTP 26, otherwise it is a no-op.\n\n","title":"Code.append_path/2","type":"function"},{"doc":"Appends a list of paths to the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The list of files is managed per Erlang VM node. All paths are expanded with Path.expand/1 before being appended. Only existing paths are appended. This function always returns :ok , regardless of how many paths were appended. Use append_path/1 if you need more control. Examples Code . append_paths ( [ &quot;.&quot; , &quot;/does_not_exist&quot; ] ) #=&gt; :ok Options :cache - when true, the code path is cached the first time it is traversed in order to reduce file system operations. It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#append_paths/2","source_doc":"Appends a list of `paths` to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nAll paths are expanded with `Path.expand/1` before being appended.\nOnly existing paths are appended. This function always returns `:ok`,\nregardless of how many paths were appended. Use `append_path/1`\nif you need more control.\n\n## Examples\n\n    Code.append_paths([\".\", \"/does_not_exist\"])\n    #=> :ok\n\n## Options\n\n  * `:cache` - when true, the code path is cached the first time\n    it is traversed in order to reduce file system operations.\n    It requires Erlang/OTP 26, otherwise it is a no-op.\n","title":"Code.append_paths/2","type":"function"},{"doc":"Returns a list with all available compiler options. For a description of all options, see put_compiler_option/2 . Examples Code . available_compiler_options ( ) #=&gt; [:docs, :debug_info, ...]","ref":"Code.html#available_compiler_options/0","source_doc":"Returns a list with all available compiler options.\n\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.available_compiler_options()\n    #=> [:docs, :debug_info, ...]\n\n","title":"Code.available_compiler_options/0","type":"function"},{"doc":"Returns true if the current process can await for module compilation. When compiling Elixir code via Kernel.ParallelCompiler , which is used by Mix and elixirc , calling a module that has not yet been compiled will block the caller until the module becomes available. Executing Elixir scripts, such as passing a filename to elixir , does not await.","ref":"Code.html#can_await_module_compilation?/0","source_doc":"Returns true if the current process can await for module compilation.\n\nWhen compiling Elixir code via `Kernel.ParallelCompiler`, which is\nused by Mix and `elixirc`, calling a module that has not yet been\ncompiled will block the caller until the module becomes available.\nExecuting Elixir scripts, such as passing a filename to `elixir`,\ndoes not await.\n","title":"Code.can_await_module_compilation?/0","type":"function"},{"doc":"Compiles the given file. Accepts relative_to as an argument to tell where the file is located. Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). Opposite to require_file/2 , it does not track the filename of the compiled file. If you would like to get the result of evaluating file rather than the modules defined in it, see eval_file/2 . For compiling many files concurrently, see Kernel.ParallelCompiler.compile/2 .","ref":"Code.html#compile_file/2","source_doc":"Compiles the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). Opposite to `require_file/2`,\nit does not track the filename of the compiled file.\n\nIf you would like to get the result of evaluating file rather than the\nmodules defined in it, see `eval_file/2`.\n\nFor compiling many files concurrently, see `Kernel.ParallelCompiler.compile/2`.\n","title":"Code.compile_file/2","type":"function"},{"doc":"Compiles the quoted expression. Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A file can be given as second argument which will be used for reporting warnings and errors.","ref":"Code.html#compile_quoted/2","source_doc":"Compiles the quoted expression.\n\nReturns a list of tuples where the first element is the module name and\nthe second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.\n","title":"Code.compile_quoted/2","type":"function"},{"doc":"Compiles the given string. Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A file can be given as second argument which will be used for reporting warnings and errors. Warning : string can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use compile_string/2 with untrusted input (such as strings coming from the network).","ref":"Code.html#compile_string/2","source_doc":"Compiles the given string.\n\nReturns a list of tuples where the first element is the module name\nand the second one is its bytecode (as a binary). A `file` can be\ngiven as second argument which will be used for reporting warnings\nand errors.\n\n**Warning**: `string` can be any Elixir code and code can be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `compile_string/2` with untrusted input (such as strings coming\nfrom the network).\n","title":"Code.compile_string/2","type":"function"},{"doc":"Gets all compilation options from the code server. To get individual options, see get_compiler_option/1 . For a description of all options, see put_compiler_option/2 . Examples Code . compiler_options ( ) #=&gt; %{debug_info: true, docs: true, ...}","ref":"Code.html#compiler_options/0","source_doc":"Gets all compilation options from the code server.\n\nTo get individual options, see `get_compiler_option/1`.\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}\n\n","title":"Code.compiler_options/0","type":"function"},{"doc":"Stores all given compilation options. Changing the compilation options affect all processes running in a given Erlang VM node. To store individual options and for a description of all options, see put_compiler_option/2 . Examples Code . compiler_options ( ) #=&gt; %{debug_info: true, docs: true, ...}","ref":"Code.html#compiler_options/1","source_doc":"Stores all given compilation options.\n\nChanging the compilation options affect all processes\nrunning in a given Erlang VM node. To store individual\noptions and for a description of all options, see\n`put_compiler_option/2`.\n\n## Examples\n\n    Code.compiler_options()\n    #=> %{debug_info: true, docs: true, ...}\n\n","title":"Code.compiler_options/1","type":"function"},{"doc":"Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The list of files is managed per Erlang VM node. The path is expanded with Path.expand/1 before being deleted. If the path does not exist, this function returns false . Examples Code . prepend_path ( &quot;.&quot; ) Code . delete_path ( &quot;.&quot; ) #=&gt; true Code . delete_path ( &quot;/does_not_exist&quot; ) #=&gt; false","ref":"Code.html#delete_path/1","source_doc":"Deletes a path from the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being deleted. If the\npath does not exist, this function returns `false`.\n\n## Examples\n\n    Code.prepend_path(\".\")\n    Code.delete_path(\".\")\n    #=> true\n\n    Code.delete_path(\"/does_not_exist\")\n    #=> false\n\n","title":"Code.delete_path/1","type":"function"},{"doc":"Deletes a list of paths from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The list of files is managed per Erlang VM node. The path is expanded with Path.expand/1 before being deleted. If the path does not exist, this function returns false .","ref":"Code.html#delete_paths/1","source_doc":"Deletes a list of paths from the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for finding\nmodule code. The list of files is managed per Erlang VM node.\n\nThe path is expanded with `Path.expand/1` before being deleted. If the\npath does not exist, this function returns `false`.\n","title":"Code.delete_paths/1","type":"function"},{"doc":"Ensures the given modules are loaded. Similar to ensure_loaded/1 , but accepts a list of modules instead of a single module, and loads all of them. If all modules load successfully, returns :ok . Otherwise, returns {:error, errors} where errors is a list of tuples made of the module and the reason it failed to load. Examples iex&gt; Code . ensure_all_loaded ( [ Atom , String ] ) :ok iex&gt; Code . ensure_all_loaded ( [ Atom , DoesNotExist ] ) { :error , [ { DoesNotExist , :nofile } ] }","ref":"Code.html#ensure_all_loaded/1","source_doc":"Ensures the given modules are loaded.\n\nSimilar to `ensure_loaded/1`, but accepts a list of modules instead of a single\nmodule, and loads all of them.\n\nIf all modules load successfully, returns `:ok`. Otherwise, returns `{:error, errors}`\nwhere `errors` is a list of tuples made of the module and the reason it failed to load.\n\n## Examples\n\n    iex> Code.ensure_all_loaded([Atom, String])\n    :ok\n\n    iex> Code.ensure_all_loaded([Atom, DoesNotExist])\n    {:error, [{DoesNotExist, :nofile}]}\n\n","title":"Code.ensure_all_loaded/1","type":"function"},{"doc":"Same as ensure_all_loaded/1 but raises if any of the modules cannot be loaded.","ref":"Code.html#ensure_all_loaded!/1","source_doc":"Same as `ensure_all_loaded/1` but raises if any of the modules cannot be loaded.\n","title":"Code.ensure_all_loaded!/1","type":"function"},{"doc":"Similar to ensure_compiled!/1 but indicates you can continue without said module. While ensure_compiled!/1 indicates to the Elixir compiler you can only continue when said module is available, this function indicates you may continue compilation without said module. If it succeeds in loading the module, it returns {:module, module} . If not, returns {:error, reason} with the error reason. If the module being checked is currently in a compiler deadlock, this function returns {:error, :unavailable} . Unavailable doesn't necessarily mean the module doesn't exist, just that it is not currently available, but it (or may not) become available in the future. Therefore, if you can only continue if the module is available, use ensure_compiled!/1 instead. In particular, do not do this: case Code . ensure_compiled ( module ) do { :module , _ } -&gt; module { :error , _ } -&gt; raise ... end See the module documentation for more information on code loading.","ref":"Code.html#ensure_compiled/1","source_doc":"Similar to `ensure_compiled!/1` but indicates you can continue without said module.\n\nWhile `ensure_compiled!/1` indicates to the Elixir compiler you can\nonly continue when said module is available, this function indicates\nyou may continue compilation without said module.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\nIf the module being checked is currently in a compiler deadlock,\nthis function returns `{:error, :unavailable}`. Unavailable doesn't\nnecessarily mean the module doesn't exist, just that it is not currently\navailable, but it (or may not) become available in the future.\n\nTherefore, if you can only continue if the module is available, use\n`ensure_compiled!/1` instead. In particular, do not do this:\n\n    case Code.ensure_compiled(module) do\n      {:module, _} -> module\n      {:error, _} -> raise ...\n    end\n\nSee the module documentation for more information on code loading.\n","title":"Code.ensure_compiled/1","type":"function"},{"doc":"Ensures the given module is compiled and loaded. If the module is already loaded, it works as no-op. If the module was not compiled yet, ensure_compiled!/1 halts the compilation of the caller until the module given to ensure_compiled!/1 becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available or is in a deadlock, an error is raised. Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not. See the module documentation for more information on code loading.","ref":"Code.html#ensure_compiled!/1","source_doc":"Ensures the given module is compiled and loaded.\n\nIf the module is already loaded, it works as no-op. If the module was\nnot compiled yet, `ensure_compiled!/1` halts the compilation of the caller\nuntil the module given to `ensure_compiled!/1` becomes available or\nall files for the current project have been compiled. If compilation\nfinishes and the module is not available or is in a deadlock, an error\nis raised.\n\nGiven this function halts compilation, use it carefully. In particular,\navoid using it to guess which modules are in the system. Overuse of this\nfunction can also lead to deadlocks, where two modules check at the same time\nif the other is compiled. This returns a specific unavailable error code,\nwhere we cannot successfully verify a module is available or not.\n\nSee the module documentation for more information on code loading.\n","title":"Code.ensure_compiled!/1","type":"function"},{"doc":"Ensures the given module is loaded. If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it. If it succeeds in loading the module, it returns {:module, module} . If not, returns {:error, reason} with the error reason. See the module documentation for more information on code loading. Examples iex&gt; Code . ensure_loaded ( Atom ) { :module , Atom } iex&gt; Code . ensure_loaded ( DoesNotExist ) { :error , :nofile }","ref":"Code.html#ensure_loaded/1","source_doc":"Ensures the given module is loaded.\n\nIf the module is already loaded, this works as no-op. If the module\nwas not yet loaded, it tries to load it.\n\nIf it succeeds in loading the module, it returns `{:module, module}`.\nIf not, returns `{:error, reason}` with the error reason.\n\nSee the module documentation for more information on code loading.\n\n## Examples\n\n    iex> Code.ensure_loaded(Atom)\n    {:module, Atom}\n\n    iex> Code.ensure_loaded(DoesNotExist)\n    {:error, :nofile}\n\n","title":"Code.ensure_loaded/1","type":"function"},{"doc":"Same as ensure_loaded/1 but raises if the module cannot be loaded.","ref":"Code.html#ensure_loaded!/1","source_doc":"Same as `ensure_loaded/1` but raises if the module cannot be loaded.\n","title":"Code.ensure_loaded!/1","type":"function"},{"doc":"Ensures the given module is loaded. Similar to ensure_loaded/1 , but returns true if the module is already loaded or was successfully loaded. Returns false otherwise. Examples iex&gt; Code . ensure_loaded? ( Atom ) true","ref":"Code.html#ensure_loaded?/1","source_doc":"Ensures the given module is loaded.\n\nSimilar to `ensure_loaded/1`, but returns `true` if the module\nis already loaded or was successfully loaded. Returns `false`\notherwise.\n\n## Examples\n\n    iex> Code.ensure_loaded?(Atom)\n    true\n\n","title":"Code.ensure_loaded?/1","type":"function"},{"doc":"Returns an environment for evaluation. It accepts either a Macro.Env , that is then pruned and prepared, or a list of options. It returns an environment that is ready for evaluation. Most functions in this module will automatically prepare the given environment for evaluation, so you don't need to explicitly call this function, with the exception of eval_quoted_with_env/3 , which was designed precisely to be called in a loop, to implement features such as interactive shells or anything else with multiple evaluations. Options If an env is not given, the options can be: :file - the file to be considered in the evaluation :line - the line on which the script starts","ref":"Code.html#env_for_eval/1","source_doc":"Returns an environment for evaluation.\n\nIt accepts either a `Macro.Env`, that is then pruned and prepared,\nor a list of options. It returns an environment that is ready for\nevaluation.\n\nMost functions in this module will automatically prepare the given\nenvironment for evaluation, so you don't need to explicitly call\nthis function, with the exception of `eval_quoted_with_env/3`,\nwhich was designed precisely to be called in a loop, to implement\nfeatures such as interactive shells or anything else with multiple\nevaluations.\n\n## Options\n\nIf an env is not given, the options can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts\n","title":"Code.env_for_eval/1","type":"function"},{"doc":"Evaluates the given file. Accepts relative_to as an argument to tell where the file is located. While require_file/2 and compile_file/2 return the loaded modules and their bytecode, eval_file/2 simply evaluates the file contents and returns the evaluation result and its binding (exactly the same return value as eval_string/3 ).","ref":"Code.html#eval_file/2","source_doc":"Evaluates the given file.\n\nAccepts `relative_to` as an argument to tell where the file is located.\n\nWhile `require_file/2` and `compile_file/2` return the loaded modules and their\nbytecode, `eval_file/2` simply evaluates the file contents and returns the\nevaluation result and its binding (exactly the same return value as `eval_string/3`).\n","title":"Code.eval_file/2","type":"function"},{"doc":"Evaluates the quoted contents. Warning : Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated). See eval_string/3 for a description of binding and opts . Examples iex&gt; contents = quote ( do : var! ( a ) + var! ( b ) ) iex&gt; { result , binding } = Code . eval_quoted ( contents , [ a : 1 , b : 2 ] , file : __ENV__ . file , line : __ENV__ . line ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ] For convenience, you can pass __ENV__/0 as the opts argument and all options will be automatically extracted from the current environment: iex&gt; contents = quote ( do : var! ( a ) + var! ( b ) ) iex&gt; { result , binding } = Code . eval_quoted ( contents , [ a : 1 , b : 2 ] , __ENV__ ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ]","ref":"Code.html#eval_quoted/3","source_doc":"Evaluates the quoted contents.\n\n**Warning**: Calling this function inside a macro is considered bad\npractice as it will attempt to evaluate runtime values at compile time.\nMacro arguments are typically transformed by unquoting them into the\nreturned quoted expressions (instead of evaluated).\n\nSee `eval_string/3` for a description of `binding` and `opts`.\n\n## Examples\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall options will be automatically extracted from the current environment:\n\n    iex> contents = quote(do: var!(a) + var!(b))\n    iex> {result, binding} = Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n","title":"Code.eval_quoted/3","type":"function"},{"doc":"Evaluates the given quoted contents with binding and env . This function is meant to be called in a loop, to implement features such as interactive shells or anything else with multiple evaluations. Therefore, the first time you call this function, you must compute the initial environment with env_for_eval/1 . The remaining calls must pass the environment that was returned by this function. Options :prune_binding - (since v1.14.2) prune binding to keep only variables read or written by the evaluated code. Note that variables used by modules are always pruned, even if later used by the modules. You can submit to the :on_module tracer event and access the variables used by the module from its environment.","ref":"Code.html#eval_quoted_with_env/4","source_doc":"Evaluates the given `quoted` contents with `binding` and `env`.\n\nThis function is meant to be called in a loop, to implement features\nsuch as interactive shells or anything else with multiple evaluations.\nTherefore, the first time you call this function, you must compute\nthe initial environment with `env_for_eval/1`. The remaining calls\nmust pass the environment that was returned by this function.\n\n## Options\n\n  * `:prune_binding` - (since v1.14.2) prune binding to keep only\n    variables read or written by the evaluated code. Note that\n    variables used by modules are always pruned, even if later used\n    by the modules. You can submit to the `:on_module` tracer event\n    and access the variables used by the module from its environment.\n\n","title":"Code.eval_quoted_with_env/4","type":"function"},{"doc":"Evaluates the contents given by string . The binding argument is a list of all variables and their values. The opts argument is a keyword list of environment options. Warning : string can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use eval_string/3 with untrusted input (such as strings coming from the network). Options Options can be: :file - the file to be considered in the evaluation :line - the line on which the script starts Additionally, you may also pass an environment as second argument, so the evaluation happens within that environment. Returns a tuple of the form {value, binding} , where value is the value returned from evaluating string . If an error occurs while evaluating string , an exception will be raised. binding is a list with all variable names and their values after evaluating string . The binding keys are usually atoms, but they may be a tuple for variables defined in a different context. The names are in no particular order. Examples iex&gt; { result , binding } = Code . eval_string ( &quot;a + b&quot; , [ a : 1 , b : 2 ] , file : __ENV__ . file , line : __ENV__ . line ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ] iex&gt; { result , binding } = Code . eval_string ( &quot;c = a + b&quot; , [ a : 1 , b : 2 ] , __ENV__ ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 , c : 3 ] iex&gt; { result , binding } = Code . eval_string ( &quot;a = a + b&quot; , [ a : 1 , b : 2 ] ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 3 , b : 2 ] For convenience, you can pass __ENV__/0 as the opts argument and all imports, requires and aliases defined in the current environment will be automatically carried over: iex&gt; { result , binding } = Code . eval_string ( &quot;a + b&quot; , [ a : 1 , b : 2 ] , __ENV__ ) iex&gt; result 3 iex&gt; Enum . sort ( binding ) [ a : 1 , b : 2 ]","ref":"Code.html#eval_string/3","source_doc":"Evaluates the contents given by `string`.\n\nThe `binding` argument is a list of all variables and their values.\nThe `opts` argument is a keyword list of environment options.\n\n**Warning**: `string` can be any Elixir code and will be executed with\nthe same privileges as the Erlang VM: this means that such code could\ncompromise the machine (for example by executing system commands).\nDon't use `eval_string/3` with untrusted input (such as strings coming\nfrom the network).\n\n## Options\n\nOptions can be:\n\n  * `:file` - the file to be considered in the evaluation\n\n  * `:line` - the line on which the script starts\n\nAdditionally, you may also pass an environment as second argument,\nso the evaluation happens within that environment.\n\nReturns a tuple of the form `{value, binding}`, where `value` is the value\nreturned from evaluating `string`. If an error occurs while evaluating\n`string`, an exception will be raised.\n\n`binding` is a list with all variable names and their values after evaluating\n`string`. The binding keys are usually atoms, but they may be a tuple for variables\ndefined in a different context. The names are in no particular order.\n\n## Examples\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n    iex> {result, binding} = Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2, c: 3]\n\n    iex> {result, binding} = Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 3, b: 2]\n\nFor convenience, you can pass `__ENV__/0` as the `opts` argument and\nall imports, requires and aliases defined in the current environment\nwill be automatically carried over:\n\n    iex> {result, binding} = Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n    iex> result\n    3\n    iex> Enum.sort(binding)\n    [a: 1, b: 2]\n\n","title":"Code.eval_string/3","type":"function"},{"doc":"Returns the docs for the given module or path to .beam file. When given a module name, it finds its BEAM code and reads the docs from it. When given a path to a .beam file, it will load the docs directly from that file. It returns the term stored in the documentation chunk in the format defined by EEP 48 or {:error, reason} if the chunk is not available. Examples # Module documentation of an existing module iex&gt; { :docs_v1 , _ , :elixir , _ , %{ &quot;en&quot; =&gt; module_doc } , _ , _ } = Code . fetch_docs ( Atom ) iex&gt; module_doc |&gt; String . split ( &quot; \\n &quot; ) |&gt; Enum . at ( 0 ) &quot;Atoms are constants whose values are their own name.&quot; # A module that doesn&#39;t exist iex&gt; Code . fetch_docs ( ModuleNotGood ) { :error , :module_not_found }","ref":"Code.html#fetch_docs/1","source_doc":"Returns the docs for the given module or path to `.beam` file.\n\nWhen given a module name, it finds its BEAM code and reads the docs from it.\n\nWhen given a path to a `.beam` file, it will load the docs directly from that\nfile.\n\nIt returns the term stored in the documentation chunk in the format defined by\n[EEP 48](https://www.erlang.org/eeps/eep-0048.html) or `{:error, reason}` if\nthe chunk is not available.\n\n## Examples\n\n    # Module documentation of an existing module\n    iex> {:docs_v1, _, :elixir, _, %{\"en\" => module_doc}, _, _} = Code.fetch_docs(Atom)\n    iex> module_doc |> String.split(\"\\n\") |> Enum.at(0)\n    \"Atoms are constants whose values are their own name.\"\n\n    # A module that doesn't exist\n    iex> Code.fetch_docs(ModuleNotGood)\n    {:error, :module_not_found}\n\n","title":"Code.fetch_docs/1","type":"function"},{"doc":"Formats a file. See format_string!/2 for more information on code formatting and available options.","ref":"Code.html#format_file!/2","source_doc":"Formats a file.\n\nSee `format_string!/2` for more information on code formatting and\navailable options.\n","title":"Code.format_file!/2","type":"function"},{"doc":"Formats the given code string . The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules. Options :file - the file which contains the string, used for error reporting :line - the line the string starts, used for error reporting :line_length - the line length to aim for when formatting the document. Defaults to 98. Note this value is used as guideline but there are situations where it is not enforced. See the &quot;Line length&quot; section below for more information :locals_without_parens - a keyword list of name and arity pairs that should be kept without parens whenever possible. The arity may be the atom :* , which implies all arities of that name. The formatter already includes a list of functions and this option augments this list. :force_do_end_blocks (since v1.9.0) - when true , converts all inline usages of do: ... , else: ... and friends into do - end blocks. Defaults to false . Note that this option is convergent: once you set it to true , all keywords will be converted. If you set it to false later on, do - end blocks won't be converted back to keywords. :normalize_bitstring_modifiers (since v1.14.0) - when true , removes unnecessary parentheses in known bitstring modifiers , for example &lt;&lt;foo::binary()&gt;&gt; becomes &lt;&lt;foo::binary&gt;&gt; , or adds parentheses for custom modifiers, where &lt;&lt;foo::custom_type&gt;&gt; becomes &lt;&lt;foo::custom_type()&gt;&gt; . Defaults to true . This option changes the AST. :normalize_charlists_as_sigils (since v1.15.0) - when true , formats charlists as ~c sigils, for example 'foo' becomes ~c&quot;foo&quot; . Defaults to true . This option changes the AST. Design principles The formatter was designed under three principles. First, the formatter never changes the semantics of the code. This means the input AST and the output AST are almost always equivalent. The only cases where the formatter will change the AST is when the input AST would cause compiler warnings and the output AST won't. The cases where the formatter changes the AST can be disabled through formatting options if desired. The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole. The formatter does not hard code names. The formatter will not behave specially because a function is named defmodule , def , or the like. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the :locals_without_parens option. Running the formatter The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot. In some cases, this may lead to undesired formatting. Therefore, some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer . That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file. For example, the formatter may break a long function definition over multiple clauses: def my_function ( % User { name : name , age : age , ... } , arg1 , arg2 ) do ... end While the code above is completely valid, you may prefer to match on the struct variables inside the function body in order to keep the definition on a single line: def my_function ( % User { } = user , arg1 , arg2 ) do %{ name : name , age : age , ... } = user ... end In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code: def board? ( board_id , % User { } = user , available_permissions , required_permissions ) do Tracker.OrganizationMembers . user_in_organization? ( user . id , board . organization_id ) and required_permissions == Enum . to_list ( MapSet . intersection ( MapSet . new ( required_permissions ) , MapSet . new ( available_permissions ) ) ) end The code above has very long lines and running the formatter is not going to address this issue. In fact, the formatter may make it more obvious that you have complex expressions: def board? ( board_id , % User { } = user , available_permissions , required_permissions ) do Tracker.OrganizationMembers . user_in_organization? ( user . id , board . organization_id ) and required_permissions == Enum . to_list ( MapSet . intersection ( MapSet . new ( required_permissions ) , MapSet . new ( available_permissions ) ) ) end Take such cases as a suggestion that your code should be refactored: def board? ( board_id , % User { } = user , available_permissions , required_permissions ) do Tracker.OrganizationMembers . user_in_organization? ( user . id , board . organization_id ) and matching_permissions? ( required_permissions , available_permissions ) end defp matching_permissions? ( required_permissions , available_permissions ) do intersection = required_permissions |&gt; MapSet . new ( ) |&gt; MapSet . intersection ( MapSet . new ( available_permissions ) ) |&gt; Enum . to_list ( ) required_permissions == intersection end To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions. Line length Another point about the formatter is that the :line_length configuration is a guideline. In many cases, it is not possible for the formatter to break your code apart, which means it will go over the line length. For example, if you have a long string: &quot;this is a very long string that will go over the line length&quot; The formatter doesn't know how to break it apart without changing the code underlying syntax representation, so it is up to you to step in: &quot;this is a very long string &quot; &lt;&gt; &quot;that will go over the line length&quot; The string concatenation makes the code fit on a single line and also gives more options to the formatter. This may also appear in do/end blocks, where the do keyword (or -&gt; ) may go over the line length because there is no opportunity for the formatter to introduce a line break in a readable way. For example, if you do: case very_long_expression ( ) do end And only the do keyword is above the line length, Elixir will not emit this: case very_long_expression ( ) do end So it prefers to not touch the line at all and leave do above the line limit. Keeping user's formatting The formatter respects the input format in some cases. Those are listed below: Insignificant digits in numbers are kept as is. The formatter, however, always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input Newlines inside blocks are kept as in the input except for: expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line The choice between :do keyword and do - end blocks is left to the user Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators) The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter. Multi-line lists, maps, tuples, and the like You can force lists, tuples, bitstrings, maps, structs and function calls to have one entry per line by adding a newline after the opening bracket and a new line before the closing bracket lines. For example: [ foo , bar ] If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below [ foo , bar ] will be formatted as [ foo , bar ] You can also force function calls and keywords to be rendered on multiple lines by having each entry on its own line: defstruct name : nil , age : 0 The code above will be kept with one keyword entry per line by the formatter. To avoid that, just squash everything into a single line. Parens and no parens in function calls Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for: calls that have do - end blocks local calls without parens where the name and arity of the local call is also listed under :locals_without_parens (except for calls with arity 0, where the compiler always require parens) The choice of parens and no parens also affects indentation. When a function call with parens doesn't fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces: some_call ( arg1 , arg2 , arg3 ) On the other hand, function calls without parens are always indented by the function call length itself, like this: some_call arg1 , arg2 , arg3 If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this: Enum . reduce ( some_collection , initial_value , fn element , acc -&gt; # code end ) some_function_without_parens %{ foo : :bar , baz : :bat } Code comments The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character. The formatter also extracts all trailing comments to their previous line. For example, the code below hello #world will be rewritten to # world hello Because code comments are handled apart from the code representation (AST), there are some situations where code comments are seen as ambiguous by the code formatter. For example, the comment in the anonymous function below fn arg1 -&gt; body1 # comment arg2 -&gt; body2 end and in this one fn arg1 -&gt; body1 # comment arg2 -&gt; body2 end are considered equivalent (the nesting is discarded alongside most of user formatting). In such cases, the code formatter will always format to the latter. Newlines The formatter converts all newlines in code from \\r\\n to \\n .","ref":"Code.html#format_string!/2","source_doc":"Formats the given code `string`.\n\nThe formatter receives a string representing Elixir code and\nreturns iodata representing the formatted code according to\npre-defined rules.\n\n## Options\n\n  * `:file` - the file which contains the string, used for error\n    reporting\n\n  * `:line` - the line the string starts, used for error reporting\n\n  * `:line_length` - the line length to aim for when formatting\n    the document. Defaults to 98. Note this value is used as\n    guideline but there are situations where it is not enforced.\n    See the \"Line length\" section below for more information\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n\n  * `:force_do_end_blocks` (since v1.9.0) - when `true`, converts all\n    inline usages of `do: ...`,  `else: ...` and friends into `do`-`end`\n    blocks. Defaults to `false`. Note that this option is convergent:\n    once you set it to `true`, **all keywords** will be converted.\n    If you set it to `false` later on, `do`-`end` blocks won't be\n    converted back to keywords.\n\n  * `:normalize_bitstring_modifiers` (since v1.14.0) - when `true`,\n    removes unnecessary parentheses in known bitstring\n    [modifiers](`<<>>/1`), for example `<<foo::binary()>>`\n    becomes `<<foo::binary>>`, or adds parentheses for custom\n    modifiers, where `<<foo::custom_type>>` becomes `<<foo::custom_type()>>`.\n    Defaults to `true`. This option changes the AST.\n\n  * `:normalize_charlists_as_sigils` (since v1.15.0) - when `true`,\n    formats charlists as [`~c`](`Kernel.sigil_c/2`) sigils, for example\n    `'foo'` becomes `~c\"foo\"`.\n    Defaults to `true`. This option changes the AST.\n\n## Design principles\n\nThe formatter was designed under three principles.\n\nFirst, the formatter never changes the semantics of the code.\nThis means the input AST and the output AST are almost always equivalent.\nThe only cases where the formatter will change the AST is when the input AST\nwould cause *compiler warnings* and the output AST won't. The cases where\nthe formatter changes the AST can be disabled through formatting options\nif desired.\n\nThe second principle is to provide as little configuration as possible.\nThis eases the formatter adoption by removing contention points while\nmaking sure a single style is followed consistently by the community as\na whole.\n\nThe formatter does not hard code names. The formatter will not behave\nspecially because a function is named `defmodule`, `def`, or the like. This\nprinciple mirrors Elixir's goal of being an extensible language where\ndevelopers can extend the language with new constructs as if they were\npart of the language. When it is absolutely necessary to change behaviour\nbased on the name, this behaviour should be configurable, such as the\n`:locals_without_parens` option.\n\n## Running the formatter\n\nThe formatter attempts to fit the most it can on a single line and\nintroduces line breaks wherever possible when it cannot.\n\nIn some cases, this may lead to undesired formatting. Therefore, **some\ncode generated by the formatter may not be aesthetically pleasing and\nmay require explicit intervention from the developer**. That's why we\ndo not recommend to run the formatter blindly in an existing codebase.\nInstead you should format and sanity check each formatted file.\n\nFor example, the formatter may break a long function definition over\nmultiple clauses:\n\n    def my_function(\n      %User{name: name, age: age, ...},\n      arg1,\n      arg2\n    ) do\n      ...\n    end\n\nWhile the code above is completely valid, you may prefer to match on\nthe struct variables inside the function body in order to keep the\ndefinition on a single line:\n\n    def my_function(%User{} = user, arg1, arg2) do\n      %{name: name, age: age, ...} = user\n      ...\n    end\n\nIn some situations, you can use the fact the formatter does not generate\nelegant code as a hint for refactoring. Take this code:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions == Enum.to_list(MapSet.intersection(MapSet.new(required_permissions), MapSet.new(available_permissions)))\n    end\n\nThe code above has very long lines and running the formatter is not going\nto address this issue. In fact, the formatter may make it more obvious that\nyou have complex expressions:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        required_permissions ==\n          Enum.to_list(\n            MapSet.intersection(\n              MapSet.new(required_permissions),\n              MapSet.new(available_permissions)\n            )\n          )\n    end\n\nTake such cases as a suggestion that your code should be refactored:\n\n    def board?(board_id, %User{} = user, available_permissions, required_permissions) do\n      Tracker.OrganizationMembers.user_in_organization?(user.id, board.organization_id) and\n        matching_permissions?(required_permissions, available_permissions)\n    end\n\n    defp matching_permissions?(required_permissions, available_permissions) do\n      intersection =\n        required_permissions\n        |> MapSet.new()\n        |> MapSet.intersection(MapSet.new(available_permissions))\n        |> Enum.to_list()\n\n      required_permissions == intersection\n    end\n\nTo sum it up: since the formatter cannot change the semantics of your\ncode, sometimes it is necessary to tweak or refactor the code to get\noptimal formatting. To help better understand how to control the formatter,\nwe describe in the next sections the cases where the formatter keeps the\nuser encoding and how to control multiline expressions.\n\n## Line length\n\nAnother point about the formatter is that the `:line_length` configuration\nis a guideline. In many cases, it is not possible for the formatter to break\nyour code apart, which means it will go over the line length. For example,\nif you have a long string:\n\n    \"this is a very long string that will go over the line length\"\n\nThe formatter doesn't know how to break it apart without changing the\ncode underlying syntax representation, so it is up to you to step in:\n\n    \"this is a very long string \" <>\n       \"that will go over the line length\"\n\nThe string concatenation makes the code fit on a single line and also\ngives more options to the formatter.\n\nThis may also appear in do/end blocks, where the `do` keyword (or `->`)\nmay go over the line length because there is no opportunity for the\nformatter to introduce a line break in a readable way. For example,\nif you do:\n\n    case very_long_expression() do\n    end\n\nAnd only the `do` keyword is above the line length, Elixir **will not**\nemit this:\n\n    case very_long_expression()\n    do\n    end\n\nSo it prefers to not touch the line at all and leave `do` above the\nline limit.\n\n## Keeping user's formatting\n\nThe formatter respects the input format in some cases. Those are\nlisted below:\n\n  * Insignificant digits in numbers are kept as is. The formatter,\n    however, always inserts underscores for decimal numbers with more\n    than 5 digits and converts hexadecimal digits to uppercase\n\n  * Strings, charlists, atoms and sigils are kept as is. No character\n    is automatically escaped or unescaped. The choice of delimiter is\n    also respected from the input\n\n  * Newlines inside blocks are kept as in the input except for:\n    1) expressions that take multiple lines will always have an empty\n    line before and after and 2) empty lines are always squeezed\n    together into a single empty line\n\n  * The choice between `:do` keyword and `do`-`end` blocks is left\n    to the user\n\n  * Lists, tuples, bitstrings, maps, structs and function calls will be\n    broken into multiple lines if they are followed by a newline in the\n    opening bracket and preceded by a new line in the closing bracket\n\n  * Newlines before certain operators (such as the pipeline operators)\n    and before other operators (such as comparison operators)\n\nThe behaviours above are not guaranteed. We may remove or add new\nrules in the future. The goal of documenting them is to provide better\nunderstanding on what to expect from the formatter.\n\n### Multi-line lists, maps, tuples, and the like\n\nYou can force lists, tuples, bitstrings, maps, structs and function\ncalls to have one entry per line by adding a newline after the opening\nbracket and a new line before the closing bracket lines. For example:\n\n    [\n      foo,\n      bar\n    ]\n\nIf there are no newlines around the brackets, then the formatter will\ntry to fit everything on a single line, such that the snippet below\n\n    [foo,\n     bar]\n\nwill be formatted as\n\n    [foo, bar]\n\nYou can also force function calls and keywords to be rendered on multiple\nlines by having each entry on its own line:\n\n    defstruct name: nil,\n              age: 0\n\nThe code above will be kept with one keyword entry per line by the\nformatter. To avoid that, just squash everything into a single line.\n\n### Parens and no parens in function calls\n\nElixir has two syntaxes for function calls. With parens and no parens.\nBy default, Elixir will add parens to all calls except for:\n\n  1. calls that have `do`-`end` blocks\n  2. local calls without parens where the name and arity of the local\n     call is also listed under `:locals_without_parens` (except for\n     calls with arity 0, where the compiler always require parens)\n\nThe choice of parens and no parens also affects indentation. When a\nfunction call with parens doesn't fit on the same line, the formatter\nintroduces a newline around parens and indents the arguments with two\nspaces:\n\n    some_call(\n      arg1,\n      arg2,\n      arg3\n    )\n\nOn the other hand, function calls without parens are always indented\nby the function call length itself, like this:\n\n    some_call arg1,\n              arg2,\n              arg3\n\nIf the last argument is a data structure, such as maps and lists, and\nthe beginning of the data structure fits on the same line as the function\ncall, then no indentation happens, this allows code like this:\n\n    Enum.reduce(some_collection, initial_value, fn element, acc ->\n      # code\n    end)\n\n    some_function_without_parens %{\n      foo: :bar,\n      baz: :bat\n    }\n\n## Code comments\n\nThe formatter also handles code comments in a way to guarantee a space\nis always added between the beginning of the comment (#) and the next\ncharacter.\n\nThe formatter also extracts all trailing comments to their previous line.\nFor example, the code below\n\n    hello #world\n\nwill be rewritten to\n\n    # world\n    hello\n\nBecause code comments are handled apart from the code representation (AST),\nthere are some situations where code comments are seen as ambiguous by the\ncode formatter. For example, the comment in the anonymous function below\n\n    fn\n      arg1 ->\n        body1\n        # comment\n\n      arg2 ->\n        body2\n    end\n\nand in this one\n\n    fn\n      arg1 ->\n        body1\n\n      # comment\n      arg2 ->\n        body2\n    end\n\nare considered equivalent (the nesting is discarded alongside most of\nuser formatting). In such cases, the code formatter will always format to\nthe latter.\n\n## Newlines\n\nThe formatter converts all newlines in code from `\\r\\n` to `\\n`.\n","title":"Code.format_string!/2","type":"function"},{"doc":"Returns the value of a given compiler option. For a description of all options, see put_compiler_option/2 . Examples Code . get_compiler_option ( :debug_info ) #=&gt; true","ref":"Code.html#get_compiler_option/1","source_doc":"Returns the value of a given compiler option.\n\nFor a description of all options, see `put_compiler_option/2`.\n\n## Examples\n\n    Code.get_compiler_option(:debug_info)\n    #=> true\n\n","title":"Code.get_compiler_option/1","type":"function"},{"doc":"Returns true if the module is loaded. This function doesn't attempt to load the module. For such behaviour, ensure_loaded?/1 can be used. Examples iex&gt; Code . loaded? ( Atom ) true iex&gt; Code . loaded? ( NotYetLoaded ) false","ref":"Code.html#loaded?/1","source_doc":"Returns `true` if the module is loaded.\n\nThis function doesn't attempt to load the module. For such behaviour,\n`ensure_loaded?/1` can be used.\n\n## Examples\n\n    iex> Code.loaded?(Atom)\n    true\n\n    iex> Code.loaded?(NotYetLoaded)\n    false\n\n","title":"Code.loaded?/1","type":"function"},{"doc":"Prepends a path to the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The list of files is managed per Erlang VM node. The path is expanded with Path.expand/1 before being prepended. It requires the path to exist. Returns a boolean indicating if the path was successfully added. Examples Code . prepend_path ( &quot;.&quot; ) #=&gt; true Code . prepend_path ( &quot;/does_not_exist&quot; ) #=&gt; false Options :cache - (since v1.15.0) when true, the code path is cached the first time it is traversed in order to reduce file system operations. It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#prepend_path/2","source_doc":"Prepends a path to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nThe path is expanded with `Path.expand/1` before being prepended.\nIt requires the path to exist. Returns a boolean indicating if\nthe path was successfully added.\n\n## Examples\n\n    Code.prepend_path(\".\")\n    #=> true\n\n    Code.prepend_path(\"/does_not_exist\")\n    #=> false\n\n## Options\n\n  * `:cache` - (since v1.15.0) when true, the code path is cached\n    the first time it is traversed in order to reduce file system\n    operations. It requires Erlang/OTP 26, otherwise it is a no-op.\n\n","title":"Code.prepend_path/2","type":"function"},{"doc":"Prepends a list of paths to the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code. The list of files is managed per Erlang VM node. All paths are expanded with Path.expand/1 before being prepended. Only existing paths are prepended. This function always returns :ok , regardless of how many paths were prepended. Use prepend_path/1 if you need more control. Examples Code . prepend_paths ( [ &quot;.&quot; , &quot;/does_not_exist&quot; ] ) #=&gt; :ok Options :cache - when true, the code path is cached the first time it is traversed in order to reduce file system operations. It requires Erlang/OTP 26, otherwise it is a no-op.","ref":"Code.html#prepend_paths/2","source_doc":"Prepends a list of `paths` to the Erlang VM code path list.\n\nThis is the list of directories the Erlang VM uses for\nfinding module code. The list of files is managed per Erlang\nVM node.\n\nAll paths are expanded with `Path.expand/1` before being prepended.\nOnly existing paths are prepended. This function always returns `:ok`,\nregardless of how many paths were prepended. Use `prepend_path/1`\nif you need more control.\n\n## Examples\n\n    Code.prepend_paths([\".\", \"/does_not_exist\"])\n    #=> :ok\n\n## Options\n\n  * `:cache` - when true, the code path is cached the first time\n    it is traversed in order to reduce file system operations.\n    It requires Erlang/OTP 26, otherwise it is a no-op.\n","title":"Code.prepend_paths/2","type":"function"},{"doc":"Purge compiler modules. The compiler utilizes temporary modules to compile code. For example, elixir_compiler_1 , elixir_compiler_2 , and so on. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as elixir_compiler_12345 . This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too. This function is only meant to be called if you have a long running node that is constantly evaluating code. It returns {:ok, number_of_modules_purged} .","ref":"Code.html#purge_compiler_modules/0","source_doc":"Purge compiler modules.\n\nThe compiler utilizes temporary modules to compile code. For example,\n`elixir_compiler_1`, `elixir_compiler_2`, and so on. In case the compiled code\nstores references to anonymous functions or similar, the Elixir compiler\nmay be unable to reclaim those modules, keeping an unnecessary amount of\ncode in memory and eventually leading to modules such as `elixir_compiler_12345`.\n\nThis function purges all modules currently kept by the compiler, allowing\nold compiler module names to be reused. If there are any processes running\nany code from such modules, they will be terminated too.\n\nThis function is only meant to be called if you have a long running node\nthat is constantly evaluating code.\n\nIt returns `{:ok, number_of_modules_purged}`.\n","title":"Code.purge_compiler_modules/0","type":"function"},{"doc":"Stores a compilation option. Changing the compilation options affect all processes running in a given Erlang VM node. Available options are: :docs - when true , retains documentation in the compiled module. Defaults to true . :debug_info - when true , retains debug information in the compiled module. Defaults to true . This enables static analysis tools as it allows developers to partially reconstruct the original source code. Therefore, disabling :debug_info is not recommended as it removes the ability of the Elixir compiler and other tools to provide feedback. If you want to remove the :debug_info while deploying, tools like mix release already do such by default. Additionally, mix test disables it via the :test_elixirc_options project configuration option. This option can also be overridden per module using the @compile directive. :ignore_already_consolidated (since v1.10.0) - when true , does not warn when a protocol has already been consolidated and a new implementation is added. Defaults to false . :ignore_module_conflict - when true , does not warn when a module has already been defined. Defaults to false . :relative_paths - when true , uses relative paths in quoted nodes, warnings, and errors generated by the compiler. Note disabling this option won't affect runtime warnings and errors. Defaults to true . :warnings_as_errors - causes compilation to fail when warnings are generated. Defaults to false . :no_warn_undefined (since v1.10.0) - list of modules and {Mod, fun, arity} tuples that will not emit warnings that the module or function does not exist at compilation time. Pass atom :all to skip warning for all undefined functions. This can be useful when doing dynamic compilation. Defaults to [] . :tracers (since v1.10.0) - a list of tracers (modules) to be used during compilation. See the module docs for more information. Defaults to [] . :parser_options (since v1.10.0) - a keyword list of options to be given to the parser when compiling files. It accepts the same options as string_to_quoted/2 (except by the options that change the AST itself). This can be used in combination with the tracer to retrieve localized information about events happening during compilation. Defaults to [] . This option only affects code compilation functions, such as compile_string/2 and compile_file/2 but not string_to_quoted/2 and friends, as the latter is used for other purposes beyond compilation. :on_undefined_variable (since v1.15.0) - either :raise or :warn . When :raise (the default), undefined variables will trigger a compilation error. You may be set it to :warn if you want undefined variables to emit a warning and expand as to a local call to the zero-arity function of the same name (for example, node would be expanded as node() ). This :warn behaviour only exists for compatibility reasons when working with old dependencies. It always returns :ok . Raises an error for invalid options. Examples Code . put_compiler_option ( :debug_info , true ) #=&gt; :ok","ref":"Code.html#put_compiler_option/2","source_doc":"Stores a compilation option.\n\nChanging the compilation options affect all processes running in a\ngiven Erlang VM node.\n\nAvailable options are:\n\n  * `:docs` - when `true`, retains documentation in the compiled module.\n    Defaults to `true`.\n\n  * `:debug_info` - when `true`, retains debug information in the compiled\n    module. Defaults to `true`.\n    This enables static analysis tools as it allows developers to\n    partially reconstruct the original source code. Therefore, disabling\n    `:debug_info` is not recommended as it removes the ability of the\n    Elixir compiler and other tools to provide feedback. If you want to\n    remove the `:debug_info` while deploying, tools like `mix release`\n    already do such by default.\n    Additionally, `mix test` disables it via the `:test_elixirc_options`\n    project configuration option.\n    This option can also be overridden per module using the `@compile` directive.\n\n  * `:ignore_already_consolidated` (since v1.10.0) - when `true`, does not warn\n    when a protocol has already been consolidated and a new implementation is added.\n    Defaults to `false`.\n\n  * `:ignore_module_conflict` - when `true`, does not warn when a module has\n    already been defined. Defaults to `false`.\n\n  * `:relative_paths` - when `true`, uses relative paths in quoted nodes,\n    warnings, and errors generated by the compiler. Note disabling this option\n    won't affect runtime warnings and errors. Defaults to `true`.\n\n  * `:warnings_as_errors` - causes compilation to fail when warnings are\n    generated. Defaults to `false`.\n\n  * `:no_warn_undefined` (since v1.10.0) - list of modules and `{Mod, fun, arity}`\n    tuples that will not emit warnings that the module or function does not exist\n    at compilation time. Pass atom `:all` to skip warning for all undefined\n    functions. This can be useful when doing dynamic compilation. Defaults to `[]`.\n\n  * `:tracers` (since v1.10.0) - a list of tracers (modules) to be used during\n    compilation. See the module docs for more information. Defaults to `[]`.\n\n  * `:parser_options` (since v1.10.0) - a keyword list of options to be given\n    to the parser when compiling files. It accepts the same options as\n    `string_to_quoted/2` (except by the options that change the AST itself).\n    This can be used in combination with the tracer to retrieve localized\n    information about events happening during compilation. Defaults to `[]`.\n    This option only affects code compilation functions, such as `compile_string/2`\n    and `compile_file/2` but not `string_to_quoted/2` and friends, as the\n    latter is used for other purposes beyond compilation.\n\n  * `:on_undefined_variable` (since v1.15.0) - either `:raise` or `:warn`.\n    When `:raise` (the default), undefined variables will trigger a compilation\n    error. You may be set it to `:warn` if you want undefined variables to\n    emit a warning and expand as to a local call to the zero-arity function\n    of the same name (for example, `node` would be expanded as `node()`).\n    This `:warn` behaviour only exists for compatibility reasons when working\n    with old dependencies.\n\nIt always returns `:ok`. Raises an error for invalid options.\n\n## Examples\n\n    Code.put_compiler_option(:debug_info, true)\n    #=> :ok\n\n","title":"Code.put_compiler_option/2","type":"function"},{"doc":"Converts a quoted expression to an algebra document using Elixir's formatter rules. The algebra document can be converted into a string by calling: doc |&gt; Inspect.Algebra . format ( :infinity ) |&gt; IO . iodata_to_binary ( ) For a high-level function that does the same, see Macro.to_string/1 . Formatting considerations The Elixir AST does not contain metadata for literals like strings, lists, or tuples with two elements, which means that the produced algebra document will not respect all of the user preferences and comments may be misplaced. To get better results, you can use the :token_metadata , :unescape and :literal_encoder options to string_to_quoted/2 to provide additional information to the formatter: [ literal_encoder : &amp; { :ok , { :__block__ , &amp;2 , [ &amp;1 ] } } , token_metadata : true , unescape : false ] This will produce an AST that contains information such as do blocks start and end lines or sigil delimiters, and by wrapping literals in blocks they can now hold metadata like line number, string delimiter and escaped sequences, or integer formatting (such as 0x2a instead of 47 ). However, note this AST is not valid . If you evaluate it, it won't have the same semantics as the regular Elixir AST due to the :unescape and :literal_encoder options. However, those options are useful if you're doing source code manipulation, where it's important to preserve user choices and comments placing. Options :comments - the list of comments associated with the quoted expression. Defaults to [] . It is recommended that both :token_metadata and :literal_encoder options are given to string_to_quoted_with_comments/2 in order to get proper placement for comments :escape - when true , escaped sequences like \\n will be escaped into \\\\n . If the :unescape option was set to false when using string_to_quoted/2 , setting this option to false will prevent it from escaping the sequences twice. Defaults to true . :locals_without_parens - a keyword list of name and arity pairs that should be kept without parens whenever possible. The arity may be the atom :* , which implies all arities of that name. The formatter already includes a list of functions and this option augments this list. :syntax_colors - a keyword list of colors the output is colorized. See Inspect.Opts for more information.","ref":"Code.html#quoted_to_algebra/2","source_doc":"Converts a quoted expression to an algebra document using Elixir's formatter rules.\n\nThe algebra document can be converted into a string by calling:\n\n    doc\n    |> Inspect.Algebra.format(:infinity)\n    |> IO.iodata_to_binary()\n\nFor a high-level function that does the same, see `Macro.to_string/1`.\n\n## Formatting considerations\n\nThe Elixir AST does not contain metadata for literals like strings, lists, or\ntuples with two elements, which means that the produced algebra document will\nnot respect all of the user preferences and comments may be misplaced.\nTo get better results, you can use the `:token_metadata`, `:unescape` and\n`:literal_encoder` options to `string_to_quoted/2` to provide additional\ninformation to the formatter:\n\n    [\n      literal_encoder: &{:ok, {:__block__, &2, [&1]}},\n      token_metadata: true,\n      unescape: false\n    ]\n\nThis will produce an AST that contains information such as `do` blocks start\nand end lines or sigil delimiters, and by wrapping literals in blocks they can\nnow hold metadata like line number, string delimiter and escaped sequences, or\ninteger formatting (such as `0x2a` instead of `47`). However, **note this AST is\nnot valid**. If you evaluate it, it won't have the same semantics as the regular\nElixir AST due to the `:unescape` and `:literal_encoder` options. However,\nthose options are useful if you're doing source code manipulation, where it's\nimportant to preserve user choices and comments placing.\n\n## Options\n\n  * `:comments` - the list of comments associated with the quoted expression.\n    Defaults to `[]`. It is recommended that both `:token_metadata` and\n    `:literal_encoder` options are given to `string_to_quoted_with_comments/2`\n    in order to get proper placement for comments\n\n  * `:escape` - when `true`, escaped sequences like `\\n` will be escaped into\n    `\\\\n`. If the `:unescape` option was set to `false` when using\n    `string_to_quoted/2`, setting this option to `false` will prevent it from\n    escaping the sequences twice. Defaults to `true`.\n\n  * `:locals_without_parens` - a keyword list of name and arity\n    pairs that should be kept without parens whenever possible.\n    The arity may be the atom `:*`, which implies all arities of\n    that name. The formatter already includes a list of functions\n    and this option augments this list.\n\n  * `:syntax_colors` - a keyword list of colors the output is colorized.\n    See `Inspect.Opts` for more information.\n","title":"Code.quoted_to_algebra/2","type":"function"},{"doc":"Requires the given file . Accepts relative_to as an argument to tell where the file is located. If the file was already required, require_file/2 doesn't do anything and returns nil . Note that if require_file/2 is invoked by different processes concurrently, the first process to invoke require_file/2 acquires a lock and the remaining ones will block until the file is available. This means that if require_file/2 is called more than once with a given file, that file will be compiled only once. The first process to call require_file/2 will get the list of loaded modules, others will get nil . The list of required files is managed per Erlang VM node. See compile_file/2 if you would like to compile a file without tracking its filenames. Finally, if you would like to get the result of evaluating a file rather than the modules defined in it, see eval_file/2 . Examples If the file has not been required, it returns the list of modules: modules = Code . require_file ( &quot;eex_test.exs&quot; , &quot;../eex/test&quot; ) List . first ( modules ) #=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;} If the file has been required, it returns nil : Code . require_file ( &quot;eex_test.exs&quot; , &quot;../eex/test&quot; ) #=&gt; nil","ref":"Code.html#require_file/2","source_doc":"Requires the given `file`.\n\nAccepts `relative_to` as an argument to tell where the file is located.\nIf the file was already required, `require_file/2` doesn't do anything and\nreturns `nil`.\n\nNote that if `require_file/2` is invoked by different processes concurrently,\nthe first process to invoke `require_file/2` acquires a lock and the remaining\nones will block until the file is available. This means that if `require_file/2`\nis called more than once with a given file, that file will be compiled only once.\nThe first process to call `require_file/2` will get the list of loaded modules,\nothers will get `nil`. The list of required files is managed per Erlang VM node.\n\nSee `compile_file/2` if you would like to compile a file without tracking its\nfilenames. Finally, if you would like to get the result of evaluating a file rather\nthan the modules defined in it, see `eval_file/2`.\n\n## Examples\n\nIf the file has not been required, it returns the list of modules:\n\n    modules = Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    List.first(modules)\n    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n\nIf the file has been required, it returns `nil`:\n\n    Code.require_file(\"eex_test.exs\", \"../eex/test\")\n    #=> nil\n\n","title":"Code.require_file/2","type":"function"},{"doc":"Lists all required files. Examples Code . require_file ( &quot;../eex/test/eex_test.exs&quot; ) List . first ( Code . required_files ( ) ) =~ &quot;eex_test.exs&quot; #=&gt; true","ref":"Code.html#required_files/0","source_doc":"Lists all required files.\n\n## Examples\n\n    Code.require_file(\"../eex/test/eex_test.exs\")\n    List.first(Code.required_files()) =~ \"eex_test.exs\"\n    #=> true\n\n","title":"Code.required_files/0","type":"function"},{"doc":"Converts the given string to its quoted form. Returns {:ok, quoted_form} if it succeeds, {:error, {meta, message_info, token}} otherwise. Options :file - the filename to be reported in case of parsing errors. Defaults to &quot;nofile&quot; . :line - the starting line of the string being parsed. Defaults to 1. :column - (since v1.11.0) the starting column of the string being parsed. Defaults to 1. :columns - when true , attach a :column key to the quoted metadata. Defaults to false . :unescape (since v1.10.0) - when false , preserves escaped sequences. For example, &quot;null byte\\\\t\\\\x00&quot; will be kept as is instead of being converted to a bitstring literal. Note if you set this option to false, the resulting AST is no longer valid, but it can be useful to analyze/transform source code, typically in in combination with quoted_to_algebra/2 . Defaults to true . :existing_atoms_only - when true , raises an error when non-existing atoms are found by the tokenizer. Defaults to false . :token_metadata (since v1.10.0) - when true , includes token-related metadata in the expression AST, such as metadata for do and end tokens, for closing tokens, end of expressions, as well as delimiters for sigils. See Macro.metadata/0 . Defaults to false . :literal_encoder (since v1.10.0) - how to encode literals in the AST. It must be a function that receives two arguments, the literal and its metadata, and it must return {:ok, ast :: Macro.t} or {:error, reason :: binary} . If you return anything than the literal itself as the term , then the AST is no longer valid. This option may still useful for textual analysis of the source code. :static_atoms_encoder - the static atom encoder function, see &quot;The :static_atoms_encoder function&quot; section below. Note this option overrides the :existing_atoms_only behaviour for static atoms but :existing_atoms_only is still used for dynamic atoms, such as atoms with interpolations. :warn_on_unnecessary_quotes - when false , does not warn when atoms, keywords or calls have unnecessary quotes on them. Defaults to true . Macro.to_string/2 The opposite of converting a string to its quoted form is Macro.to_string/2 , which converts a quoted form to a string/binary representation. The :static_atoms_encoder function When static_atoms_encoder: &amp;my_encoder/2 is passed as an argument, my_encoder/2 is called every time the tokenizer needs to create a &quot;static&quot; atom. Static atoms are atoms in the AST that function as aliases, remote calls, local calls, variable names, regular atoms and keyword lists. The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return {:ok, token :: term} | {:error, reason :: binary} . The encoder function is supposed to create an atom from the given string. To produce a valid AST, it is required to return {:ok, term} , where term is an atom. It is possible to return something other than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table. The atom encoder is not called for all atoms that are present in the AST. It won't be invoked for the following atoms: operators ( :+ , :- , and so on) syntax keywords ( fn , do , else , and so on) atoms containing interpolation ( :&quot;\#{1 + 1} is two&quot; ), as these atoms are constructed at runtime.","ref":"Code.html#string_to_quoted/2","source_doc":"Converts the given string to its quoted form.\n\nReturns `{:ok, quoted_form}` if it succeeds,\n`{:error, {meta, message_info, token}}` otherwise.\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - (since v1.11.0) the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:unescape` (since v1.10.0) - when `false`, preserves escaped sequences.\n    For example, `\"null byte\\\\t\\\\x00\"` will be kept as is instead of being\n    converted to a bitstring literal. Note if you set this option to false, the\n    resulting AST is no longer valid, but it can be useful to analyze/transform\n    source code, typically in in combination with `quoted_to_algebra/2`.\n    Defaults to `true`.\n\n  * `:existing_atoms_only` - when `true`, raises an error\n    when non-existing atoms are found by the tokenizer.\n    Defaults to `false`.\n\n  * `:token_metadata` (since v1.10.0) - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` (since v1.10.0) - how to encode literals in the AST.\n    It must be a function that receives two arguments, the literal and its\n    metadata, and it must return `{:ok, ast :: Macro.t}` or\n    `{:error, reason :: binary}`. If you return anything than the literal\n    itself as the `term`, then the AST is no longer valid. This option\n    may still useful for textual analysis of the source code.\n\n  * `:static_atoms_encoder` - the static atom encoder function, see\n    \"The `:static_atoms_encoder` function\" section below. Note this\n    option overrides the `:existing_atoms_only` behaviour for static\n    atoms but `:existing_atoms_only` is still used for dynamic atoms,\n    such as atoms with interpolations.\n\n  * `:warn_on_unnecessary_quotes` - when `false`, does not warn\n    when atoms, keywords or calls have unnecessary quotes on\n    them. Defaults to `true`.\n\n## `Macro.to_string/2`\n\nThe opposite of converting a string to its quoted form is\n`Macro.to_string/2`, which converts a quoted form to a string/binary\nrepresentation.\n\n## The `:static_atoms_encoder` function\n\nWhen `static_atoms_encoder: &my_encoder/2` is passed as an argument,\n`my_encoder/2` is called every time the tokenizer needs to create a\n\"static\" atom. Static atoms are atoms in the AST that function as\naliases, remote calls, local calls, variable names, regular atoms\nand keyword lists.\n\nThe encoder function will receive the atom name (as a binary) and a\nkeyword list with the current file, line and column. It must return\n`{:ok, token :: term} | {:error, reason :: binary}`.\n\nThe encoder function is supposed to create an atom from the given\nstring. To produce a valid AST, it is required to return `{:ok, term}`,\nwhere `term` is an atom. It is possible to return something other than an atom,\nhowever, in that case the AST is no longer \"valid\" in that it cannot\nbe used to compile or evaluate Elixir code. A use case for this is\nif you want to use the Elixir parser in a user-facing situation, but\nyou don't want to exhaust the atom table.\n\nThe atom encoder is not called for *all* atoms that are present in\nthe AST. It won't be invoked for the following atoms:\n\n  * operators (`:+`, `:-`, and so on)\n\n  * syntax keywords (`fn`, `do`, `else`, and so on)\n\n  * atoms containing interpolation (`:\"\#{1 + 1} is two\"`), as these\n    atoms are constructed at runtime.\n\n","title":"Code.string_to_quoted/2","type":"function"},{"doc":"Converts the given string to its quoted form. It returns the AST if it succeeds, raises an exception otherwise. The exception is a TokenMissingError in case a token is missing (usually because the expression is incomplete), SyntaxError otherwise. Check string_to_quoted/2 for options information.","ref":"Code.html#string_to_quoted!/2","source_doc":"Converts the given string to its quoted form.\n\nIt returns the AST if it succeeds,\nraises an exception otherwise. The exception is a `TokenMissingError`\nin case a token is missing (usually because the expression is incomplete),\n`SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.\n","title":"Code.string_to_quoted!/2","type":"function"},{"doc":"Converts the given string to its quoted form and a list of comments. This function is useful when performing textual changes to the source code, while preserving information like comments and literals position. Returns {:ok, quoted_form, comments} if it succeeds, {:error, {line, error, token}} otherwise. Comments are maps with the following fields: :line - The line number the source code :text - The full text of the comment, including the leading # :previous_eol_count - How many end of lines there are between the comment and the previous AST node or comment :next_eol_count - How many end of lines there are between the comment and the next AST node or comment Check string_to_quoted/2 for options information. Examples iex&gt; Code . string_to_quoted_with_comments ( &quot;&quot;&quot; ...&gt; :foo ...&gt; ...&gt; # Hello, world! ...&gt; ...&gt; ...&gt; # Some more comments! ...&gt; &quot;&quot;&quot; ) { :ok , :foo , [ %{ line : 3 , column : 1 , previous_eol_count : 2 , next_eol_count : 3 , text : &quot;# Hello, world!&quot; } , %{ line : 6 , column : 1 , previous_eol_count : 3 , next_eol_count : 1 , text : &quot;# Some more comments!&quot; } , ] } iex&gt; Code . string_to_quoted_with_comments ( &quot;:foo # :bar&quot; ) { :ok , :foo , [ %{ line : 1 , column : 6 , previous_eol_count : 0 , next_eol_count : 0 , text : &quot;# :bar&quot; } ] }","ref":"Code.html#string_to_quoted_with_comments/2","source_doc":"Converts the given string to its quoted form and a list of comments.\n\nThis function is useful when performing textual changes to the source code,\nwhile preserving information like comments and literals position.\n\nReturns `{:ok, quoted_form, comments}` if it succeeds,\n`{:error, {line, error, token}}` otherwise.\n\nComments are maps with the following fields:\n\n  * `:line` - The line number the source code\n\n  * `:text` - The full text of the comment, including the leading `#`\n\n  * `:previous_eol_count` - How many end of lines there are between the comment and the previous AST node or comment\n\n  * `:next_eol_count` - How many end of lines there are between the comment and the next AST node or comment\n\nCheck `string_to_quoted/2` for options information.\n\n## Examples\n\n    iex> Code.string_to_quoted_with_comments(\"\"\"\n    ...> :foo\n    ...>\n    ...> # Hello, world!\n    ...>\n    ...>\n    ...> # Some more comments!\n    ...> \"\"\")\n    {:ok, :foo, [\n      %{line: 3, column: 1, previous_eol_count: 2, next_eol_count: 3, text: \"# Hello, world!\"},\n      %{line: 6, column: 1, previous_eol_count: 3, next_eol_count: 1, text: \"# Some more comments!\"},\n    ]}\n\n    iex> Code.string_to_quoted_with_comments(\":foo # :bar\")\n    {:ok, :foo, [\n      %{line: 1, column: 6, previous_eol_count: 0, next_eol_count: 0, text: \"# :bar\"}\n    ]}\n\n","title":"Code.string_to_quoted_with_comments/2","type":"function"},{"doc":"Converts the given string to its quoted form and a list of comments. Returns the AST and a list of comments if it succeeds, raises an exception otherwise. The exception is a TokenMissingError in case a token is missing (usually because the expression is incomplete), SyntaxError otherwise. Check string_to_quoted/2 for options information.","ref":"Code.html#string_to_quoted_with_comments!/2","source_doc":"Converts the given string to its quoted form and a list of comments.\n\nReturns the AST and a list of comments if it succeeds, raises an exception\notherwise. The exception is a `TokenMissingError` in case a token is missing\n(usually because the expression is incomplete), `SyntaxError` otherwise.\n\nCheck `string_to_quoted/2` for options information.\n","title":"Code.string_to_quoted_with_comments!/2","type":"function"},{"doc":"Removes files from the required files list. The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again. The list of files is managed per Erlang VM node. Examples # Require EEx test code Code . require_file ( &quot;../eex/test/eex_test.exs&quot; ) # Now unrequire all files Code . unrequire_files ( Code . required_files ( ) ) # Note that modules are still available function_exported? ( EExTest.Compiled , :before_compile , 0 ) #=&gt; true","ref":"Code.html#unrequire_files/1","source_doc":"Removes files from the required files list.\n\nThe modules defined in the file are not removed;\ncalling this function only removes them from the list,\nallowing them to be required again.\n\nThe list of files is managed per Erlang VM node.\n\n## Examples\n\n    # Require EEx test code\n    Code.require_file(\"../eex/test/eex_test.exs\")\n\n    # Now unrequire all files\n    Code.unrequire_files(Code.required_files())\n\n    # Note that modules are still available\n    function_exported?(EExTest.Compiled, :before_compile, 0)\n    #=> true\n\n","title":"Code.unrequire_files/1","type":"function"},{"doc":"A list with all variables and their values. The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.","ref":"Code.html#t:binding/0","source_doc":"A list with all variables and their values.\n\nThe binding keys are usually atoms, but they may be a tuple for variables\ndefined in a different context.\n","title":"Code.binding/0","type":"type"},{"doc":"This module provides conveniences for analyzing fragments of textual code and extract available information whenever possible. Most of the functions in this module provide a best-effort and may not be accurate under all circumstances. Read each documentation for more information. This module should be considered experimental.","ref":"Code.Fragment.html","source_doc":"This module provides conveniences for analyzing fragments of\ntextual code and extract available information whenever possible.\n\nMost of the functions in this module provide a best-effort\nand may not be accurate under all circumstances. Read each\ndocumentation for more information.\n\nThis module should be considered experimental.\n","title":"Code.Fragment","type":"module"},{"doc":"Receives a string and returns a quoted expression with a cursor at the nearest argument position. This function receives a string with an Elixir code fragment, representing a cursor position, and converts such string to AST with the inclusion of special __cursor__() node based on the position of the cursor with a container. A container is any Elixir expression starting with ( , { , and [ . This includes function calls, tuples, lists, maps, and so on. For example, take this code, which would be given as input: max ( some_value , This function will return the AST equivalent to: max ( some_value , __cursor__ ( ) ) In other words, this function is capable of closing any open brackets and insert the cursor position. Any content at the cursor position that is after a comma or an opening bracket is discarded. For example, if this is given as input: max ( some_value , another_val It will return the same AST: max ( some_value , __cursor__ ( ) ) Similarly, if only this is given: max ( some_va Then it returns: max ( __cursor__ ( ) ) Calls without parenthesis are also supported, as we assume the brackets are implicit. Operators and anonymous functions are not containers, and therefore will be discarded. The following will all return the same AST: max ( some_value , max ( some_value , fn x -&gt; x end max ( some_value , 1 + another_val max ( some_value , 1 |&gt; some_fun ( ) |&gt; another_fun On the other hand, tuples, lists, maps, and binaries all retain the cursor position: max ( some_value , [ 1 , 2 , Returns the following AST: max ( some_value , [ 1 , 2 , __cursor__ ( ) ] ) Keyword lists (and do-end blocks) are also retained. The following: if ( some_value , do : if ( some_value , do : :token if ( some_value , do : 1 + val all return: if ( some_value , do : __cursor__ ( ) ) The AST returned by this function is not safe to evaluate but it can be analyzed and expanded. Examples Function call: iex&gt; Code.Fragment . container_cursor_to_quoted ( &quot;max(some_value, &quot; ) { :ok , { :max , [ line : 1 ] , [ { :some_value , [ line : 1 ] , nil } , { :__cursor__ , [ line : 1 ] , [ ] } ] } } Containers (for example, a list): iex&gt; Code.Fragment . container_cursor_to_quoted ( &quot;[some, value&quot; ) { :ok , [ { :some , [ line : 1 ] , nil } , { :__cursor__ , [ line : 1 ] , [ ] } ] } For binaries, the :: is exclusively kept as an operator: iex&gt; Code.Fragment . container_cursor_to_quoted ( &quot;&lt;&lt;some::integer&quot; ) { :ok , { :&lt;&lt;&gt;&gt; , [ line : 1 ] , [ { :&quot;::&quot; , [ line : 1 ] , [ { :some , [ line : 1 ] , nil } , { :__cursor__ , [ line : 1 ] , [ ] } ] } ] } } Options :file - the filename to be reported in case of parsing errors. Defaults to &quot;nofile&quot; . :line - the starting line of the string being parsed. Defaults to 1. :column - the starting column of the string being parsed. Defaults to 1. :columns - when true , attach a :column key to the quoted metadata. Defaults to false . :token_metadata - when true , includes token-related metadata in the expression AST, such as metadata for do and end tokens, for closing tokens, end of expressions, as well as delimiters for sigils. See Macro.metadata/0 . Defaults to false . :literal_encoder - a function to encode literals in the AST. See the documentation for Code.string_to_quoted/2 for more information.","ref":"Code.Fragment.html#container_cursor_to_quoted/2","source_doc":"Receives a string and returns a quoted expression\nwith a cursor at the nearest argument position.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and converts such string to\nAST with the inclusion of special `__cursor__()` node based\non the position of the cursor with a container.\n\nA container is any Elixir expression starting with `(`,\n`{`, and `[`. This includes function calls, tuples, lists,\nmaps, and so on. For example, take this code, which would\nbe given as input:\n\n    max(some_value,\n\nThis function will return the AST equivalent to:\n\n    max(some_value, __cursor__())\n\nIn other words, this function is capable of closing any open\nbrackets and insert the cursor position. Any content at the\ncursor position that is after a comma or an opening bracket\nis discarded. For example, if this is given as input:\n\n    max(some_value, another_val\n\nIt will return the same AST:\n\n    max(some_value, __cursor__())\n\nSimilarly, if only this is given:\n\n    max(some_va\n\nThen it returns:\n\n    max(__cursor__())\n\nCalls without parenthesis are also supported, as we assume the\nbrackets are implicit.\n\nOperators and anonymous functions are not containers, and therefore\nwill be discarded. The following will all return the same AST:\n\n    max(some_value,\n    max(some_value, fn x -> x end\n    max(some_value, 1 + another_val\n    max(some_value, 1 |> some_fun() |> another_fun\n\nOn the other hand, tuples, lists, maps, and binaries all retain the\ncursor position:\n\n    max(some_value, [1, 2,\n\nReturns the following AST:\n\n    max(some_value, [1, 2, __cursor__()])\n\nKeyword lists (and do-end blocks) are also retained. The following:\n\n    if(some_value, do:\n    if(some_value, do: :token\n    if(some_value, do: 1 + val\n\nall return:\n\n    if(some_value, do: __cursor__())\n\nThe AST returned by this function is not safe to evaluate but\nit can be analyzed and expanded.\n\n## Examples\n\nFunction call:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"max(some_value, \")\n    {:ok, {:max, [line: 1], [{:some_value, [line: 1], nil}, {:__cursor__, [line: 1], []}]}}\n\nContainers (for example, a list):\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"[some, value\")\n    {:ok, [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}\n\nFor binaries, the `::` is exclusively kept as an operator:\n\n    iex> Code.Fragment.container_cursor_to_quoted(\"<<some::integer\")\n    {:ok, {:<<>>, [line: 1], [{:\"::\", [line: 1], [{:some, [line: 1], nil}, {:__cursor__, [line: 1], []}]}]}}\n\n## Options\n\n  * `:file` - the filename to be reported in case of parsing errors.\n    Defaults to `\"nofile\"`.\n\n  * `:line` - the starting line of the string being parsed.\n    Defaults to 1.\n\n  * `:column` - the starting column of the string being parsed.\n    Defaults to 1.\n\n  * `:columns` - when `true`, attach a `:column` key to the quoted\n    metadata. Defaults to `false`.\n\n  * `:token_metadata` - when `true`, includes token-related\n    metadata in the expression AST, such as metadata for `do` and `end`\n    tokens, for closing tokens, end of expressions, as well as delimiters\n    for sigils. See `t:Macro.metadata/0`. Defaults to `false`.\n\n  * `:literal_encoder` - a function to encode literals in the AST.\n    See the documentation for `Code.string_to_quoted/2` for more information.\n\n","title":"Code.Fragment.container_cursor_to_quoted/2","type":"function"},{"doc":"Receives a string and returns the cursor context. This function receives a string with an Elixir code fragment, representing a cursor position, and based on the string, it provides contextual information about said position. The return of this function can then be used to provide tips, suggestions, and autocompletion functionality. This function provides a best-effort detection and may not be accurate under all circumstances. See the &quot;Limitations&quot; section below. Consider adding a catch-all clause when handling the return type of this function as new cursor information may be added in future releases. Examples iex&gt; Code.Fragment . cursor_context ( &quot;&quot; ) :expr iex&gt; Code.Fragment . cursor_context ( &quot;hello_wor&quot; ) { :local_or_var , &#39;hello_wor&#39; } Return values {:alias, charlist} - the context is an alias, potentially a nested one, such as Hello.Wor or HelloWor {:alias, inside_alias, charlist} - the context is an alias, potentially a nested one, where inside_alias is an expression {:module_attribute, charlist} or {:local_or_var, charlist} and charlist is a static part Examples are __MODULE__.Submodule or @hello.Submodule {:dot, inside_dot, charlist} - the context is a dot where inside_dot is either a {:var, charlist} , {:alias, charlist} , {:module_attribute, charlist} , {:unquoted_atom, charlist} or a dot itself. If a var is given, this may either be a remote call or a map field access. Examples are Hello.wor , :hello.wor , hello.wor , Hello.nested.wor , hello.nested.wor , and @hello.world . If charlist is empty and inside_dot is an alias, then the autocompletion may either be an alias or a remote call. {:dot_arity, inside_dot, charlist} - the context is a dot arity where inside_dot is either a {:var, charlist} , {:alias, charlist} , {:module_attribute, charlist} , {:unquoted_atom, charlist} or a dot itself. If a var is given, it must be a remote arity. Examples are Hello.world/ , :hello.world/ , hello.world/2 , and @hello.world/2 {:dot_call, inside_dot, charlist} - the context is a dot call. This means parentheses or space have been added after the expression. where inside_dot is either a {:var, charlist} , {:alias, charlist} , {:module_attribute, charlist} , {:unquoted_atom, charlist} or a dot itself. If a var is given, it must be a remote call. Examples are Hello.world( , :hello.world( , Hello.world , hello.world( , hello.world , and @hello.world( :expr - may be any expression. Autocompletion may suggest an alias, local or var {:local_or_var, charlist} - the context is a variable or a local (import or local) call, such as hello_wor {:local_arity, charlist} - the context is a local (import or local) arity, such as hello_world/ {:local_call, charlist} - the context is a local (import or local) call, such as hello_world( and hello_world {:module_attribute, charlist} - the context is a module attribute, such as @hello_wor {:operator, charlist} - the context is an operator, such as + or == . Note textual operators, such as when do not appear as operators but rather as :local_or_var . @ is never an :operator and always a :module_attribute {:operator_arity, charlist} - the context is an operator arity, which is an operator followed by /, such as +/ , not/ or when/ {:operator_call, charlist} - the context is an operator call, which is an operator followed by space, such as left + , not or x when :none - no context possible {:sigil, charlist} - the context is a sigil. It may be either the beginning of a sigil, such as ~ or ~s , or an operator starting with ~ , such as ~&gt; and ~&gt;&gt; {:struct, inside_struct} - the context is a struct, such as % , %UR or %URI . inside_struct can either be a charlist in case of a static alias or an expression {:alias, inside_alias, charlist} , {:module_attribute, charlist} , {:local_or_var, charlist} , {:dot, inside_dot, charlist} {:unquoted_atom, charlist} - the context is an unquoted atom. This can be any atom or an atom representing a module Limitations The current algorithm only considers the last line of the input. This means it will also show suggestions inside strings, heredocs, etc, which is intentional as it helps with doctests, references, and more.","ref":"Code.Fragment.html#cursor_context/2","source_doc":"Receives a string and returns the cursor context.\n\nThis function receives a string with an Elixir code fragment,\nrepresenting a cursor position, and based on the string, it\nprovides contextual information about said position. The\nreturn of this function can then be used to provide tips,\nsuggestions, and autocompletion functionality.\n\nThis function provides a best-effort detection and may not be\naccurate under all circumstances. See the \"Limitations\"\nsection below.\n\nConsider adding a catch-all clause when handling the return\ntype of this function as new cursor information may be added\nin future releases.\n\n## Examples\n\n    iex> Code.Fragment.cursor_context(\"\")\n    :expr\n\n    iex> Code.Fragment.cursor_context(\"hello_wor\")\n    {:local_or_var, 'hello_wor'}\n\n## Return values\n\n  * `{:alias, charlist}` - the context is an alias, potentially\n    a nested one, such as `Hello.Wor` or `HelloWor`\n\n  * `{:alias, inside_alias, charlist}` - the context is an alias, potentially\n    a nested one, where `inside_alias` is an expression `{:module_attribute, charlist}`\n    or `{:local_or_var, charlist}` and `charlist` is a static part\n    Examples are `__MODULE__.Submodule` or `@hello.Submodule`\n\n  * `{:dot, inside_dot, charlist}` - the context is a dot\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, this may either be a remote call or a map\n    field access. Examples are `Hello.wor`, `:hello.wor`, `hello.wor`,\n    `Hello.nested.wor`, `hello.nested.wor`, and `@hello.world`. If `charlist`\n    is empty and `inside_dot` is an alias, then the autocompletion may either\n    be an alias or a remote call.\n\n  * `{:dot_arity, inside_dot, charlist}` - the context is a dot arity\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote arity. Examples are\n    `Hello.world/`, `:hello.world/`, `hello.world/2`, and `@hello.world/2`\n\n  * `{:dot_call, inside_dot, charlist}` - the context is a dot\n    call. This means parentheses or space have been added after the expression.\n    where `inside_dot` is either a `{:var, charlist}`, `{:alias, charlist}`,\n    `{:module_attribute, charlist}`, `{:unquoted_atom, charlist}` or a `dot`\n    itself. If a var is given, it must be a remote call. Examples are\n    `Hello.world(`, `:hello.world(`, `Hello.world `, `hello.world(`, `hello.world `,\n    and `@hello.world(`\n\n  * `:expr` - may be any expression. Autocompletion may suggest an alias,\n    local or var\n\n  * `{:local_or_var, charlist}` - the context is a variable or a local\n    (import or local) call, such as `hello_wor`\n\n  * `{:local_arity, charlist}` - the context is a local (import or local)\n    arity, such as `hello_world/`\n\n  * `{:local_call, charlist}` - the context is a local (import or local)\n    call, such as `hello_world(` and `hello_world `\n\n  * `{:module_attribute, charlist}` - the context is a module attribute,\n    such as `@hello_wor`\n\n  * `{:operator, charlist}` - the context is an operator, such as `+` or\n    `==`. Note textual operators, such as `when` do not appear as operators\n    but rather as `:local_or_var`. `@` is never an `:operator` and always a\n    `:module_attribute`\n\n  * `{:operator_arity, charlist}` - the context is an operator arity, which\n    is an operator followed by /, such as `+/`, `not/` or `when/`\n\n  * `{:operator_call, charlist}` - the context is an operator call, which is\n    an operator followed by space, such as `left + `, `not ` or `x when `\n\n  * `:none` - no context possible\n\n  * `{:sigil, charlist}` - the context is a sigil. It may be either the beginning\n    of a sigil, such as `~` or `~s`, or an operator starting with `~`, such as\n    `~>` and `~>>`\n\n  * `{:struct, inside_struct}` - the context is a struct, such as `%`, `%UR` or `%URI`.\n    `inside_struct` can either be a `charlist` in case of a static alias or an\n    expression `{:alias, inside_alias, charlist}`, `{:module_attribute, charlist}`,\n    `{:local_or_var, charlist}`, `{:dot, inside_dot, charlist}`\n\n  * `{:unquoted_atom, charlist}` - the context is an unquoted atom. This\n    can be any atom or an atom representing a module\n\n## Limitations\n\nThe current algorithm only considers the last line of the input. This means\nit will also show suggestions inside strings, heredocs, etc, which is\nintentional as it helps with doctests, references, and more.\n","title":"Code.Fragment.cursor_context/2","type":"function"},{"doc":"Receives a string and returns the surround context. This function receives a string with an Elixir code fragment and a position . It returns a map containing the beginning and ending of the identifier alongside its context, or :none if there is nothing with a known context. The difference between cursor_context/2 and surround_context/3 is that the former assumes the expression in the code fragment is incomplete. For example, do in cursor_context/2 may be a keyword or a variable or a local call, while surround_context/3 assumes the expression in the code fragment is complete, therefore do would always be a keyword. The position contains both the line and column , both starting with the index of 1. The column must precede the surrounding expression. For example, the expression foo , will return something for the columns 1, 2, and 3, but not 4: foo ^ column 1 foo ^ column 2 foo ^ column 3 foo ^ column 4 The returned map contains the column the expression starts and the first column after the expression ends. Similar to cursor_context/2 , this function also provides a best-effort detection and may not be accurate under all circumstances. See the &quot;Return values&quot; and &quot;Limitations&quot; section under cursor_context/2 for more information. Examples iex&gt; Code.Fragment . surround_context ( &quot;foo&quot; , { 1 , 1 } ) %{ begin : { 1 , 1 } , context : { :local_or_var , &#39;foo&#39; } , end : { 1 , 4 } } Differences to cursor_context/2 Because surround_context/3 deals with complete code, it has some difference to cursor_context/2 : dot_call / dot_arity and operator_call / operator_arity are collapsed into dot and operator contexts respectively as there aren't any meaningful distinctions between them On the other hand, this function still makes a distinction between local_call / local_arity and local_or_var , since the latter can be a local or variable @ when not followed by any identifier is returned as {:operator, '@'} (in contrast to {:module_attribute, ''} in cursor_context/2 This function never returns empty sigils {:sigil, ''} or empty structs {:struct, ''} as context This function returns keywords as {:keyword, 'do'} This function never returns :expr","ref":"Code.Fragment.html#surround_context/3","source_doc":"Receives a string and returns the surround context.\n\nThis function receives a string with an Elixir code fragment\nand a `position`. It returns a map containing the beginning\nand ending of the identifier alongside its context, or `:none`\nif there is nothing with a known context.\n\nThe difference between `cursor_context/2` and `surround_context/3`\nis that the former assumes the expression in the code fragment\nis incomplete. For example, `do` in `cursor_context/2` may be\na keyword or a variable or a local call, while `surround_context/3`\nassumes the expression in the code fragment is complete, therefore\n`do` would always be a keyword.\n\nThe `position` contains both the `line` and `column`, both starting\nwith the index of 1. The column must precede the surrounding expression.\nFor example, the expression `foo`, will return something for the columns\n1, 2, and 3, but not 4:\n\n    foo\n    ^ column 1\n\n    foo\n     ^ column 2\n\n    foo\n      ^ column 3\n\n    foo\n       ^ column 4\n\nThe returned map contains the column the expression starts and the\nfirst column after the expression ends.\n\nSimilar to `cursor_context/2`, this function also provides a best-effort\ndetection and may not be accurate under all circumstances. See the\n\"Return values\" and \"Limitations\" section under `cursor_context/2` for\nmore information.\n\n## Examples\n\n    iex> Code.Fragment.surround_context(\"foo\", {1, 1})\n    %{begin: {1, 1}, context: {:local_or_var, 'foo'}, end: {1, 4}}\n\n## Differences to `cursor_context/2`\n\nBecause `surround_context/3` deals with complete code, it has some\ndifference to `cursor_context/2`:\n\n  * `dot_call`/`dot_arity` and `operator_call`/`operator_arity`\n    are collapsed into `dot` and `operator` contexts respectively\n    as there aren't any meaningful distinctions between them\n\n  * On the other hand, this function still makes a distinction between\n    `local_call`/`local_arity` and `local_or_var`, since the latter can\n    be a local or variable\n\n  * `@` when not followed by any identifier is returned as `{:operator, '@'}`\n    (in contrast to `{:module_attribute, ''}` in `cursor_context/2`\n\n  * This function never returns empty sigils `{:sigil, ''}` or empty structs\n    `{:struct, ''}` as context\n\n  * This function returns keywords as `{:keyword, 'do'}`\n\n  * This function never returns `:expr`\n\n","title":"Code.Fragment.surround_context/3","type":"function"},{"doc":"","ref":"Code.Fragment.html#t:position/0","source_doc":false,"title":"Code.Fragment.position/0","type":"type"},{"doc":"A module responsible for compiling and requiring files in parallel.","ref":"Kernel.ParallelCompiler.html","source_doc":"A module responsible for compiling and requiring files in parallel.\n","title":"Kernel.ParallelCompiler","type":"module"},{"doc":"Starts a task for parallel compilation. If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments. See Task.async/1 for more information. The task spawned must be always awaited on by calling Task.await/1","ref":"Kernel.ParallelCompiler.html#async/1","source_doc":"Starts a task for parallel compilation.\n\nIf you have a file that needs to compile other modules in parallel,\nthe spawned processes need to be aware of the compiler environment.\nThis function allows a developer to create a task that is aware of\nthose environments.\n\nSee `Task.async/1` for more information. The task spawned must be\nalways awaited on by calling `Task.await/1`\n","title":"Kernel.ParallelCompiler.async/1","type":"function"},{"doc":"Compiles the given files. Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved. It returns {:ok, modules, warnings} or {:error, errors, warnings} by default but we recommend using return_maps: true so it returns diagnostics as maps as well as a map of compilation information. The map has the shape of: %{ runtime_warnings : [ warning ] , compile_warnings : [ warning ] } Options :each_file - for each file compiled, invokes the callback passing the file :each_long_compilation - for each file that takes more than a given timeout (see the :long_compilation_threshold option) to compile, invoke this callback passing the file as its argument :each_module - for each module compiled, invokes the callback passing the file, module and the module bytecode :each_cycle - after the given files are compiled, invokes this function that should return the following values: {:compile, modules, warnings} - to continue compilation with a list of further modules to compile {:runtime, modules, warnings} - to stop compilation and verify the list of modules because dependent modules have changed :long_compilation_threshold - the timeout (in seconds) to check for modules taking too long to compile. For each file that exceeds the threshold, the :each_long_compilation callback is invoked. From Elixir v1.11, only the time spent compiling the actual module is taken into account by the threshold, the time spent waiting is not considered. Defaults to 10 seconds. :profile - if set to :time measure the compilation time of each compilation cycle and group pass checker :dest - the destination directory for the BEAM files. When using compile/2 , this information is only used to properly annotate the BEAM files before they are loaded into memory. If you want a file to actually be written to dest , use compile_to_path/3 instead. :beam_timestamp - the modification timestamp to give all BEAM files :return_maps (since v1.15.0) - returns maps with information instead of a list of warnings and returns diagnostics as maps instead of tuples","ref":"Kernel.ParallelCompiler.html#compile/2","source_doc":"Compiles the given files.\n\nThose files are compiled in parallel and can automatically\ndetect dependencies between them. Once a dependency is found,\nthe current file stops being compiled until the dependency is\nresolved.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`\nby default but we recommend using `return_maps: true` so it returns\ndiagnostics as maps as well as a map of compilation information.\nThe map has the shape of:\n\n    %{\n      runtime_warnings: [warning],\n      compile_warnings: [warning]\n    }\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_long_compilation` - for each file that takes more than a given\n    timeout (see the `:long_compilation_threshold` option) to compile, invoke\n    this callback passing the file as its argument\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n  * `:each_cycle` - after the given files are compiled, invokes this function\n    that should return the following values:\n    * `{:compile, modules, warnings}` - to continue compilation with a list of\n      further modules to compile\n    * `{:runtime, modules, warnings}` - to stop compilation and verify the list\n      of modules because dependent modules have changed\n\n  * `:long_compilation_threshold` - the timeout (in seconds) to check for modules\n    taking too long to compile. For each file that exceeds the threshold, the\n    `:each_long_compilation` callback is invoked. From Elixir v1.11, only the time\n    spent compiling the actual module is taken into account by the threshold, the\n    time spent waiting is not considered. Defaults to `10` seconds.\n\n  * `:profile` - if set to `:time` measure the compilation time of each compilation cycle\n     and group pass checker\n\n  * `:dest` - the destination directory for the BEAM files. When using `compile/2`,\n    this information is only used to properly annotate the BEAM files before\n    they are loaded into memory. If you want a file to actually be written to\n    `dest`, use `compile_to_path/3` instead.\n\n  * `:beam_timestamp` - the modification timestamp to give all BEAM files\n\n  * `:return_maps` (since v1.15.0) - returns maps with information instead of\n    a list of warnings and returns diagnostics as maps instead of tuples\n\n","title":"Kernel.ParallelCompiler.compile/2","type":"function"},{"doc":"Compiles the given files and writes resulting BEAM files into path. See compile/2 for more information.","ref":"Kernel.ParallelCompiler.html#compile_to_path/3","source_doc":"Compiles the given files and writes resulting BEAM files into path.\n\nSee `compile/2` for more information.\n","title":"Kernel.ParallelCompiler.compile_to_path/3","type":"function"},{"doc":"Prints a diagnostic returned by the compiler into stderr.","ref":"Kernel.ParallelCompiler.html#print_diagnostic/1","source_doc":"Prints a diagnostic returned by the compiler into stderr.\n","title":"Kernel.ParallelCompiler.print_diagnostic/1","type":"function"},{"doc":"Requires the given files in parallel. Opposite to compile, dependencies are not attempted to be automatically solved between files. It returns {:ok, modules, warnings} or {:error, errors, warnings} by default but we recommend using return_maps: true so it returns diagnostics as maps as well as a map of compilation information. The map has the shape of: %{ runtime_warnings : [ warning ] , compile_warnings : [ warning ] } Options :each_file - for each file compiled, invokes the callback passing the file :each_module - for each module compiled, invokes the callback passing the file, module and the module bytecode","ref":"Kernel.ParallelCompiler.html#require/2","source_doc":"Requires the given files in parallel.\n\nOpposite to compile, dependencies are not attempted to be\nautomatically solved between files.\n\nIt returns `{:ok, modules, warnings}` or `{:error, errors, warnings}`\nby default but we recommend using `return_maps: true` so it returns\ndiagnostics as maps as well as a map of compilation information.\nThe map has the shape of:\n\n    %{\n      runtime_warnings: [warning],\n      compile_warnings: [warning]\n    }\n\n## Options\n\n  * `:each_file` - for each file compiled, invokes the callback passing the\n    file\n\n  * `:each_module` - for each module compiled, invokes the callback passing\n    the file, module and the module bytecode\n\n","title":"Kernel.ParallelCompiler.require/2","type":"function"},{"doc":"","ref":"Kernel.ParallelCompiler.html#t:diagnostic/1","source_doc":false,"title":"Kernel.ParallelCompiler.diagnostic/1","type":"type"},{"doc":"","ref":"Kernel.ParallelCompiler.html#t:error/0","source_doc":false,"title":"Kernel.ParallelCompiler.error/0","type":"type"},{"doc":"","ref":"Kernel.ParallelCompiler.html#t:info/0","source_doc":false,"title":"Kernel.ParallelCompiler.info/0","type":"type"},{"doc":"The line. 0 indicates no line.","ref":"Kernel.ParallelCompiler.html#t:line/0","source_doc":"The line. 0 indicates no line.","title":"Kernel.ParallelCompiler.line/0","type":"type"},{"doc":"","ref":"Kernel.ParallelCompiler.html#t:position/0","source_doc":false,"title":"Kernel.ParallelCompiler.position/0","type":"type"},{"doc":"","ref":"Kernel.ParallelCompiler.html#t:warning/0","source_doc":false,"title":"Kernel.ParallelCompiler.warning/0","type":"type"},{"doc":"Functions for manipulating AST and implementing macros. Macros are compile-time constructs that receive Elixir's AST as input and return Elixir's AST as output. Many of the functions in this module exist precisely to work with Elixir AST, to traverse, query, and transform it. Let's see a simple example that shows the difference between functions and macros: defmodule Example do defmacro macro_inspect ( value ) do IO . inspect ( value ) value end def fun_inspect ( value ) do IO . inspect ( value ) value end end Now let's give it a try: import Example macro_inspect ( 1 ) #=&gt; 1 #=&gt; 1 fun_inspect ( 1 ) #=&gt; 1 #=&gt; 1 So far they behave the same, as we are passing an integer as argument. But let's see what happens when we pass an expression: macro_inspect ( 1 + 2 ) #=&gt; {:+, [line: 3], [1, 2]} #=&gt; 3 fun_inspect ( 1 + 2 ) #=&gt; 3 #=&gt; 3 The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See input/0 and output/0 for more information. To learn more about Elixir's AST and how to build them programmatically, see quote/2 . Evaluating code The functions in this module do not evaluate code. In fact, evaluating code from macros is often an anti-pattern. For code evaluation, see the Code module. Custom Sigils Macros are also commonly used to implement custom sigils. Sigils start with ~ and are followed by one lowercase letter or by one or more uppercase letters, and then a separator (see the Syntax Reference ). One example is ~D[2020-10-13] to define a date. To create a custom sigil, define a macro with the name sigil_{identifier} that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as sigil_x ) then the string argument will allow interpolation. If the sigil is one or more upper case letters (such as sigil_X and sigil_EXAMPLE ) then the string will not be interpolated. Valid modifiers are ASCII letters and digits. Any other character will cause a syntax error. Single-letter sigils are typically reserved to the language. Multi-letter sigils are uppercased and extensively used by the community to embed alternative markups and data-types within Elixir source code. The module containing the custom sigil must be imported before the sigil syntax can be used. Examples As an example, let's define a sigil ~x and sigil ~X which return its contents as a string. However, if the r modifier is given, it reverses the string instead: defmodule MySigils do defmacro sigil_x ( term , [ ?r ] ) do quote do unquote ( term ) |&gt; String . reverse ( ) end end defmacro sigil_x ( term , _modifiers ) do term end defmacro sigil_X ( term , [ ?r ] ) do quote do unquote ( term ) |&gt; String . reverse ( ) end end defmacro sigil_X ( term , _modifiers ) do term end end import MySigils ~x(with \#{ &quot;inter&quot; &lt;&gt; &quot;polation&quot; } ) #=&gt; &quot;with interpolation&quot; ~x(with \#{ &quot;inter&quot; &lt;&gt; &quot;polation&quot; } )r #=&gt; &quot;noitalopretni htiw&quot; ~X(without \#{&quot;interpolation&quot;}) #=&gt; &quot;without \\\#{&quot;interpolation&quot;}&quot; ~X(without \#{&quot;interpolation&quot;})r #=&gt; &quot;}\\&quot;noitalopretni\\&quot;{# tuohtiw&quot;","ref":"Macro.html","source_doc":"Functions for manipulating AST and implementing macros.\n\nMacros are compile-time constructs that receive Elixir's AST as input\nand return Elixir's AST as output.\n\nMany of the functions in this module exist precisely to work with Elixir\nAST, to traverse, query, and transform it.\n\nLet's see a simple example that shows the difference between functions\nand macros:\n\n    defmodule Example do\n      defmacro macro_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n\n      def fun_inspect(value) do\n        IO.inspect(value)\n        value\n      end\n    end\n\nNow let's give it a try:\n\n    import Example\n\n    macro_inspect(1)\n    #=> 1\n    #=> 1\n\n    fun_inspect(1)\n    #=> 1\n    #=> 1\n\nSo far they behave the same, as we are passing an integer as argument.\nBut let's see what happens when we pass an expression:\n\n    macro_inspect(1 + 2)\n    #=> {:+, [line: 3], [1, 2]}\n    #=> 3\n\n    fun_inspect(1 + 2)\n    #=> 3\n    #=> 3\n\nThe macro receives the representation of the code given as argument,\nwhile a function receives the result of the code given as argument.\nA macro must return a superset of the code representation. See\n`t:input/0` and `t:output/0` for more information.\n\nTo learn more about Elixir's AST and how to build them programmatically,\nsee `quote/2`.\n\n> #### Evaluating code {: .tip}\n>\n> The functions in this module do not evaluate code. In fact,\n> evaluating code from macros is often an anti-pattern. For code\n> evaluation, see the `Code` module.\n\n## Custom Sigils\n\nMacros are also commonly used to implement custom sigils.\n\nSigils start with `~` and are followed by one lowercase letter or by one\nor more uppercase letters, and then a separator\n(see the [Syntax Reference](syntax-reference.md)). One example is\n`~D[2020-10-13]` to define a date.\n\nTo create a custom sigil, define a macro with the name `sigil_{identifier}`\nthat takes two arguments. The first argument will be the string, the second\nwill be a charlist containing any modifiers. If the sigil is lower case\n(such as `sigil_x`) then the string argument will allow interpolation.\nIf the sigil is one or more upper case letters (such as `sigil_X` and\n`sigil_EXAMPLE`) then the string will not be interpolated.\n\nValid modifiers are ASCII letters and digits. Any other character will\ncause a syntax error.\n\nSingle-letter sigils are typically reserved to the language. Multi-letter\nsigils are uppercased and extensively used by the community to embed\nalternative markups and data-types within Elixir source code.\n\nThe module containing the custom sigil must be imported before the sigil\nsyntax can be used.\n\n### Examples\n\nAs an example, let's define a sigil `~x` and sigil `~X` which\nreturn its contents as a string. However, if the `r` modifier\nis given, it reverses the string instead:\n\n    defmodule MySigils do\n      defmacro sigil_x(term, [?r]) do\n        quote do\n          unquote(term) |> String.reverse()\n        end\n      end\n\n      defmacro sigil_x(term, _modifiers) do\n        term\n      end\n\n      defmacro sigil_X(term, [?r]) do\n        quote do\n          unquote(term) |> String.reverse()\n        end\n      end\n\n      defmacro sigil_X(term, _modifiers) do\n        term\n      end\n    end\n\n    import MySigils\n\n    ~x(with \#{\"inter\" <> \"polation\"})\n    #=> \"with interpolation\"\n\n    ~x(with \#{\"inter\" <> \"polation\"})r\n    #=> \"noitalopretni htiw\"\n\n    ~X(without \#{\"interpolation\"})\n    #=> \"without \\\#{\"interpolation\"}\"\n\n    ~X(without \#{\"interpolation\"})r\n    #=> \"}\\\"noitalopretni\\\"{# tuohtiw\"\n\n","title":"Macro","type":"module"},{"doc":"Converts the given string to CamelCase format. This function was designed to camelize language identifiers/tokens, that's why it belongs to the Macro module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers. Examples iex&gt; Macro . camelize ( &quot;foo_bar&quot; ) &quot;FooBar&quot; iex&gt; Macro . camelize ( &quot;foo/bar&quot; ) &quot;Foo.Bar&quot; If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms: iex&gt; Macro . camelize ( &quot;API.V1&quot; ) &quot;API.V1&quot; iex&gt; Macro . camelize ( &quot;API_SPEC&quot; ) &quot;API_SPEC&quot;","ref":"Macro.html#camelize/1","source_doc":"Converts the given string to CamelCase format.\n\nThis function was designed to camelize language identifiers/tokens,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for camelizing strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.camelize(\"foo_bar\")\n    \"FooBar\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\nIf uppercase characters are present, they are not modified in any way\nas a mechanism to preserve acronyms:\n\n    iex> Macro.camelize(\"API.V1\")\n    \"API.V1\"\n    iex> Macro.camelize(\"API_SPEC\")\n    \"API_SPEC\"\n\n","title":"Macro.camelize/1","type":"function"},{"doc":"Classifies a runtime atom based on its possible AST placement. It returns one of the following atoms: :alias - the atom represents an alias :identifier - the atom can be used as a variable or local function call (as well as be an unquoted atom) :unquoted - the atom can be used in its unquoted form, includes operators and atoms with @ in them :quoted - all other atoms which can only be used in their quoted form Most operators are going to be :unquoted , such as :+ , with some exceptions returning :quoted due to ambiguity, such as :&quot;::&quot; . Use operator?/2 to check if a given atom is an operator. Examples iex&gt; Macro . classify_atom ( :foo ) :identifier iex&gt; Macro . classify_atom ( Foo ) :alias iex&gt; Macro . classify_atom ( :foo@bar ) :unquoted iex&gt; Macro . classify_atom ( :+ ) :unquoted iex&gt; Macro . classify_atom ( :Foo ) :unquoted iex&gt; Macro . classify_atom ( :&quot;with spaces&quot; ) :quoted","ref":"Macro.html#classify_atom/1","source_doc":"Classifies a runtime `atom` based on its possible AST placement.\n\nIt returns one of the following atoms:\n\n  * `:alias` - the atom represents an alias\n\n  * `:identifier` - the atom can be used as a variable or local function\n    call (as well as be an unquoted atom)\n\n  * `:unquoted` - the atom can be used in its unquoted form,\n    includes operators and atoms with `@` in them\n\n  * `:quoted` - all other atoms which can only be used in their quoted form\n\nMost operators are going to be `:unquoted`, such as `:+`, with\nsome exceptions returning `:quoted` due to ambiguity, such as\n`:\"::\"`. Use `operator?/2` to check if a given atom is an operator.\n\n## Examples\n\n    iex> Macro.classify_atom(:foo)\n    :identifier\n    iex> Macro.classify_atom(Foo)\n    :alias\n    iex> Macro.classify_atom(:foo@bar)\n    :unquoted\n    iex> Macro.classify_atom(:+)\n    :unquoted\n    iex> Macro.classify_atom(:Foo)\n    :unquoted\n    iex> Macro.classify_atom(:\"with spaces\")\n    :quoted\n\n","title":"Macro.classify_atom/1","type":"function"},{"doc":"Default backend for Kernel.dbg/2 . This function provides a default backend for Kernel.dbg/2 . See the Kernel.dbg/2 documentation for more information. This function: prints information about the given env prints information about code and its returned value (using opts to inspect terms) returns the value returned by evaluating code You can call this function directly to build Kernel.dbg/2 backends that fall back to this function. This function raises if the context of the given env is :match or :guard .","ref":"Macro.html#dbg/3","source_doc":"Default backend for `Kernel.dbg/2`.\n\nThis function provides a default backend for `Kernel.dbg/2`. See the\n`Kernel.dbg/2` documentation for more information.\n\nThis function:\n\n  * prints information about the given `env`\n  * prints information about `code` and its returned value (using `opts` to inspect terms)\n  * returns the value returned by evaluating `code`\n\nYou can call this function directly to build `Kernel.dbg/2` backends that fall back\nto this function.\n\nThis function raises if the context of the given `env` is `:match` or `:guard`.\n","title":"Macro.dbg/3","type":"function"},{"doc":"Decomposes a local or remote call into its remote part (when provided), function name and argument list. Returns :error when an invalid call syntax is provided. Examples iex&gt; Macro . decompose_call ( quote ( do : foo ) ) { :foo , [ ] } iex&gt; Macro . decompose_call ( quote ( do : foo ( ) ) ) { :foo , [ ] } iex&gt; Macro . decompose_call ( quote ( do : foo ( 1 , 2 , 3 ) ) ) { :foo , [ 1 , 2 , 3 ] } iex&gt; Macro . decompose_call ( quote ( do : Elixir.M . foo ( 1 , 2 , 3 ) ) ) { { :__aliases__ , [ ] , [ :Elixir , :M ] } , :foo , [ 1 , 2 , 3 ] } iex&gt; Macro . decompose_call ( quote ( do : 42 ) ) :error iex&gt; Macro . decompose_call ( quote ( do : { :foo , [ ] , [ ] } ) ) :error","ref":"Macro.html#decompose_call/1","source_doc":"Decomposes a local or remote call into its remote part (when provided),\nfunction name and argument list.\n\nReturns `:error` when an invalid call syntax is provided.\n\n## Examples\n\n    iex> Macro.decompose_call(quote(do: foo))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo()))\n    {:foo, []}\n\n    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n    {:foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n\n    iex> Macro.decompose_call(quote(do: 42))\n    :error\n\n    iex> Macro.decompose_call(quote(do: {:foo, [], []}))\n    :error\n\n","title":"Macro.decompose_call/1","type":"function"},{"doc":"Recursively escapes a value so it can be inserted into a syntax tree. Examples iex&gt; Macro . escape ( :foo ) :foo iex&gt; Macro . escape ( { :a , :b , :c } ) { :{} , [ ] , [ :a , :b , :c ] } iex&gt; Macro . escape ( { :unquote , [ ] , [ 1 ] } , unquote : true ) 1 Options :unquote - when true, this function leaves unquote/1 and unquote_splicing/1 statements unescaped, effectively unquoting the contents on escape. This option is useful only when escaping ASTs which may have quoted fragments in them. Defaults to false. :prune_metadata - when true, removes metadata from escaped AST nodes. Note this option changes the semantics of escaped code and it should only be used when escaping ASTs. Defaults to false. As an example, ExUnit stores the AST of every assertion, so when an assertion fails we can show code snippets to users. Without this option, each time the test module is compiled, we get a different MD5 of the module bytecode, because the AST contains metadata, such as counters, specific to the compilation environment. By pruning the metadata, we ensure that the module is deterministic and reduce the amount of data ExUnit needs to keep around. Only the minimal amount of metadata is kept, such as :line and :no_parens . Comparison to quote/2 The escape/2 function is sometimes confused with quote/2 , because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable. iex&gt; Macro . escape ( { :a , :b , :c } ) { :{} , [ ] , [ :a , :b , :c ] } iex&gt; quote do : { :a , :b , :c } { :{} , [ ] , [ :a , :b , :c ] } iex&gt; value = { :a , :b , :c } iex&gt; Macro . escape ( value ) { :{} , [ ] , [ :a , :b , :c ] } iex&gt; quote do : value { :value , [ ] , __MODULE__ } iex&gt; value = { :a , :b , :c } iex&gt; quote do : unquote ( value ) { :a , :b , :c } escape/2 is used to escape values (either directly passed or variable bound), while quote/2 produces syntax trees for expressions.","ref":"Macro.html#escape/2","source_doc":"Recursively escapes a value so it can be inserted into a syntax tree.\n\n## Examples\n\n    iex> Macro.escape(:foo)\n    :foo\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n\n    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n    1\n\n## Options\n\n  * `:unquote` - when true, this function leaves `unquote/1` and\n    `unquote_splicing/1` statements unescaped, effectively unquoting\n    the contents on escape. This option is useful only when escaping\n    ASTs which may have quoted fragments in them. Defaults to false.\n\n  * `:prune_metadata` - when true, removes metadata from escaped AST\n    nodes. Note this option changes the semantics of escaped code and\n    it should only be used when escaping ASTs. Defaults to false.\n\n    As an example, `ExUnit` stores the AST of every assertion, so when\n    an assertion fails we can show code snippets to users. Without this\n    option, each time the test module is compiled, we get a different\n    MD5 of the module bytecode, because the AST contains metadata,\n    such as counters, specific to the compilation environment. By pruning\n    the metadata, we ensure that the module is deterministic and reduce\n    the amount of data `ExUnit` needs to keep around. Only the minimal\n    amount of metadata is kept, such as `:line` and `:no_parens`.\n\n## Comparison to `quote/2`\n\nThe `escape/2` function is sometimes confused with `quote/2`,\nbecause the above examples behave the same with both. The key difference is\nbest illustrated when the value to escape is stored in a variable.\n\n    iex> Macro.escape({:a, :b, :c})\n    {:{}, [], [:a, :b, :c]}\n    iex> quote do: {:a, :b, :c}\n    {:{}, [], [:a, :b, :c]}\n\n    iex> value = {:a, :b, :c}\n    iex> Macro.escape(value)\n    {:{}, [], [:a, :b, :c]}\n\n    iex> quote do: value\n    {:value, [], __MODULE__}\n\n    iex> value = {:a, :b, :c}\n    iex> quote do: unquote(value)\n    {:a, :b, :c}\n\n`escape/2` is used to escape *values* (either directly passed or variable\nbound), while `quote/2` produces syntax trees for\nexpressions.\n","title":"Macro.escape/2","type":"function"},{"doc":"Receives an AST node and expands it until it can no longer be expanded. Note this function does not traverse the AST, only the root node is expanded. This function uses expand_once/2 under the hood. Check it out for more information and examples.","ref":"Macro.html#expand/2","source_doc":"Receives an AST node and expands it until it can no longer\nbe expanded.\n\nNote this function does not traverse the AST, only the root\nnode is expanded.\n\nThis function uses `expand_once/2` under the hood. Check\nit out for more information and examples.\n","title":"Macro.expand/2","type":"function"},{"doc":"Expands all literals in ast with the given env . This function is mostly used to remove compile-time dependencies from AST nodes. In such cases, the given environment is usually manipulated to represent a function: Macro . expand_literals ( ast , %{ env | function : { :my_code , 1 } } ) At the moment, the only expandable literal nodes in an AST are aliases, so this function only expands aliases. However, be careful when removing compile-time dependencies between modules. If you remove them but you still invoke the module at compile-time, Elixir will be unable to properly recompile modules when they change.","ref":"Macro.html#expand_literals/2","source_doc":"Expands all literals in `ast` with the given `env`.\n\nThis function is mostly used to remove compile-time dependencies\nfrom AST nodes. In such cases, the given environment is usually\nmanipulated to represent a function:\n\n    Macro.expand_literals(ast, %{env | function: {:my_code, 1}})\n\nAt the moment, the only expandable literal nodes in an AST are\naliases, so this function only expands aliases.\n\nHowever, be careful when removing compile-time dependencies between\nmodules. If you remove them but you still invoke the module at\ncompile-time, Elixir will be unable to properly recompile modules\nwhen they change.\n","title":"Macro.expand_literals/2","type":"function"},{"doc":"Expands all literals in ast with the given acc and fun . fun will be invoked with an expandable AST node and acc and must return a new node with acc . This is a general version of expand_literals/2 which supports a custom expansion function. Please check expand_literals/2 for use cases and pitfalls.","ref":"Macro.html#expand_literals/3","source_doc":"Expands all literals in `ast` with the given `acc` and `fun`.\n\n`fun` will be invoked with an expandable AST node and `acc` and\nmust return a new node with `acc`. This is a general version of\n`expand_literals/2` which supports a custom expansion function.\nPlease check `expand_literals/2` for use cases and pitfalls.\n","title":"Macro.expand_literals/3","type":"function"},{"doc":"Receives an AST node and expands it once. The following contents are expanded: Macros (local or remote) Aliases are expanded (if possible) and return atoms Compilation environment macros ( __CALLER__/0 , __DIR__/0 , __ENV__/0 and __MODULE__/0 ) Module attributes reader ( @foo ) If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded. expand_once/2 performs the expansion just once. Check expand/2 to perform expansion until the node can no longer be expanded. Examples In the example below, we have a macro that generates a module with a function named name_length that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime. Consider the implementation below: defmacro defmodule_with_length ( name , do : block ) do length = length ( Atom . to_charlist ( name ) ) quote do defmodule unquote ( name ) do def name_length , do : unquote ( length ) unquote ( block ) end end end When invoked like this: defmodule_with_length My.Module do def other_function , do : ... end The compilation will fail because My.Module when quoted is not an atom, but a syntax tree as follows: { :__aliases__ , [ ] , [ :My , :Module ] } That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example: alias MyHelpers , as : My defmodule_with_length My.Module do def other_function , do : ... end The final module name will be MyHelpers.Module and not My.Module . With Macro.expand/2 , such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as: defmacro defmodule_with_length ( name , do : block ) do expanded = Macro . expand ( name , __CALLER__ ) length = length ( Atom . to_charlist ( expanded ) ) quote do defmodule unquote ( name ) do def name_length , do : unquote ( length ) unquote ( block ) end end end","ref":"Macro.html#expand_once/2","source_doc":"Receives an AST node and expands it once.\n\nThe following contents are expanded:\n\n  * Macros (local or remote)\n  * Aliases are expanded (if possible) and return atoms\n  * Compilation environment macros (`__CALLER__/0`, `__DIR__/0`, `__ENV__/0` and `__MODULE__/0`)\n  * Module attributes reader (`@foo`)\n\nIf the expression cannot be expanded, it returns the expression\nitself. This function does not traverse the AST, only the root\nnode is expanded.\n\n`expand_once/2` performs the expansion just once. Check `expand/2`\nto perform expansion until the node can no longer be expanded.\n\n## Examples\n\nIn the example below, we have a macro that generates a module\nwith a function named `name_length` that returns the length\nof the module name. The value of this function will be calculated\nat compilation time and not at runtime.\n\nConsider the implementation below:\n\n    defmacro defmodule_with_length(name, do: block) do\n      length = length(Atom.to_charlist(name))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\nWhen invoked like this:\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe compilation will fail because `My.Module` when quoted\nis not an atom, but a syntax tree as follows:\n\n    {:__aliases__, [], [:My, :Module]}\n\nThat said, we need to expand the aliases node above to an\natom, so we can retrieve its length. Expanding the node is\nnot straightforward because we also need to expand the\ncaller aliases. For example:\n\n    alias MyHelpers, as: My\n\n    defmodule_with_length My.Module do\n      def other_function, do: ...\n    end\n\nThe final module name will be `MyHelpers.Module` and not\n`My.Module`. With `Macro.expand/2`, such aliases are taken\ninto consideration. Local and remote macros are also\nexpanded. We could rewrite our macro above to use this\nfunction as:\n\n    defmacro defmodule_with_length(name, do: block) do\n      expanded = Macro.expand(name, __CALLER__)\n      length = length(Atom.to_charlist(expanded))\n\n      quote do\n        defmodule unquote(name) do\n          def name_length, do: unquote(length)\n          unquote(block)\n        end\n      end\n    end\n\n","title":"Macro.expand_once/2","type":"function"},{"doc":"Generates AST nodes for a given number of required argument variables using Macro.var/2 . Note the arguments are not unique. If you later on want to access the same variables, you can invoke this function with the same inputs. Use generate_unique_arguments/2 to generate a unique arguments that can't be overridden. Examples iex&gt; Macro . generate_arguments ( 2 , __MODULE__ ) [ { :arg1 , [ ] , __MODULE__ } , { :arg2 , [ ] , __MODULE__ } ]","ref":"Macro.html#generate_arguments/2","source_doc":"Generates AST nodes for a given number of required argument\nvariables using `Macro.var/2`.\n\nNote the arguments are not unique. If you later on want\nto access the same variables, you can invoke this function\nwith the same inputs. Use `generate_unique_arguments/2` to\ngenerate a unique arguments that can't be overridden.\n\n## Examples\n\n    iex> Macro.generate_arguments(2, __MODULE__)\n    [{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]\n\n","title":"Macro.generate_arguments/2","type":"function"},{"doc":"Generates AST nodes for a given number of required argument variables using Macro.unique_var/2 . Examples iex&gt; [ var1 , var2 ] = Macro . generate_unique_arguments ( 2 , __MODULE__ ) iex&gt; { :arg1 , [ counter : c1 ] , __MODULE__ } = var1 iex&gt; { :arg2 , [ counter : c2 ] , __MODULE__ } = var2 iex&gt; is_integer ( c1 ) and is_integer ( c2 ) true","ref":"Macro.html#generate_unique_arguments/2","source_doc":"Generates AST nodes for a given number of required argument\nvariables using `Macro.unique_var/2`.\n\n## Examples\n\n    iex> [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)\n    iex> {:arg1, [counter: c1], __MODULE__} = var1\n    iex> {:arg2, [counter: c2], __MODULE__} = var2\n    iex> is_integer(c1) and is_integer(c2)\n    true\n\n","title":"Macro.generate_unique_arguments/2","type":"function"},{"doc":"Inspects atom according to different source formats. The atom can be inspected according to the three different formats it appears in the AST: as a literal ( :literal ), as a key ( :key ), or as the function name of a remote call ( :remote_call ). Examples As a literal Literals include regular atoms, quoted atoms, operators, aliases, and the special nil , true , and false atoms. iex&gt; Macro . inspect_atom ( :literal , nil ) &quot;nil&quot; iex&gt; Macro . inspect_atom ( :literal , :foo ) &quot;:foo&quot; iex&gt; Macro . inspect_atom ( :literal , :&lt;&gt; ) &quot;:&lt;&gt;&quot; iex&gt; Macro . inspect_atom ( :literal , :Foo ) &quot;:Foo&quot; iex&gt; Macro . inspect_atom ( :literal , Foo.Bar ) &quot;Foo.Bar&quot; iex&gt; Macro . inspect_atom ( :literal , :&quot;with spaces&quot; ) &quot;: \\&quot; with spaces \\&quot; &quot; As a key Inspect an atom as a key of a keyword list or a map. iex&gt; Macro . inspect_atom ( :key , :foo ) &quot;foo:&quot; iex&gt; Macro . inspect_atom ( :key , :&lt;&gt; ) &quot;&lt;&gt;:&quot; iex&gt; Macro . inspect_atom ( :key , :Foo ) &quot;Foo:&quot; iex&gt; Macro . inspect_atom ( :key , :&quot;with spaces&quot; ) &quot; \\&quot; with spaces \\&quot; :&quot; As a remote call Inspect an atom the function name of a remote call. iex&gt; Macro . inspect_atom ( :remote_call , :foo ) &quot;foo&quot; iex&gt; Macro . inspect_atom ( :remote_call , :&lt;&gt; ) &quot;&lt;&gt;&quot; iex&gt; Macro . inspect_atom ( :remote_call , :Foo ) &quot; \\&quot; Foo \\&quot; &quot; iex&gt; Macro . inspect_atom ( :remote_call , :&quot;with spaces&quot; ) &quot; \\&quot; with spaces \\&quot; &quot;","ref":"Macro.html#inspect_atom/2","source_doc":"Inspects `atom` according to different source formats.\n\nThe atom can be inspected according to the three different\nformats it appears in the AST: as a literal (`:literal`),\nas a key (`:key`), or as the function name of a remote call\n(`:remote_call`).\n\n## Examples\n\n### As a literal\n\nLiterals include regular atoms, quoted atoms, operators,\naliases, and the special `nil`, `true`, and `false` atoms.\n\n    iex> Macro.inspect_atom(:literal, nil)\n    \"nil\"\n    iex> Macro.inspect_atom(:literal, :foo)\n    \":foo\"\n    iex> Macro.inspect_atom(:literal, :<>)\n    \":<>\"\n    iex> Macro.inspect_atom(:literal, :Foo)\n    \":Foo\"\n    iex> Macro.inspect_atom(:literal, Foo.Bar)\n    \"Foo.Bar\"\n    iex> Macro.inspect_atom(:literal, :\"with spaces\")\n    \":\\\"with spaces\\\"\"\n\n### As a key\n\nInspect an atom as a key of a keyword list or a map.\n\n    iex> Macro.inspect_atom(:key, :foo)\n    \"foo:\"\n    iex> Macro.inspect_atom(:key, :<>)\n    \"<>:\"\n    iex> Macro.inspect_atom(:key, :Foo)\n    \"Foo:\"\n    iex> Macro.inspect_atom(:key, :\"with spaces\")\n    \"\\\"with spaces\\\":\"\n\n### As a remote call\n\nInspect an atom the function name of a remote call.\n\n    iex> Macro.inspect_atom(:remote_call, :foo)\n    \"foo\"\n    iex> Macro.inspect_atom(:remote_call, :<>)\n    \"<>\"\n    iex> Macro.inspect_atom(:remote_call, :Foo)\n    \"\\\"Foo\\\"\"\n    iex> Macro.inspect_atom(:remote_call, :\"with spaces\")\n    \"\\\"with spaces\\\"\"\n\n","title":"Macro.inspect_atom/2","type":"function"},{"doc":"Returns true if the given name and arity is an operator. Examples iex&gt; Macro . operator? ( :not_an_operator , 3 ) false iex&gt; Macro . operator? ( :.. , 0 ) true iex&gt; Macro . operator? ( :+ , 1 ) true iex&gt; Macro . operator? ( :++ , 2 ) true iex&gt; Macro . operator? ( :..// , 3 ) true","ref":"Macro.html#operator?/2","source_doc":"Returns `true` if the given name and arity is an operator.\n\n## Examples\n\n    iex> Macro.operator?(:not_an_operator, 3)\n    false\n    iex> Macro.operator?(:.., 0)\n    true\n    iex> Macro.operator?(:+, 1)\n    true\n    iex> Macro.operator?(:++, 2)\n    true\n    iex> Macro.operator?(:..//, 3)\n    true\n\n","title":"Macro.operator?/2","type":"function"},{"doc":"Returns the path to the node in ast which fun returns true. The path is a list, starting with the node in which fun returns true, followed by all of its parents. Computing the path can be an efficient operation when you want to find a particular node in the AST within its context and then assert something about it. Examples iex&gt; Macro . path ( quote ( do : [ 1 , 2 , 3 ] ) , &amp; &amp;1 == 3 ) [ 3 , [ 1 , 2 , 3 ] ] iex&gt; Macro . path ( quote ( do : Foo . bar ( 3 ) ) , &amp; &amp;1 == 3 ) [ 3 , quote ( do : Foo . bar ( 3 ) ) ] iex&gt; Macro . path ( quote ( do : %{ foo : [ bar : :baz ] } ) , &amp; &amp;1 == :baz ) [ :baz , { :bar , :baz } , [ bar : :baz ] , { :foo , [ bar : :baz ] } , { :%{} , [ ] , [ foo : [ bar : :baz ] ] } ]","ref":"Macro.html#path/2","source_doc":"Returns the path to the node in `ast` which `fun` returns true.\n\nThe path is a list, starting with the node in which `fun` returns\ntrue, followed by all of its parents.\n\nComputing the path can be an efficient operation when you want\nto find a particular node in the AST within its context and then\nassert something about it.\n\n## Examples\n\n    iex> Macro.path(quote(do: [1, 2, 3]), & &1 == 3)\n    [3, [1, 2, 3]]\n\n    iex> Macro.path(quote(do: Foo.bar(3)), & &1 == 3)\n    [3, quote(do: Foo.bar(3))]\n\n    iex> Macro.path(quote(do: %{foo: [bar: :baz]}), & &1 == :baz)\n    [\n      :baz,\n      {:bar, :baz},\n      [bar: :baz],\n      {:foo, [bar: :baz]},\n      {:%{}, [], [foo: [bar: :baz]]}\n    ]\n\n","title":"Macro.path/2","type":"function"},{"doc":"Pipes expr into the call_args at the given position . This function can be used to implement |&gt; like functionality. For example, |&gt; itself is implemented as: defmacro left |&gt; right do Macro . pipe ( left , right , 0 ) end expr is the AST of an expression. call_args must be the AST of a call , otherwise this function will raise an error. As an example, consider the pipe operator |&gt;/2 , which uses this function to build pipelines. Even if the expression is piped into the AST, it doesn't necessarily mean that the AST is valid. For example, you could pipe an argument to div/2 , effectively turning it into a call to div/3 , which is a function that doesn't exist by default. The code will raise unless a div/3 function is locally defined.","ref":"Macro.html#pipe/3","source_doc":"Pipes `expr` into the `call_args` at the given `position`.\n\nThis function can be used to implement `|>` like functionality. For example,\n`|>` itself is implemented as:\n\n    defmacro left |> right do\n      Macro.pipe(left, right, 0)\n    end\n\n`expr` is the AST of an expression. `call_args` must be the AST *of a call*,\notherwise this function will raise an error. As an example, consider the pipe\noperator `|>/2`, which uses this function to build pipelines.\n\nEven if the expression is piped into the AST, it doesn't necessarily mean that\nthe AST is valid. For example, you could pipe an argument to `div/2`, effectively\nturning it into a call to `div/3`, which is a function that doesn't exist by\ndefault. The code will raise unless a `div/3` function is locally defined.\n","title":"Macro.pipe/3","type":"function"},{"doc":"This function behaves like prewalk/2 , but performs a depth-first, post-order traversal of quoted expressions.","ref":"Macro.html#postwalk/2","source_doc":"This function behaves like `prewalk/2`, but performs a depth-first,\npost-order traversal of quoted expressions.\n","title":"Macro.postwalk/2","type":"function"},{"doc":"This functions behaves like prewalk/3 , but performs a depth-first, post-order traversal of quoted expressions using an accumulator.","ref":"Macro.html#postwalk/3","source_doc":"This functions behaves like `prewalk/3`, but performs a depth-first,\npost-order traversal of quoted expressions using an accumulator.\n","title":"Macro.postwalk/3","type":"function"},{"doc":"Returns an enumerable that traverses the ast in depth-first, post-order traversal. Examples iex&gt; ast = quote do : foo ( 1 , &quot;abc&quot; ) iex&gt; Enum . map ( Macro . postwalker ( ast ) , &amp; &amp;1 ) [ 1 , &quot;abc&quot; , { :foo , [ ] , [ 1 , &quot;abc&quot; ] } ]","ref":"Macro.html#postwalker/1","source_doc":"Returns an enumerable that traverses the  `ast` in depth-first,\npost-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.postwalker(ast), & &1)\n    [1, \"abc\", {:foo, [], [1, \"abc\"]}]\n\n","title":"Macro.postwalker/1","type":"function"},{"doc":"Performs a depth-first, pre-order traversal of quoted expressions. Returns a new AST where each node is the result of invoking fun on each corresponding node of ast . Examples iex&gt; ast = quote do : 5 + 3 * 7 iex&gt; { :+ , _ , [ 5 , { :* , _ , [ 3 , 7 ] } ] } = ast iex&gt; new_ast = Macro . prewalk ( ast , fn ...&gt; { :+ , meta , children } -&gt; { :* , meta , children } ...&gt; { :* , meta , children } -&gt; { :+ , meta , children } ...&gt; other -&gt; other ...&gt; end ) iex&gt; { :* , _ , [ 5 , { :+ , _ , [ 3 , 7 ] } ] } = new_ast iex&gt; Code . eval_quoted ( ast ) { 26 , [ ] } iex&gt; Code . eval_quoted ( new_ast ) { 50 , [ ] }","ref":"Macro.html#prewalk/2","source_doc":"Performs a depth-first, pre-order traversal of quoted expressions.\n\nReturns a new AST where each node is the result of invoking `fun` on each\ncorresponding node of `ast`.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> new_ast = Macro.prewalk(ast, fn\n    ...>   {:+, meta, children} -> {:*, meta, children}\n    ...>   {:*, meta, children} -> {:+, meta, children}\n    ...>   other -> other\n    ...> end)\n    iex> {:*, _, [5, {:+, _, [3, 7]}]} = new_ast\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}\n\n","title":"Macro.prewalk/2","type":"function"},{"doc":"Performs a depth-first, pre-order traversal of quoted expressions using an accumulator. Returns a tuple where the first element is a new AST where each node is the result of invoking fun on each corresponding node and the second one is the final accumulator. Examples iex&gt; ast = quote do : 5 + 3 * 7 iex&gt; { :+ , _ , [ 5 , { :* , _ , [ 3 , 7 ] } ] } = ast iex&gt; { new_ast , acc } = Macro . prewalk ( ast , [ ] , fn ...&gt; { :+ , meta , children } , acc -&gt; { { :* , meta , children } , [ :+ | acc ] } ...&gt; { :* , meta , children } , acc -&gt; { { :+ , meta , children } , [ :* | acc ] } ...&gt; other , acc -&gt; { other , acc } ...&gt; end ) iex&gt; { { :* , _ , [ 5 , { :+ , _ , [ 3 , 7 ] } ] } , [ :* , :+ ] } = { new_ast , acc } iex&gt; Code . eval_quoted ( ast ) { 26 , [ ] } iex&gt; Code . eval_quoted ( new_ast ) { 50 , [ ] }","ref":"Macro.html#prewalk/3","source_doc":"Performs a depth-first, pre-order traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST where each node is the\nresult of invoking `fun` on each corresponding node and the second one is the\nfinal accumulator.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} = Macro.prewalk(ast, [], fn\n    ...>   {:+, meta, children}, acc -> {{:*, meta, children}, [:+ | acc]}\n    ...>   {:*, meta, children}, acc -> {{:+, meta, children}, [:* | acc]}\n    ...>   other, acc -> {other, acc}\n    ...> end)\n    iex> {{:*, _, [5, {:+, _, [3, 7]}]}, [:*, :+]} = {new_ast, acc}\n    iex> Code.eval_quoted(ast)\n    {26, []}\n    iex> Code.eval_quoted(new_ast)\n    {50, []}\n\n","title":"Macro.prewalk/3","type":"function"},{"doc":"Returns an enumerable that traverses the ast in depth-first, pre-order traversal. Examples iex&gt; ast = quote do : foo ( 1 , &quot;abc&quot; ) iex&gt; Enum . map ( Macro . prewalker ( ast ) , &amp; &amp;1 ) [ { :foo , [ ] , [ 1 , &quot;abc&quot; ] } , 1 , &quot;abc&quot; ]","ref":"Macro.html#prewalker/1","source_doc":"Returns an enumerable that traverses the  `ast` in depth-first,\npre-order traversal.\n\n## Examples\n\n    iex> ast = quote do: foo(1, \"abc\")\n    iex> Enum.map(Macro.prewalker(ast), & &1)\n    [{:foo, [], [1, \"abc\"]}, 1, \"abc\"]\n\n","title":"Macro.prewalker/1","type":"function"},{"doc":"Returns true if the given quoted expression represents a quoted literal. Atoms and numbers are always literals. Binaries, lists, tuples, maps, and structs are only literals if all of their terms are also literals. Examples iex&gt; Macro . quoted_literal? ( quote ( do : &quot;foo&quot; ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : { &quot;foo&quot; , 1 } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : { &quot;foo&quot; , 1 , :baz } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : %{ foo : &quot;bar&quot; } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : % URI { path : &quot;/&quot; } ) ) true iex&gt; Macro . quoted_literal? ( quote ( do : URI . parse ( &quot;/&quot; ) ) ) false iex&gt; Macro . quoted_literal? ( quote ( do : { foo , var } ) ) false","ref":"Macro.html#quoted_literal?/1","source_doc":"Returns `true` if the given quoted expression represents a quoted literal.\n\nAtoms and numbers are always literals. Binaries, lists, tuples,\nmaps, and structs are only literals if all of their terms are also literals.\n\n## Examples\n\n    iex> Macro.quoted_literal?(quote(do: \"foo\"))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1}))\n    true\n    iex> Macro.quoted_literal?(quote(do: {\"foo\", 1, :baz}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %{foo: \"bar\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: %URI{path: \"/\"}))\n    true\n    iex> Macro.quoted_literal?(quote(do: URI.parse(\"/\")))\n    false\n    iex> Macro.quoted_literal?(quote(do: {foo, var}))\n    false\n\n","title":"Macro.quoted_literal?/1","type":"function"},{"doc":"Returns true if the given name and arity is a special form.","ref":"Macro.html#special_form?/2","source_doc":"Returns `true` if the given name and arity is a special form.\n","title":"Macro.special_form?/2","type":"function"},{"doc":"Expands the struct given by module in the given env . This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled. It will raise CompileError if the struct is not available. From Elixir v1.12, calling this function also adds an export dependency on the given struct.","ref":"Macro.html#struct!/2","source_doc":"Expands the struct given by `module` in the given `env`.\n\nThis is useful when a struct needs to be expanded at\ncompilation time and the struct being expanded may or may\nnot have been compiled. This function is also capable of\nexpanding structs defined under the module being compiled.\n\nIt will raise `CompileError` if the struct is not available.\nFrom Elixir v1.12, calling this function also adds an export\ndependency on the given struct.\n","title":"Macro.struct!/2","type":"function"},{"doc":"Converts the given expression AST to a string. This is a convenience function for converting AST into a string, which discards all formatting of the original code and wraps newlines around 98 characters. See Code.quoted_to_algebra/2 as a lower level function with more control around formatting. Examples iex&gt; Macro . to_string ( quote ( do : foo . bar ( 1 , 2 , 3 ) ) ) &quot;foo.bar(1, 2, 3)&quot;","ref":"Macro.html#to_string/1","source_doc":"Converts the given expression AST to a string.\n\nThis is a convenience function for converting AST into\na string, which discards all formatting of the original\ncode and wraps newlines around 98 characters. See\n`Code.quoted_to_algebra/2` as a lower level function\nwith more control around formatting.\n\n## Examples\n\n    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n    \"foo.bar(1, 2, 3)\"\n\n","title":"Macro.to_string/1","type":"function"},{"doc":"Converts the given expression AST to a string. The given fun is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node. This function discards all formatting of the original code. Examples Macro . to_string ( quote ( do : 1 + 2 ) , fn 1 , _string -&gt; &quot;one&quot; 2 , _string -&gt; &quot;two&quot; _ast , string -&gt; string end ) #=&gt; &quot;one + two&quot;","ref":"Macro.html#to_string/2","source_doc":"Converts the given expression AST to a string.\n\nThe given `fun` is called for every node in the AST with two arguments: the\nAST of the node being printed and the string representation of that same\nnode. The return value of this function is used as the final string\nrepresentation for that AST node.\n\nThis function discards all formatting of the original code.\n\n## Examples\n\n    Macro.to_string(quote(do: 1 + 2), fn\n      1, _string -> \"one\"\n      2, _string -> \"two\"\n      _ast, string -> string\n    end)\n    #=> \"one + two\"\n\n","title":"Macro.to_string/2","type":"function"},{"doc":"Performs a depth-first traversal of quoted expressions using an accumulator. Returns a tuple where the first element is a new AST and the second one is the final accumulator. The new AST is the result of invoking pre on each node of ast during the pre-order phase and post during the post-order phase. Examples iex&gt; ast = quote do : 5 + 3 * 7 iex&gt; { :+ , _ , [ 5 , { :* , _ , [ 3 , 7 ] } ] } = ast iex&gt; { new_ast , acc } = ...&gt; Macro . traverse ( ...&gt; ast , ...&gt; [ ] , ...&gt; fn ...&gt; { :+ , meta , children } , acc -&gt; { { :- , meta , children } , [ :- | acc ] } ...&gt; { :* , meta , children } , acc -&gt; { { :/ , meta , children } , [ :/ | acc ] } ...&gt; other , acc -&gt; { other , acc } ...&gt; end , ...&gt; fn ...&gt; { :- , meta , children } , acc -&gt; { { :min , meta , children } , [ :min | acc ] } ...&gt; { :/ , meta , children } , acc -&gt; { { :max , meta , children } , [ :max | acc ] } ...&gt; other , acc -&gt; { other , acc } ...&gt; end ...&gt; ) iex&gt; { :min , _ , [ 5 , { :max , _ , [ 3 , 7 ] } ] } = new_ast iex&gt; [ :min , :max , :/ , :- ] = acc iex&gt; Code . eval_quoted ( new_ast ) { 5 , [ ] }","ref":"Macro.html#traverse/4","source_doc":"Performs a depth-first traversal of quoted expressions\nusing an accumulator.\n\nReturns a tuple where the first element is a new AST and the second one is\nthe final accumulator. The new AST is the result of invoking `pre` on each\nnode of `ast` during the pre-order phase and `post` during the post-order\nphase.\n\n## Examples\n\n    iex> ast = quote do: 5 + 3 * 7\n    iex> {:+, _, [5, {:*, _, [3, 7]}]} = ast\n    iex> {new_ast, acc} =\n    ...>  Macro.traverse(\n    ...>    ast,\n    ...>    [],\n    ...>    fn\n    ...>      {:+, meta, children}, acc -> {{:-, meta, children}, [:- | acc]}\n    ...>      {:*, meta, children}, acc -> {{:/, meta, children}, [:/ | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end,\n    ...>    fn\n    ...>      {:-, meta, children}, acc -> {{:min, meta, children}, [:min | acc]}\n    ...>      {:/, meta, children}, acc -> {{:max, meta, children}, [:max | acc]}\n    ...>      other, acc -> {other, acc}\n    ...>    end\n    ...>  )\n    iex> {:min, _, [5, {:max, _, [3, 7]}]} = new_ast\n    iex> [:min, :max, :/, :-] = acc\n    iex> Code.eval_quoted(new_ast)\n    {5, []}\n\n","title":"Macro.traverse/4","type":"function"},{"doc":"Converts the given argument to a string with the underscore-slash format. The argument must either be an atom or a string. If an atom is given, it is assumed to be an Elixir module, so it is converted to a string and then processed. This function was designed to format language identifiers/tokens with the underscore-slash format, that's why it belongs to the Macro module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers. Examples iex&gt; Macro . underscore ( &quot;FooBar&quot; ) &quot;foo_bar&quot; iex&gt; Macro . underscore ( &quot;Foo.Bar&quot; ) &quot;foo/bar&quot; iex&gt; Macro . underscore ( Foo.Bar ) &quot;foo/bar&quot; In general, underscore can be thought of as the reverse of camelize , however, in some cases formatting may be lost: iex&gt; Macro . underscore ( &quot;SAPExample&quot; ) &quot;sap_example&quot; iex&gt; Macro . camelize ( &quot;sap_example&quot; ) &quot;SapExample&quot; iex&gt; Macro . camelize ( &quot;hello_10&quot; ) &quot;Hello10&quot; iex&gt; Macro . camelize ( &quot;foo/bar&quot; ) &quot;Foo.Bar&quot;","ref":"Macro.html#underscore/1","source_doc":"Converts the given argument to a string with the underscore-slash format.\n\nThe argument must either be an atom or a string.\nIf an atom is given, it is assumed to be an Elixir module,\nso it is converted to a string and then processed.\n\nThis function was designed to format language identifiers/tokens with the underscore-slash format,\nthat's why it belongs to the `Macro` module. Do not use it as a general\nmechanism for underscoring strings as it does not support Unicode or\ncharacters that are not valid in Elixir identifiers.\n\n## Examples\n\n    iex> Macro.underscore(\"FooBar\")\n    \"foo_bar\"\n\n    iex> Macro.underscore(\"Foo.Bar\")\n    \"foo/bar\"\n\n    iex> Macro.underscore(Foo.Bar)\n    \"foo/bar\"\n\nIn general, `underscore` can be thought of as the reverse of\n`camelize`, however, in some cases formatting may be lost:\n\n    iex> Macro.underscore(\"SAPExample\")\n    \"sap_example\"\n\n    iex> Macro.camelize(\"sap_example\")\n    \"SapExample\"\n\n    iex> Macro.camelize(\"hello_10\")\n    \"Hello10\"\n\n    iex> Macro.camelize(\"foo/bar\")\n    \"Foo.Bar\"\n\n","title":"Macro.underscore/1","type":"function"},{"doc":"Unescapes characters in a string. This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check unescape_string/2 for information on how to customize the escaping map. In this setup, Elixir will escape the following: \\0 , \\a , \\b , \\d , \\e , \\f , \\n , \\r , \\s , \\t and \\v . Bytes can be given as hexadecimals via \\xNN and Unicode code points as \\uNNNN escapes. This function is commonly used on sigil implementations (like ~r , ~s and others), which receive a raw, unescaped string, and it can be used anywhere that needs to mimic how Elixir parses strings. Examples iex&gt; Macro . unescape_string ( &quot;example \\\\ n&quot; ) &quot;example \\n &quot; In the example above, we pass a string with \\n escaped and return a version with it unescaped.","ref":"Macro.html#unescape_string/1","source_doc":"Unescapes characters in a string.\n\nThis is the unescaping behaviour used by default in Elixir\nsingle- and double-quoted strings. Check `unescape_string/2`\nfor information on how to customize the escaping map.\n\nIn this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\ngiven as hexadecimals via `\\xNN` and Unicode code points as\n`\\uNNNN` escapes.\n\nThis function is commonly used on sigil implementations\n(like `~r`, `~s` and others), which receive a raw, unescaped\nstring, and it can be used anywhere that needs to mimic how\nElixir parses strings.\n\n## Examples\n\n    iex> Macro.unescape_string(\"example\\\\n\")\n    \"example\\n\"\n\nIn the example above, we pass a string with `\\n` escaped\nand return a version with it unescaped.\n","title":"Macro.unescape_string/1","type":"function"},{"doc":"Unescapes characters in a string according to the given mapping. Check unescape_string/1 if you want to use the same mapping as Elixir single- and double-quoted strings. Mapping function The mapping function receives an integer representing the code point of the character it wants to unescape. There are also the special atoms :newline , :unicode , and :hex , which control newline, unicode, and escaping respectively. Here is the default mapping function implemented by Elixir: def unescape_map ( :newline ) , do : true def unescape_map ( :unicode ) , do : true def unescape_map ( :hex ) , do : true def unescape_map ( ?0 ) , do : ?0 def unescape_map ( ?a ) , do : ?\\a def unescape_map ( ?b ) , do : ?\\b def unescape_map ( ?d ) , do : ?\\d def unescape_map ( ?e ) , do : ?\\e def unescape_map ( ?f ) , do : ?\\f def unescape_map ( ?n ) , do : ?\\n def unescape_map ( ?r ) , do : ?\\r def unescape_map ( ?s ) , do : ?\\s def unescape_map ( ?t ) , do : ?\\t def unescape_map ( ?v ) , do : ?\\v def unescape_map ( e ) , do : e If the unescape_map/1 function returns false , the char is not escaped and the backslash is kept in the string. Examples Using the unescape_map/1 function defined above is easy: Macro . unescape_string ( &quot;example \\\\ n&quot; , &amp; unescape_map ( &amp;1 ) )","ref":"Macro.html#unescape_string/2","source_doc":"Unescapes characters in a string according to the given mapping.\n\nCheck `unescape_string/1` if you want to use the same mapping\nas Elixir single- and double-quoted strings.\n\n## Mapping function\n\nThe mapping function receives an integer representing the code point\nof the character it wants to unescape. There are also the special atoms\n`:newline`, `:unicode`, and `:hex`, which control newline, unicode,\nand escaping respectively.\n\nHere is the default mapping function implemented by Elixir:\n\n    def unescape_map(:newline), do: true\n    def unescape_map(:unicode), do: true\n    def unescape_map(:hex), do: true\n    def unescape_map(?0), do: ?0\n    def unescape_map(?a), do: ?\\a\n    def unescape_map(?b), do: ?\\b\n    def unescape_map(?d), do: ?\\d\n    def unescape_map(?e), do: ?\\e\n    def unescape_map(?f), do: ?\\f\n    def unescape_map(?n), do: ?\\n\n    def unescape_map(?r), do: ?\\r\n    def unescape_map(?s), do: ?\\s\n    def unescape_map(?t), do: ?\\t\n    def unescape_map(?v), do: ?\\v\n    def unescape_map(e), do: e\n\nIf the `unescape_map/1` function returns `false`, the char is\nnot escaped and the backslash is kept in the string.\n\n## Examples\n\nUsing the `unescape_map/1` function defined above is easy:\n\n    Macro.unescape_string(\"example\\\\n\", &unescape_map(&1))\n\n","title":"Macro.unescape_string/2","type":"function"},{"doc":"Generates an AST node representing a unique variable given by the atoms var and context . Calling this function with the same arguments will generate another variable, with its own unique counter. See var/2 for an alternative. Examples iex&gt; { :foo , [ counter : c ] , __MODULE__ } = Macro . unique_var ( :foo , __MODULE__ ) iex&gt; is_integer ( c ) true","ref":"Macro.html#unique_var/2","source_doc":"Generates an AST node representing a unique variable\ngiven by the atoms `var` and `context`.\n\nCalling this function with the same arguments will\ngenerate another variable, with its own unique counter.\nSee `var/2` for an alternative.\n\n## Examples\n\n    iex> {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)\n    iex> is_integer(c)\n    true\n\n","title":"Macro.unique_var/2","type":"function"},{"doc":"Breaks a pipeline expression into a list. The AST for a pipeline (a sequence of applications of |&gt;/2 ) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most :|&gt; (which is the last one to be executed), and its left-hand and right-hand sides are its arguments: quote do : 100 |&gt; div ( 5 ) |&gt; div ( 2 ) #=&gt; {:|&gt;, _, [arg1, arg2]} In the example above, the |&gt;/2 pipe is the right-most pipe; arg1 is the AST for 100 |&gt; div(5) , and arg2 is the AST for div(2) . It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that: Macro . unpipe ( quote do : 100 |&gt; div ( 5 ) |&gt; div ( 2 ) ) #=&gt; [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}] We get a list that follows the pipeline directly: first the 100 , then the div(5) (more precisely, its AST), then div(2) . The 0 as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: {{:div, [], [5]}, 0} means that the previous element ( 100 ) will be inserted as the 0th (first) argument to the div/2 function, so that the AST for that function will become {:div, [], [100, 5]} ( div(100, 5) ).","ref":"Macro.html#unpipe/1","source_doc":"Breaks a pipeline expression into a list.\n\nThe AST for a pipeline (a sequence of applications of `|>/2`) is similar to the\nAST of a sequence of binary operators or function applications: the top-level\nexpression is the right-most `:|>` (which is the last one to be executed), and\nits left-hand and right-hand sides are its arguments:\n\n    quote do: 100 |> div(5) |> div(2)\n    #=> {:|>, _, [arg1, arg2]}\n\nIn the example above, the `|>/2` pipe is the right-most pipe; `arg1` is the AST\nfor `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n\nIt's often useful to have the AST for such a pipeline as a list of function\napplications. This function does exactly that:\n\n    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n\nWe get a list that follows the pipeline directly: first the `100`, then the\n`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\nelement of the tuples is the position of the previous element in the pipeline\ninside the current function application: `{{:div, [], [5]}, 0}` means that the\nprevious element (`100`) will be inserted as the 0th (first) argument to the\n`div/2` function, so that the AST for that function will become `{:div, [],\n[100, 5]}` (`div(100, 5)`).\n","title":"Macro.unpipe/1","type":"function"},{"doc":"Applies the given function to the node metadata if it contains one. This is often useful when used with Macro.prewalk/2 to remove information like lines and hygienic counters from the expression for either storage or comparison. Examples iex&gt; quoted = quote line : 10 , do : sample ( ) { :sample , [ line : 10 ] , [ ] } iex&gt; Macro . update_meta ( quoted , &amp; Keyword . delete ( &amp;1 , :line ) ) { :sample , [ ] , [ ] }","ref":"Macro.html#update_meta/2","source_doc":"Applies the given function to the node metadata if it contains one.\n\nThis is often useful when used with `Macro.prewalk/2` to remove\ninformation like lines and hygienic counters from the expression\nfor either storage or comparison.\n\n## Examples\n\n    iex> quoted = quote line: 10, do: sample()\n    {:sample, [line: 10], []}\n    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n    {:sample, [], []}\n\n","title":"Macro.update_meta/2","type":"function"},{"doc":"Validates the given expressions are valid quoted expressions. Check the type Macro.t/0 for a complete specification of a valid quoted expression. It returns :ok if the expression is valid. Otherwise it returns a tuple in the form of {:error, remainder} where remainder is the invalid part of the quoted expression. Examples iex&gt; Macro . validate ( { :two_element , :tuple } ) :ok iex&gt; Macro . validate ( { :three , :element , :tuple } ) { :error , { :three , :element , :tuple } } iex&gt; Macro . validate ( [ 1 , 2 , 3 ] ) :ok iex&gt; Macro . validate ( [ 1 , 2 , 3 , { 4 } ] ) { :error , { 4 } }","ref":"Macro.html#validate/1","source_doc":"Validates the given expressions are valid quoted expressions.\n\nCheck the type `t:Macro.t/0` for a complete specification of a\nvalid quoted expression.\n\nIt returns `:ok` if the expression is valid. Otherwise it returns\na tuple in the form of `{:error, remainder}` where `remainder` is\nthe invalid part of the quoted expression.\n\n## Examples\n\n    iex> Macro.validate({:two_element, :tuple})\n    :ok\n    iex> Macro.validate({:three, :element, :tuple})\n    {:error, {:three, :element, :tuple}}\n\n    iex> Macro.validate([1, 2, 3])\n    :ok\n    iex> Macro.validate([1, 2, 3, {4}])\n    {:error, {4}}\n\n","title":"Macro.validate/1","type":"function"},{"doc":"Generates an AST node representing the variable given by the atoms var and context . Note this variable is not unique. If you later on want to access this same variable, you can invoke var/2 again with the same arguments. Use unique_var/2 to generate a unique variable that can't be overridden. Examples In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be __MODULE__/0 : iex&gt; Macro . var ( :foo , __MODULE__ ) { :foo , [ ] , __MODULE__ } However, if there is a need to access the user variable, nil can be given: iex&gt; Macro . var ( :foo , nil ) { :foo , [ ] , nil }","ref":"Macro.html#var/2","source_doc":"Generates an AST node representing the variable given\nby the atoms `var` and `context`.\n\nNote this variable is not unique. If you later on want\nto access this same variable, you can invoke `var/2`\nagain with the same arguments. Use `unique_var/2` to\ngenerate a unique variable that can't be overridden.\n\n## Examples\n\nIn order to build a variable, a context is expected.\nMost of the times, in order to preserve hygiene, the\ncontext must be `__MODULE__/0`:\n\n    iex> Macro.var(:foo, __MODULE__)\n    {:foo, [], __MODULE__}\n\nHowever, if there is a need to access the user variable,\nnil can be given:\n\n    iex> Macro.var(:foo, nil)\n    {:foo, [], nil}\n\n","title":"Macro.var/2","type":"function"},{"doc":"A captured remote function in the format of &amp;Mod.fun/arity","ref":"Macro.html#t:captured_remote_function/0","source_doc":"A captured remote function in the format of &Mod.fun/arity","title":"Macro.captured_remote_function/0","type":"type"},{"doc":"The inputs of a macro","ref":"Macro.html#t:input/0","source_doc":"The inputs of a macro","title":"Macro.input/0","type":"type"},{"doc":"A keyword list of AST metadata. The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the :line annotation, while the AST emitted by quote/2 will only have the :line annotation if the :line option is provided. The following metadata keys are public: :context - Defines the context in which the AST was generated. For example, quote/2 will include the module calling quote/2 as the context. This is often used to distinguish regular code from code generated by a macro or by quote/2 . :counter - The variable counter used for variable hygiene. In terms of the compiler, each variable is identified by the combination of either name and metadata[:counter] , or name and context . :generated - Whether the code should be considered as generated by the compiler or not. This means the compiler and tools like Dialyzer may not emit certain warnings. :if_undefined - How to expand a variable that is undefined. Set it to :apply if you want a variable to become a nullary call without warning or :raise :keep - Used by quote/2 with the option location: :keep to annotate the file and the line number of the quoted source. :line - The line number of the AST node. :from_brackets - Used to determine whether a call to Access.get/3 is from bracket syntax or a function call. The following metadata keys are enabled by Code.string_to_quoted/2 : :closing - contains metadata about the closing pair, such as a } in a tuple or in a map, or such as the closing ) in a function call with parens. The :closing does not delimit the end of expression if there are :do and :end metadata (when :token_metadata is true) :column - the column number of the AST node (when :columns is true) :delimiter - contains the opening delimiter for sigils, strings, and charlists as a string (such as &quot;{&quot; , &quot;/&quot; , &quot;'&quot; , and the like) :format - set to :keyword when an atom is defined as a keyword :do - contains metadata about the do location in a function call with do - end blocks (when :token_metadata is true) :end - contains metadata about the end location in a function call with do - end blocks (when :token_metadata is true) :end_of_expression - denotes when the end of expression effectively happens. Available for all expressions except the last one inside a __block__ (when :token_metadata is true) :indentation - indentation of a sigil heredoc The following metadata keys are private: :alias - Used for alias hygiene. :ambiguous_op - Used for improved error messages in the compiler. :imports - Used for import hygiene. :var - Used for improved error messages on undefined variables. Do not rely on them as they may change or be fully removed in future versions of the language. They are often used by quote/2 and the compiler to provide features like hygiene, better error messages, and so forth. If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.","ref":"Macro.html#t:metadata/0","source_doc":"A keyword list of AST metadata.\n\nThe metadata in Elixir AST is a keyword list of values. Any key can be used\nand different parts of the compiler may use different keys. For example,\nthe AST received by a macro will always include the `:line` annotation,\nwhile the AST emitted by `quote/2` will only have the `:line` annotation if\nthe `:line` option is provided.\n\nThe following metadata keys are public:\n\n  * `:context` - Defines the context in which the AST was generated.\n    For example, `quote/2` will include the module calling `quote/2`\n    as the context. This is often used to distinguish regular code from code\n    generated by a macro or by `quote/2`.\n\n  * `:counter` - The variable counter used for variable hygiene. In terms of\n    the compiler, each variable is identified by the combination of either\n    `name` and `metadata[:counter]`, or `name` and `context`.\n\n  * `:generated` - Whether the code should be considered as generated by\n    the compiler or not. This means the compiler and tools like Dialyzer may not\n    emit certain warnings.\n\n  * `:if_undefined` - How to expand a variable that is undefined. Set it to\n    `:apply` if you want a variable to become a nullary call without warning\n    or `:raise`\n\n  * `:keep` - Used by `quote/2` with the option `location: :keep` to annotate\n    the file and the line number of the quoted source.\n\n  * `:line` - The line number of the AST node.\n\n  * `:from_brackets` - Used to determine whether a call to `Access.get/3` is from\n    bracket syntax or a function call.\n\nThe following metadata keys are enabled by `Code.string_to_quoted/2`:\n\n  * `:closing` - contains metadata about the closing pair, such as a `}`\n    in a tuple or in a map, or such as the closing `)` in a function call\n    with parens. The `:closing` does not delimit the end of expression if\n    there are `:do` and `:end` metadata  (when `:token_metadata` is true)\n  * `:column` - the column number of the AST node (when `:columns` is true)\n  * `:delimiter` - contains the opening delimiter for sigils, strings,\n    and charlists as a string (such as `\"{\"`, `\"/\"`, `\"'\"`, and the like)\n  * `:format` - set to `:keyword` when an atom is defined as a keyword\n  * `:do` - contains metadata about the `do` location in a function call with\n    `do`-`end` blocks (when `:token_metadata` is true)\n  * `:end` - contains metadata about the `end` location in a function call with\n    `do`-`end` blocks (when `:token_metadata` is true)\n  * `:end_of_expression` - denotes when the end of expression effectively\n    happens. Available for all expressions except the last one inside a\n    `__block__` (when `:token_metadata` is true)\n  * `:indentation` - indentation of a sigil heredoc\n\nThe following metadata keys are private:\n\n  * `:alias` - Used for alias hygiene.\n  * `:ambiguous_op` - Used for improved error messages in the compiler.\n  * `:imports` - Used for import hygiene.\n  * `:var` - Used for improved error messages on undefined variables.\n\nDo not rely on them as they may change or be fully removed in future versions\nof the language. They are often used by `quote/2` and the compiler to provide\nfeatures like hygiene, better error messages, and so forth.\n\nIf you introduce custom keys into the AST metadata, please make sure to prefix\nthem with the name of your library or application, so that they will not conflict\nwith keys that could potentially be introduced by the compiler in the future.\n","title":"Macro.metadata/0","type":"type"},{"doc":"The output of a macro","ref":"Macro.html#t:output/0","source_doc":"The output of a macro","title":"Macro.output/0","type":"type"},{"doc":"Abstract Syntax Tree (AST)","ref":"Macro.html#t:t/0","source_doc":"Abstract Syntax Tree (AST)","title":"Macro.t/0","type":"type"},{"doc":"A struct that holds compile time environment information. The current environment can be accessed at any time as __ENV__/0 . Inside macros, the caller environment can be accessed as __CALLER__/0 . An instance of Macro.Env must not be modified by hand. If you need to create a custom environment to pass to Code.eval_quoted/3 , use the following trick: def make_custom_env do import SomeModule , only : [ some_function : 2 ] alias A.B.C __ENV__ end You may then call make_custom_env() to get a struct with the desired imports and aliases included. It contains the following fields: context - the context of the environment; it can be nil (default context), :guard (inside a guard) or :match (inside a match) context_modules - a list of modules defined in the current context file - the current absolute file name as a binary function - a tuple as {atom, integer} , where the first element is the function name and the second its arity; returns nil if not inside a function line - the current line as an integer module - the current module name The following fields are private to Elixir's macro expansion mechanism and must not be accessed directly: aliases functions macro_aliases macros lexical_tracker requires tracers versioned_vars","ref":"Macro.Env.html","source_doc":"A struct that holds compile time environment information.\n\nThe current environment can be accessed at any time as\n`__ENV__/0`. Inside macros, the caller environment can be\naccessed as `__CALLER__/0`.\n\nAn instance of `Macro.Env` must not be modified by hand. If you need to\ncreate a custom environment to pass to `Code.eval_quoted/3`, use the\nfollowing trick:\n\n    def make_custom_env do\n      import SomeModule, only: [some_function: 2]\n      alias A.B.C\n      __ENV__\n    end\n\nYou may then call `make_custom_env()` to get a struct with the desired\nimports and aliases included.\n\nIt contains the following fields:\n\n  * `context` - the context of the environment; it can be `nil`\n    (default context), `:guard` (inside a guard) or `:match` (inside a match)\n  * `context_modules` - a list of modules defined in the current context\n  * `file` - the current absolute file name as a binary\n  * `function` - a tuple as `{atom, integer}`, where the first\n    element is the function name and the second its arity; returns\n    `nil` if not inside a function\n  * `line` - the current line as an integer\n  * `module` - the current module name\n\nThe following fields are private to Elixir's macro expansion mechanism and\nmust not be accessed directly:\n\n  * `aliases`\n  * `functions`\n  * `macro_aliases`\n  * `macros`\n  * `lexical_tracker`\n  * `requires`\n  * `tracers`\n  * `versioned_vars`\n\n","title":"Macro.Env","type":"module"},{"doc":"Fetches the alias for the given atom. Returns {:ok, alias} if the alias exists, :error otherwise. Examples iex&gt; alias Foo.Bar , as : Baz iex&gt; Baz Foo.Bar iex&gt; Macro.Env . fetch_alias ( __ENV__ , :Baz ) { :ok , Foo.Bar } iex&gt; Macro.Env . fetch_alias ( __ENV__ , :Unknown ) :error","ref":"Macro.Env.html#fetch_alias/2","source_doc":"Fetches the alias for the given atom.\n\nReturns `{:ok, alias}` if the alias exists, `:error`\notherwise.\n\n## Examples\n\n    iex> alias Foo.Bar, as: Baz\n    iex> Baz\n    Foo.Bar\n    iex> Macro.Env.fetch_alias(__ENV__, :Baz)\n    {:ok, Foo.Bar}\n    iex> Macro.Env.fetch_alias(__ENV__, :Unknown)\n    :error\n\n","title":"Macro.Env.fetch_alias/2","type":"function"},{"doc":"Fetches the macro alias for the given atom. Returns {:ok, macro_alias} if the alias exists, :error otherwise. A macro alias is only used inside quoted expansion. See fetch_alias/2 for a more general example.","ref":"Macro.Env.html#fetch_macro_alias/2","source_doc":"Fetches the macro alias for the given atom.\n\nReturns `{:ok, macro_alias}` if the alias exists, `:error`\notherwise.\n\nA macro alias is only used inside quoted expansion. See\n`fetch_alias/2` for a more general example.\n","title":"Macro.Env.fetch_macro_alias/2","type":"function"},{"doc":"Checks if a variable belongs to the environment. Examples iex&gt; x = 13 iex&gt; x 13 iex&gt; Macro.Env . has_var? ( __ENV__ , { :x , nil } ) true iex&gt; Macro.Env . has_var? ( __ENV__ , { :unknown , nil } ) false","ref":"Macro.Env.html#has_var?/2","source_doc":"Checks if a variable belongs to the environment.\n\n## Examples\n\n    iex> x = 13\n    iex> x\n    13\n    iex> Macro.Env.has_var?(__ENV__, {:x, nil})\n    true\n    iex> Macro.Env.has_var?(__ENV__, {:unknown, nil})\n    false\n\n","title":"Macro.Env.has_var?/2","type":"function"},{"doc":"Returns whether the compilation environment is currently inside a guard.","ref":"Macro.Env.html#in_guard?/1","source_doc":"Returns whether the compilation environment is currently\ninside a guard.\n","title":"Macro.Env.in_guard?/1","type":"function"},{"doc":"Returns whether the compilation environment is currently inside a match clause.","ref":"Macro.Env.html#in_match?/1","source_doc":"Returns whether the compilation environment is currently\ninside a match clause.\n","title":"Macro.Env.in_match?/1","type":"function"},{"doc":"Returns a keyword list containing the file and line information as keys.","ref":"Macro.Env.html#location/1","source_doc":"Returns a keyword list containing the file and line\ninformation as keys.\n","title":"Macro.Env.location/1","type":"function"},{"doc":"Returns the names of any aliases for the given module or atom. Examples iex&gt; alias Foo.Bar iex&gt; Bar Foo.Bar iex&gt; Macro.Env . lookup_alias_as ( __ENV__ , Foo.Bar ) [ Elixir.Bar ] iex&gt; alias Foo.Bar , as : Baz iex&gt; Baz Foo.Bar iex&gt; Macro.Env . lookup_alias_as ( __ENV__ , Foo.Bar ) [ Elixir.Bar , Elixir.Baz ] iex&gt; Macro.Env . lookup_alias_as ( __ENV__ , Unknown ) [ ]","ref":"Macro.Env.html#lookup_alias_as/2","source_doc":"Returns the names of any aliases for the given module or atom.\n\n## Examples\n\n    iex> alias Foo.Bar\n    iex> Bar\n    Foo.Bar\n    iex> Macro.Env.lookup_alias_as(__ENV__, Foo.Bar)\n    [Elixir.Bar]\n    iex> alias Foo.Bar, as: Baz\n    iex> Baz\n    Foo.Bar\n    iex> Macro.Env.lookup_alias_as(__ENV__, Foo.Bar)\n    [Elixir.Bar, Elixir.Baz]\n    iex> Macro.Env.lookup_alias_as(__ENV__, Unknown)\n    []\n\n","title":"Macro.Env.lookup_alias_as/2","type":"function"},{"doc":"Returns the modules from which the given {name, arity} was imported. It returns a list of two element tuples in the shape of {:function | :macro, module} . The elements in the list are in no particular order and the order is not guaranteed. Examples iex&gt; Macro.Env . lookup_import ( __ENV__ , { :duplicate , 2 } ) [ ] iex&gt; import Tuple , only : [ duplicate : 2 ] , warn : false iex&gt; Macro.Env . lookup_import ( __ENV__ , { :duplicate , 2 } ) [ { :function , Tuple } ] iex&gt; import List , only : [ duplicate : 2 ] , warn : false iex&gt; Macro.Env . lookup_import ( __ENV__ , { :duplicate , 2 } ) [ { :function , List } , { :function , Tuple } ] iex&gt; Macro.Env . lookup_import ( __ENV__ , { :def , 1 } ) [ { :macro , Kernel } ]","ref":"Macro.Env.html#lookup_import/2","source_doc":"Returns the modules from which the given `{name, arity}` was\nimported.\n\nIt returns a list of two element tuples in the shape of\n`{:function | :macro, module}`. The elements in the list\nare in no particular order and the order is not guaranteed.\n\n## Examples\n\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    []\n    iex> import Tuple, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, Tuple}]\n    iex> import List, only: [duplicate: 2], warn: false\n    iex> Macro.Env.lookup_import(__ENV__, {:duplicate, 2})\n    [{:function, List}, {:function, Tuple}]\n\n    iex> Macro.Env.lookup_import(__ENV__, {:def, 1})\n    [{:macro, Kernel}]\n\n","title":"Macro.Env.lookup_import/2","type":"function"},{"doc":"Prepend a tracer to the list of tracers in the environment. Examples Macro.Env . prepend_tracer ( __ENV__ , MyCustomTracer )","ref":"Macro.Env.html#prepend_tracer/2","source_doc":"Prepend a tracer to the list of tracers in the environment.\n\n## Examples\n\n    Macro.Env.prepend_tracer(__ENV__, MyCustomTracer)\n\n","title":"Macro.Env.prepend_tracer/2","type":"function"},{"doc":"Prunes compile information from the environment. This happens when the environment is captured at compilation time, for example, in the module body, and then used to evaluate code after the module has been defined.","ref":"Macro.Env.html#prune_compile_info/1","source_doc":"Prunes compile information from the environment.\n\nThis happens when the environment is captured at compilation\ntime, for example, in the module body, and then used to\nevaluate code after the module has been defined.\n","title":"Macro.Env.prune_compile_info/1","type":"function"},{"doc":"Returns true if the given module has been required. Examples iex&gt; Macro.Env . required? ( __ENV__ , Integer ) false iex&gt; require Integer iex&gt; Macro.Env . required? ( __ENV__ , Integer ) true iex&gt; Macro.Env . required? ( __ENV__ , Kernel ) true","ref":"Macro.Env.html#required?/2","source_doc":"Returns true if the given module has been required.\n\n## Examples\n\n    iex> Macro.Env.required?(__ENV__, Integer)\n    false\n    iex> require Integer\n    iex> Macro.Env.required?(__ENV__, Integer)\n    true\n\n    iex> Macro.Env.required?(__ENV__, Kernel)\n    true\n","title":"Macro.Env.required?/2","type":"function"},{"doc":"Returns the environment stacktrace.","ref":"Macro.Env.html#stacktrace/1","source_doc":"Returns the environment stacktrace.\n","title":"Macro.Env.stacktrace/1","type":"function"},{"doc":"Returns a Macro.Env in the match context.","ref":"Macro.Env.html#to_match/1","source_doc":"Returns a `Macro.Env` in the match context.\n","title":"Macro.Env.to_match/1","type":"function"},{"doc":"Returns a list of variables in the current environment. Each variable is identified by a tuple of two elements, where the first element is the variable name as an atom and the second element is its context, which may be an atom or an integer.","ref":"Macro.Env.html#vars/1","source_doc":"Returns a list of variables in the current environment.\n\nEach variable is identified by a tuple of two elements,\nwhere the first element is the variable name as an atom\nand the second element is its context, which may be an\natom or an integer.\n","title":"Macro.Env.vars/1","type":"function"},{"doc":"","ref":"Macro.Env.html#t:context/0","source_doc":false,"title":"Macro.Env.context/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:context_modules/0","source_doc":false,"title":"Macro.Env.context_modules/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:file/0","source_doc":false,"title":"Macro.Env.file/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:line/0","source_doc":false,"title":"Macro.Env.line/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:name_arity/0","source_doc":false,"title":"Macro.Env.name_arity/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:t/0","source_doc":false,"title":"Macro.Env.t/0","type":"type"},{"doc":"","ref":"Macro.Env.html#t:variable/0","source_doc":false,"title":"Macro.Env.variable/0","type":"type"},{"doc":"Mechanism for handling behaviours. This module is deprecated. Instead of defcallback/1 and defmacrocallback/1 , the @callback and @macrocallback module attributes can be used respectively. See the documentation for Module for more information on these attributes. Instead of MyModule.__behaviour__(:callbacks) , MyModule.behaviour_info(:callbacks) can be used.","ref":"Behaviour.html","source_doc":"Mechanism for handling behaviours.\n\nThis module is deprecated. Instead of `defcallback/1` and\n`defmacrocallback/1`, the `@callback` and `@macrocallback`\nmodule attributes can be used respectively. See the\ndocumentation for `Module` for more information on these\nattributes.\n\nInstead of `MyModule.__behaviour__(:callbacks)`,\n`MyModule.behaviour_info(:callbacks)` can be used.\n","title":"Behaviour","type":"module"},{"doc":"Defines a function callback according to the given type specification.","ref":"Behaviour.html#defcallback/1","source_doc":"Defines a function callback according to the given type specification.\n","title":"Behaviour.defcallback/1","type":"macro"},{"doc":"Defines a macro callback according to the given type specification.","ref":"Behaviour.html#defmacrocallback/1","source_doc":"Defines a macro callback according to the given type specification.\n","title":"Behaviour.defmacrocallback/1","type":"macro"},{"doc":"Generic API for dictionaries. If you need a general dictionary, use the Map module. If you need to manipulate keyword lists, use Keyword . To convert maps into keywords and vice-versa, use the new function in the respective modules.","ref":"Dict.html","source_doc":"Generic API for dictionaries.\n\nIf you need a general dictionary, use the `Map` module.\nIf you need to manipulate keyword lists, use `Keyword`.\n\nTo convert maps into keywords and vice-versa, use the\n`new` function in the respective modules.\n","title":"Dict","type":"module"},{"doc":"","ref":"Dict.html#delete/2","source_doc":false,"title":"Dict.delete/2","type":"function"},{"doc":"","ref":"Dict.html#drop/2","source_doc":false,"title":"Dict.drop/2","type":"function"},{"doc":"","ref":"Dict.html#empty/1","source_doc":false,"title":"Dict.empty/1","type":"function"},{"doc":"","ref":"Dict.html#equal?/2","source_doc":false,"title":"Dict.equal?/2","type":"function"},{"doc":"","ref":"Dict.html#fetch/2","source_doc":false,"title":"Dict.fetch/2","type":"function"},{"doc":"","ref":"Dict.html#fetch!/2","source_doc":false,"title":"Dict.fetch!/2","type":"function"},{"doc":"","ref":"Dict.html#get/3","source_doc":false,"title":"Dict.get/3","type":"function"},{"doc":"","ref":"Dict.html#get_and_update/3","source_doc":false,"title":"Dict.get_and_update/3","type":"function"},{"doc":"","ref":"Dict.html#get_lazy/3","source_doc":false,"title":"Dict.get_lazy/3","type":"function"},{"doc":"","ref":"Dict.html#has_key?/2","source_doc":false,"title":"Dict.has_key?/2","type":"function"},{"doc":"","ref":"Dict.html#keys/1","source_doc":false,"title":"Dict.keys/1","type":"function"},{"doc":"","ref":"Dict.html#merge/2","source_doc":false,"title":"Dict.merge/2","type":"function"},{"doc":"","ref":"Dict.html#merge/3","source_doc":false,"title":"Dict.merge/3","type":"function"},{"doc":"","ref":"Dict.html#pop/3","source_doc":false,"title":"Dict.pop/3","type":"function"},{"doc":"","ref":"Dict.html#pop_lazy/3","source_doc":false,"title":"Dict.pop_lazy/3","type":"function"},{"doc":"","ref":"Dict.html#put/3","source_doc":false,"title":"Dict.put/3","type":"function"},{"doc":"","ref":"Dict.html#put_new/3","source_doc":false,"title":"Dict.put_new/3","type":"function"},{"doc":"","ref":"Dict.html#put_new_lazy/3","source_doc":false,"title":"Dict.put_new_lazy/3","type":"function"},{"doc":"","ref":"Dict.html#size/1","source_doc":false,"title":"Dict.size/1","type":"function"},{"doc":"","ref":"Dict.html#split/2","source_doc":false,"title":"Dict.split/2","type":"function"},{"doc":"","ref":"Dict.html#take/2","source_doc":false,"title":"Dict.take/2","type":"function"},{"doc":"","ref":"Dict.html#to_list/1","source_doc":false,"title":"Dict.to_list/1","type":"function"},{"doc":"","ref":"Dict.html#update/4","source_doc":false,"title":"Dict.update/4","type":"function"},{"doc":"","ref":"Dict.html#update!/3","source_doc":false,"title":"Dict.update!/3","type":"function"},{"doc":"","ref":"Dict.html#values/1","source_doc":false,"title":"Dict.values/1","type":"function"},{"doc":"","ref":"Dict.html#t:key/0","source_doc":false,"title":"Dict.key/0","type":"type"},{"doc":"","ref":"Dict.html#t:t/0","source_doc":false,"title":"Dict.t/0","type":"type"},{"doc":"","ref":"Dict.html#t:value/0","source_doc":false,"title":"Dict.value/0","type":"type"},{"doc":"An event manager with event handlers behaviour. If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use :gen_event instead. Alternatives There are a few suitable alternatives to replace GenEvent. Each of them can be the most beneficial based on the use case. Supervisor and GenServers One alternative to GenEvent is a very minimal solution consisting of using a supervisor and multiple GenServers started under it. The supervisor acts as the &quot;event manager&quot; and the children GenServers act as the &quot;event handlers&quot;. This approach has some shortcomings (it provides no backpressure for example) but can still replace GenEvent for low-profile usages of it. This blog post by José Valim has more detailed information on this approach. GenStage If the use case where you were using GenEvent requires more complex logic, GenStage provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the GenStage documentation for more information. :gen_event If your use case requires exactly what GenEvent provided, or you have to integrate with an existing :gen_event -based system, you can still use the :gen_event Erlang module.","ref":"GenEvent.html","source_doc":"An event manager with event handlers behaviour.\n\nIf you are interested in implementing an event manager, please read the\n\"Alternatives\" section below. If you have to implement an event handler to\nintegrate with an existing system, such as Elixir's Logger, please use\n[`:gen_event`](`:gen_event`) instead.\n\n## Alternatives\n\nThere are a few suitable alternatives to replace GenEvent. Each of them can be\nthe most beneficial based on the use case.\n\n### Supervisor and GenServers\n\nOne alternative to GenEvent is a very minimal solution consisting of using a\nsupervisor and multiple GenServers started under it. The supervisor acts as\nthe \"event manager\" and the children GenServers act as the \"event handlers\".\nThis approach has some shortcomings (it provides no backpressure for example)\nbut can still replace GenEvent for low-profile usages of it. [This blog post\nby José\nValim](http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/)\nhas more detailed information on this approach.\n\n### GenStage\n\nIf the use case where you were using GenEvent requires more complex logic,\n[GenStage](https://github.com/elixir-lang/gen_stage) provides a great\nalternative. GenStage is an external Elixir library maintained by the Elixir\nteam; it provides a tool to implement systems that exchange events in a\ndemand-driven way with built-in support for backpressure. See the [GenStage\ndocumentation](https://hexdocs.pm/gen_stage) for more information.\n\n### `:gen_event`\n\nIf your use case requires exactly what GenEvent provided, or you have to\nintegrate with an existing `:gen_event`-based system, you can still use the\n[`:gen_event`](`:gen_event`) Erlang module.\n","title":"GenEvent","type":"behaviour"},{"doc":"","ref":"GenEvent.html#c:code_change/3","source_doc":false,"title":"GenEvent.code_change/3","type":"callback"},{"doc":"","ref":"GenEvent.html#c:handle_call/2","source_doc":false,"title":"GenEvent.handle_call/2","type":"callback"},{"doc":"","ref":"GenEvent.html#c:handle_event/2","source_doc":false,"title":"GenEvent.handle_event/2","type":"callback"},{"doc":"","ref":"GenEvent.html#c:handle_info/2","source_doc":false,"title":"GenEvent.handle_info/2","type":"callback"},{"doc":"","ref":"GenEvent.html#c:init/1","source_doc":false,"title":"GenEvent.init/1","type":"callback"},{"doc":"","ref":"GenEvent.html#c:terminate/2","source_doc":false,"title":"GenEvent.terminate/2","type":"callback"},{"doc":"","ref":"GenEvent.html#t:handler/0","source_doc":false,"title":"GenEvent.handler/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:manager/0","source_doc":false,"title":"GenEvent.manager/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:name/0","source_doc":false,"title":"GenEvent.name/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:on_start/0","source_doc":false,"title":"GenEvent.on_start/0","type":"type"},{"doc":"","ref":"GenEvent.html#t:options/0","source_doc":false,"title":"GenEvent.options/0","type":"type"},{"doc":"Tuple-based HashDict implementation. This module is deprecated. Use the Map module instead.","ref":"HashDict.html","source_doc":"Tuple-based HashDict implementation.\n\nThis module is deprecated. Use the `Map` module instead.\n","title":"HashDict","type":"module"},{"doc":"","ref":"HashDict.html#delete/2","source_doc":false,"title":"HashDict.delete/2","type":"function"},{"doc":"","ref":"HashDict.html#drop/2","source_doc":false,"title":"HashDict.drop/2","type":"function"},{"doc":"","ref":"HashDict.html#equal?/2","source_doc":false,"title":"HashDict.equal?/2","type":"function"},{"doc":"","ref":"HashDict.html#fetch/2","source_doc":false,"title":"HashDict.fetch/2","type":"function"},{"doc":"","ref":"HashDict.html#fetch!/2","source_doc":false,"title":"HashDict.fetch!/2","type":"function"},{"doc":"","ref":"HashDict.html#get/3","source_doc":false,"title":"HashDict.get/3","type":"function"},{"doc":"","ref":"HashDict.html#get_and_update/3","source_doc":false,"title":"HashDict.get_and_update/3","type":"function"},{"doc":"","ref":"HashDict.html#get_lazy/3","source_doc":false,"title":"HashDict.get_lazy/3","type":"function"},{"doc":"","ref":"HashDict.html#has_key?/2","source_doc":false,"title":"HashDict.has_key?/2","type":"function"},{"doc":"","ref":"HashDict.html#keys/1","source_doc":false,"title":"HashDict.keys/1","type":"function"},{"doc":"","ref":"HashDict.html#merge/3","source_doc":false,"title":"HashDict.merge/3","type":"function"},{"doc":"Creates a new empty dict.","ref":"HashDict.html#new/0","source_doc":"Creates a new empty dict.\n","title":"HashDict.new/0","type":"function"},{"doc":"","ref":"HashDict.html#pop/3","source_doc":false,"title":"HashDict.pop/3","type":"function"},{"doc":"","ref":"HashDict.html#pop_lazy/3","source_doc":false,"title":"HashDict.pop_lazy/3","type":"function"},{"doc":"","ref":"HashDict.html#put/3","source_doc":false,"title":"HashDict.put/3","type":"function"},{"doc":"","ref":"HashDict.html#put_new/3","source_doc":false,"title":"HashDict.put_new/3","type":"function"},{"doc":"","ref":"HashDict.html#put_new_lazy/3","source_doc":false,"title":"HashDict.put_new_lazy/3","type":"function"},{"doc":"","ref":"HashDict.html#size/1","source_doc":false,"title":"HashDict.size/1","type":"function"},{"doc":"","ref":"HashDict.html#split/2","source_doc":false,"title":"HashDict.split/2","type":"function"},{"doc":"","ref":"HashDict.html#take/2","source_doc":false,"title":"HashDict.take/2","type":"function"},{"doc":"","ref":"HashDict.html#to_list/1","source_doc":false,"title":"HashDict.to_list/1","type":"function"},{"doc":"","ref":"HashDict.html#update/4","source_doc":false,"title":"HashDict.update/4","type":"function"},{"doc":"","ref":"HashDict.html#update!/3","source_doc":false,"title":"HashDict.update!/3","type":"function"},{"doc":"","ref":"HashDict.html#values/1","source_doc":false,"title":"HashDict.values/1","type":"function"},{"doc":"","ref":"HashDict.html#t:t/0","source_doc":false,"title":"HashDict.t/0","type":"opaque"},{"doc":"Tuple-based HashSet implementation. This module is deprecated. Use the MapSet module instead.","ref":"HashSet.html","source_doc":"Tuple-based HashSet implementation.\n\nThis module is deprecated. Use the `MapSet` module instead.\n","title":"HashSet","type":"module"},{"doc":"","ref":"HashSet.html#delete/2","source_doc":false,"title":"HashSet.delete/2","type":"function"},{"doc":"","ref":"HashSet.html#difference/2","source_doc":false,"title":"HashSet.difference/2","type":"function"},{"doc":"","ref":"HashSet.html#disjoint?/2","source_doc":false,"title":"HashSet.disjoint?/2","type":"function"},{"doc":"","ref":"HashSet.html#equal?/2","source_doc":false,"title":"HashSet.equal?/2","type":"function"},{"doc":"","ref":"HashSet.html#intersection/2","source_doc":false,"title":"HashSet.intersection/2","type":"function"},{"doc":"","ref":"HashSet.html#member?/2","source_doc":false,"title":"HashSet.member?/2","type":"function"},{"doc":"","ref":"HashSet.html#new/0","source_doc":false,"title":"HashSet.new/0","type":"function"},{"doc":"","ref":"HashSet.html#put/2","source_doc":false,"title":"HashSet.put/2","type":"function"},{"doc":"","ref":"HashSet.html#size/1","source_doc":false,"title":"HashSet.size/1","type":"function"},{"doc":"","ref":"HashSet.html#subset?/2","source_doc":false,"title":"HashSet.subset?/2","type":"function"},{"doc":"","ref":"HashSet.html#to_list/1","source_doc":false,"title":"HashSet.to_list/1","type":"function"},{"doc":"","ref":"HashSet.html#union/2","source_doc":false,"title":"HashSet.union/2","type":"function"},{"doc":"","ref":"HashSet.html#t:t/0","source_doc":false,"title":"HashSet.t/0","type":"opaque"},{"doc":"Generic API for sets. This module is deprecated, use the MapSet module instead.","ref":"Set.html","source_doc":"Generic API for sets.\n\nThis module is deprecated, use the `MapSet` module instead.\n","title":"Set","type":"module"},{"doc":"","ref":"Set.html#delete/2","source_doc":false,"title":"Set.delete/2","type":"function"},{"doc":"","ref":"Set.html#difference/2","source_doc":false,"title":"Set.difference/2","type":"function"},{"doc":"","ref":"Set.html#disjoint?/2","source_doc":false,"title":"Set.disjoint?/2","type":"function"},{"doc":"","ref":"Set.html#empty/1","source_doc":false,"title":"Set.empty/1","type":"function"},{"doc":"","ref":"Set.html#equal?/2","source_doc":false,"title":"Set.equal?/2","type":"function"},{"doc":"","ref":"Set.html#intersection/2","source_doc":false,"title":"Set.intersection/2","type":"function"},{"doc":"","ref":"Set.html#member?/2","source_doc":false,"title":"Set.member?/2","type":"function"},{"doc":"","ref":"Set.html#put/2","source_doc":false,"title":"Set.put/2","type":"function"},{"doc":"","ref":"Set.html#size/1","source_doc":false,"title":"Set.size/1","type":"function"},{"doc":"","ref":"Set.html#subset?/2","source_doc":false,"title":"Set.subset?/2","type":"function"},{"doc":"","ref":"Set.html#to_list/1","source_doc":false,"title":"Set.to_list/1","type":"function"},{"doc":"","ref":"Set.html#union/2","source_doc":false,"title":"Set.union/2","type":"function"},{"doc":"","ref":"Set.html#t:t/0","source_doc":false,"title":"Set.t/0","type":"type"},{"doc":"","ref":"Set.html#t:value/0","source_doc":false,"title":"Set.value/0","type":"type"},{"doc":"","ref":"Set.html#t:values/0","source_doc":false,"title":"Set.values/0","type":"type"},{"doc":"Outdated functions for building child specifications. The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the Supervisor documentation instead. Convenience functions for defining supervisor specifications. Example By using the functions in this module one can specify the children to be used under a supervisor, started with Supervisor.start_link/2 : import Supervisor.Spec children = [ worker ( MyWorker , [ arg1 , arg2 , arg3 ] ) , supervisor ( MySupervisor , [ arg1 ] ) ] Supervisor . start_link ( children , strategy : :one_for_one ) Sometimes, it may be handy to define supervisors backed by a module: defmodule MySupervisor do use Supervisor def start_link ( arg ) do Supervisor . start_link ( __MODULE__ , arg ) end def init ( arg ) do children = [ worker ( MyWorker , [ arg ] , restart : :temporary ) ] supervise ( children , strategy : :simple_one_for_one ) end end Note that in this case we don't have to explicitly import Supervisor.Spec since use Supervisor automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the Supervisor.init/1 callback. Supervisor and worker options In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options: :id - a name used to identify the child specification internally by the supervisor; defaults to the given module name for the child worker/supervisor :function - the function to invoke on the child to start it :restart - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below) :shutdown - an atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below) :modules - it should be a list with one element [module] , where module is the name of the callback module only if the child process is a Supervisor or GenServer ; if the child process is a GenEvent , :modules should be :dynamic Restart values (:restart) The following restart values are supported in the :restart option: :permanent - the child process is always restarted :temporary - the child process is never restarted (not even when the supervisor's strategy is :rest_for_one or :one_for_all ) :transient - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than :normal , :shutdown or {:shutdown, term} Note that supervisor that reached maximum restart intensity will exit with :shutdown reason. In this case the supervisor will only restart if its child specification was defined with the :restart option set to :permanent (the default). Shutdown values ( :shutdown ) The following shutdown values are supported in the :shutdown option: :brutal_kill - the child process is unconditionally terminated using Process.exit(child, :kill) :infinity - if the child process is a supervisor, this is a mechanism to give the subtree enough time to shut down; it can also be used with workers with care a non-negative integer - the amount of time in milliseconds that the supervisor tells the child process to terminate by calling Process.exit(child, :shutdown) and then waits for an exit signal back. If no exit signal is received within the specified time, the child process is unconditionally terminated using Process.exit(child, :kill)","ref":"Supervisor.Spec.html","source_doc":"Outdated functions for building child specifications.\n\nThe functions in this module are deprecated and they do not work\nwith the module-based child specs introduced in Elixir v1.5.\nPlease see the `Supervisor` documentation instead.\n\nConvenience functions for defining supervisor specifications.\n\n## Example\n\nBy using the functions in this module one can specify the children\nto be used under a supervisor, started with `Supervisor.start_link/2`:\n\n    import Supervisor.Spec\n\n    children = [\n      worker(MyWorker, [arg1, arg2, arg3]),\n      supervisor(MySupervisor, [arg1])\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_one)\n\nSometimes, it may be handy to define supervisors backed\nby a module:\n\n    defmodule MySupervisor do\n      use Supervisor\n\n      def start_link(arg) do\n        Supervisor.start_link(__MODULE__, arg)\n      end\n\n      def init(arg) do\n        children = [\n          worker(MyWorker, [arg], restart: :temporary)\n        ]\n\n        supervise(children, strategy: :simple_one_for_one)\n      end\n    end\n\nNote that in this case we don't have to explicitly import\n`Supervisor.Spec` since `use Supervisor` automatically does so.\nDefining a module-based supervisor can be useful, for example,\nto perform initialization tasks in the `c:Supervisor.init/1` callback.\n\n## Supervisor and worker options\n\nIn the example above, we defined specs for workers and supervisors.\nThese specs (both for workers as well as supervisors) accept the\nfollowing options:\n\n  * `:id` - a name used to identify the child specification\n    internally by the supervisor; defaults to the given module\n    name for the child worker/supervisor\n\n  * `:function` - the function to invoke on the child to start it\n\n  * `:restart` - an atom that defines when a terminated child process should\n    be restarted (see the \"Restart values\" section below)\n\n  * `:shutdown` - an atom that defines how a child process should be\n    terminated (see the \"Shutdown values\" section below)\n\n  * `:modules` - it should be a list with one element `[module]`,\n    where module is the name of the callback module only if the\n    child process is a `Supervisor` or `GenServer`; if the child\n    process is a `GenEvent`, `:modules` should be `:dynamic`\n\n### Restart values (:restart)\n\nThe following restart values are supported in the `:restart` option:\n\n  * `:permanent` - the child process is always restarted\n\n  * `:temporary` - the child process is never restarted (not even\n    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n\n  * `:transient` - the child process is restarted only if it\n    terminates abnormally, i.e., with an exit reason other than\n    `:normal`, `:shutdown` or `{:shutdown, term}`\n\nNote that supervisor that reached maximum restart intensity will exit with `:shutdown` reason.\nIn this case the supervisor will only restart if its child specification was defined with\nthe `:restart` option set to `:permanent` (the default).\n\n### Shutdown values (`:shutdown`)\n\nThe following shutdown values are supported in the `:shutdown` option:\n\n  * `:brutal_kill` - the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`\n\n  * `:infinity` - if the child process is a supervisor, this is a mechanism\n    to give the subtree enough time to shut down; it can also be used with\n    workers with care\n\n  * a non-negative integer - the amount of time in milliseconds\n    that the supervisor tells the child process to terminate by calling\n    `Process.exit(child, :shutdown)` and then waits for an exit signal back.\n    If no exit signal is received within the specified time,\n    the child process is unconditionally terminated\n    using `Process.exit(child, :kill)`\n\n","title":"Supervisor.Spec","type":"module"},{"doc":"Receives a list of children (workers or supervisors) to supervise and a set of options . Returns a tuple containing the supervisor specification. This tuple can be used as the return value of the Supervisor.init/1 callback when implementing a module-based supervisor. Examples supervise ( children , strategy : :one_for_one ) Options :strategy - the restart strategy option. It can be either :one_for_one , :rest_for_one , :one_for_all , or :simple_one_for_one . You can learn more about strategies in the Supervisor module docs. :max_restarts - the maximum number of restarts allowed in a time frame. Defaults to 3 . :max_seconds - the time frame in which :max_restarts applies. Defaults to 5 . The :strategy option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the Supervisor module for a detailed description of the available strategies.","ref":"Supervisor.Spec.html#supervise/2","source_doc":"Receives a list of `children` (workers or supervisors) to\nsupervise and a set of `options`.\n\nReturns a tuple containing the supervisor specification. This tuple can be\nused as the return value of the `c:Supervisor.init/1` callback when implementing a\nmodule-based supervisor.\n\n## Examples\n\n    supervise(children, strategy: :one_for_one)\n\n## Options\n\n  * `:strategy` - the restart strategy option. It can be either\n    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n    `:simple_one_for_one`. You can learn more about strategies\n    in the `Supervisor` module docs.\n\n  * `:max_restarts` - the maximum number of restarts allowed in\n    a time frame. Defaults to `3`.\n\n  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n    Defaults to `5`.\n\nThe `:strategy` option is required and by default a maximum of 3 restarts is\nallowed within 5 seconds. Check the `Supervisor` module for a detailed\ndescription of the available strategies.\n","title":"Supervisor.Spec.supervise/2","type":"function"},{"doc":"Defines the given module as a supervisor which will be started with the given arguments. supervisor ( module , [ ] , restart : :permanent ) By default, the function start_link is invoked on the given module. Overall, the default values for the options are: [ id : module , function : :start_link , restart : :permanent , shutdown : :infinity , modules : [ module ] ] See the &quot;Supervisor and worker options&quot; section in the Supervisor.Spec module for more information on the available options.","ref":"Supervisor.Spec.html#supervisor/3","source_doc":"Defines the given `module` as a supervisor which will be started\nwith the given arguments.\n\n    supervisor(module, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: :infinity,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.\n","title":"Supervisor.Spec.supervisor/3","type":"function"},{"doc":"Defines the given module as a worker which will be started with the given arguments. worker ( ExUnit.Runner , [ ] , restart : :permanent ) By default, the function start_link is invoked on the given module. Overall, the default values for the options are: [ id : module , function : :start_link , restart : :permanent , shutdown : 5000 , modules : [ module ] ] See the &quot;Supervisor and worker options&quot; section in the Supervisor.Spec module for more information on the available options.","ref":"Supervisor.Spec.html#worker/3","source_doc":"Defines the given `module` as a worker which will be started\nwith the given arguments.\n\n    worker(ExUnit.Runner, [], restart: :permanent)\n\nBy default, the function `start_link` is invoked on the given\nmodule. Overall, the default values for the options are:\n\n    [\n      id: module,\n      function: :start_link,\n      restart: :permanent,\n      shutdown: 5000,\n      modules: [module]\n    ]\n\nSee the \"Supervisor and worker options\" section in the `Supervisor.Spec` module for more\ninformation on the available options.\n","title":"Supervisor.Spec.worker/3","type":"function"},{"doc":"Supported ID values","ref":"Supervisor.Spec.html#t:child_id/0","source_doc":"Supported ID values","title":"Supervisor.Spec.child_id/0","type":"type"},{"doc":"Supported module values","ref":"Supervisor.Spec.html#t:modules/0","source_doc":"Supported module values","title":"Supervisor.Spec.modules/0","type":"type"},{"doc":"Supported restart values","ref":"Supervisor.Spec.html#t:restart/0","source_doc":"Supported restart values","title":"Supervisor.Spec.restart/0","type":"type"},{"doc":"Supported shutdown values","ref":"Supervisor.Spec.html#t:shutdown/0","source_doc":"Supported shutdown values","title":"Supervisor.Spec.shutdown/0","type":"type"},{"doc":"The supervisor specification","ref":"Supervisor.Spec.html#t:spec/0","source_doc":"The supervisor specification","title":"Supervisor.Spec.spec/0","type":"type"},{"doc":"Supported strategies","ref":"Supervisor.Spec.html#t:strategy/0","source_doc":"Supported strategies","title":"Supervisor.Spec.strategy/0","type":"type"},{"doc":"Supported worker values","ref":"Supervisor.Spec.html#t:worker/0","source_doc":"Supported worker values","title":"Supervisor.Spec.worker/0","type":"type"},{"doc":"","ref":"ArgumentError.html","source_doc":false,"title":"ArgumentError","type":"exception"},{"doc":"","ref":"ArithmeticError.html","source_doc":false,"title":"ArithmeticError","type":"exception"},{"doc":"","ref":"BadArityError.html","source_doc":false,"title":"BadArityError","type":"exception"},{"doc":"","ref":"BadBooleanError.html","source_doc":false,"title":"BadBooleanError","type":"exception"},{"doc":"","ref":"BadFunctionError.html","source_doc":false,"title":"BadFunctionError","type":"exception"},{"doc":"","ref":"BadMapError.html","source_doc":false,"title":"BadMapError","type":"exception"},{"doc":"","ref":"BadStructError.html","source_doc":false,"title":"BadStructError","type":"exception"},{"doc":"","ref":"CaseClauseError.html","source_doc":false,"title":"CaseClauseError","type":"exception"},{"doc":"","ref":"Code.LoadError.html","source_doc":false,"title":"Code.LoadError","type":"exception"},{"doc":"","ref":"CompileError.html","source_doc":false,"title":"CompileError","type":"exception"},{"doc":"","ref":"CondClauseError.html","source_doc":false,"title":"CondClauseError","type":"exception"},{"doc":"","ref":"Enum.EmptyError.html","source_doc":false,"title":"Enum.EmptyError","type":"exception"},{"doc":"","ref":"Enum.OutOfBoundsError.html","source_doc":false,"title":"Enum.OutOfBoundsError","type":"exception"},{"doc":"","ref":"ErlangError.html","source_doc":false,"title":"ErlangError","type":"exception"},{"doc":"","ref":"File.CopyError.html","source_doc":false,"title":"File.CopyError","type":"exception"},{"doc":"","ref":"File.Error.html","source_doc":false,"title":"File.Error","type":"exception"},{"doc":"","ref":"File.LinkError.html","source_doc":false,"title":"File.LinkError","type":"exception"},{"doc":"","ref":"File.RenameError.html","source_doc":false,"title":"File.RenameError","type":"exception"},{"doc":"","ref":"FunctionClauseError.html","source_doc":false,"title":"FunctionClauseError","type":"exception"},{"doc":"","ref":"IO.StreamError.html","source_doc":false,"title":"IO.StreamError","type":"exception"},{"doc":"Raised when a struct cannot be inspected.","ref":"Inspect.Error.html","source_doc":"Raised when a struct cannot be inspected.\n","title":"Inspect.Error","type":"exception"},{"doc":"","ref":"Kernel.TypespecError.html","source_doc":false,"title":"Kernel.TypespecError","type":"exception"},{"doc":"","ref":"KeyError.html","source_doc":false,"title":"KeyError","type":"exception"},{"doc":"","ref":"MatchError.html","source_doc":false,"title":"MatchError","type":"exception"},{"doc":"","ref":"Module.Types.Error.html","source_doc":false,"title":"Module.Types.Error","type":"exception"},{"doc":"","ref":"OptionParser.ParseError.html","source_doc":false,"title":"OptionParser.ParseError","type":"exception"},{"doc":"","ref":"Protocol.UndefinedError.html","source_doc":false,"title":"Protocol.UndefinedError","type":"exception"},{"doc":"","ref":"Regex.CompileError.html","source_doc":false,"title":"Regex.CompileError","type":"exception"},{"doc":"","ref":"RuntimeError.html","source_doc":false,"title":"RuntimeError","type":"exception"},{"doc":"","ref":"SyntaxError.html","source_doc":false,"title":"SyntaxError","type":"exception"},{"doc":"","ref":"System.EnvError.html","source_doc":false,"title":"System.EnvError","type":"exception"},{"doc":"","ref":"SystemLimitError.html","source_doc":false,"title":"SystemLimitError","type":"exception"},{"doc":"","ref":"TokenMissingError.html","source_doc":false,"title":"TokenMissingError","type":"exception"},{"doc":"","ref":"TryClauseError.html","source_doc":false,"title":"TryClauseError","type":"exception"},{"doc":"","ref":"URI.Error.html","source_doc":false,"title":"URI.Error","type":"exception"},{"doc":"","ref":"UndefinedFunctionError.html","source_doc":false,"title":"UndefinedFunctionError","type":"exception"},{"doc":"","ref":"UnicodeConversionError.html","source_doc":false,"title":"UnicodeConversionError","type":"exception"},{"doc":"","ref":"Version.InvalidRequirementError.html","source_doc":false,"title":"Version.InvalidRequirementError","type":"exception"},{"doc":"","ref":"Version.InvalidVersionError.html","source_doc":false,"title":"Version.InvalidVersionError","type":"exception"},{"doc":"","ref":"WithClauseError.html","source_doc":false,"title":"WithClauseError","type":"exception"},{"doc":"Elixir is versioned according to a vMAJOR.MINOR.PATCH schema. Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches. Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches: Elixir version Support 1.15 Development 1.14 Bug fixes and security patches 1.13 Security patches only 1.12 Security patches only 1.11 Security patches only 1.10 Security patches only New releases are announced in the read-only announcements mailing list . All security releases will be tagged with [security] . There are currently no plans for a major v2 release.","ref":"compatibility-and-deprecations.html","source_doc":"# Compatibility and Deprecations\n\nElixir is versioned according to a vMAJOR.MINOR.PATCH schema.\n\nElixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.\n\nElixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:\n\nElixir version | Support\n:------------- | :-----------------------------\n1.15           | Development\n1.14           | Bug fixes and security patches\n1.13           | Security patches only\n1.12           | Security patches only\n1.11           | Security patches only\n1.10           | Security patches only\n\nNew releases are announced in the read-only [announcements mailing list](https://groups.google.com/group/elixir-lang-ann). All security releases [will be tagged with `[security]`](https://groups.google.com/forum/#!searchin/elixir-lang-ann/%5Bsecurity%5D%7Csort:date).\n\nThere are currently no plans for a major v2 release.","title":"Compatibility and Deprecations","type":"extras"},{"doc":"Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions. Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code: Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues. Bugs: if an API has undesired behaviour, a program that depends on the buggy behaviour may break if the bug is fixed. We reserve the right to fix such bugs. Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with --warning-as-errors ) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements. Imports: new functions may be added to the Kernel module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using import Kernel, except: [...] with a list of all functions you don't want to be imported from Kernel . We reserve the right to do such additions. In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &quot;Deprecations&quot; section . The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.","ref":"compatibility-and-deprecations.html#compatibility-between-non-major-elixir-versions","source_doc":"Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions.\n\nAlthough we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:\n\n  * Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues.\n\n  * Bugs: if an API has undesired behaviour, a program that depends on the buggy behaviour may break if the bug is fixed. We reserve the right to fix such bugs.\n\n  * Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with `--warning-as-errors`) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements.\n\n  * Imports: new functions may be added to the `Kernel` module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using `import Kernel, except: [...]` with a list of all functions you don't want to be imported from `Kernel`. We reserve the right to do such additions.\n\nIn order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the [\"Deprecations\" section](#deprecations).\n\nThe only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.","title":"Compatibility and Deprecations - Compatibility between non-major Elixir versions","type":"extras"},{"doc":"Erlang/OTP versioning is independent from the versioning of Elixir. Erlang releases a new major version yearly. Our goal is to support the last three Erlang major versions by the time Elixir is released. The compatibility table is shown below. Elixir version Supported Erlang/OTP versions 1.15 24 - 26 1.14 23 - 25 1.13 22 - 24 (and Erlang/OTP 25 from v1.13.4) 1.12 22 - 24 1.11 21 - 23 (and Erlang/OTP 24 from v1.11.4) 1.10 21 - 22 (and Erlang/OTP 23 from v1.10.3) 1.9 20 - 22 1.8 20 - 22 1.7 19 - 22 1.6 19 - 20 (and Erlang/OTP 21 from v1.6.6) 1.5 18 - 20 1.4 18 - 19 (and Erlang/OTP 20 from v1.4.5) 1.3 18 - 19 1.2 18 - 18 (and Erlang/OTP 19 from v1.2.6) 1.1 17 - 18 1.0 17 - 17 (and Erlang/OTP 18 from v1.0.5) Elixir may add compatibility to new Erlang/OTP versions on patch releases, such as support for Erlang/OTP 20 in v1.4.5. Those releases are made for convenience and typically contain the minimum changes for Elixir to run without errors, if any changes are necessary. Only the next minor release, in this case v1.5.0, effectively leverages the new features provided by the latest Erlang/OTP release.","ref":"compatibility-and-deprecations.html#compatibility-between-elixir-and-erlang-otp","source_doc":"Erlang/OTP versioning is independent from the versioning of Elixir. Erlang releases a new major version yearly. Our goal is to support the last three Erlang major versions by the time Elixir is released. The compatibility table is shown below.\n\nElixir version | Supported Erlang/OTP versions\n:------------- | :-------------------------------\n1.15           | 24 - 26\n1.14           | 23 - 25\n1.13           | 22 - 24 (and Erlang/OTP 25 from v1.13.4)\n1.12           | 22 - 24\n1.11           | 21 - 23 (and Erlang/OTP 24 from v1.11.4)\n1.10           | 21 - 22 (and Erlang/OTP 23 from v1.10.3)\n1.9            | 20 - 22\n1.8            | 20 - 22\n1.7            | 19 - 22\n1.6            | 19 - 20 (and Erlang/OTP 21 from v1.6.6)\n1.5            | 18 - 20\n1.4            | 18 - 19 (and Erlang/OTP 20 from v1.4.5)\n1.3            | 18 - 19\n1.2            | 18 - 18 (and Erlang/OTP 19 from v1.2.6)\n1.1            | 17 - 18\n1.0            | 17 - 17 (and Erlang/OTP 18 from v1.0.5)\n\nElixir may add compatibility to new Erlang/OTP versions on patch releases, such as support for Erlang/OTP 20 in v1.4.5. Those releases are made for convenience and typically contain the minimum changes for Elixir to run without errors, if any changes are necessary. Only the next minor release, in this case v1.5.0, effectively leverages the new features provided by the latest Erlang/OTP release.","title":"Compatibility and Deprecations - Compatibility between Elixir and Erlang/OTP","type":"extras"},{"doc":"Policy Elixir deprecations happen in 3 steps: The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature. The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, Enum.uniq/2 was soft-deprecated in favor of Enum.uniq_by/2 in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later. The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x. Table of deprecations The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from. Version Deprecated feature Replaced by (available since) v1.15 Calendar.ISO.day_of_week/3 Calendar.ISO.day_of_week/4 (v1.11) v1.15 Exception.exception?/1 Kernel.is_exception/1 (v1.11) v1.15 Regex.regex?/1 Kernel.is_struct/2 (v1.11) v1.15 Logger.warn/2 Logger.warning/2 (v1.11) v1.14 use Bitwise import Bitwise (v1.0) v1.14 ~~~/1 bnot/2 (v1.0) v1.14 Application.get_env/3 and similar in module body Application.compile_env/3 (v1.10) v1.14 Compiled patterns in String.starts_with?/2 Pass a list of strings instead (v1.0) v1.14 Mix.Tasks.Xref.calls/1 Compilation tracers (outlined in Code ) (v1.10) v1.14 $levelpad in Logger None v1.14 &lt;|&gt; as a custom operator Another custom operator (v1.0) v1.13 ! and != in Version requirements ~&gt; or &gt;= (v1.0) v1.13 Mix.Config Config (v1.9) v1.13 :strip_beam config to mix escript.build :strip_beams (v1.9) v1.13 Macro.to_string/2 Macro.to_string/1 (v1.0) v1.13 System.get_pid/0 System.pid/0 (v1.9) v1.12 ^^^/2 bxor/2 (v1.0) v1.12 @foo() to read module attributes Remove the parenthesis (v1.0) v1.12 use EEx.Engine Explicitly delegate to EEx.Engine instead (v1.0) v1.12 :xref compiler in Mix Nothing (it always runs as part of the compiler now) v1.11 Mix.Project.compile/2 Mix.Task.run(&quot;compile&quot;, args) (v1.0) v1.11 Supervisor.Spec.worker/3 and Supervisor.Spec.supervisor/3 The new child specs outlined in Supervisor (v1.5) v1.11 Supervisor.start_child/2 and Supervisor.terminate_child/2 DynamicSupervisor (v1.6) v1.11 System.stacktrace/1 __STACKTRACE__ in try/catch/rescue (v1.7) v1.10 Code.ensure_compiled?/1 Code.ensure_compiled/1 (v1.0) v1.10 Code.load_file/2 Code.require_file/2 (v1.0) or Code.compile_file/2 (v1.7) v1.10 Code.loaded_files/0 Code.required_files/0 (v1.7) v1.10 Code.unload_file/1 Code.unrequire_files/1 (v1.7) v1.10 Passing non-chardata to Logger.log/2 Explicitly convert to string with to_string/1 (v1.0) v1.10 :compile_time_purge_level in Logger app environment :compile_time_purge_matching in Logger app environment (v1.7) v1.10 Supervisor.Spec.supervise/2 The new child specs outlined in Supervisor (v1.5) v1.10 :simple_one_for_one strategy in Supervisor DynamicSupervisor (v1.6) v1.10 :restart and :shutdown in Task.Supervisor.start_link/1 :restart and :shutdown in Task.Supervisor.start_child/3 (v1.6) v1.9 Enumerable keys in Map.drop/2 , Map.split/2 , and Map.take/2 Call Enum.to_list/1 on the second argument before hand (v1.0) v1.9 Mix.Project.load_paths/1 Mix.Project.compile_path/1 (v1.0) v1.9 Passing :insert_replaced to String.replace/4 Use :binary.replace/4 (v1.0) v1.8 Passing a non-empty list to Collectable.into/1 ++/2 or Keyword.merge/2 (v1.0) v1.8 Passing a non-empty list to :into in for/1 ++/2 or Keyword.merge/2 (v1.0) v1.8 Passing a non-empty list to Enum.into/2 ++/2 or Keyword.merge/2 (v1.0) v1.8 Time units in its plural form, such as: :seconds , :milliseconds , and the like Use the singular form, such as: :second , :millisecond , and so on (v1.4) v1.8 Inspect.Algebra.surround/3 Inspect.Algebra.concat/2 and Inspect.Algebra.nest/2 (v1.0) v1.8 Inspect.Algebra.surround_many/6 Inspect.Algebra.container_doc/6 (v1.6) v1.9 --detached in Kernel.CLI --erl &quot;-detached&quot; (v1.0) v1.8 Kernel.ParallelCompiler.files/2 Kernel.ParallelCompiler.compile/2 (v1.6) v1.8 Kernel.ParallelCompiler.files_to_path/2 Kernel.ParallelCompiler.compile_to_path/2 (v1.6) v1.8 Kernel.ParallelRequire.files/2 Kernel.ParallelCompiler.require/2 (v1.6) v1.8 Returning {:ok, contents} or :error from Mix.Compilers.Erlang.compile/6 's callback Return {:ok, contents, warnings} or {:error, errors, warnings} (v1.6) v1.8 System.cwd/0 and System.cwd!/0 File.cwd/0 and File.cwd!/0 (v1.0) v1.7 Code.get_docs/2 Code.fetch_docs/1 (v1.7) v1.7 Enum.chunk/2,3,4 Enum.chunk_every/2 and Enum.chunk_every/3,4 (v1.5) v1.7 Calling super/1 in GenServer callbacks Implementing the behaviour explicitly without calling super/1 (v1.0) v1.7 not left in right left not in right (v1.5) v1.7 Registry.start_link/3 Registry.start_link/1 (v1.5) v1.7 Stream.chunk/2,3,4 Stream.chunk_every/2 and Stream.chunk_every/3,4 (v1.5) v1.6 Enum.partition/2 Enum.split_with/2 (v1.4) v1.6 Macro.unescape_tokens/1,2 Use Enum.map/2 to traverse over the arguments (v1.0) v1.6 Module.add_doc/6 @doc module attribute (v1.0) v1.6 Range.range?/1 Pattern match on _.._ (v1.0) v1.5 () to mean nil nil (v1.0) v1.5 char_list/0 type charlist/0 type (v1.3) v1.5 Atom.to_char_list/1 Atom.to_charlist/1 (v1.3) v1.5 Enum.filter_map/3 Enum.filter/2 + Enum.map/2 or for/1 comprehensions (v1.0) v1.5 Float.to_char_list/1 Float.to_charlist/1 (v1.3) v1.5 GenEvent module Supervisor and GenServer (v1.0);&lt;br/&gt; GenStage (v1.3);&lt;br/&gt; :gen_event (Erlang/OTP 17) v1.5 &lt;%= in middle and end expressions in EEx Use &lt;% ( &lt;%= is allowed only in start expressions) (v1.0) v1.5 :as_char_lists value in Inspect.Opts.t/0 type :as_charlists value (v1.3) v1.5 :char_lists key in Inspect.Opts.t/0 type :charlists key (v1.3) v1.5 Integer.to_char_list/1,2 Integer.to_charlist/1 and Integer.to_charlist/2 (v1.3) v1.5 to_char_list/1 to_charlist/1 (v1.3) v1.5 List.Chars.to_char_list/1 List.Chars.to_charlist/1 (v1.3) v1.5 @compile {:parse_transform, _} in Module None v1.5 Stream.filter_map/3 Stream.filter/2 + Stream.map/2 (v1.0) v1.5 String.ljust/3 and String.rjust/3 Use String.pad_leading/3 and String.pad_trailing/3 with a binary padding (v1.3) v1.5 String.lstrip/1 and String.rstrip/1 String.trim_leading/1 and String.trim_trailing/1 (v1.3) v1.5 String.lstrip/2 and String.rstrip/2 Use String.trim_leading/2 and String.trim_trailing/2 with a binary as second argument (v1.3) v1.5 String.strip/1 and String.strip/2 String.trim/1 and String.trim/2 (v1.3) v1.5 String.to_char_list/1 String.to_charlist/1 (v1.3) v1.4 Anonymous functions with no expression after -&gt; Use an expression or explicitly return nil (v1.0) v1.4 Support for making private functions overridable Use public functions (v1.0) v1.4 Variable used as function call Use parentheses (v1.0) v1.4 Access.key/1 Access.key/2 (v1.3) v1.4 Behaviour module @callback module attribute (v1.0) v1.4 Enum.uniq/2 Enum.uniq_by/2 (v1.2) v1.4 Float.to_char_list/2 :erlang.float_to_list/2 (Erlang/OTP 17) v1.4 Float.to_string/2 :erlang.float_to_binary/2 (Erlang/OTP 17) v1.4 HashDict module Map (v1.2) v1.4 HashSet module MapSet (v1.1) v1.4 IEx.Helpers.import_file/2 IEx.Helpers.import_file_if_available/1 (v1.3) v1.4 Mix.Utils.camelize/1 Macro.camelize/1 (v1.2) v1.4 Mix.Utils.underscore/1 Macro.underscore/1 (v1.2) v1.4 Multi-letter aliases in OptionParser Use single-letter aliases (v1.0) v1.4 Set module MapSet (v1.1) v1.4 Stream.uniq/2 Stream.uniq_by/2 (v1.2) v1.3 \\x{X*} inside strings/sigils/charlists \\uXXXX or \\u{X*} (v1.1) v1.3 Dict module Keyword (v1.0) or Map (v1.2) v1.3 :append_first option in defdelegate/2 Define the function explicitly (v1.0) v1.3 Map/dictionary as 2nd argument in Enum.group_by/3 Enum.reduce/3 (v1.0) v1.3 Keyword.size/1 length/1 (v1.0) v1.3 Map.size/1 map_size/1 (v1.0) v1.3 /r option in Regex /U (v1.1) v1.3 Set behaviour MapSet data structure (v1.1) v1.3 String.valid_character?/1 String.valid?/1 (v1.0) v1.3 Task.find/2 Use direct message matching (v1.0) v1.3 Non-map as 2nd argument in URI.decode_query/2 Use a map (v1.0) v1.2 Dict behaviour Map and Keyword (v1.0) v1.1 ?\\xHEX 0xHEX (v1.0) v1.1 Access protocol Access behaviour (v1.1) v1.1 as: true | false in alias/2 and require/2 None","ref":"compatibility-and-deprecations.html#deprecations","source_doc":"#","title":"Compatibility and Deprecations - Deprecations","type":"extras"},{"doc":"This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.","ref":"library-guidelines.html","source_doc":"# Library Guidelines\n\nThis document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.","title":"Library Guidelines","type":"extras"},{"doc":"You can create a new Elixir library by running the mix new command: $ mix new my_library The project name is given in the snake_case convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the Naming Conventions document for more information. Every project has a mix.exs file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a lib directory, which includes Elixir source code, and a test directory. A src directory may also exist for Erlang sources. For more information on running your project, see the official Mix &amp; OTP guide or Mix documentation . Applications with supervision tree The mix new command also allows the --sup option to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.","ref":"library-guidelines.html#getting-started","source_doc":"You can create a new Elixir library by running the `mix new` command:\n\n    $ mix new my_library\n\nThe project name is given in the `snake_case` convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the [Naming Conventions](naming-conventions.md) document for more information.\n\nEvery project has a `mix.exs` file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a `lib` directory, which includes Elixir source code, and a `test` directory. A `src` directory may also exist for Erlang sources.\n\nFor more information on running your project, see the official [Mix & OTP guide](https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html) or [Mix documentation](https://hexdocs.pm/mix/Mix.html).\n\n#","title":"Library Guidelines - Getting started","type":"extras"},{"doc":"Writing code is only the first of many steps to publish a package. We strongly recommend developers to: Choose a versioning schema. Elixir requires versions to be in the format MAJOR.MINOR.PATCH but the meaning of those numbers is up to you. Most projects choose Semantic Versioning . Choose a license . The most common licenses in the Elixir community are the MIT License and the Apache License 2.0 . The latter is also the one used by Elixir itself. Run the code formatter . The code formatter formats your code according to a consistent style shared by your library and the whole community, making it easier for other developers to understand your code and contribute. Write tests. Elixir ships with a test-framework named ExUnit . The project generated by mix new includes sample tests and doctests. Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the Writing Documentation guide for more information. Projects like ExDoc can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports &quot;extra pages&quot;, like this one that you are reading. Such pages augment the documentation with tutorials, guides and references. Projects are often made available to other developers by publishing a Hex package . Hex also supports private packages for organizations . If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to HexDocs .","ref":"library-guidelines.html#publishing","source_doc":"The `mix new` command also allows the `--sup` option to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.","title":"Library Guidelines - Publishing","type":"extras"},{"doc":"When your library is published and used as a dependency, its lockfile (usually named mix.lock ) is ignored by the host project . Running mix deps.get in the host project attempts to get the latest possible versions of your library’s dependencies, as specified by the requirements in the deps section of your mix.exs . These versions might be greater than those stored in your mix.lock (and hence used in your tests / CI). On the other hand, contributors of your library, need a deterministic build, which implies the presence of mix.lock in your Version Control System (VCS). The best practice of handling mix.lock file therefore would be to keep it in VCS, and run two different Continuous Integration (CI) workflows: the usual deterministic one, and another one, that starts with mix deps.unlock --all and always compiles your library and runs tests against latest versions of dependencies. The latter one might be even run nightly or otherwise recurrently to stay notified about any possible issue in regard to dependencies updates.","ref":"library-guidelines.html#dependency-handling","source_doc":"Writing code is only the first of many steps to publish a package. We strongly recommend developers to:\n\n  * Choose a versioning schema. Elixir requires versions to be in the format `MAJOR.MINOR.PATCH` but the meaning of those numbers is up to you. Most projects choose [Semantic Versioning](https://semver.org/).\n\n  * Choose a [license](https://choosealicense.com/). The most common licenses in the Elixir community are the [MIT License](https://choosealicense.com/licenses/mit/) and the [Apache License 2.0](https://choosealicense.com/licenses/apache-2.0/). The latter is also the one used by Elixir itself.\n\n  * Run the [code formatter](https://hexdocs.pm/mix/Mix.Tasks.Format.html). The code formatter formats your code according to a consistent style shared by your library and the whole community, making it easier for other developers to understand your code and contribute.\n\n  * Write tests. Elixir ships with a test-framework named [ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html). The project generated by `mix new` includes sample tests and doctests.\n\n  * Write documentation. The Elixir community is proud of treating documentation as a first-class citizen and making documentation easily accessible. Libraries contribute to the status quo by providing complete API documentation with examples for their modules, types and functions. See the [Writing Documentation](writing-documentation.md) guide for more information. Projects like [ExDoc](https://github.com/elixir-lang/ex_doc) can be used to generate HTML and EPUB documents from the documentation. ExDoc also supports \"extra pages\", like this one that you are reading. Such pages augment the documentation with tutorials, guides and references.\n\nProjects are often made available to other developers [by publishing a Hex package](https://hex.pm/docs/publish). Hex also [supports private packages for organizations](https://hex.pm/pricing). If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to [HexDocs](https://hexdocs.pm).","title":"Library Guidelines - Dependency handling","type":"extras"},{"doc":"In this section we document common anti-patterns to avoid when writing libraries. Avoid using exceptions for control-flow You should avoid using exceptions for control-flow. For example, instead of: try do contents = File . read! ( &quot;some_path_that_may_or_may_not_exist&quot; ) { :it_worked , contents } rescue File.Error -&gt; :it_failed end you should prefer: case File . read ( &quot;some_path_that_may_or_may_not_exist&quot; ) do { :ok , contents } -&gt; { :it_worked , contents }   { :error , _ } -&gt; :it_failed end As a library author, it is your responsibility to make sure users are not required to use exceptions for control-flow in their applications. You can follow the same convention as Elixir here, using the name without ! for returning :ok / :error tuples and appending ! for a version of the function which raises an exception. It is important to note that a name without ! does not mean a function will never raise. For example, even File.read/1 can fail in case of bad arguments: iex&gt; File . read ( 1 ) ** (FunctionClauseError) no function clause matching in IO.chardata_to_string/1 The usage of :ok / :error tuples is about the domain that the function works on, in this case, file system access. Bad arguments, logical errors, invalid options should raise regardless of the function name. If in doubt, prefer to return tuples instead of raising, as users of your library can always match on the results and raise if necessary. Avoid working with invalid data Elixir programs should prefer to validate data as close to the end user as possible, so the errors are easy to locate and fix. This practice also saves you from writing defensive code in the internals of the library. For example, imagine you have an API that receives a filename as a binary. At some point you will want to write to this file. You could have a function like this: def my_fun ( some_arg , file_to_write_to , options \\\\ [ ] ) do ... some code ... AnotherModuleInLib . invoke_something_that_will_eventually_write_to_file ( file_to_write_to ) ... more code ... end The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with. A better function definition would be: def my_fun ( some_arg , file_to_write_to , options \\\\ [ ] ) when is_binary ( file_to_write_to ) do Elixir also leverages pattern matching and guards in function clauses to provide clear error messages in case invalid arguments are given. This advice does not only apply to libraries, but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a GenServer that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms. Avoid application configuration You should avoid using the application environment (see Application.get_env/2 ) as the configuration mechanism for libraries. The application environment is global which means it becomes impossible for two dependencies to use your library in two different ways. Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash - character: defmodule DashSplitter do def split ( string ) when is_binary ( string ) do String . split ( string , &quot;-&quot; , parts : 2 ) end end Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment: def split ( string ) when is_binary ( string ) do parts = Application . get_env ( :dash_splitter , :parts , 2 ) String . split ( string , &quot;-&quot; , parts : parts ) end Now users can configure your library in their config/config.exs file as follows: config :dash_splitter , :parts , 3 Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts. The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could expect keyword lists as a new argument: def split ( string , opts \\\\ [ ] ) when is_binary ( string ) and is_list ( opts ) do parts = Keyword . get ( opts , :parts , 2 ) String . split ( string , &quot;-&quot; , parts : parts ) end In case you need to configure a process, the options should be passed when starting that process. The application environment should be reserved only for configurations that are truly global, for example, to control your application boot process and its supervision tree. And, generally speaking, it is best to avoid global configuration. If you must use configuration, then prefer runtime configuration instead of compile-time configuration. See the Application module for more information. For all remaining scenarios, libraries should not force their users to use the application environment for configuration. If the user of a library believes that certain parameter should be configured globally, then they can wrap the library functionality with their own application environment configuration. Avoid defining modules that are not in your &quot;namespace&quot; Even though Elixir does not formally have the concept of namespaces, a library should use its name as a &quot;prefix&quot; for all of its modules (except for special cases like mix tasks). For example, if the library's OTP application name is :my_lib , then all of its modules should start with the MyLib prefix, for example MyLib.User , MyLib.SubModule , and MyLib.Application . This is important because the Erlang VM can only load one instance of a module at a time. So if there are multiple libraries that define the same module, then they are incompatible with each other due to this limitation. By always using the library name as a prefix, it avoids module name clashes due to the unique prefix. Furthermore, when writing a library that is an extension of another library, you should avoid defining modules inside the parent's library namespace. For example, if you are writing a package that adds authentication to Plug called plug_auth , its modules should be namespaced under PlugAuth instead of Plug.Auth , so it avoids conflicts with Plug if it were to ever define its own authentication functionality. Avoid use when an import is enough A library should not provide use MyLib functionality if all use MyLib does is to import / alias the module itself. For example, this is an anti-pattern: defmodule MyLib do defmacro __using__ ( _ ) do quote do import MyLib end end def some_fun ( arg1 , arg2 ) do ... end end The reason why defining the __using__ macro above should be avoided is because when a developer writes: defmodule MyApp do use MyLib end It allows use MyLib to run any code into the MyApp module. For someone reading the code, it is impossible to assess the impact that use MyLib has in a module without looking at the implementation of __using__ . The following code is clearer: defmodule MyApp do import MyLib end The code above says we are only bringing in the functions from MyLib so we can invoke some_fun(arg1, arg2) directly without the MyLib. prefix. Even more important, import MyLib says that we have an option to not import MyLib at all as we can simply invoke the function as MyLib.some_fun(arg1, arg2) . If the module you want to invoke a function on has a long name, such as SomeLibrary.Namespace.MyLib , and you find it verbose, you can leverage the alias/2 special form and still refer to the module as MyLib . While there are situations where use SomeModule is necessary, use should be skipped when all it does is to import or alias other modules. In a nutshell, alias should be preferred, as it is simpler and clearer than import , while import is simpler and clearer than use . Avoid macros Although the previous section could be summarized as &quot;avoid macros&quot;, both topics are important enough to deserve their own sections. To quote the official guide on macros : Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it's considered to be bad style to use them when they're not necessary. So write macros responsibly. Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that explicit is better than implicit . Clear code is better than concise code . When you absolutely have to use a macro, make sure that a macro is not the only way the user can interface with your library and keep the amount of code generated by a macro to a minimum. For example, the Logger module provides Logger.debug/2 , Logger.info/2 and friends as macros that are capable of extracting environment information, but a low-level mechanism for logging is still available with Logger.bare_log/3 . Avoid using processes for code organization A developer must never use a process for code organization purposes. A process must be used to model runtime properties such as: Mutable state and access to shared resources (such as ETS, files, and others) Concurrency and distribution Initialization, shutdown and restart logic (as seen in supervisors) System messages such as timer messages and monitoring events In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer : def add ( a , b ) do GenServer . call ( __MODULE__ , { :add , a , b } ) end def handle_call ( { :add , a , b } , _from , state ) do { :reply , a + b , state } end def handle_call ( { :subtract , a , b } , _from , state ) do { :reply , a - b , state } end This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead, just define the functions directly: def add ( a , b ) do a + b end def subtract ( a , b ) do a - b end Use processes only to model runtime properties, never for code organization. And even when you think something could be done in parallel with processes, often it is best to let the callers of your library decide how to parallelize, rather than impose a certain execution flow in users of your code. Avoid spawning unsupervised processes You should avoid spawning processes outside of a supervision tree, especially long-running ones. Instead, processes must be started inside supervision trees. This guarantees developers have full control over the initialization, restarts, and shutdown of the system. If your application does not have a supervision tree, one can be added by changing def application inside mix.exs to include a :mod key with the application callback name: def application do [ extra_applications : [ :logger ] , mod : { MyApp.Application , [ ] } ] end and then defining a my_app/application.ex file with the following template: defmodule MyApp.Application do # See https://hexdocs.pm/elixir/Application.html # for more information on OTP Applications @moduledoc false use Application def start ( _type , _args ) do children = [ # Starts a worker by calling: MyApp.Worker.start_link(arg) # {MyApp.Worker, arg} ] # See https://hexdocs.pm/elixir/Supervisor.html # for other strategies and supported options opts = [ strategy : :one_for_one , name : MyApp.Supervisor ] Supervisor . start_link ( children , opts ) end end This is the same template generated by mix new --sup . Each process started with the application must be listed as a child under the Supervisor above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the DynamicSupervisor module. One of the few times where it is acceptable to start a process outside of a supervision tree is with Task.async/1 and Task.await/2 . Opposite to Task.start_link/1 , the async/await mechanism gives you full control over the spawned process life cycle - which is also why you must always call Task.await/2 after starting a task with Task.async/1 . Even though, if your application is spawning multiple async processes, you should consider using Task.Supervisor for better visibility when instrumenting and monitoring the system.","ref":"library-guidelines.html#anti-patterns","source_doc":"When your library is published and used as a dependency, its [lockfile](https://hexdocs.pm/mix/Mix.Project.html#module-configuration) (usually named `mix.lock`) is _ignored by the host project_. Running `mix deps.get` in the host project attempts to get the latest possible versions of your library’s dependencies, as specified by the requirements in the `deps` section of your `mix.exs`. These versions might be greater than those stored in your `mix.lock` (and hence used in your tests / CI).\n\nOn the other hand, contributors of your library, need a deterministic build, which implies the presence of `mix.lock` in your Version Control System (VCS).\n\nThe best practice of handling `mix.lock` file therefore would be to keep it in VCS, and run two different Continuous Integration (CI) workflows: the usual deterministic one, and another one, that starts with `mix deps.unlock --all` and always compiles your library and runs tests against latest versions of dependencies. The latter one might be even run nightly or otherwise recurrently to stay notified about any possible issue in regard to dependencies updates.","title":"Library Guidelines - Anti-patterns","type":"extras"},{"doc":"This document is an overview of the naming conventions in Elixir, from casing to punctuation characters. See Syntax reference for a complete description of the naming rules and allowed characters.","ref":"naming-conventions.html","source_doc":"# Naming Conventions\n\nThis document is an overview of the naming conventions in Elixir, from casing to punctuation characters. See [Syntax reference](syntax-reference.md) for a complete description of the naming rules and allowed characters.","title":"Naming Conventions","type":"extras"},{"doc":"Elixir developers must use snake_case when defining variables, function names, module attributes, and the like: some_map = %{ this_is_a_key : &quot;and a value&quot; } is_map ( some_map ) Aliases, commonly used as module names, are an exception as they must be capitalized and written in CamelCase , like OptionParser . For aliases, capital letters are kept in acronyms, like ExUnit.CaptureIO or Mix.SCM . Atoms can be written either in :snake_case or :CamelCase , although the convention is to use the snake case version throughout Elixir. Generally speaking, filenames follow the snake_case convention of the module they define. For example, MyApp should be defined inside the my_app.ex file. However, this is only a convention. At the end of the day any filename can be used as they do not affect the compiled code in any way.","ref":"naming-conventions.html#casing","source_doc":"Elixir developers must use `snake_case` when defining variables, function names, module attributes, and the like:\n\n    some_map = %{this_is_a_key: \"and a value\"}\n    is_map(some_map)\n\nAliases, commonly used as module names, are an exception as they must be capitalized and written in `CamelCase`, like `OptionParser`. For aliases, capital letters are kept in acronyms, like `ExUnit.CaptureIO` or `Mix.SCM`.\n\nAtoms can be written either in `:snake_case` or `:CamelCase`, although the convention is to use the snake case version throughout Elixir.\n\nGenerally speaking, filenames follow the `snake_case` convention of the module they define. For example, `MyApp` should be defined inside the `my_app.ex` file. However, this is only a convention. At the end of the day any filename can be used as they do not affect the compiled code in any way.","title":"Naming Conventions - Casing","type":"extras"},{"doc":"Elixir relies on underscores in different situations. For example, a value that is not meant to be used must be assigned to _ or to a variable starting with underscore: iex&gt; { :ok , _contents } = File . read ( &quot;README.md&quot; ) Function names may also start with an underscore. Such functions are never imported by default: iex&gt; defmodule Example do ...&gt; def _wont_be_imported do ...&gt; :oops ...&gt; end ...&gt; end iex&gt; import Example iex&gt; _wont_be_imported ( ) ** (CompileError) iex:1: undefined function _wont_be_imported/0 Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the __foo__ format. For example, every module in Elixir has an __info__/1 function: iex&gt; String . __info__ ( :functions ) [ at : 2 , capitalize : 1 , chunk : 2 , ... ] Elixir also includes five special forms that follow the double underscore format: __CALLER__/0 , __DIR__/0 , __ENV__/0 and __MODULE__/0 retrieve compile-time information about the current environment, while __STACKTRACE__/0 retrieves the stacktrace for the current exception.","ref":"naming-conventions.html#underscore-_foo","source_doc":"Elixir relies on underscores in different situations.\n\nFor example, a value that is not meant to be used must be assigned to `_` or to a variable starting with underscore:\n\n    iex> {:ok, _contents} = File.read(\"README.md\")\n\nFunction names may also start with an underscore. Such functions are never imported by default:\n\n    iex> defmodule Example do\n    ...>   def _wont_be_imported do\n    ...>     :oops\n    ...>   end\n    ...> end\n\n    iex> import Example\n    iex> _wont_be_imported()\n    ** (CompileError) iex:1: undefined function _wont_be_imported/0\n\nDue to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the `__foo__` format. For example, every module in Elixir has an [`__info__/1`](`c:Module.__info__/1`) function:\n\n    iex> String.__info__(:functions)\n    [at: 2, capitalize: 1, chunk: 2, ...]\n\nElixir also includes five special forms that follow the double underscore format: `__CALLER__/0`, `__DIR__/0`, `__ENV__/0`and `__MODULE__/0` retrieve compile-time information about the current environment, while `__STACKTRACE__/0` retrieves the stacktrace for the current exception.","title":"Naming Conventions - Underscore (_foo)","type":"extras"},{"doc":"A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception. Many functions come in pairs, such as File.read/1 and File.read!/1 . File.read/1 will return a success or failure tuple, whereas File.read!/1 will return a plain value or else raise an exception: iex&gt; File . read ( &quot;file.txt&quot; ) { :ok , &quot;file contents&quot; } iex&gt; File . read ( &quot;no_such_file.txt&quot; ) { :error , :enoent } iex&gt; File . read! ( &quot;file.txt&quot; ) &quot;file contents&quot; iex&gt; File . read! ( &quot;no_such_file.txt&quot; ) ** (File.Error) could not read file no_such_file.txt: no such file or directory The version without ! is preferred when you want to handle different outcomes using pattern matching: case File . read ( file ) do { :ok , body } -&gt; # do something with the `body` { :error , reason } -&gt; # handle the error caused by `reason` end However, if you expect the outcome to always be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure. More examples of paired functions: Base.decode16/2 and Base.decode16!/2 , File.cwd/0 and File.cwd!/0 . There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: Protocol.assert_protocol!/1 . In macro code, the bang on alias!/1 and var!/2 signifies that macro hygiene is set aside.","ref":"naming-conventions.html#trailing-bang-foo","source_doc":"A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception.\n\nMany functions come in pairs, such as `File.read/1` and `File.read!/1`. `File.read/1` will return a success or failure tuple, whereas `File.read!/1` will return a plain value or else raise an exception:\n\n    iex> File.read(\"file.txt\")\n    {:ok, \"file contents\"}\n    iex> File.read(\"no_such_file.txt\")\n    {:error, :enoent}\n\n    iex> File.read!(\"file.txt\")\n    \"file contents\"\n    iex> File.read!(\"no_such_file.txt\")\n    ** (File.Error) could not read file no_such_file.txt: no such file or directory\n\nThe version without `!` is preferred when you want to handle different outcomes using pattern matching:\n\n    case File.read(file) do\n      {:ok, body}      -> # do something with the `body`\n      {:error, reason} -> # handle the error caused by `reason`\n    end\n\nHowever, if you expect the outcome to always be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.\n\nMore examples of paired functions: `Base.decode16/2` and `Base.decode16!/2`, `File.cwd/0` and `File.cwd!/0`.\n\nThere are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: `Protocol.assert_protocol!/1`.\n\nIn macro code, the bang on `alias!/1` and `var!/2` signifies that [macro hygiene](https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene) is set aside.","title":"Naming Conventions - Trailing bang (foo!)","type":"extras"},{"doc":"Functions that return a boolean are named with a trailing question mark. Examples: Keyword.keyword?/1 , Mix.debug?/0 , String.contains?/2 However, functions that return booleans and are valid in guards follow another convention, described next.","ref":"naming-conventions.html#trailing-question-mark-foo","source_doc":"Functions that return a boolean are named with a trailing question mark.\n\nExamples: `Keyword.keyword?/1`, `Mix.debug?/0`, `String.contains?/2`\n\nHowever, functions that return booleans and are valid in guards follow another convention, described next.\n\n## `is_` prefix (`is_foo`)\n\nType checks and other boolean checks that are allowed in guard clauses are named with an `is_` prefix.\n\nExamples: `Integer.is_even/1`, `is_list/1`\n\nThese functions and macros follow the Erlang convention of an `is_` prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses.\n\nNote that type checks that are not valid in guard clauses do not follow this convention. For example: `Keyword.keyword?/1`.","title":"Naming Conventions - Trailing question mark (foo?)","type":"extras"},{"doc":"Type checks and other boolean checks that are allowed in guard clauses are named with an is_ prefix. Examples: Integer.is_even/1 , is_list/1 These functions and macros follow the Erlang convention of an is_ prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses. Note that type checks that are not valid in guard clauses do not follow this convention. For example: Keyword.keyword?/1 .","ref":"naming-conventions.html#is_-prefix-is_foo","source_doc":"Some names have specific meaning in Elixir. We detail those cases below.\n\n#","title":"Naming Conventions - is_ prefix (is_foo)","type":"extras"},{"doc":"Some names have specific meaning in Elixir. We detail those cases below. length and size When you see size in a function name, it means the operation runs in constant time (also written as &quot;O(1) time&quot;) because the size is stored alongside the data structure. Examples: map_size/1 , tuple_size/1 When you see length , the operation runs in linear time (&quot;O(n) time&quot;) because the entire data structure has to be traversed. Examples: length/1 , String.length/1 In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.","ref":"naming-conventions.html#special-names","source_doc":"When you see `size` in a function name, it means the operation runs in constant time (also written as \"O(1) time\") because the size is stored alongside the data structure.\n\nExamples: `map_size/1`, `tuple_size/1`\n\nWhen you see `length`, the operation runs in linear time (\"O(n) time\") because the entire data structure has to be traversed.\n\nExamples: `length/1`, `String.length/1`\n\nIn other words, functions using the word \"size\" in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having \"length\" in its name will take more time as the data structure grows in size.","title":"Naming Conventions - Special names","type":"extras"},{"doc":"This document is a complete reference of operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.","ref":"operators.html","source_doc":"# Operators\n\nThis document is a complete reference of operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.","title":"Operators","type":"extras"},{"doc":"The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity: Operator Associativity @ Unary . Left + - ! ^ not Unary ** Left * / Left + - Left ++ -- +++ --- .. &lt;&gt; Right in not in Left |&gt; &lt;&lt;&lt; &gt;&gt;&gt; &lt;&lt;~ ~&gt;&gt; &lt;~ ~&gt; &lt;~&gt; Left &lt; &gt; &lt;= &gt;= Left == != =~ === !== Left &amp;&amp; &amp;&amp;&amp; and Left || ||| or Left = Right &amp; Unary =&gt; (valid only inside %{} ) Right | Right :: Right when Right &lt;- \\\\ Left","ref":"operators.html#operator-precedence-and-associativity","source_doc":"The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:\n\nOperator                                       | Associativity\n---------------------------------------------- | -------------\n`@`                                            | Unary\n`.`                                            | Left\n`+` `-` `!` `^` `not`                          | Unary\n`**`                                           | Left\n`*` `/`                                        | Left\n`+` `-`                                        | Left\n`++` `--` `+++` `---` `..` `<>`                | Right\n`in` `not in`                                  | Left\n`\\|>` `<<<` `>>>` `<<~` `~>>` `<~` `~>` `<~>`  | Left\n`<` `>` `<=` `>=`                              | Left\n`==` `!=` `=~` `===` `!==`                     | Left\n`&&` `&&&` `and`                               | Left\n`\\|\\|` `\\|\\|\\|` `or`                           | Left\n`=`                                            | Right\n`&`                                            | Unary\n`=>` (valid only inside `%{}`)                 | Right\n`\\|`                                           | Right\n`::`                                           | Right\n`when`                                         | Right\n`<-` `\\\\`                                      | Left","title":"Operators - Operator precedence and associativity","type":"extras"},{"doc":"Elixir provides the following built-in operators: + and - - unary positive/negative + , - , * , and / - basic arithmetic operations ++ and -- - list concatenation and subtraction and and &amp;&amp; - strict and relaxed boolean &quot;and&quot; or and || - strict and relaxed boolean &quot;or&quot; not and ! - strict and relaxed boolean &quot;not&quot; in and not in - membership @ - module attribute .. , .. , and ..// - range creation &lt;&gt; - binary concatenation |&gt; - pipeline =~ - text-based match Many of those can be used in guards; consult the list of allowed guard functions and operators . Additionally, there are a few other operators that Elixir parses but doesn't actually use. See Custom and overridden operators below for a list and for guidelines about their use. Some other operators are special forms and cannot be overridden: ^ - pin operator . - dot operator = - match operator &amp; - capture operator :: - type operator Finally, these operators appear in the precedence table above but are only meaningful within certain constructs: =&gt; - see %{} when - see Guards &lt;- - see for and with \\\\ - see Default arguments","ref":"operators.html#general-operators","source_doc":"Elixir provides the following built-in operators:\n\n  * [`+`](`+/1`) and [`-`](`-/1`) - unary positive/negative\n  * [`+`](`+/2`), [`-`](`-/2`), [`*`](`*/2`), and [`/`](`//2`) - basic arithmetic operations\n  * [`++`](`++/2`) and [`--`](`--/2`) - list concatenation and subtraction\n  * [`and`](`and/2`) and [`&&`](`&&/2`) - strict and relaxed boolean \"and\"\n  * [`or`](`or/2`) and [`||`](`||/2`) - strict and relaxed boolean \"or\"\n  * [`not`](`not/1`) and [`!`](`!/1`) - strict and relaxed boolean \"not\"\n  * [`in`](`in/2`) and [`not in`](`in/2`) - membership\n  * [`@`](`@/1`) - module attribute\n  * [`..`](`../0`), [`..`](`../2`), and [`..//`](`..///3`) - range creation\n  * [`<>`](`<>/2`) - binary concatenation\n  * [`|>`](`|>/2`) - pipeline\n  * [`=~`](`=~/2`) - text-based match\n\nMany of those can be used in guards; consult the [list of allowed guard functions and operators](patterns-and-guards.md#list-of-allowed-functions-and-operators).\n\nAdditionally, there are a few other operators that Elixir parses but doesn't actually use.\nSee [Custom and overridden operators](#custom-and-overridden-operators) below for a list and for guidelines about their use.\n\nSome other operators are special forms and cannot be overridden:\n\n  * [`^`](`^/1`) - pin operator\n  * [`.`](`./2`) - dot operator\n  * [`=`](`=/2`) - match operator\n  * [`&`](`&/1`) - capture operator\n  * [`::`](`::/2`) - type operator\n\nFinally, these operators appear in the precedence table above but are only meaningful within certain constructs:\n\n  * `=>` - see [`%{}`](`%{}/1`)\n  * `when` - see [Guards](patterns-and-guards.md#guards)\n  * `<-` - see [`for`](`for/1`) and [`with`](`with/1`)\n  * `\\\\` - see [Default arguments](Kernel.html#def/2-default-arguments)","title":"Operators - General operators","type":"extras"},{"doc":"Elixir provides the following built-in comparison operators (all of which can be used in guards): == - equal to === - strictly equal to != - inequal to !== - strictly inequal to &lt; - less-than &gt; - greater-than &lt;= - less-than or equal to &gt;= - greater-than or equal to The only difference between == and === is that === is strict when it comes to comparing integers and floats: iex&gt; 1 == 1.0 true iex&gt; 1 === 1.0 false != and !== act as the negation of == and === , respectively.","ref":"operators.html#comparison-operators","source_doc":"Elixir provides the following built-in comparison operators (all of which can be used in guards):\n\n  * [`==`](`==/2`) - equal to\n  * [`===`](`===/2`) - strictly equal to\n  * [`!=`](`!=/2`) - inequal to\n  * [`!==`](`!==/2`) - strictly inequal to\n  * [`<`](`</2`) - less-than\n  * [`>`](`>/2`) - greater-than\n  * [`<=`](`<=/2`) - less-than or equal to\n  * [`>=`](`>=/2`) - greater-than or equal to\n\nThe only difference between [`==`](`==/2`) and [`===`](`===/2`) is that [`===`](`===/2`) is strict when it comes to comparing integers and floats:\n\n```elixir\niex> 1 == 1.0\ntrue\niex> 1 === 1.0\nfalse\n```\n\n[`!=`](`!=/2`) and [`!==`](`!==/2`) act as the negation of [`==`](`==/2`) and [`===`](`===/2`), respectively.","title":"Operators - Comparison operators","type":"extras"},{"doc":"Defining custom operators Elixir is capable of parsing a predefined set of operators. It's not possible to define new operators (as supported by some languages). However, not all operators that Elixir can parse are used by Elixir: for example, + and || are used by Elixir for addition and boolean or , but &lt;~&gt; is not used (but valid). To define an operator, you can use the usual def* constructs ( def , defp , defmacro , and so on) but with a syntax similar to how the operator is used: defmodule MyOperators do # We define ~&gt; to return the maximum of the given two numbers, # and &lt;~ to return the minimum. def a ~&gt; b , do : max ( a , b ) def a &lt;~ b , do : min ( a , b ) end To use the newly defined operators, you have to import the module that defines them: iex&gt; import MyOperators iex&gt; 1 ~&gt; 2 2 iex&gt; 1 &lt;~ 2 1 The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default: ||| &amp;&amp;&amp; &lt;&lt;&lt; &gt;&gt;&gt; &lt;&lt;~ ~&gt;&gt; &lt;~ ~&gt; &lt;~&gt; +++ --- The following operators are used by the Bitwise module when imported: &amp;&amp;&amp; , &lt;&lt;&lt; , &gt;&gt;&gt; , and ||| . See the documentation for Bitwise for more information. Note that the Elixir community generally discourages custom operators. They can be hard to read and even more to understand, as they don't have a descriptive name like functions do. That said, some specific cases or custom domain specific languages (DSLs) may justify these practices. It is also possible to replace predefined operators, such as + , but doing so is extremely discouraged.","ref":"operators.html#custom-and-overridden-operators","source_doc":"#","title":"Operators - Custom and overridden operators","type":"extras"},{"doc":"Elixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited. This page provides a complete reference patterns and guards, their semantics, where they are allowed, and how to extend them.","ref":"patterns-and-guards.html","source_doc":"# Patterns and Guards\n\nElixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.\n\nThis page provides a complete reference patterns and guards, their semantics, where they are allowed, and how to extend them.","title":"Patterns and Guards","type":"extras"},{"doc":"Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator ( = ): iex&gt; x = 1 1 iex&gt; 1 = x 1 In the example above, x starts without a value and has 1 assigned to it. Then, we compare the value of x to the literal 1 , which succeeds as they are both 1 . Matching x against 2 would raise: iex&gt; 2 = x ** (MatchError) no match of right hand side value: 1 Patterns are not bidirectional. If you have a variable y that was never assigned to (often called an unbound variable) and you write 1 = y , an error will be raised: iex&gt; 1 = y ** (CompileError) iex:2: undefined variable &quot;y&quot; In other words, patterns are allowed only on the left side of = . The right side of = follows the regular evaluation semantics of the language. Now let's cover the pattern matching rules for each construct and then for each relevant data types. Variables Variables in patterns are always assigned to: iex&gt; x = 1 1 iex&gt; x = 2 2 iex&gt; x 2 In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator ( ^ ): iex&gt; x = 1 1 iex&gt; ^ x = 2 ** (MatchError) no match of right hand side value: 2 If the same variable appears twice in the same pattern, then they must be bound to the same value: iex&gt; { x , x } = { 1 , 1 } { 1 , 1 } iex&gt; { x , x } = { 1 , 2 } ** (MatchError) no match of right hand side value: {1, 2} The underscore variable ( _ ) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern: iex&gt; { _ , integer } = { :not_important , 1 } { :not_important , 1 } iex&gt; integer 1 iex&gt; _ ** (CompileError) iex:3: invalid use of _ Literals (numbers and atoms) Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom: iex&gt; :atom = :atom :atom iex&gt; :atom = :another_atom ** (MatchError) no match of right hand side value: :another_atom Similar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats: iex&gt; 1 = 1.0 ** (MatchError) no match of right hand side value: 1.0 Tuples Tuples may appear in patterns using the curly brackets syntax ( {} ). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match: iex&gt; { :ok , integer } = { :ok , 13 } { :ok , 13 } # won&#39;t match due to different size iex&gt; { :ok , integer } = { :ok , 11 , 13 } ** (MatchError) no match of right hand side value: {:ok, 11, 13} # won&#39;t match due to mismatch on first element iex&gt; { :ok , binary } = { :error , :enoent } ** (MatchError) no match of right hand side value: {:error, :enoent} Lists Lists may appear in patterns using the square brackets syntax ( [] ). A list in a pattern will match only lists of the same size, where each individual list element must also match: iex&gt; [ :ok , integer ] = [ :ok , 13 ] [ :ok , 13 ] # won&#39;t match due to different size iex&gt; [ :ok , integer ] = [ :ok , 11 , 13 ] ** (MatchError) no match of right hand side value: [:ok, 11, 13] # won&#39;t match due to mismatch on first element iex&gt; [ :ok , binary ] = [ :error , :enoent ] ** (MatchError) no match of right hand side value: [:error, :enoent] Opposite to tuples, lists also allow matching on non-empty lists by using the [head | tail] notation, which matches on the head and tail of a list: iex&gt; [ head | tail ] = [ 1 , 2 , 3 ] [ 1 , 2 , 3 ] iex&gt; head 1 iex&gt; tail [ 2 , 3 ] Multiple elements may prefix the | tail construct: iex&gt; [ first , second | tail ] = [ 1 , 2 , 3 ] [ 1 , 2 , 3 ] iex&gt; tail [ 3 ] Note [head | tail] does not match empty lists: iex&gt; [ head | tail ] = [ ] ** (MatchError) no match of right hand side value: [] Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator ( ++ ): iex&gt; &#39;hello &#39; ++ world = &#39;hello world&#39; &#39;hello world&#39; iex&gt; world &#39;world&#39; Which is equivalent to matching on [?h, ?e, ?l, ?l, ?o, ?\\s | world] . Suffix matches ( hello ++ ' world' ) are not valid patterns. Maps Maps may appear in patterns using the percentage sign followed by the curly brackets syntax ( %{} ). Opposite to lists and tuples, maps perform a subset match. This means a map pattern will match any other map that has at least all of the keys in the pattern. Here is an example where all keys match: iex&gt; %{ name : name } = %{ name : &quot;meg&quot; } %{ name : &quot;meg&quot; } iex&gt; name &quot;meg&quot; Here is when a subset of the keys match: iex&gt; %{ name : name } = %{ name : &quot;meg&quot; , age : 23 } %{ age : 23 , name : &quot;meg&quot; } iex&gt; name &quot;meg&quot; If a key in the pattern is not available in the map, then they won't match: iex&gt; %{ name : name , age : age } = %{ name : &quot;meg&quot; } ** (MatchError) no match of right hand side value: %{name: &quot;meg&quot;} Note that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively: iex&gt; %{ } = %{ name : &quot;meg&quot; } %{ name : &quot;meg&quot; } Finally, note map keys in patterns must always be literals or previously bound variables matched with the pin operator. Structs Structs may appear in patterns using the percentage sign, the struct module name or a variable followed by the curly brackets syntax ( %{} ). Given the following struct: defmodule User do defstruct [ :name ] end Here is an example where all keys match: iex&gt; % User { name : name } = % User { name : &quot;meg&quot; } % User { name : &quot;meg&quot; } iex&gt; name &quot;meg&quot; If an unknown key is given, the compiler will raise an error: iex&gt; % User { type : type } = % User { name : &quot;meg&quot; } ** (CompileError) iex: unknown key :type for struct User The struct name can be extracted when putting a variable instead of a module name: iex&gt; % struct_name { } = % User { name : &quot;meg&quot; } % User { name : &quot;meg&quot; } iex&gt; struct_name User Binaries Binaries may appear in patterns using the double less-than/greater-than syntax ( &lt;&lt;&gt;&gt; ). A binary in a pattern can match multiple segments at the same time, each with different type, size, and unit: iex&gt; &lt;&lt; val :: unit ( 8 ) - size ( 2 ) - integer &gt;&gt; = &lt;&lt; 123 , 56 &gt;&gt; &quot;{8&quot; iex&gt; val 31544 See the documentation for &lt;&lt;&gt;&gt; for a complete definition of pattern matching for binaries. Finally, remember that strings in Elixir are UTF-8 encoded binaries. This means that, similar to charlists, prefix matches on strings are also possible with the binary concatenation operator ( &lt;&gt; ): iex&gt; &quot;hello &quot; &lt;&gt; world = &quot;hello world&quot; &quot;hello world&quot; iex&gt; world &quot;world&quot; Suffix matches ( hello &lt;&gt; &quot; world&quot; ) are not valid patterns.","ref":"patterns-and-guards.html#patterns","source_doc":"Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator ([`=`](`=/2`)):\n\n```iex\niex> x = 1\n1\niex> 1 = x\n1\n```\n\nIn the example above, `x` starts without a value and has `1` assigned to it. Then, we compare the value of `x` to the literal `1`, which succeeds as they are both `1`.\n\nMatching `x` against 2 would raise:\n\n```iex\niex> 2 = x\n** (MatchError) no match of right hand side value: 1\n```\n\nPatterns are not bidirectional. If you have a variable `y` that was never assigned to (often called an unbound variable) and you write `1 = y`, an error will be raised:\n\n```iex\niex> 1 = y\n** (CompileError) iex:2: undefined variable \"y\"\n```\n\nIn other words, patterns are allowed only on the left side of `=`. The right side of `=` follows the regular evaluation semantics of the language.\n\nNow let's cover the pattern matching rules for each construct and then for each relevant data types.\n\n#","title":"Patterns and Guards - Patterns","type":"extras"},{"doc":"Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others. Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently. List of allowed functions and operators You can find the built-in list of guards in the Kernel module . Here is an overview: comparison operators ( == , != , === , !== , &lt; , &lt;= , &gt; , &gt;= ) strictly boolean operators ( and , or , not ). Note &amp;&amp; , || , and ! sibling operators are not allowed as they're not strictly boolean - meaning they don't require arguments to be booleans arithmetic unary operators ( + , - ) arithmetic binary operators + , - , * , / ) in and not in operators (as long as the right-hand side is a list or a range) &quot;type-check&quot; functions ( is_list/1 , is_number/1 , and the like) functions that work on built-in datatypes ( abs/1 , hd/1 , map_size/1 , and others) the map.field syntax The module Bitwise also includes a handful of Erlang bitwise operations as guards . Macros constructed out of any combination of the above guards are also valid guards - for example, Integer.is_even/1 . For more information, see the &quot;Custom patterns and guards expressions&quot; section shown below. Why guards Let's see an example of a guard used in a function clause: def empty_map? ( map ) when map_size ( map ) == 0 , do : true def empty_map? ( map ) when is_map ( map ) , do : false Guards start with the when operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns true . Multiple boolean conditions can be combined with the and and or operators. Writing the empty_map?/1 function by only using pattern matching would not be possible (as pattern matching on %{} would match any map, not only the empty ones). Failing guards A function clause will be executed if and only if its guard expression evaluates to true . If any other value is returned, the function clause will be skipped. In particular, guards have no concept of &quot;truthy&quot; or &quot;falsy&quot;. For example, imagine a function that checks that the head of a list is not nil : def not_nil_head? ( [ head | _ ] ) when head , do : true def not_nil_head? ( _ ) , do : false not_nil_head? ( [ &quot;some_value&quot; , &quot;another_value&quot; ] ) #=&gt; false Even though the head of the list is not nil , the first clause for not_nil_head?/1 fails because the expression does not evaluate to true , but to &quot;some_value&quot; , therefore triggering the second clause which returns false . To make the guard behave correctly, you must ensure that the guard evaluates to true , like so: def not_nil_head? ( [ head | _ ] ) when head != nil , do : true def not_nil_head? ( _ ) , do : false not_nil_head? ( [ &quot;some_value&quot; , &quot;another_value&quot; ] ) #=&gt; true Errors in guards In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the tuple_size/1 function only works with tuples. If we use it with anything else, an argument error is raised: iex&gt; tuple_size ( &quot;hello&quot; ) ** (ArgumentError) argument error However, when used in guards, the corresponding clause will fail to match instead of raising an error: iex&gt; case &quot;hello&quot; do ...&gt; something when tuple_size ( something ) == 2 -&gt; ...&gt; :worked ...&gt; _anything_else -&gt; ...&gt; :failed ...&gt; end :failed In many cases, we can take advantage of this. In the code above, we used tuple_size/1 to both check that the given value is a tuple and check its size (instead of using is_tuple(something) and tuple_size(something) == 2 ). However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like is_tuple/1 before tuple_size/1 , otherwise the whole guard will fail if a tuple is not given. Alternatively, your function clause can use multiple guards as shown in the following section. Multiple guards in the same clause There exists an additional way to simplify a chain of or expressions in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. The following code: def is_number_or_nil ( term ) when is_integer ( term ) or is_float ( term ) or is_nil ( term ) , do : :maybe_number def is_number_or_nil ( _other ) , do : :something_else can be alternatively written as: def is_number_or_nil ( term ) when is_integer ( term ) when is_float ( term ) when is_nil ( term ) do :maybe_number end def is_number_or_nil ( _other ) do :something_else end If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples: defmodule Check do # If given a tuple, map_size/1 will raise, and tuple_size/1 will not be evaluated def empty? ( val ) when map_size ( val ) == 0 or tuple_size ( val ) == 0 , do : true def empty? ( _val ) , do : false end Check . empty? ( %{ } ) #=&gt; true Check . empty? ( { } ) #=&gt; false # true was expected! This could be corrected by ensuring that no exception is raised, either via type checks like is_map(val) and map_size(val) == 0 , or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated. defmodule Check do # If given a tuple, map_size/1 will raise, and the second guard will be evaluated def empty? ( val ) when map_size ( val ) == 0 when tuple_size ( val ) == 0 , do : true def empty? ( _val ) , do : false end Check . empty? ( %{ } ) #=&gt; true Check . empty? ( { } ) #=&gt; true","ref":"patterns-and-guards.html#guards","source_doc":"Variables in patterns are always assigned to:\n\n```iex\niex> x = 1\n1\niex> x = 2\n2\niex> x\n2\n```\n\nIn other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (`^`):\n\n```iex\niex> x = 1\n1\niex> ^x = 2\n** (MatchError) no match of right hand side value: 2\n```\n\nIf the same variable appears twice in the same pattern, then they must be bound to the same value:\n\n```iex\niex> {x, x} = {1, 1}\n{1, 1}\niex> {x, x} = {1, 2}\n** (MatchError) no match of right hand side value: {1, 2}\n```\n\nThe underscore variable (`_`) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:\n\n```iex\niex> {_, integer} = {:not_important, 1}\n{:not_important, 1}\niex> integer\n1\niex> _\n** (CompileError) iex:3: invalid use of _\n```\n\n#","title":"Patterns and Guards - Guards","type":"extras"},{"doc":"In the examples above, we have used the match operator ( = ) and function clauses to showcase patterns and guards respectively. Here is the list of the built-in constructs in Elixir that support patterns and guards. match?/2 : match? ( { :ok , value } when value &gt; 0 , { :ok , 13 } ) function clauses: def type ( term ) when is_integer ( term ) , do : :integer def type ( term ) when is_float ( term ) , do : :float case expressions: case x do 1 -&gt; :one 2 -&gt; :two n when is_integer ( n ) and n &gt; 2 -&gt; :larger_than_two end anonymous functions ( fn/1 ): larger_than_two? = fn n when is_integer ( n ) and n &gt; 2 -&gt; true n when is_integer ( n ) -&gt; false end for and with support patterns and guards on the left side of &lt;- : for x when x &gt;= 0 &lt;- [ 1 , - 2 , 3 , - 4 ] , do : x with also supports the else keyword, which supports patterns matching and guards. try supports patterns and guards on catch and else receive supports patterns and guards to match on the received messages. custom guards can also be defined with defguard/1 and defguardp/1 . A custom guard can only be defined based on existing guards. Note that the match operator ( = ) does not support guards: { :ok , binary } = File . read ( &quot;some/file&quot; )","ref":"patterns-and-guards.html#where-patterns-and-guards-can-be-used","source_doc":"Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom:\n\n```iex\niex> :atom = :atom\n:atom\niex> :atom = :another_atom\n** (MatchError) no match of right hand side value: :another_atom\n```\n\nSimilar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats:\n\n```iex\niex> 1 = 1.0\n** (MatchError) no match of right hand side value: 1.0\n```\n\n#","title":"Patterns and Guards - Where patterns and guards can be used","type":"extras"},{"doc":"Only the constructs listed in this page are allowed in patterns and guards. However, we can take advantage of macros to write custom patterns guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the output of the macros boils down to a combination of the constructs above. For example, the Record module in Elixir provides a series of macros to be used in patterns and guards that allows tuples to have named fields during compilation. For defining your own guards, Elixir even provides conveniences in defguard and defguardp . Let's look at a quick case study: we want to check whether an argument is an even or an odd integer. With pattern matching this is impossible because there is an infinite number of integers, and therefore we can't pattern match on every single one of them. Therefore we must use guards. We will just focus on checking for even numbers since checking for the odd ones is almost identical. Such a guard would look like this: def my_function ( number ) when is_integer ( number ) and rem ( number , 2 ) == 0 do # do stuff end It would be repetitive to write every time we need this check. Instead, you can use defguard/1 and defguardp/1 to create guard macros. Here's an example how: defmodule MyInteger do defguard is_even ( term ) when is_integer ( term ) and rem ( term , 2 ) == 0 end and then: import MyInteger , only : [ is_even : 1 ] def my_function ( number ) when is_even ( number ) do # do stuff end While it's possible to create custom guards with macros, it's recommended to define them using defguard/1 and defguardp/1 which perform additional compile-time checks.","ref":"patterns-and-guards.html#custom-patterns-and-guards-expressions","source_doc":"Tuples may appear in patterns using the curly brackets syntax (`{}`). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:\n\n```iex\niex> {:ok, integer} = {:ok, 13}\n{:ok, 13}\n\n# won't match due to different size\niex> {:ok, integer} = {:ok, 11, 13}\n** (MatchError) no match of right hand side value: {:ok, 11, 13}\n\n# won't match due to mismatch on first element\niex> {:ok, binary} = {:error, :enoent}\n** (MatchError) no match of right hand side value: {:error, :enoent}\n```\n\n#","title":"Patterns and Guards - Custom patterns and guards expressions","type":"extras"},{"doc":"Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of &quot;syntax sugar&quot; constructs to reduce the noise in common Elixir idioms. This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.","ref":"syntax-reference.html","source_doc":"# Syntax reference\n\nElixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of \"syntax sugar\" constructs to reduce the noise in common Elixir idioms.\n\nThis document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.","title":"Syntax reference","type":"extras"},{"doc":"These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience: true , false , nil - used as atoms when , and , or , not , in - used as operators fn - used for anonymous function definitions do , end , catch , rescue , after , else - used in do-end blocks","ref":"syntax-reference.html#reserved-words","source_doc":"These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:\n\n  * `true`, `false`, `nil` - used as atoms\n  * `when`, `and`, `or`, `not`, `in` - used as operators\n  * `fn` - used for anonymous function definitions\n  * `do`, `end`, `catch`, `rescue`, `after`, `else` - used in do-end blocks","title":"Syntax reference - Reserved words","type":"extras"},{"doc":"Numbers Integers ( 1234 ) and floats ( 123.4 ) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as 1_000_000 . Integers never contain a dot ( . ) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as 123.4e10 or 123.4E10 . Atoms Unquoted atoms start with a colon ( : ) which must be immediately followed by a Unicode letter or an underscore. The atom may continue using a sequence of Unicode letters, numbers, underscores, and @ . Atoms may end in ! or ? . Valid unquoted atoms are: :ok , :ISO8601 , and :integer? . If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as :'🌢 Elixir' , :&quot;++olá++&quot; , and :&quot;123&quot; . Quoted and unquoted atoms with the same name are considered equivalent, so :atom , :&quot;atom&quot; , and :'atom' represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted. All operators in Elixir are also valid atoms. Valid examples are :foo , :FOO , :foo_42 , :foo@bar , and :++ . Invalid examples are :@foo ( @ is not allowed at start), :123 (numbers are not allowed at start), and :(*) (not a valid operator). true , false , and nil are reserved words that are represented by the atoms :true , :false and :nil respectively. To learn more about all Unicode characters allowed in atom, see the Unicode syntax document. Strings Single-line strings in Elixir are written between double-quotes, such as &quot;foo&quot; . Any double-quote inside the string must be escaped with \\ . Strings support Unicode characters and are stored as UTF-8 encoded binaries. Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &quot;&quot;&quot; is used to strip indentation from the inner string. For example: iex&gt; test = &quot;&quot;&quot; ...&gt; this ...&gt; is ...&gt; a ...&gt; test ...&gt; &quot;&quot;&quot; &quot; this \\n is \\n a \\n test \\n &quot; iex&gt; test = &quot;&quot;&quot; ...&gt; This ...&gt; Is ...&gt; A ...&gt; Test ...&gt; &quot;&quot;&quot; &quot;This \\n Is \\n A \\n Test \\n &quot; Strings are always represented as themselves in the AST. Charlists Charlists in Elixir are written in single-quotes, such as 'foo' . Any single-quote inside the string must be escaped with \\ . Charlists are made of non-negative integers, where each integer represents a Unicode code point. Multi-line charlists are written with three single-quotes ( ''' ), the same way multi-line strings are. Charlists are always represented as themselves in the AST. For more in-depth information, please read the &quot;Charlists&quot; section in the List module. Lists, tuples and binaries Data structures such as lists, tuples, and binaries are marked respectively by the delimiters [...] , {...} , and &lt;&lt;...&gt;&gt; . Each element is separated by comma. A trailing comma is also allowed, such as in [1, 2, 3,] . Maps and keyword lists Maps use the %{...} notation and each key-value is given by pairs marked with =&gt; , such as %{&quot;hello&quot; =&gt; 1, 2 =&gt; &quot;world&quot;} . Both keyword lists (list of two-element tuples where the first element is atom) and maps with atom keys support a keyword notation where the colon character : is moved to the end of the atom. %{hello: &quot;world&quot;} is equivalent to %{:hello =&gt; &quot;world&quot;} and [foo: :bar] is equivalent to [{:foo, :bar}] . This notation is a syntax sugar that emits the same AST representation. It will be explained in later sections. Structs Structs built on the map syntax by passing the struct name between % and { . For example, %User{...} .","ref":"syntax-reference.html#data-types","source_doc":"#","title":"Syntax reference - Data types","type":"extras"},{"doc":"Variables Variables in Elixir must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The variable may continue using a sequence of Unicode letters, numbers, and underscores. Variables may end in ? or ! . To learn more about all Unicode characters allowed in variables, see the Unicode syntax document. Elixir's naming conventions recommend variables to be in snake_case format. Non-qualified calls (local calls) Non-qualified calls, such as add(1, 2) , must start with characters and then follow the same rules as as variables, which are optionally followed by parentheses, and then arguments. Parentheses are required for zero-arity calls (i.e. calls without arguments), to avoid ambiguity with variables. If parentheses are used, they must immediately follow the function name without spaces . For example, add (1, 2) is a syntax error, since (1, 2) is treated as an invalid block which is attempted to be given as a single argument to add . Elixir's naming conventions recommend calls to be in snake_case format. Operators As many programming languages, Elixir also support operators as non-qualified calls with their precedence and associativity rules. Constructs such as = , when , &amp; and @ are simply treated as operators. See the Operators page for a full reference. Qualified calls (remote calls) Qualified calls, such as Math.add(1, 2) , must start with characters and then follow the same rules as as variables, which are optionally followed by parentheses, and then arguments. Qualified calls also support operators, such as Kernel.+(1, 2) . Elixir also allows the function name to be written between double- or single-quotes, allowing any character in between the quotes, such as Math.&quot;++add++&quot;(1, 2) . Similar to non-qualified calls, parentheses have different meaning for zero-arity calls (i.e. calls without arguments). If parentheses are used, such as mod.fun() , it means a function call. If parenthesis are skipped, such as map.field , it means accessing a field of a map. Elixir's naming conventions recommend calls to be in snake_case format. Aliases Aliases are constructs that expand to atoms at compile-time. The alias String expands to the atom :&quot;Elixir.String&quot; . Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases. Multiple aliases can be joined with . , such as MyApp.String , and it expands to the atom :&quot;Elixir.MyApp.String&quot; . The dot is effectively part of the name but it can also be used for composition. If you define alias MyApp.Example, as: Example in your code, then Example will always expand to :&quot;Elixir.MyApp.Example&quot; and Example.String will expand to :&quot;Elixir.MyApp.Example.String&quot; . Elixir's naming conventions recommend aliases to be in CamelCase format. Module attributes Module attributes are module-specific storage and are written as the composition of the unary operator @ with variables and local calls. For example, to write to a module attribute named foo , use @foo &quot;value&quot; , and use @foo to read from it. Given module attributes are written using existing constructs, they follow the same rules above defined for operators, variables, and local calls. Blocks Blocks are multiple Elixir expressions separated by newlines or semi-colons. A new block may be created at any moment by using parentheses. Left to right arrow The left to right arrow ( -&gt; ) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The -&gt; may appear one or more times between one of the following terminators: do - end , fn - end or ( - ) . When -&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax. It is seen on case and cond constructs between do and end : case 1 do 2 -&gt; 3 4 -&gt; 5 end cond do true -&gt; false end Seen in typespecs between ( and ) : ( integer ( ) , boolean ( ) -&gt; integer ( ) ) It is also used between fn and end for building anonymous functions: fn x , y -&gt; x + y end Sigils Sigils start with ~ and are followed by one lowercase letter or by one or more uppercase letters, immediatelly followed by one of the following pairs: ( and ) { and } [ and ] &lt; and &gt; &quot; and &quot; ' and ' | and | / and / After closing the pair, zero or more ASCII letters and digits can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with sigil_ where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers: If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information: ~s/f \#{ &quot;o&quot; } o/ ~S/f\#{&quot;o&quot;}o/ Sigils are useful to encode text with their own escaping rules, such as regular expressions, datetimes, and others.","ref":"syntax-reference.html#expressions","source_doc":"Integers (`1234`) and floats (`123.4`) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as `1_000_000`. Integers never contain a dot (`.`) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as `123.4e10` or `123.4E10`.\n\n#","title":"Syntax reference - Expressions","type":"extras"},{"doc":"Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements: atoms - such as :foo integers - such as 42 floats - such as 13.1 strings - such as &quot;hello&quot; lists - such as [1, 2, 3] tuples with two elements - such as {&quot;hello&quot;, :world} tuples with three elements, representing calls or variables, as explained next The building block of Elixir's AST is a call, such as: sum ( 1 , 2 , 3 ) which is represented as a tuple with three elements: { :sum , meta , [ 1 , 2 , 3 ] } the first element is an atom (or another tuple), the second element is a list of two-element tuples with metadata (such as line numbers) and the third is a list of arguments. We can retrieve the AST for any Elixir expression by calling quote : quote do sum ( ) end #=&gt; {:sum, [], []} Variables are also represented using a tuple with three elements and a combination of lists and atoms, for example: quote do sum end #=&gt; {:sum, [], Elixir} You can see that variables are also represented with a tuple, except the third element is an atom expressing the variable context. Over the course of this section, we will explore many Elixir syntax constructs alongside their AST representations. Operators Operators are treated as non-qualified calls: quote do 1 + 2 end #=&gt; {:+, [], [1, 2]} Note that . is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom: quote do foo . bar ( 1 , 2 , 3 ) end #=&gt; {{:., [], [{:foo, [], Elixir}, :bar]}, [], [1, 2, 3]} Calling anonymous functions uses the dot in the AST with a single argument, mirroring the fact the function name is &quot;missing&quot; from right side of the dot: quote do foo . ( 1 , 2 , 3 ) end #=&gt; {{:., [], [{:foo, [], Elixir}]}, [], [1, 2, 3]} Aliases Aliases are represented by an __aliases__ call with each segment separated by a dot as an argument: quote do Foo.Bar.Baz end #=&gt; {:__aliases__, [], [:Foo, :Bar, :Baz]} quote do __MODULE__ . Bar.Baz end #=&gt; {:__aliases__, [], [{:__MODULE__, [], Elixir}, :Bar, :Baz]} All arguments, except the first, are guaranteed to be atoms. Data structures Remember that lists are literals, so they are represented as themselves in the AST: quote do [ 1 , 2 , 3 ] end #=&gt; [1, 2, 3] Tuples have their own representation, except for two-element tuples, which are represented as themselves: quote do { 1 , 2 } end #=&gt; {1, 2} quote do { 1 , 2 , 3 } end #=&gt; {:{}, [], [1, 2, 3]} Binaries have a representation similar to tuples, except they are tagged with :&lt;&lt;&gt;&gt; instead of :{} : quote do &lt;&lt; 1 , 2 , 3 &gt;&gt; end #=&gt; {:&lt;&lt;&gt;&gt;, [], [1, 2, 3]} The same applies to maps, where each pair is treated as a list of tuples with two elements: quote do %{ 1 =&gt; 2 , 3 =&gt; 4 } end #=&gt; {:%{}, [], [{1, 2}, {3, 4}]} Blocks Blocks are represented as a __block__ call with each line as a separate argument: quote do 1 2 3 end #=&gt; {:__block__, [], [1, 2, 3]} quote do 1 ; 2 ; 3 ; end #=&gt; {:__block__, [], [1, 2, 3]} Left to right arrow The left to right arrow ( -&gt; ) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression. For example, in case and cond : quote do case 1 do 2 -&gt; 3 4 -&gt; 5 end end #=&gt; {:case, [], [1, [do: [{:-&gt;, [], [[2], 3]}, {:-&gt;, [], [[4], 5]}]]]} quote do cond do true -&gt; false end end #=&gt; {:cond, [], [[do: [{:-&gt;, [], [[true], false]}]]]} Between ( and ) : quote do ( 1 , 2 -&gt; 3 4 , 5 -&gt; 6 ) end #=&gt; [{:-&gt;, [], [[1, 2], 3]}, {:-&gt;, [], [[4, 5], 6]}] Between fn and end : quote do fn 1 , 2 -&gt; 3 4 , 5 -&gt; 6 end end #=&gt; {:fn, [], [{:-&gt;, [], [[1, 2], 3]}, {:-&gt;, [], [[4, 5], 6]}]} Qualified tuples Qualified tuples ( foo.{bar, baz} ) are represented by a {:., [], [expr, :{}]} call, where the expr represents the left hand side of the dot, and the arguments represent the elements inside the curly braces. This is used in Elixir to provide multi aliases: quote do Foo . { Bar , Baz } end #=&gt; {{:., [], [{:__aliases__, [], [:Foo]}, :{}]}, [], [{:__aliases__, [], [:Bar]}, {:__aliases__, [], [:Baz]}]}","ref":"syntax-reference.html#the-elixir-ast","source_doc":"Unquoted atoms start with a colon (`:`) which must be immediately followed by a Unicode letter or an underscore. The atom may continue using a sequence of Unicode letters, numbers, underscores, and `@`. Atoms may end in `!` or `?`. Valid unquoted atoms are: `:ok`, `:ISO8601`, and `:integer?`.\n\nIf the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as `:'🌢 Elixir'`, `:\"++olá++\"`, and `:\"123\"`.\n\nQuoted and unquoted atoms with the same name are considered equivalent, so `:atom`, `:\"atom\"`, and `:'atom'` represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.\n\nAll operators in Elixir are also valid atoms. Valid examples are `:foo`, `:FOO`, `:foo_42`, `:foo@bar`, and `:++`. Invalid examples are `:@foo` (`@` is not allowed at start), `:123` (numbers are not allowed at start), and `:(*)` (not a valid operator).\n\n`true`, `false`, and `nil` are reserved words that are represented by the atoms `:true`, `:false` and `:nil` respectively.\n\nTo learn more about all Unicode characters allowed in atom, see the [Unicode syntax](unicode-syntax.md) document.\n\n#","title":"Syntax reference - The Elixir AST","type":"extras"},{"doc":"All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that are alternative representations of the constructs above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence. We call this &quot;Optional Syntax&quot;. For a lightweight introduction to Elixir's Optional Syntax, see this document . Below we continue with a more complete reference. Integers in other bases and Unicode code points Elixir allows integers to contain _ to separate digits and provides conveniences to represent integers in other bases: 1_000_000 #=&gt; 1000000 0xABCD #=&gt; 43981 (Hexadecimal base) 0o01234567 #=&gt; 342391 (Octal base) 0b10101010 #=&gt; 170 (Binary base) ?é #=&gt; 233 (Unicode code point) Those constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST. Access syntax The access syntax is represented as a call to Access.get/2 : quote do opts [ arg ] end #=&gt; {{:., [], [Access, :get]}, [], [{:opts, [], Elixir}, {:arg, [], Elixir}]} Optional parentheses Elixir provides optional parentheses: quote do sum 1 , 2 , 3 end #=&gt; {:sum, [], [1, 2, 3]} The above is treated the same as sum(1, 2, 3) by the parser. You can remove the parentheses on all calls with at least one argument. You can also skip parentheses on qualified calls, such as Foo.bar 1, 2, 3 . Parentheses are required when invoking anonymous functions, such as f.(1, 2, 3) . In practice, developers prefer to add parentheses to most of their calls. They are skipped mainly in Elixir's control-flow constructs, such as defmodule , if , case , etc, and in certain DSLs. Keywords Keywords in Elixir are a list of tuples of two elements, where the first element is an atom. Using the base constructs, they would be represented as: [ { :foo , 1 } , { :bar , 2 } ] However, Elixir introduces a syntax sugar where the keywords above may be written as follows: [ foo : 1 , bar : 2 ] Atoms with foreign characters, such as whitespace, must be wrapped in quotes. This rule applies to keywords as well: [ { :&quot;foo bar&quot; , 1 } , { :&quot;bar baz&quot; , 2 } ] == [ &quot;foo bar&quot; : 1 , &quot;bar baz&quot; : 2 ] Remember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals). Keywords as last arguments Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following: if ( condition , do : this , else : that ) is the same as if ( condition , [ do : this , else : that ] ) which in turn is the same as if ( condition , [ { :do , this } , { :else , that } ] ) do - end blocks The last syntax convenience are do - end blocks. do - end blocks are equivalent to keywords as the last argument of a function call, where the block contents are wrapped in parentheses. For example: if true do this else that end is the same as: if ( true , do : ( this ) , else : ( that ) ) which we have explored in the previous section. Parentheses are important to support multiple expressions. This: if true do this that end is the same as: if ( true , do : ( this that ) ) Inside do - end blocks you may introduce other keywords, such as else used in the if above. The supported keywords between do - end are static and are: after catch else rescue You can see them being used in constructs such as receive , try , and others.","ref":"syntax-reference.html#optional-syntax","source_doc":"Single-line strings in Elixir are written between double-quotes, such as `\"foo\"`. Any double-quote inside the string must be escaped with `\\ `. Strings support Unicode characters and are stored as UTF-8 encoded binaries.\n\nMulti-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last `\"\"\"` is used to strip indentation from the inner string. For example:\n\n```\niex> test = \"\"\"\n...>     this\n...>     is\n...>     a\n...>     test\n...> \"\"\"\n\"    this\\n    is\\n    a\\n    test\\n\"\niex> test = \"\"\"\n...>     This\n...>     Is\n...>     A\n...>     Test\n...>     \"\"\"\n\"This\\nIs\\nA\\nTest\\n\"\n```\n\nStrings are always represented as themselves in the AST.\n\n#","title":"Syntax reference - Optional syntax","type":"extras"},{"doc":"Elixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because: they provide documentation (for example, tools such as ExDoc show type specifications in the documentation) they're used by tools such as Dialyzer , that can analyze code with typespecs to find type inconsistencies and possible bugs Type specifications (most often referred to as typespecs ) are defined in different contexts using the following attributes: @type @opaque @typep @spec @callback @macrocallback In addition, you can use @typedoc to describe a custom @type definition. See the &quot;User-defined types&quot; and &quot;Defining a specification&quot; sub-sections below for more information on defining types and typespecs.","ref":"typespecs.html","source_doc":"# Typespecs\n\nElixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:\n\n  * they provide documentation (for example, tools such as [`ExDoc`](https://hexdocs.pm/ex_doc/) show type specifications in the documentation)\n  * they're used by tools such as [Dialyzer](`:dialyzer`), that can analyze code with typespecs to find type inconsistencies and possible bugs\n\nType specifications (most often referred to as *typespecs*) are defined in different contexts using the following attributes:\n\n  * `@type`\n  * `@opaque`\n  * `@typep`\n  * `@spec`\n  * `@callback`\n  * `@macrocallback`\n\nIn addition, you can use `@typedoc` to describe a custom `@type` definition.\n\nSee the \"User-defined types\" and \"Defining a specification\" sub-sections below for more information on defining types and typespecs.","title":"Typespecs","type":"extras"},{"doc":"defmodule StringHelpers do @typedoc &quot;A word from the dictionary&quot; @type word ( ) :: String . t ( ) @spec long_word? ( word ( ) ) :: boolean ( ) def long_word? ( word ) when is_binary ( word ) do String . length ( word ) &gt; 8 end end In the example above: We declare a new type ( word() ) that is equivalent to the string type ( String.t() ). We describe the type using a @typedoc , which will be included in the generated documentation. We specify that the long_word?/1 function takes an argument of type word() and returns a boolean ( boolean() ), that is, either true or false .","ref":"typespecs.html#a-simple-example","source_doc":"defmodule StringHelpers do\n      @typedoc \"A word from the dictionary\"\n      @type word() :: String.t()\n\n      @spec long_word?(word()) :: boolean()\n      def long_word?(word) when is_binary(word) do\n        String.length(word) > 8\n      end\n    end\n\nIn the example above:\n\n  * We declare a new type (`word()`) that is equivalent to the string type (`String.t()`).\n\n  * We describe the type using a `@typedoc`, which will be included in the generated documentation.\n\n  * We specify that the `long_word?/1` function takes an argument of type `word()` and\n    returns a boolean (`boolean()`), that is, either `true` or `false`.","title":"Typespecs - A simple example","type":"extras"},{"doc":"The syntax Elixir provides for type specifications is similar to the one in Erlang . Most of the built-in types provided in Erlang (for example, pid() ) are expressed in the same way: pid() (or simply pid ). Parameterized types (such as list(integer) ) are supported as well and so are remote types (such as Enum.t() ). Integers and atom literals are allowed as types (for example, 1 , :atom , or false ). All other types are built out of unions of predefined types. Some shorthands are allowed, such as [...] , &lt;&lt;&gt;&gt; , and {...} . The notation to represent the union of types is the pipe | . For example, the typespec type :: atom() | pid() | tuple() creates a type type that can be either an atom , a pid , or a tuple . This is usually called a sum type in other languages Basic types type :: any ( ) # the top type, the set of all terms | none ( ) # the bottom type, contains no terms | atom ( ) | map ( ) # any map | pid ( ) # process identifier | port ( ) # port identifier | reference ( ) | tuple ( ) # tuple of any size ## Numbers | float ( ) | integer ( ) | neg_integer ( ) # ..., -3, -2, -1 | non_neg_integer ( ) # 0, 1, 2, 3, ... | pos_integer ( ) # 1, 2, 3, ... ## Lists | list ( type ) # proper list ([]-terminated) | nonempty_list ( type ) # non-empty proper list | maybe_improper_list ( content_type , termination_type ) # proper or improper list | nonempty_improper_list ( content_type , termination_type ) # improper list | nonempty_maybe_improper_list ( content_type , termination_type ) # non-empty proper or improper list | Literals # Described in section &quot;Literals&quot; | BuiltIn # Described in section &quot;Built-in types&quot; | Remotes # Described in section &quot;Remote types&quot; | UserDefined # Described in section &quot;User-defined types&quot; Literals The following literals are also supported in typespecs: type :: ## Atoms :atom # atoms: :foo, :bar, ... | true | false | nil # special atom literals ## Bitstrings | &lt;&lt; &gt;&gt; # empty bitstring | &lt;&lt; _ :: size &gt;&gt; # size is 0 or a positive integer | &lt;&lt; _ :: _ * unit &gt;&gt; # unit is an integer from 1 to 256 | &lt;&lt; _ :: size , _ :: _ * unit &gt;&gt; ## (Anonymous) Functions | ( -&gt; type ) # zero-arity, returns type | ( type1 , type2 -&gt; type ) # two-arity, returns type | ( ... -&gt; type ) # any arity, returns type ## Integers | 1 # integer | 1 .. 10 # integer from 1 to 10 ## Lists | [ type ] # list with any number of type elements | [ ] # empty list | [ ... ] # shorthand for nonempty_list(any()) | [ type , ... ] # shorthand for nonempty_list(type) | [ key : value_type ] # keyword list with optional key :key of value_type ## Maps | %{ } # empty map | %{ key : value_type } # map with required key :key of value_type | %{ key_type =&gt; value_type } # map with required pairs of key_type and value_type | %{ required ( key_type ) =&gt; value_type } # map with required pairs of key_type and value_type | %{ optional ( key_type ) =&gt; value_type } # map with optional pairs of key_type and value_type | % SomeStruct { } # struct with all fields of any type | % SomeStruct { key : value_type } # struct with required key :key of value_type ## Tuples | { } # empty tuple | { :ok , type } # two-element tuple with an atom and any type Built-in types The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above. Built-in type Defined as term() any() arity() 0..255 as_boolean(t) t binary() &lt;&lt;_::_*8&gt;&gt; nonempty_binary() &lt;&lt;_::8, _::_*8&gt;&gt; bitstring() &lt;&lt;_::_*1&gt;&gt; nonempty_bitstring() &lt;&lt;_::1, _::_*1&gt;&gt; boolean() true | false byte() 0..255 char() 0..0x10FFFF charlist() [char()] nonempty_charlist() [char(), ...] fun() (... -&gt; any) function() fun() identifier() pid() | port() | reference() iodata() iolist() | binary() iolist() maybe_improper_list(byte() | binary() | iolist(), binary() | []) keyword() [{atom(), any()}] keyword(t) [{atom(), t}] list() [any()] nonempty_list() nonempty_list(any()) maybe_improper_list() maybe_improper_list(any(), any()) nonempty_maybe_improper_list() nonempty_maybe_improper_list(any(), any()) mfa() {module(), atom(), arity()} module() atom() no_return() none() node() atom() number() integer() | float() struct() %{:__struct__ =&gt; atom(), optional(atom()) =&gt; any()} timeout() :infinity | non_neg_integer() as_boolean(t) exists to signal users that the given value will be treated as a boolean, where nil and false will be evaluated as false and everything else is true . For example, Enum.filter/2 has the following specification: filter(t, (element -&gt; as_boolean(term))) :: list . Remote types Any module is also able to define its own types and the modules in Elixir are no exception. For example, the Range module defines a t/0 type that represents a range: this type can be referred to as Range.t/0 . In a similar fashion, a string is String.t/0 , and so on. Maps The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys. If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with optional(any) =&gt; any . Note that the syntactic representation of map() is %{optional(any) =&gt; any} , not %{} . The notation %{} specifies the singleton type for the empty map. Keyword Lists Beyond keyword() and keyword(t) , it can be helpful to compose a spec for an expected keyword list. For example: @type option :: { :name , String . t } | { :max , pos_integer } | { :min , pos_integer } @type options :: [ option ( ) ] This makes it clear that only these options are allowed, none are required, and order does not matter. It also allows composition with existing types. For example: type option :: { :my_option , String . t ( ) } | GenServer . option ( ) @spec start_link ( [ option ( ) ] ) :: GenServer . on_start ( ) def start_link ( opts ) do { my_opts , gen_server_opts } = Keyword . split ( opts , [ :my_option ] ) GenServer . start_link ( __MODULE__ , my_opts , gen_server_opts ) end User-defined types The @type , @typep , and @opaque module attributes can be used to define new types: @type type_name :: type @typep type_name :: type @opaque type_name :: type A type defined with @typep is private. An opaque type, defined with @opaque is a type where the internal structure of the type will not be visible, but the type is still public. Types can be parameterized by defining variables as parameters; these variables can then be used to define the type. @type dict ( key , value ) :: [ { key , value } ]","ref":"typespecs.html#types-and-their-syntax","source_doc":"The syntax Elixir provides for type specifications is similar to [the one in Erlang](https://www.erlang.org/doc/reference_manual/typespec.html). Most of the built-in types provided in Erlang (for example, `pid()`) are expressed in the same way: `pid()` (or simply `pid`). Parameterized types (such as `list(integer)`) are supported as well and so are remote types (such as [`Enum.t()`](`t:Enum.t/0`)). Integers and atom literals are allowed as types (for example, `1`, `:atom`, or `false`). All other types are built out of unions of predefined types. Some shorthands are allowed, such as `[...]`, `<<>>`, and `{...}`.\n\nThe notation to represent the union of types is the pipe `|`. For example, the typespec `type :: atom() | pid() | tuple()` creates a type `type` that can be either an `atom`, a `pid`, or a `tuple`. This is usually called a [sum type](https://en.wikipedia.org/wiki/Tagged_union) in other languages\n\n#","title":"Typespecs - Types and their syntax","type":"extras"},{"doc":"A specification for a function can be defined as follows: @spec function_name ( type1 , type2 ) :: return_type Guards can be used to restrict type variables given as arguments to the function. @spec function ( arg ) :: [ arg ] when arg : atom If you want to specify more than one variable, you separate them by a comma. @spec function ( arg1 , arg2 ) :: { arg1 , arg2 } when arg1 : atom , arg2 : integer Type variables with no restriction can also be defined using var . @spec function ( arg ) :: [ arg ] when arg : var This guard notation only works with @spec , @callback , and @macrocallback . You can also name your arguments in a typespec using arg_name :: arg_type syntax. This is particularly useful in documentation as a way to differentiate multiple arguments of the same type (or multiple elements of the same type in a type definition): @spec days_since_epoch ( year :: integer , month :: integer , day :: integer ) :: integer @type color :: { red :: integer , green :: integer , blue :: integer } Specifications can be overloaded, just like ordinary functions. @spec function ( integer ) :: atom @spec function ( atom ) :: integer","ref":"typespecs.html#defining-a-specification","source_doc":"type ::\n          any()                     # the top type, the set of all terms\n          | none()                  # the bottom type, contains no terms\n          | atom()\n          | map()                   # any map\n          | pid()                   # process identifier\n          | port()                  # port identifier\n          | reference()\n          | tuple()                 # tuple of any size","title":"Typespecs - Defining a specification","type":"extras"},{"doc":"Behaviours in Elixir (and Erlang) are a way to separate and abstract the generic part of a component (which becomes the behaviour module ) from the specific part (which becomes the callback module ). A behaviour module defines a set of functions and macros (referred to as callbacks ) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the GenServer behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform. To define a behaviour module, it's enough to define one or more callbacks in that module. To define callbacks, the @callback and @macrocallback module attributes can be used (for function callbacks and macro callbacks respectively). defmodule MyBehaviour do @callback my_fun ( arg :: any ) :: any @macrocallback my_macro ( arg :: any ) :: Macro . t end As seen in the example above, defining a callback is a matter of defining a specification for that callback, made of: the callback name ( my_fun or my_macro in the example) the arguments that the callback must accept ( arg :: any in the example) the expected type of the callback return value Optional callbacks Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with function_exported?/3 or macro_exported?/3 . Optional callbacks can be defined through the @optional_callbacks module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example: defmodule MyBehaviour do @callback vital_fun ( ) :: any @callback non_vital_fun ( ) :: any @macrocallback non_vital_macro ( arg :: any ) :: Macro . t @optional_callbacks non_vital_fun : 0 , non_vital_macro : 1 end One example of optional callback in Elixir's standard library is GenServer.format_status/2 . Implementing behaviours To specify that a module implements a given behaviour, the @behaviour attribute must be used: defmodule MyBehaviour do @callback my_fun ( arg :: any ) :: any end defmodule MyCallbackModule do @behaviour MyBehaviour def my_fun ( arg ) , do : arg end If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen). Elixir's standard library contains a few frequently used behaviours such as GenServer , Supervisor , and Application . Inspecting behaviours The @callback and @optional_callbacks attributes are used to create a behaviour_info/1 function available on the defining module. This function can be used to retrieve the callbacks and optional callbacks defined by that module. For example, for the MyBehaviour module defined in &quot;Optional callbacks&quot; above: MyBehaviour . behaviour_info ( :callbacks ) #=&gt; [vital_fun: 0, &quot;MACRO-non_vital_macro&quot;: 2, non_vital_fun: 0] MyBehaviour . behaviour_info ( :optional_callbacks ) #=&gt; [&quot;MACRO-non_vital_macro&quot;: 2, non_vital_fun: 0] When using iex , the IEx.Helpers.b/1 helper is also available.","ref":"typespecs.html#behaviours","source_doc":"| float()\n          | integer()\n          | neg_integer()           # ..., -3, -2, -1\n          | non_neg_integer()       # 0, 1, 2, 3, ...\n          | pos_integer()           # 1, 2, 3, ...","title":"Typespecs - Behaviours","type":"extras"},{"doc":"Elixir discourages the use of the string() type. The string() type refers to Erlang strings, which are known as &quot;charlists&quot; in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type string() , Elixir will emit a warning. You should use charlist() , nonempty_charlist() , binary() or String.t() accordingly, or any of the several literal representations for these types. Note that String.t() and binary() are equivalent to analysis tools. Although, for those reading the documentation, String.t() implies it is a UTF-8 encoded binary.","ref":"typespecs.html#the-string-type","source_doc":"| list(type)                                                    # proper list ([]-terminated)\n          | nonempty_list(type)                                           # non-empty proper list\n          | maybe_improper_list(content_type, termination_type)           # proper or improper list\n          | nonempty_improper_list(content_type, termination_type)        # improper list\n          | nonempty_maybe_improper_list(content_type, termination_type)  # non-empty proper or improper list\n\n          | Literals                # Described in section \"Literals\"\n          | BuiltIn                 # Described in section \"Built-in types\"\n          | Remotes                 # Described in section \"Remote types\"\n          | UserDefined             # Described in section \"User-defined types\"\n\n#","title":"Typespecs - The string() type","type":"extras"},{"doc":"Elixir supports Unicode throughout the language. Strings ( &quot;olá&quot; ) and charlists ( 'olá' ) support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation. Elixir also supports Unicode in variables, atoms, and calls since Elixir v1.5. The focus of this document is to provide a high-level introduction to how Elixir allows Unicode in its syntax. We also provide technical documentation describing how Elixir complies with the Unicode specification. To check the Unicode version of your current Elixir installation, run String.Unicode.version() .","ref":"unicode-syntax.html","source_doc":"# Unicode Syntax\n\nElixir supports Unicode throughout the language.\n\nStrings (`\"olá\"`) and charlists (`'olá'`) support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.\n\nElixir also supports Unicode in variables, atoms, and calls since Elixir v1.5. The focus of this document is to provide a high-level introduction to how Elixir allows Unicode in its syntax. We also provide technical documentation describing how Elixir complies with the Unicode specification.\n\nTo check the Unicode version of your current Elixir installation, run `String.Unicode.version()`.","title":"Unicode Syntax","type":"extras"},{"doc":"Elixir allows Unicode characters in its variables, atoms, and calls. However, the Unicode characters must still obey the rules of the language syntax. In particular, variables and calls cannot start with an uppercase letter. From now on, we will refer to those terms as identifiers. The characters allowed in identifiers are the ones specified by Unicode. Generally speaking, it is restricted to characters typically used by the writing system of human languages still in activity. In particular, it excludes symbols such as emojis, alternate numeric representations, musical notes, and the like. Elixir imposes many restrictions on identifiers for security purposes. For example, the word &quot;josé&quot; can be written in two ways in Unicode: as the combination of the characters j o s é and as a combination of the characters j o s e ́ , where the accent is its own character. The former is called NFC form and the latter is the NFD form. Elixir normalizes all characters to be the in the NFC form. Elixir also disallows mixed-scripts in most scenarios. For example, it is not possible to name a variable аdmin , where а is in Cyrillic and the remaining characters are in Latin. Doing so will raise the following error: ** (SyntaxError) invalid mixed-script identifier found: аdmin Mixed - script identifiers are not supported for security reasons . &#39;аdmin&#39; is made of the following scripts : \\ u0430 а { Cyrillic } \\ u0064 d { Latin } \\ u006D m { Latin } \\ u0069 i { Latin } \\ u006E n { Latin } Make sure all characters in the identifier resolve to a single script or a highly restrictive script . See https :// hexdocs . pm / elixir / unicode - syntax . html for more information . The character must either be all in Cyrillic or all in Latin. The only mixed-scripts that Elixir allows, according to the Highly Restrictive Unicode recommendations, are: Latin and Han with Bopomofo Latin and Japanese Latin and Korean Finally, Elixir will also warn on confusable identifiers in the same file. For example, Elixir will emit a warning if you use both variables а (Cyrillic) and а (Latin) in your code. That's the overall introduction of how Unicode is used in Elixir identifiers. In a nutshell, its goal is to support different writing systems in use today while keeping the Elixir languague itself clear and secure. For the technical details, see the next sections that cover the technical Unicode requirements.","ref":"unicode-syntax.html#introduction","source_doc":"Elixir allows Unicode characters in its variables, atoms, and calls. However, the Unicode characters must still obey the rules of the language syntax. In particular, variables and calls cannot start with an uppercase letter. From now on, we will refer to those terms as identifiers.\n\nThe characters allowed in identifiers are the ones specified by Unicode. Generally speaking, it is restricted to characters typically used by the writing system of human languages still in activity. In particular, it excludes symbols such as emojis, alternate numeric representations, musical notes, and the like.\n\nElixir imposes many restrictions on identifiers for security purposes. For example, the word \"josé\" can be written in two ways in Unicode: as the combination of the characters `j o s é` and as a combination of the characters `j o s e ́ `, where the accent is its own character. The former is called NFC form and the latter is the NFD form. Elixir normalizes all characters to be the in the NFC form.\n\nElixir also disallows mixed-scripts in most scenarios. For example, it is not possible to name a variable `аdmin`, where `а` is in Cyrillic and the remaining characters are in Latin. Doing so will raise the following error:\n\n```\n** (SyntaxError) invalid mixed-script identifier found: аdmin\n\nMixed-script identifiers are not supported for security reasons. 'аdmin' is made of the following scripts:\n\n  \\u0430 а {Cyrillic}\n  \\u0064 d {Latin}\n  \\u006D m {Latin}\n  \\u0069 i {Latin}\n  \\u006E n {Latin}\n\nMake sure all characters in the identifier resolve to a single script or a highly\nrestrictive script. See https://hexdocs.pm/elixir/unicode-syntax.html for more information.\n```\n\nThe character must either be all in Cyrillic or all in Latin. The only mixed-scripts that Elixir allows, according to the Highly Restrictive Unicode recommendations, are:\n\n  * Latin and Han with Bopomofo\n  * Latin and Japanese\n  * Latin and Korean\n\nFinally, Elixir will also warn on confusable identifiers in the same file. For example, Elixir will emit a warning if you use both variables `а` (Cyrillic) and `а` (Latin) in your code.\n\nThat's the overall introduction of how Unicode is used in Elixir identifiers. In a nutshell, its goal is to support different writing systems in use today while keeping the Elixir languague itself clear and secure.\n\nFor the technical details, see the next sections that cover the technical Unicode requirements.","title":"Unicode Syntax - Introduction","type":"extras"},{"doc":"Elixir implements the requirements outlined in the Unicode Annex #31 , version 15.0. R1. Default Identifiers The general Elixir identifier rule is specified as: &lt; Identifier &gt; := &lt; Start &gt; &lt; Continue &gt; * &lt; Ending &gt; ? where &lt;Start&gt; uses the same categories as the spec but normalizes them to the NFC form (see R4): characters derived from the Unicode General Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus Other_ID_Start , minus Pattern_Syntax and Pattern_White_Space code points In set notation: [\\p{L}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}] . and &lt;Continue&gt; uses the same categories as the spec but normalizes them to the NFC form (see R4): ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus Other_ID_Continue , minus Pattern_Syntax and Pattern_White_Space code points. In set notation: [\\p{ID_Start}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\p{Other_ID_Continue}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}] . &lt;Ending&gt; is an addition specific to Elixir that includes only the code points ? (003F) and ! (0021). The spec also provides a &lt;Medial&gt; set, but Elixir does not include any character on this set. Therefore, the identifier rule has been simplified to consider this. Elixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. Bidirectional control characters are also not supported. R1b is guaranteed for backwards compatibility purposes. Atoms Unicode atoms in Elixir follow the identifier rule above with the following modifications: &lt;Start&gt; additionally includes the code point _ (005F) &lt;Continue&gt; additionally includes the code point @ (0040) Note atoms can also be quoted, which allows any characters, such as :&quot;hello elixir&quot; . All Elixir operators are also valid atoms, such as :+ , :@ , :|&gt; , and others. The full description of valid atoms is available in the &quot;Atoms&quot; section in the syntax reference . Variables, local calls, and remote calls Variables in Elixir follow the identifier rule above with the following modifications: &lt;Start&gt; additionally includes the code point _ (005F) &lt;Start&gt; additionally excludes Lu (letter uppercase) and Lt (letter titlecase) characters In set notation: [\\u{005F}\\p{Ll}\\p{Lm}\\p{Lo}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}] . Aliases Aliases in Elixir only allow ASCII characters, starting in uppercase, and no punctuation characters. R3. Pattern_White_Space and Pattern_Syntax Characters Elixir supports only code points \\t (0009), \\n (000A), \\r (000D) and \\s (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported. R4. Equivalent Normalized Identifiers Identifiers in Elixir are case sensitive. Elixir normalizes all atoms and variables to NFC form. Quoted-atoms and strings can, however, be in any form and are not verified by the parser. In other words, the atom :josé can only be written with the code points 006A 006F 0073 00E9 or 006A 006F 0073 0065 0301 , but Elixir will rewrite it to the former (from Elixir 1.14). On the other hand, :&quot;josé&quot; may be written as 006A 006F 0073 00E9 or 006A 006F 0073 0065 0301 and its form will be retained, since it is written between quotes. Choosing requirement R4 automatically excludes requirements R5, R6, and R7.","ref":"unicode-syntax.html#unicode-annex-31","source_doc":"Elixir implements the requirements outlined in the [Unicode Annex #31](https://unicode.org/reports/tr31/), version 15.0.\n\n#","title":"Unicode Syntax - Unicode Annex #31","type":"extras"},{"doc":"Elixir conforms to the clauses outlined in the Unicode Technical Standard #39 on Security, version 15.0. C1. General Security Profile for Identifiers Elixir will not allow tokenization of identifiers with codepoints in \\p{Identifier_Status=Restricted} . An implementation following the General Security Profile does not permit any characters in \\p{Identifier_Status=Restricted}, ... For instance, the 'HANGUL FILLER' ( ㅤ ) character, which is often invisible, is an uncommon codepoint and will trigger this warning. See the note below about additional normalizations, which can perform automatic replacement of some Restricted identifiers. C2. Confusable detection Elixir will warn on identifiers that look the same, but aren't. Examples: in а = a = 1 , the two 'a' characters are Cyrillic and Latin, and could be confused for each other; in 力 = カ = 1 , both are Japanese, but different codepoints, in different scripts of that writing system. Confusable identifiers can lead to hard-to-catch bugs (say, due to copy-pasted code) and can be unsafe, so we will warn about identifiers within a single file that could be confused with each other. We use the means described in Section 4, 'Confusable Detection', with one noted modification Alternatively, it shall declare that it uses a modification, and provide a precise list of character mappings that are added to or removed from the provided ones. Elixir will not warn on confusability for identifiers made up exclusively of characters in a-z, A-Z, 0-9, and _. This is because ASCII identifiers have existed for so long that the programming community has had their own means of dealing with confusability between identifiers like l,1 or O,0 (for instance, fonts designed for programming usually make it easy to differentiate between those characters). C3. Mixed Script Detection Elixir will not allow tokenization of mixed-script identifiers unless the mixings is one of the exceptions defined in UTS 39 5.2, 'Highly Restrictive'. We use the means described in Section 5.1, Mixed-Script Detection, to determine if script mixing is occurring, with the modification documented in the section 'Additional Normalizations', below. Examples: Elixir allows an identifiers like 幻ㄒㄧㄤ , even though it includes characters from multiple 'scripts', because those scripts all 'resolve' to Japanese when applying the resolution rules from UTS 39 5.1. It also allows an atom like :Tシャツ , the Japanese word for 't-shirt', which incorporates a Latin capital T, because {Latn, Jpan} is one of the allowed script mixings in the definition of 'Highly Restrictive' in UTS 39 5.2, and it 'covers' the string. However, Elixir would prevent tokenization in code like if аdmin, do: :ok, else: :err , where the scriptset for the 'a' character is {Cyrillic} but all other characters have scriptsets of {Latin}. The scriptsets fail to resolve, and the scriptsets from the definition of 'Highly Restrictive' in UTS 39 5.2 do not cover the string either, so a descriptive error is shown. C4, C5 (inapplicable) 'C4 - Restriction Level detection' conformance is not claimed and does not apply to identifiers in code; rather, it applies to classifying the level of safety of a given arbitrary string into one of 5 restriction levels. 'C5 - Mixed number detection' conformance is inapplicable as Elixir does not support Unicode numbers. Addition normalizations and documented UTS 39 modifications As of Elixir 1.14, some codepoints in \\p{Identifier_Status=Restricted} are normalized to other, unrestricted codepoints. Initially this is only done to translate MICRO SIGN µ to Greek lowercase mu, μ . This is not a modification of UTS39 clauses C1 (General Security Profile) or C2 (Confusability Detection); however, it is a documented modification of C3, 'Mixed-Script detection'. Mixed-script detection is modified by these normalizations to the extent that the normalized codepoint is given the union of scriptsets from both characters. For instance, in the example of MICRO =&gt; MU, Micro was a 'Common'-script character -- the same script given to the '_' underscore codepoint -- and thus the normalized character's scriptset will be {Greek, Common}. 'Common' intersects with all non-empty scriptsets, and thus the normalized character can be used in tokens written in any script without causing script mixing. The code points normalized in this fashion are those that are in use in the community, and judged not likely to cause issues with unsafe script mixing. For instance, the MICRO or MU codepoint may be used in an atom or variable dealing with microseconds.","ref":"unicode-syntax.html#unicode-technical-standard-39","source_doc":"The general Elixir identifier rule is specified as:\n\n    <Identifier> := <Start> <Continue>* <Ending>?\n\nwhere `<Start>` uses the same categories as the spec but normalizes them to the NFC form (see R4):\n\n> characters derived from the Unicode General Category of uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus `Other_ID_Start`, minus `Pattern_Syntax` and `Pattern_White_Space` code points\n>\n> In set notation: `[\\p{L}\\p{Nl}\\p{Other_ID_Start}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}]`.\n\nand `<Continue>` uses the same categories as the spec but normalizes them to the NFC form (see R4):\n\n> ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus `Other_ID_Continue`, minus `Pattern_Syntax` and `Pattern_White_Space` code points.\n>\n> In set notation: `[\\p{ID_Start}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}\\p{Other_ID_Continue}-\\p{Pattern_Syntax}-\\p{Pattern_White_Space}]`.\n\n`<Ending>` is an addition specific to Elixir that includes only the code points `?` (003F) and `!` (0021).\n\nThe spec also provides a `<Medial>` set, but Elixir does not include any character on this set. Therefore, the identifier rule has been simplified to consider this.\n\nElixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. Bidirectional control characters are also not supported. R1b is guaranteed for backwards compatibility purposes.\n\n##","title":"Unicode Syntax - Unicode Technical Standard #39","type":"extras"},{"doc":"Elixir treats documentation as a first-class citizen. Documentation must be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices, and doctests.","ref":"writing-documentation.html","source_doc":"# Writing Documentation\n\nElixir treats documentation as a first-class citizen. Documentation must be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices, and doctests.","title":"Writing Documentation","type":"extras"},{"doc":"Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the one from GitHub as a getting started point: Basic writing and formatting syntax","ref":"writing-documentation.html#markdown","source_doc":"Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the one from GitHub as a getting started point:\n\n  * [Basic writing and formatting syntax](https://help.github.com/articles/basic-writing-and-formatting-syntax/)","title":"Writing Documentation - Markdown","type":"extras"},{"doc":"Documentation in Elixir is usually attached to module attributes. Let's see an example: defmodule MyApp.Hello do @moduledoc &quot;&quot;&quot; This is the Hello module. &quot;&quot;&quot; @moduledoc since : &quot;1.0.0&quot; @doc &quot;&quot;&quot; Says hello to the given `name`. Returns `:ok`. ## Examples iex&gt; MyApp.Hello.world(:john) :ok &quot;&quot;&quot; @doc since : &quot;1.3.0&quot; def world ( name ) do IO . puts ( &quot;hello \#{ name } &quot; ) end end The @moduledoc attribute is used to add documentation to the module. @doc is used before a function to provide documentation for it. Besides the attributes above, @typedoc can also be used to attach documentation to types defined as part of typespecs. Elixir also allows metadata to be attached to documentation, by passing a keyword list to @doc and friends.","ref":"writing-documentation.html#module-attributes","source_doc":"Documentation in Elixir is usually attached to module attributes. Let's see an example:\n\n    defmodule MyApp.Hello do\n      @moduledoc \"\"\"\n      This is the Hello module.\n      \"\"\"\n      @moduledoc since: \"1.0.0\"\n\n      @doc \"\"\"\n      Says hello to the given `name`.\n\n      Returns `:ok`.","title":"Writing Documentation - Module Attributes","type":"extras"},{"doc":"When documenting a function, argument names are inferred by the compiler. For example: def size ( %{ size : size } ) do size end The compiler will infer this argument as map . Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation: def size ( map_with_size ) def size ( %{ size : size } ) do size end","ref":"writing-documentation.html#function-arguments","source_doc":"iex> MyApp.Hello.world(:john)\n          :ok\n\n      \"\"\"\n      @doc since: \"1.3.0\"\n      def world(name) do\n        IO.puts(\"hello \#{name}\")\n      end\n    end\n\nThe `@moduledoc` attribute is used to add documentation to the module. `@doc` is used before a function to provide documentation for it. Besides the attributes above, `@typedoc` can also be used to attach documentation to types defined as part of typespecs. Elixir also allows metadata to be attached to documentation, by passing a keyword list to `@doc` and friends.","title":"Writing Documentation - Function Arguments","type":"extras"},{"doc":"Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as @moduledoc , @typedoc , and @doc ). A commonly used metadata is :since , which annotates in which version that particular module, function, type, or callback was added, as shown in the example above. Another common metadata is :deprecated , which emits a warning in the documentation, explaining that its usage is discouraged: @doc deprecated : &quot;Use Foo.bar/2 instead&quot; Note that the :deprecated key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the @deprecated attribute: @deprecated &quot;Use Foo.bar/2 instead&quot; Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.","ref":"writing-documentation.html#documentation-metadata","source_doc":"When documenting a function, argument names are inferred by the compiler. For example:\n\n    def size(%{size: size}) do\n      size\n    end\n\nThe compiler will infer this argument as `map`. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:\n\n    def size(map_with_size)\n    def size(%{size: size}) do\n      size\n    end","title":"Writing Documentation - Documentation metadata","type":"extras"},{"doc":"When writing documentation: Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like ExDoc use the first line to generate a summary. Reference modules by their full name. Markdown uses backticks ( ` ) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called MyApp.Hello , always reference it as `MyApp.Hello` and never as `Hello` . Reference functions by name and arity if they are local, as in `world/1` , or by module, name and arity if pointing to an external module: `MyApp.Hello.world/1` . Reference a @callback by prepending c: , as in `c:world/1` . Reference a @type by prepending t: , as in `t:values/0` . Start new sections with second level Markdown headers ## . First level headers are reserved for module and function names. Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause. Use the :since key in the documentation metadata to annotate whenever new functions or modules are added to your API.","ref":"writing-documentation.html#recommendations","source_doc":"Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as `@moduledoc`, `@typedoc`, and `@doc`). A commonly used metadata is `:since`, which annotates in which version that particular module, function, type, or callback was added, as shown in the example above.\n\nAnother common metadata is `:deprecated`, which emits a warning in the documentation, explaining that its usage is discouraged:\n\n    @doc deprecated: \"Use Foo.bar/2 instead\"\n\nNote that the `:deprecated` key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the `@deprecated` attribute:\n\n    @deprecated \"Use Foo.bar/2 instead\"\n\nMetadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.","title":"Writing Documentation - Recommendations","type":"extras"},{"doc":"We recommend that developers include examples in their documentation, often under their own ## Examples heading. To ensure examples do not get out of date, Elixir's test framework (ExUnit) provides a feature called doctests that allows developers to test the examples in their documentation. Doctests work by parsing out code samples starting with iex&gt; from the documentation. You can read more about it at ExUnit.DocTest . Note that doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the iex&gt; prompt.","ref":"writing-documentation.html#doctests","source_doc":"When writing documentation:\n\n  * Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like [ExDoc](https://github.com/elixir-lang/ex_doc/) use the first line to generate a summary.\n\n  * Reference modules by their full name.\n\n    Markdown uses backticks (`` ` ``) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called `MyApp.Hello`, always reference it as `` `MyApp.Hello` `` and never as `` `Hello` ``.\n\n  * Reference functions by name and arity if they are local, as in `` `world/1` ``, or by module, name and arity if pointing to an external module: `` `MyApp.Hello.world/1` ``.\n\n  * Reference a `@callback` by prepending `c:`, as in `` `c:world/1` ``.\n\n  * Reference a `@type` by prepending `t:`, as in `` `t:values/0` ``.\n\n  * Start new sections with second level Markdown headers `##`. First level headers are reserved for module and function names.\n\n  * Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause.\n\n  * Use the `:since` key in the documentation metadata to annotate whenever new functions or modules are added to your API.","title":"Writing Documentation - Doctests","type":"extras"},{"doc":"Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API. Code comments are aimed at developers reading the code. They are useful for marking improvements, leaving notes (for example, why you had to resort to a workaround due to a bug in a library), and so forth. They are tied to the source code: you can completely rewrite a function and remove all existing code comments, and it will continue to behave the same, with no change to either its behaviour or its documentation. Because private functions cannot be accessed externally, Elixir will warn if a private function has a @doc attribute and will discard its content. However, you can add code comments to private functions, as with any other piece of code, and we recommend developers to do so whenever they believe it will add relevant information to the readers and maintainers of such code. Finally, beware of redundant code comments, such as the ones describing the exact same that the code does: # Total is the sum of the batch and individual entries total = batch_sum + individual_sum In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.","ref":"writing-documentation.html#documentation-code-comments","source_doc":"We recommend that developers include examples in their documentation, often under their own `","title":"Writing Documentation - Documentation != Code comments","type":"extras"},{"doc":"Besides the modules and functions libraries provide as part of their public interface, libraries may also implement important functionality that is not part of their API. While these modules and functions can be accessed, they are meant to be internal to the library and thus should not have documentation for end users. Conveniently, Elixir allows developers to hide modules and functions from the documentation, by setting @doc false to hide a particular function, or @moduledoc false to hide the whole module. If a module is hidden, you may even document the functions in the module, but the module itself won't be listed in the documentation: defmodule MyApp.Hidden do @moduledoc false @doc &quot;&quot;&quot; This function won&#39;t be listed in docs. &quot;&quot;&quot; def function_that_wont_be_listed_in_docs do # ... end end In case you don't want to hide a whole module, you can hide functions individually: defmodule MyApp.Sample do @doc false def add ( a , b ) , do : a + b end However, keep in mind @moduledoc false or @doc false do not make a function private. The function above can still be invoked as MyApp.Sample.add(1, 2) . Not only that, if MyApp.Sample is imported, the add/2 function will also be imported into the caller. For those reasons, be cautious when adding @doc false to functions, instead use one of these two options: Move the undocumented function to a module with @moduledoc false , like MyApp.Hidden , ensuring the function won't be accidentally exposed or imported. Remember that you can use @moduledoc false to hide a whole module and still document each function with @doc . Tools will still ignore the module. Start the function name with one or two underscores, for example, __add__/2 . Functions starting with underscore are automatically treated as hidden, although you can also be explicit and add @doc false . The compiler does not import functions with leading underscores and they hint to anyone reading the code of their intended private usage.","ref":"writing-documentation.html#hiding-internal-modules-and-functions","source_doc":"Note that doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the `iex>` prompt.","title":"Writing Documentation - Hiding internal Modules and Functions","type":"extras"},{"doc":"Elixir stores documentation inside pre-defined chunks in the bytecode. Documentation is not loaded into memory when modules are loaded, instead, it can be read from the bytecode in disk using the Code.fetch_docs/1 function. The downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not write their bytecode to disk.","ref":"writing-documentation.html#code-fetch_docs-1","source_doc":"Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API.\n\nCode comments are aimed at developers reading the code. They are useful for marking improvements, leaving notes (for example, why you had to resort to a workaround due to a bug in a library), and so forth. They are tied to the source code: you can completely rewrite a function and remove all existing code comments, and it will continue to behave the same, with no change to either its behaviour or its documentation.\n\nBecause private functions cannot be accessed externally, Elixir will warn if a private function has a `@doc` attribute and will discard its content. However, you can add code comments to private functions, as with any other piece of code, and we recommend developers to do so whenever they believe it will add relevant information to the readers and maintainers of such code.\n\nFinally, beware of redundant code comments, such as the ones describing the exact same that the code does:\n\n    # Total is the sum of the batch and individual entries\n    total = batch_sum + individual_sum\n\nIn summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.","title":"Writing Documentation - Code.fetch_docs/1","type":"extras"},{"doc":"This release requires Erlang/OTP 24 and later. Elixir v1.15 is a smaller release with focused improvements on compilation and boot times. This release also completes our integration process with Erlang/OTP logger, bringing new features such as log rotation and compaction out of the box. Finally, you will also find additional convenience functions in Map , Keyword , all Calendar modules, and others.","ref":"changelog.html","source_doc":"# Changelog for Elixir v1.15\n\nThis release requires Erlang/OTP 24 and later.\n\nElixir v1.15 is a smaller release with focused improvements\non compilation and boot times. This release also completes\nour integration process with Erlang/OTP logger, bringing new\nfeatures such as log rotation and compaction out of the box.\n\nFinally, you will also find additional convenience functions in\n`Map`, `Keyword`, all Calendar modules, and others.","title":"Changelog for Elixir v1.15","type":"extras"},{"doc":"The last several releases brought improvements to compilation time and this version is no different. In particular, this version now caches and prunes load paths before compilation, ensuring your project (and dependencies!) compile faster and in an environment closer to production. In a nutshell the Erlang VM loads modules from code paths. Each application that ships with Erlang and Elixir plus each dependency end-up being an entry in your code path. The larger the code path, the more work Erlang has to do in order to find a module. In previous versions, Mix would only add entries to the load paths. Therefore, if you compiled 20 dependencies and you went to compile the 21st, the code path would have 21 entries (plus all Erlang and Elixir apps). This allowed modules from unrelated dependencies to be seen and made compilation slower the more dependencies you had. In this release, we will now prune the code paths to only the ones listed as dependencies. Previously if you attempted to use an Erlang/OTP or Elixir module without adding its dependency, we would warn. Now the module won't be found altogether (instead of warning as in previous versions), which is also the behaviour you see if you ran your application as a mix release . If you are using an application that does not correctly lists its dependencies, they will have to be updated accordingly (as previously warned). You can temporarily disable this new behaviour by setting prune_code_paths: false in your mix.exs . Furthermore, Erlang/OTP 26 allows us to start applications concurrently and cache the code path lookups, decreasing the cost of booting applications. The combination of Elixir v1.15 and Erlang/OTP 26 should reduce the boot time of applications, such as when starting iex -S mix or running a single test with mix test , from 5% to 15%.","ref":"changelog.html#compile-and-boot-time-improvements","source_doc":"The last several releases brought improvements to compilation\ntime and this version is no different. In particular, this version\nnow caches and prunes load paths before compilation, ensuring your\nproject (and dependencies!) compile faster and in an environment\ncloser to production.\n\nIn a nutshell the Erlang VM loads modules from code paths. Each\napplication that ships with Erlang and Elixir plus each dependency\nend-up being an entry in your code path. The larger the code path,\nthe more work Erlang has to do in order to find a module.\n\nIn previous versions, Mix would only add entries to the load paths.\nTherefore, if you compiled 20 dependencies and you went to compile\nthe 21st, the code path would have 21 entries (plus all Erlang and\nElixir apps). This allowed modules from unrelated dependencies to\nbe seen and made compilation slower the more dependencies you had.\n\nIn this release, we will now prune the code paths to only the ones\nlisted as dependencies. Previously if you attempted to use an\nErlang/OTP or Elixir module without adding its dependency, we would warn.\nNow the module won't be found altogether (instead of warning as in\nprevious versions), which is also the behaviour you see if you ran\nyour application as a `mix release`. If you are using an application\nthat does not correctly lists its dependencies, they will have to\nbe updated accordingly (as previously warned). You can temporarily\ndisable this new behaviour by setting `prune_code_paths: false` in\nyour `mix.exs`.\n\nFurthermore, Erlang/OTP 26 allows us to start applications concurrently\nand cache the code path lookups, decreasing the cost of booting applications.\nThe combination of Elixir v1.15 and Erlang/OTP 26 should reduce the boot\ntime of applications, such as when starting `iex -S mix` or running a single\ntest with `mix test`, from 5% to 15%.","title":"Changelog for Elixir v1.15 - Compile and boot-time improvements","type":"extras"},{"doc":"TODO.","ref":"changelog.html#compiler-warnings-and-errors","source_doc":"TODO.","title":"Changelog for Elixir v1.15 - Compiler warnings and errors","type":"extras"},{"doc":"This provides additional features such as global logger metadata and file logging (with rotation and compaction) out-of-the-box! See the Logger documentation for more information. TODO: Mention :console vs Logger.Backends.Console","ref":"changelog.html#integration-with-erlang-otp-logger","source_doc":"This provides additional features such as global logger metadata and\nfile logging (with rotation and compaction) out-of-the-box! See\nthe `Logger` documentation for more information.\n\nTODO: Mention :console vs Logger.Backends.Console","title":"Changelog for Elixir v1.15 - Integration with Erlang/OTP logger","type":"extras"},{"doc":"1. Enhancements EEx [EEx] Include source code snippets in syntax errors Elixir [Calendar] Add support for epoch time (%s) to Calendar.strftime/2 [Code] Code.format_string!/2 now converts 'charlists' into ~c&quot;charlists&quot; by default [Code] Add :on_undefined_variable to the compiler options to preserve the warning behaviour which was deprecated back in Elixir v1.4 [Code] Add Code.loaded?/1 and Code.ensure_all_loaded(!)/1 [Code] Add Code.prepend_paths/1 , Code.append_paths/1 , and Code.delete_paths/1 [Code] Support nested expressions in Code.cursor_context/1 [Date] Add Date.before?/2 and Date.after?/2 [DateTime] Add DateTime.before?/2 and DateTime.after?/2 [Inspect] Inspect now renders 'charlists' as ~c&quot;charlists&quot; by default [Kernel] Break down case and cond inside dbg/2 [Kernel] Add t:nonempty_binary/0 and t:nonempty_bitstring/0 [Kernel] Treat @behaviour s as runtime dependencies [Kernel] Do not add runtime dependencies for alias references in patterns and guards [Kernel] Warn for nested calls without parens inside keywords [Kernel] Support for multi-letter uppercase sigils [Kernel] Introduce mechanism to collect several errors in a module. Previously, as soon as there was a compilation error, compilation would fail. Now the compiler became a bit smarter and will report multiple errors whenever possible as multiple error: ... messages, similar to warning: ... [Kernel.CLI] Support --sname undefined / --name undefined so a name is automatically generated [Keyword] Add Keyword.split_with/2 [Macro] Improve error message when piping into an expression ending in bracket-based access [Macro.Env] Add Macro.Env.lookup_alias_as/2 [Map] Add Map.split_with/2 [Map] Add Map.intersect/2 and Map.intersect/3 [MapSet] Add MapSet.split_with/2 [MapSet] Optimize most functions [NaiveDateTime] Add NaiveDateTime.beginning_of_day/1 and NaiveDateTime.end_of_day/1 [NaiveDateTime] Add NaiveDateTime.before?/2 and NaiveDateTime.after?/2 [OptionParser] Support :return_separator option [Process] Add Process.alias/0,1 and Process.unalias/1 [Range] Add Range.split/2 [String] Update Unicode to version 15.0.0 [String] Add :fast_ascii mode to String.valid?/2 [Supervisor] Add support for automatic shutdown in Supervisor [System] Support :lines in System.cmd/3 to capture output line by line [Task] Remove head of line blocking on Task.yield_many/2 [Task] Enable selective receive optimizations in Erlang/OTP 26+ [Task.Supervisor] Do not copy args on temporary Task.Supervisor.start_child/2 [Time] Add Time.before?/2 and Time.after?/2 [URI] Add URI.append_path/2 ExUnit [ExUnit] Add more color configuration to ExUnit CLI formatter [ExUnit.Callbacks] Accept {module, function} tuples in ExUnit setup callbacks [ExUnit.Doctest] Add ExUnit.DocTest.doctest_file/2 [ExUnit.Formatter] When comparing to anonymous functions, defined at the same place but capturing a different environment, we will now also diff the environments IEx [IEx] Make pry opt-in on dbg with --dbg pry [IEX] Support IEX_HOME [IEx.Helpers] Add runtime_info(:allocators) [IEx.Info] Implement protocol for Range , DateTime and Regex Logger [Logger] Add Logger.add_handlers/1 and Logger.default_formatter/1 [Logger] Introduce default_formatter and default_handler configuration for Logger which configures Erlang/OTP logger [Logger.Formatter] Implement the Erlang Logger formatter API [Logger.Formatter] Add support for ports in Logger metadata Mix [Mix.Project] Support def cli to unify all CLI defaults in a single place [Mix.Project] Add Mix.Project.deps_tree/1 [mix eval] Allow passing additional arguments [mix compile] Set --all-warnings by default [mix compile] Reduce the amount of filesystem lookups for path dependencies by storing timestamps in manifests [mix compile.app] Write optional_applications to .app file [mix compile.elixir] Add --purge-consolidation-path-if-stale which will purge the given consolidation path if compilation is required [mix deps.get] Automatically install Hex and Rebar on mix deps.get / mix deps.update [mix deps.get] Support --check-locked which raises if changes to the lockfile are required [mix format] Allow multiple formatters per file extension and sigil [mix format] Show diffs whenever --check-formatted fails [mix profile.fprof] Support --trace-to-file to improve performance when working with large outputs [mix release] Allow passing additional arguments to the eval command [mix xref graph] Support --output flag 2. Bug fixes Elixir [Code.Formatter] Fix a scenario where a keyword followed by parenthesis could go above the maximum line length [Code.Formatter] Remove unnecessary parens in nullary type funs [Exception] Fix operator precedence when printing guards in Exception.blame/3 [File] Do not raise if there are file system race conditions in File.cp/2 [Kernel] Expand macros on the left side of -&gt; in try/rescue [Kernel] Raise on misplaced ... inside typespecs [Kernel.ParallelCompiler] Make sure compiler doesn't crash when there are stray messages in the inbox [Kernel.ParallelCompiler] Track compile and runtime warnings separately [URI] Make sure URI.merge/2 works accordingly with relative paths ExUnit [ExUnit] Fix crash when @tag capture_log: true was set to true and the Logger application was shut down in the middle of the test [ExUnit] Do not merge context as tags inside the runner to reduce memory usage when emitting events to formatters [ExUnit] Do not expand or collect vars from quote in ExUnit assertions IEx [IEx] Do not spawn a process to read IO. This fixes a bug where multiline paste stopped working whenever the input reader was killed [IEx] Do not perform completion for prompts triggered during code evaluation Mix [mix compile] Include cwd in compiler cache key [mix release] Fix Windows service when invoking erlsrv.exe in path with spaces 3. Soft deprecations (no warnings emitted) Mix [Mix.Project] :preferred_cli_env is deprecated in favor of :preferred_envs in def cli [Mix.Project] :preferred_cli_target is deprecated in favor of :preferred_targets in def cli [mix local] The environment variable HEX_MIRROR is deprecated in favor of HEX_BUILDS_URL 4. Hard deprecations Elixir [Calendar] Calendar.ISO.day_of_week/3 is deprecated in favor of Calendar.ISO.day_of_week/4 [Exception] Exception.exception?/1 is deprecated in favor of Kernel.is_exception/1 [Kernel] Deprecate ... as a valid function call identifier [Regex] Regex.regex?/1 is deprecated in favor of Kernel.is_struct/2 Logger [Logger] Logger.warn/2 is deprecated in favor of Logger.warning/2","ref":"changelog.html#v1-15-0-dev","source_doc":"#","title":"Changelog for Elixir v1.15 - v1.15.0-dev","type":"extras"},{"doc":"The CHANGELOG for v1.14 releases can be found in the v1.14 branch .","ref":"changelog.html#v1-14","source_doc":"##","title":"Changelog for Elixir v1.15 - v1.14","type":"extras"}]