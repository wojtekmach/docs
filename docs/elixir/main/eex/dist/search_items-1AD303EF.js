searchNodes=[{"doc":"EEx stands for Embedded Elixir. Embedded Elixir allows you to embed Elixir code inside a string in a robust way. iex&gt; EEx . eval_string ( &quot;foo &lt;%= bar %&gt;&quot; , bar : &quot;baz&quot; ) &quot;foo baz&quot; This module provides three main APIs for you to use: Evaluate a string ( eval_string/3 ) or a file ( eval_file/3 ) directly. This is the simplest API to use but also the slowest, since the code is evaluated at runtime and not precompiled. Define a function from a string ( function_from_string/5 ) or a file ( function_from_file/5 ). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time. Compile a string ( compile_string/2 ) or a file ( compile_file/2 ) into Elixir syntax tree. This is the API used by both functions above and is available to you if you want to provide your own ways of handling the compiled template. The APIs above support several options, documented below. You may also pass an engine which customizes how the EEx code is compiled. Options All functions in this module, unless otherwise noted, accept EEx-related options. They are: :file - the file to be used in the template. Defaults to the given file the template is read from or to &quot;nofile&quot; when compiling from a string. :line - the line to be used as the template start. Defaults to 1 . :indentation - (since v1.11.0) an integer added to the column after every new line. Defaults to 0 . :engine - the EEx engine to be used for compilation. Defaults to EEx.SmartEngine . :trim - if true , trims whitespace left and right of quotation as long as at least one newline is present. All subsequent newlines and spaces are removed but one newline is retained. Defaults to false . :parser_options - (since: 1.13.0) allow customizing the parsed code that is generated. See Code.string_to_quoted/2 for available options. Note that the options :file , :line and :column are ignored if passed in. Defaults to Code.get_compiler_option(:parser_options) (which defaults to [] if not set). Tags EEx supports multiple tags, declared below: &lt; % Elixir expression : executes code but discards output % &gt; &lt; % = Elixir expression : executes code and prints result % &gt; &lt; % % EEx quotation : returns the contents inside the tag as is % &gt; &lt; % ! -- Comments : they are discarded from source -- % &gt; EEx supports additional tags, that may be used by some engines, but they do not have a meaning by default: &lt; % | ... % &gt; &lt; % / ... % &gt; Engine EEx has the concept of engines which allows you to modify or transform the code extracted from the given string or file. By default, EEx uses the EEx.SmartEngine that provides some conveniences on top of the simple EEx.Engine . EEx.SmartEngine The smart engine uses EEx default rules and adds the @ construct for reading template assigns: iex&gt; EEx . eval_string ( &quot;&lt;%= @foo %&gt;&quot; , assigns : [ foo : 1 ] ) &quot;1&quot; In other words, &lt;%= @foo %&gt; translates to: &lt; % = { :ok , v } = Access . fetch ( assigns , :foo ) ; v % &gt; The assigns extension is useful when the number of variables required by the template is not specified at compilation time.","ref":"EEx.html","source_doc":"EEx stands for Embedded Elixir.\n\nEmbedded Elixir allows you to embed Elixir code inside a string\nin a robust way.\n\n    iex> EEx.eval_string(\"foo <%= bar %>\", bar: \"baz\")\n    \"foo baz\"\n\nThis module provides three main APIs for you to use:\n\n  1. Evaluate a string (`eval_string/3`) or a file (`eval_file/3`)\n     directly. This is the simplest API to use but also the\n     slowest, since the code is evaluated at runtime and not precompiled.\n\n  2. Define a function from a string (`function_from_string/5`)\n     or a file (`function_from_file/5`). This allows you to embed\n     the template as a function inside a module which will then\n     be compiled. This is the preferred API if you have access\n     to the template at compilation time.\n\n  3. Compile a string (`compile_string/2`) or a file (`compile_file/2`)\n     into Elixir syntax tree. This is the API used by both functions\n     above and is available to you if you want to provide your own\n     ways of handling the compiled template.\n\nThe APIs above support several options, documented below. You may\nalso pass an engine which customizes how the EEx code is compiled.\n\n## Options\n\nAll functions in this module, unless otherwise noted, accept EEx-related\noptions. They are:\n\n  * `:file` - the file to be used in the template. Defaults to the given\n    file the template is read from or to `\"nofile\"` when compiling from a string.\n\n  * `:line` - the line to be used as the template start. Defaults to `1`.\n\n  * `:indentation` - (since v1.11.0) an integer added to the column after every\n    new line. Defaults to `0`.\n\n  * `:engine` - the EEx engine to be used for compilation. Defaults to `EEx.SmartEngine`.\n\n  * `:trim` - if `true`, trims whitespace left and right of quotation as\n    long as at least one newline is present. All subsequent newlines and\n    spaces are removed but one newline is retained. Defaults to `false`.\n\n  * `:parser_options` - (since: 1.13.0) allow customizing the parsed code\n    that is generated. See `Code.string_to_quoted/2` for available options.\n    Note that the options `:file`, `:line` and `:column` are ignored if\n    passed in. Defaults to `Code.get_compiler_option(:parser_options)`\n    (which defaults to `[]` if not set).\n\n## Tags\n\nEEx supports multiple tags, declared below:\n\n    <% Elixir expression: executes code but discards output %>\n    <%= Elixir expression: executes code and prints result %>\n    <%% EEx quotation: returns the contents inside the tag as is %>\n    <%!-- Comments: they are discarded from source --%>\n\nEEx supports additional tags, that may be used by some engines,\nbut they do not have a meaning by default:\n\n    <%| ... %>\n    <%/ ... %>\n\n## Engine\n\nEEx has the concept of engines which allows you to modify or\ntransform the code extracted from the given string or file.\n\nBy default, `EEx` uses the `EEx.SmartEngine` that provides some\nconveniences on top of the simple `EEx.Engine`.\n\n### `EEx.SmartEngine`\n\nThe smart engine uses EEx default rules and adds the `@` construct\nfor reading template assigns:\n\n    iex> EEx.eval_string(\"<%= @foo %>\", assigns: [foo: 1])\n    \"1\"\n\nIn other words, `<%= @foo %>` translates to:\n\n    <%= {:ok, v} = Access.fetch(assigns, :foo); v %>\n\nThe `assigns` extension is useful when the number of variables\nrequired by the template is not specified at compilation time.\n","title":"EEx","type":"module"},{"doc":"Gets a filename and generates a quoted expression that can be evaluated by Elixir or compiled to a function. This is useful if you want to compile a EEx template into code and inject that code somewhere or evaluate it at runtime. The generated quoted code will use variables defined in the template that will be taken from the context where the code is evaluated. If you have a template such as &lt;%= a + b %&gt; , then the returned quoted code will use the a and b variables in the context where it's evaluated. See examples below. The supported options are described in the module docs . Examples # sample.eex &lt; % = a + b % &gt; # In code: quoted = EEx . compile_file ( &quot;sample.eex&quot; ) { result , _bindings } = Code . eval_quoted ( quoted , a : 1 , b : 2 ) result #=&gt; &quot;3&quot;","ref":"EEx.html#compile_file/2","source_doc":"Gets a `filename` and generates a quoted expression\nthat can be evaluated by Elixir or compiled to a function.\n\nThis is useful if you want to compile a EEx template into code and inject\nthat code somewhere or evaluate it at runtime.\n\nThe generated quoted code will use variables defined in the template that\nwill be taken from the context where the code is evaluated. If you\nhave a template such as `<%= a + b %>`, then the returned quoted code\nwill use the `a` and `b` variables in the context where it's evaluated. See\nexamples below.\n\nThe supported `options` are described [in the module docs](#module-options).\n\n## Examples\n\n    # sample.eex\n    <%= a + b %>\n\n    # In code:\n    quoted = EEx.compile_file(\"sample.eex\")\n    {result, _bindings} = Code.eval_quoted(quoted, a: 1, b: 2)\n    result\n    #=> \"3\"\n\n","title":"EEx.compile_file/2","type":"function"},{"doc":"Gets a string source and generates a quoted expression that can be evaluated by Elixir or compiled to a function. This is useful if you want to compile a EEx template into code and inject that code somewhere or evaluate it at runtime. The generated quoted code will use variables defined in the template that will be taken from the context where the code is evaluated. If you have a template such as &lt;%= a + b %&gt; , then the returned quoted code will use the a and b variables in the context where it's evaluated. See examples below. The supported options are described in the module docs . Examples iex&gt; quoted = EEx . compile_string ( &quot;&lt;%= a + b %&gt;&quot; ) iex&gt; { result , _bindings } = Code . eval_quoted ( quoted , a : 1 , b : 2 ) iex&gt; result &quot;3&quot;","ref":"EEx.html#compile_string/2","source_doc":"Gets a string `source` and generates a quoted expression\nthat can be evaluated by Elixir or compiled to a function.\n\nThis is useful if you want to compile a EEx template into code and inject\nthat code somewhere or evaluate it at runtime.\n\nThe generated quoted code will use variables defined in the template that\nwill be taken from the context where the code is evaluated. If you\nhave a template such as `<%= a + b %>`, then the returned quoted code\nwill use the `a` and `b` variables in the context where it's evaluated. See\nexamples below.\n\nThe supported `options` are described [in the module docs](#module-options).\n\n## Examples\n\n    iex> quoted = EEx.compile_string(\"<%= a + b %>\")\n    iex> {result, _bindings} = Code.eval_quoted(quoted, a: 1, b: 2)\n    iex> result\n    \"3\"\n\n","title":"EEx.compile_string/2","type":"function"},{"doc":"Gets a filename and evaluate the values using the bindings . The supported options are described in the module docs . Examples # sample.eex foo &lt; % = bar % &gt; # IEx EEx . eval_file ( &quot;sample.eex&quot; , bar : &quot;baz&quot; ) #=&gt; &quot;foo baz&quot;","ref":"EEx.html#eval_file/3","source_doc":"Gets a `filename` and evaluate the values using the `bindings`.\n\nThe supported `options` are described [in the module docs](#module-options).\n\n## Examples\n\n    # sample.eex\n    foo <%= bar %>\n\n    # IEx\n    EEx.eval_file(\"sample.eex\", bar: \"baz\")\n    #=> \"foo baz\"\n\n","title":"EEx.eval_file/3","type":"function"},{"doc":"Gets a string source and evaluate the values using the bindings . The supported options are described in the module docs . Examples iex&gt; EEx . eval_string ( &quot;foo &lt;%= bar %&gt;&quot; , bar : &quot;baz&quot; ) &quot;foo baz&quot;","ref":"EEx.html#eval_string/3","source_doc":"Gets a string `source` and evaluate the values using the `bindings`.\n\nThe supported `options` are described [in the module docs](#module-options).\n\n## Examples\n\n    iex> EEx.eval_string(\"foo <%= bar %>\", bar: \"baz\")\n    \"foo baz\"\n\n","title":"EEx.eval_string/3","type":"function"},{"doc":"Generates a function definition from the file contents. The first argument is the kind of the generated function ( :def or :defp ). The name argument is the name that the generated function will have. file is the path to the EEx template file. args is a list of arguments that the generated function will accept. They will be available inside the EEx template. This function is useful in case you have templates but you want to precompile inside a module for speed. The supported options are described in the module docs . Examples # sample.eex &lt; % = a + b % &gt; # sample.ex defmodule Sample do require EEx EEx . function_from_file ( :def , :sample , &quot;sample.eex&quot; , [ :a , :b ] ) end # iex Sample . sample ( 1 , 2 ) #=&gt; &quot;3&quot;","ref":"EEx.html#function_from_file/5","source_doc":"Generates a function definition from the file contents.\n\nThe first argument is the kind of the generated function (`:def` or `:defp`).\nThe `name` argument is the name that the generated function will have.\n`file` is the path to the EEx template file. `args` is a list of arguments\nthat the generated function will accept. They will be available inside the EEx\ntemplate.\n\nThis function is useful in case you have templates but\nyou want to precompile inside a module for speed.\n\nThe supported `options` are described [in the module docs](#module-options).\n\n## Examples\n\n    # sample.eex\n    <%= a + b %>\n\n    # sample.ex\n    defmodule Sample do\n      require EEx\n      EEx.function_from_file(:def, :sample, \"sample.eex\", [:a, :b])\n    end\n\n    # iex\n    Sample.sample(1, 2)\n    #=> \"3\"\n\n","title":"EEx.function_from_file/5","type":"macro"},{"doc":"Generates a function definition from the given string. The first argument is the kind of the generated function ( :def or :defp ). The name argument is the name that the generated function will have. template is the string containing the EEx template. args is a list of arguments that the generated function will accept. They will be available inside the EEx template. The supported options are described in the module docs . Examples iex&gt; defmodule Sample do ...&gt; require EEx ...&gt; EEx . function_from_string ( :def , :sample , &quot;&lt;%= a + b %&gt;&quot; , [ :a , :b ] ) ...&gt; end iex&gt; Sample . sample ( 1 , 2 ) &quot;3&quot;","ref":"EEx.html#function_from_string/5","source_doc":"Generates a function definition from the given string.\n\nThe first argument is the kind of the generated function (`:def` or `:defp`).\nThe `name` argument is the name that the generated function will have.\n`template` is the string containing the EEx template. `args` is a list of arguments\nthat the generated function will accept. They will be available inside the EEx\ntemplate.\n\nThe supported `options` are described [in the module docs](#module-options).\n\n## Examples\n\n    iex> defmodule Sample do\n    ...>   require EEx\n    ...>   EEx.function_from_string(:def, :sample, \"<%= a + b %>\", [:a, :b])\n    ...> end\n    iex> Sample.sample(1, 2)\n    \"3\"\n\n","title":"EEx.function_from_string/5","type":"macro"},{"doc":"Tokenize the given contents according to the given options. Options :line - An integer to start as line. Default is 1. :column - An integer to start as column. Default is 1. :indentation - An integer that indicates the indentation. Default is 0. :trim - Tells the tokenizer to either trim the content or not. Default is false. :file - Can be either a file or a string &quot;nofile&quot;. Examples iex&gt; EEx . tokenize ( &#39;foo&#39; , line : 1 , column : 1 ) { :ok , [ { :text , &#39;foo&#39; , %{ column : 1 , line : 1 } } , { :eof , %{ column : 4 , line : 1 } } ] } Result It returns {:ok, [token]} where a token is one of: {:text, content, %{column: column, line: line}} {:expr, marker, content, %{column: column, line: line}} {:start_expr, marker, content, %{column: column, line: line}} {:middle_expr, marker, content, %{column: column, line: line}} {:end_expr, marker, content, %{column: column, line: line}} {:eof, %{column: column, line: line}} Or {:error, message, %{column: column, line: line}} in case of errors. Note new tokens may be added in the future.","ref":"EEx.html#tokenize/2","source_doc":"Tokenize the given contents according to the given options.\n\n## Options\n\n  * `:line` - An integer to start as line. Default is 1.\n  * `:column` - An integer to start as column. Default is 1.\n  * `:indentation` - An integer that indicates the indentation. Default is 0.\n  * `:trim` - Tells the tokenizer to either trim the content or not. Default is false.\n  * `:file` - Can be either a file or a string \"nofile\".\n\n## Examples\n\n    iex> EEx.tokenize('foo', line: 1, column: 1)\n    {:ok, [{:text, 'foo', %{column: 1, line: 1}}, {:eof, %{column: 4, line: 1}}]}\n\n## Result\n\nIt returns `{:ok, [token]}` where a token is one of:\n\n  * `{:text, content, %{column: column, line: line}}`\n  * `{:expr, marker, content, %{column: column, line: line}}`\n  * `{:start_expr, marker, content, %{column: column, line: line}}`\n  * `{:middle_expr, marker, content, %{column: column, line: line}}`\n  * `{:end_expr, marker, content, %{column: column, line: line}}`\n  * `{:eof, %{column: column, line: line}}`\n\nOr `{:error, message, %{column: column, line: line}}` in case of errors.\nNote new tokens may be added in the future.\n","title":"EEx.tokenize/2","type":"function"},{"doc":"","ref":"EEx.html#t:column/0","source_doc":false,"title":"EEx.column/0","type":"type"},{"doc":"","ref":"EEx.html#t:line/0","source_doc":false,"title":"EEx.line/0","type":"type"},{"doc":"","ref":"EEx.html#t:marker/0","source_doc":false,"title":"EEx.marker/0","type":"type"},{"doc":"","ref":"EEx.html#t:metadata/0","source_doc":false,"title":"EEx.metadata/0","type":"type"},{"doc":"","ref":"EEx.html#t:token/0","source_doc":false,"title":"EEx.token/0","type":"type"},{"doc":"Basic EEx engine that ships with Elixir. An engine needs to implement all callbacks below. This module also ships with a default engine implementation you can delegate to. See EEx.SmartEngine as an example.","ref":"EEx.Engine.html","source_doc":"Basic EEx engine that ships with Elixir.\n\nAn engine needs to implement all callbacks below.\n\nThis module also ships with a default engine implementation\nyou can delegate to. See `EEx.SmartEngine` as an example.\n","title":"EEx.Engine","type":"behaviour"},{"doc":"Handles assigns in quoted expressions. A warning will be printed on missing assigns. Future versions will raise. This can be added to any custom engine by invoking handle_assign/1 with Macro.prewalk/2 : def handle_expr ( state , token , expr ) do expr = Macro . prewalk ( expr , &amp; EEx.Engine . handle_assign / 1 ) super ( state , token , expr ) end","ref":"EEx.Engine.html#handle_assign/1","source_doc":"Handles assigns in quoted expressions.\n\nA warning will be printed on missing assigns.\nFuture versions will raise.\n\nThis can be added to any custom engine by invoking\n`handle_assign/1` with `Macro.prewalk/2`:\n\n    def handle_expr(state, token, expr) do\n      expr = Macro.prewalk(expr, &EEx.Engine.handle_assign/1)\n      super(state, token, expr)\n    end\n\n","title":"EEx.Engine.handle_assign/1","type":"function"},{"doc":"Default implementation for handle_begin/1 .","ref":"EEx.Engine.html#handle_begin/1","source_doc":"Default implementation for `c:handle_begin/1`.","title":"EEx.Engine.handle_begin/1","type":"function"},{"doc":"Invoked at the beginning of every nesting. It must return a new state that is used only inside the nesting. Once the nesting terminates, the current state is resumed.","ref":"EEx.Engine.html#c:handle_begin/1","source_doc":"Invoked at the beginning of every nesting.\n\nIt must return a new state that is used only inside the nesting.\nOnce the nesting terminates, the current `state` is resumed.\n","title":"EEx.Engine.handle_begin/1","type":"callback"},{"doc":"Default implementation for handle_body/1 .","ref":"EEx.Engine.html#handle_body/1","source_doc":"Default implementation for `c:handle_body/1`.","title":"EEx.Engine.handle_body/1","type":"function"},{"doc":"Called at the end of every template. It must return Elixir's quoted expressions for the template.","ref":"EEx.Engine.html#c:handle_body/1","source_doc":"Called at the end of every template.\n\nIt must return Elixir's quoted expressions for the template.\n","title":"EEx.Engine.handle_body/1","type":"callback"},{"doc":"Default implementation for handle_end/1 .","ref":"EEx.Engine.html#handle_end/1","source_doc":"Default implementation for `c:handle_end/1`.","title":"EEx.Engine.handle_end/1","type":"function"},{"doc":"Invokes at the end of a nesting. It must return Elixir's quoted expressions for the nesting.","ref":"EEx.Engine.html#c:handle_end/1","source_doc":"Invokes at the end of a nesting.\n\nIt must return Elixir's quoted expressions for the nesting.\n","title":"EEx.Engine.handle_end/1","type":"callback"},{"doc":"Default implementation for handle_expr/3 .","ref":"EEx.Engine.html#handle_expr/3","source_doc":"Default implementation for `c:handle_expr/3`.","title":"EEx.Engine.handle_expr/3","type":"function"},{"doc":"Called for the dynamic/code parts of a template. The marker is what follows exactly after &lt;% . For example, &lt;% foo %&gt; has an empty marker, but &lt;%= foo %&gt; has &quot;=&quot; as marker. The allowed markers so far are: &quot;&quot; &quot;=&quot; &quot;/&quot; &quot;|&quot; Markers &quot;/&quot; and &quot;|&quot; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises EEx.SyntaxError . It must return the updated state.","ref":"EEx.Engine.html#c:handle_expr/3","source_doc":"Called for the dynamic/code parts of a template.\n\nThe marker is what follows exactly after `<%`. For example,\n`<% foo %>` has an empty marker, but `<%= foo %>` has `\"=\"`\nas marker. The allowed markers so far are:\n\n  * `\"\"`\n  * `\"=\"`\n  * `\"/\"`\n  * `\"|\"`\n\nMarkers `\"/\"` and `\"|\"` are only for use in custom EEx engines\nand are not implemented by default. Using them without an\nappropriate implementation raises `EEx.SyntaxError`.\n\nIt must return the updated state.\n","title":"EEx.Engine.handle_expr/3","type":"callback"},{"doc":"Default implementation for handle_text/3 .","ref":"EEx.Engine.html#handle_text/3","source_doc":"Default implementation for `c:handle_text/3`.","title":"EEx.Engine.handle_text/3","type":"function"},{"doc":"Called for the text/static parts of a template. It must return the updated state.","ref":"EEx.Engine.html#c:handle_text/3","source_doc":"Called for the text/static parts of a template.\n\nIt must return the updated state.\n","title":"EEx.Engine.handle_text/3","type":"callback"},{"doc":"Default implementation for init/1 .","ref":"EEx.Engine.html#init/1","source_doc":"Default implementation for `c:init/1`.","title":"EEx.Engine.init/1","type":"function"},{"doc":"Called at the beginning of every template. It must return the initial state.","ref":"EEx.Engine.html#c:init/1","source_doc":"Called at the beginning of every template.\n\nIt must return the initial state.\n","title":"EEx.Engine.init/1","type":"callback"},{"doc":"","ref":"EEx.Engine.html#t:state/0","source_doc":false,"title":"EEx.Engine.state/0","type":"type"},{"doc":"The default engine used by EEx. It includes assigns (like @foo ) and possibly other conveniences in the future. Examples iex&gt; EEx . eval_string ( &quot;&lt;%= @foo %&gt;&quot; , assigns : [ foo : 1 ] ) &quot;1&quot; In the example above, we can access the value foo under the binding assigns using @foo . This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set. Assigns can also be used when compiled to a function: # sample.eex &lt; % = @a + @b % &gt; # sample.ex defmodule Sample do require EEx EEx . function_from_file ( :def , :sample , &quot;sample.eex&quot; , [ :assigns ] ) end # iex Sample . sample ( a : 1 , b : 2 ) #=&gt; &quot;3&quot;","ref":"EEx.SmartEngine.html","source_doc":"The default engine used by EEx.\n\nIt includes assigns (like `@foo`) and possibly other\nconveniences in the future.\n\n## Examples\n\n    iex> EEx.eval_string(\"<%= @foo %>\", assigns: [foo: 1])\n    \"1\"\n\nIn the example above, we can access the value `foo` under\nthe binding `assigns` using `@foo`. This is useful because\na template, after being compiled, can receive different\nassigns and would not require recompilation for each\nvariable set.\n\nAssigns can also be used when compiled to a function:\n\n    # sample.eex\n    <%= @a + @b %>\n\n    # sample.ex\n    defmodule Sample do\n      require EEx\n      EEx.function_from_file(:def, :sample, \"sample.eex\", [:assigns])\n    end\n\n    # iex\n    Sample.sample(a: 1, b: 2)\n    #=> \"3\"\n\n","title":"EEx.SmartEngine","type":"module"},{"doc":"","ref":"EEx.SyntaxError.html","source_doc":false,"title":"EEx.SyntaxError","type":"exception"}]