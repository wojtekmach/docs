searchNodes=[{"doc":"The high-level API. Req is composed of three main pieces: Req - the high-level API (you're here!) Req.Request - the low-level API and the request struct Req.Steps - the collection of built-in steps The high-level API is what most users of Req will use most of the time. Examples Making a GET request with Req.get!/1 : iex&gt; Req . get! ( &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) . body [ &quot;description&quot; ] &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; Same, but by explicitly building request struct first: iex&gt; req = Req . new ( base_url : &quot;https://api.github.com&quot; ) iex&gt; Req . get! ( req , url : &quot;/repos/elixir-lang/elixir&quot; ) . body [ &quot;description&quot; ] &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; Making a POST request with Req.post!/2 : iex&gt; Req . post! ( &quot;https://httpbin.org/post&quot; , form : [ comments : &quot;hello!&quot; ] ) . body [ &quot;form&quot; ] %{ &quot;comments&quot; =&gt; &quot;hello!&quot; }","ref":"Req.html","title":"Req","type":"module"},{"doc":"Returns default options. See default_options/1 for more information.","ref":"Req.html#default_options/0","title":"Req.default_options/0","type":"function"},{"doc":"Sets default options. Sets default options for Req.new/1 . Avoid setting default options in libraries as they are global. Examples iex&gt; Req . default_options ( base_url : &quot;https://httpbin.org&quot; ) iex&gt; Req . get! ( &quot;/statuses/201&quot; ) . status 201 iex&gt; Req . new ( ) |&gt; Req . get! ( url : &quot;/statuses/201&quot; ) . status 201","ref":"Req.html#default_options/1","title":"Req.default_options/1","type":"function"},{"doc":"Makes a DELETE request. See request/1 for a list of supported options. Examples With URL: iex&gt; Req . delete! ( &quot;https://httpbin.org/anything&quot; ) . body [ &quot;method&quot; ] &quot;DELETE&quot; With request struct: iex&gt; req = Req . new ( url : &quot;https://httpbin.org/anything&quot; ) iex&gt; Req . delete! ( req ) . body [ &quot;method&quot; ] &quot;DELETE&quot;","ref":"Req.html#delete!/2","title":"Req.delete!/2","type":"function"},{"doc":"Makes a GET request. See request/1 for a list of supported options. Examples With URL: iex&gt; Req . get! ( &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) . body [ &quot;description&quot; ] &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; With request struct: iex&gt; req = Req . new ( base_url : &quot;https://api.github.com&quot; ) iex&gt; Req . get! ( req , url : &quot;/repos/elixir-lang/elixir&quot; ) . status 200","ref":"Req.html#get!/2","title":"Req.get!/2","type":"function"},{"doc":"Makes a HEAD request. See request/1 for a list of supported options. Examples With URL: iex&gt; Req . head! ( &quot;https://httpbin.org/status/201&quot; ) . status 201 With request struct: iex&gt; req = Req . new ( base_url : &quot;https://httpbin.org&quot; ) iex&gt; Req . head! ( req , url : &quot;/status/201&quot; ) . status 201","ref":"Req.html#head!/2","title":"Req.head!/2","type":"function"},{"doc":"Returns a new request struct with built-in steps. See request/1 for a list of available options. See Req.Request module documentation for more information on the underlying request struct. Examples iex&gt; req = Req . new ( url : &quot;https://elixir-lang.org&quot; ) iex&gt; req . method :get iex&gt; URI . to_string ( req . url ) &quot;https://elixir-lang.org&quot;","ref":"Req.html#new/1","title":"Req.new/1","type":"function"},{"doc":"Makes a PATCH request. See request/1 for a list of supported options. Examples With URL: iex&gt; Req . patch! ( &quot;https://httpbin.org/anything&quot; , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot; With request struct: iex&gt; req = Req . new ( url : &quot;https://httpbin.org/anything&quot; ) iex&gt; Req . patch! ( req , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot;","ref":"Req.html#patch!/2","title":"Req.patch!/2","type":"function"},{"doc":"Makes a POST request. See request/1 for a list of supported options. Examples With URL: iex&gt; Req . post! ( &quot;https://httpbin.org/anything&quot; , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot; iex&gt; Req . post! ( &quot;https://httpbin.org/anything&quot; , form : [ x : 1 ] ) . body [ &quot;form&quot; ] %{ &quot;x&quot; =&gt; &quot;1&quot; } iex&gt; Req . post! ( &quot;https://httpbin.org/anything&quot; , json : %{ x : 2 } ) . body [ &quot;json&quot; ] %{ &quot;x&quot; =&gt; 2 } With request struct: iex&gt; req = Req . new ( url : &quot;https://httpbin.org/anything&quot; ) iex&gt; Req . post! ( req , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot;","ref":"Req.html#post!/2","title":"Req.post!/2","type":"function"},{"doc":"Makes a PUT request. See request/1 for a list of supported options. Examples With URL: iex&gt; Req . put! ( &quot;https://httpbin.org/anything&quot; , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot; With request struct: iex&gt; req = Req . new ( url : &quot;https://httpbin.org/anything&quot; ) iex&gt; Req . put! ( req , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot;","ref":"Req.html#put!/2","title":"Req.put!/2","type":"function"},{"doc":"Makes an HTTP request and returns a response or raises an error. See request/1 for more information. Examples iex&gt; Req . request! ( url : &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) . status 200","ref":"Req.html#request!/1","title":"Req.request!/1","type":"function"},{"doc":"Makes an HTTP request and returns a response or raises an error. See request/1 for more information. Examples iex&gt; req = Req . new ( base_url : &quot;https://api.github.com&quot; ) iex&gt; Req . request! ( req , url : &quot;/repos/elixir-lang/elixir&quot; ) . status 200","ref":"Req.html#request!/2","title":"Req.request!/2","type":"function"},{"doc":"Makes an HTTP request. request/1 and request/2 functions give three ways of making requests: With a list of options, for example: Req . request ( url : url ) With a request struct, for example: Req . new ( url : url ) |&gt; Req . request ( ) With a request struct and more options, for example: Req . new ( base_url : base_url ) |&gt; Req . request ( url : url ) This function as well as all the other ones in this module accept the same set of options described below. Options Basic request options: :method - the request method, defaults to :get . :url - the request URL. :headers - the request headers. The headers are automatically encoded using these rules: atom header names are turned into strings, replacing - with _ . For example, :user_agent becomes &quot;user-agent&quot; string header names are left as is. Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. NaiveDateTime and DateTime header values are encoded as &quot;HTTP date&quot;. Otherwise, the header value is encoded with String.Chars.to_string/1 . If you set :headers options both in Req.new/1 and request/2 , the header lists are merged. :body - the request body. Additional URL options: :base_url - if set, the request URL is prepended with this base URL (via put_base_url step). :params - if set, appends parameters to the request query string (via put_params step). Authentication options: :auth - sets request authentication (via auth step). Request body options: :form - if set, encodes the request body as form data ( encode_body step). :json - if set, encodes the request body as JSON ( encode_body step). :compress_body - if set to true , compresses the request body using gzip (via compress_body step). Defaults to false . Response body options: :compressed - if set to true , asks the server to return compressed response. (via compressed step). Defaults to true . :raw - if set to true , disables automatic body decompression ( decompress_body step) and decoding ( decode_body step). Defaults to false . :decode_body - if set to false , disables automatic response body decoding. Defaults to true . :output - if set, writes the response body to a file (via output step). Can be set to a string path or an atom :remote_name which would use the remote name as the filename in the current working directory. Once the file is written, the response body is replaced with &quot;&quot; . Setting :output also sets the decode_body: false option to prevent decoding the response before writing it to the file. Response redirect options ( follow_redirects step): :follow_redirects - if set to false , disables automatic response redirects. Defaults to true . :location_trusted - by default, authorization credentials are only sent on redirects with the same host, scheme and port. If :location_trusted is set to true , credentials will be sent to any host. :max_redirects - the maximum number of redirects, defaults to 10 . Retry options ( retry step): :retry : can be set to: :safe (default) to only retry GET/HEAD requests on HTTP 408/5xx responses or exceptions, :always to always retry, :never to never retry, and fun - a 1-arity function that accepts either a Req.Response or an exception struct and returns boolean whether to retry :retry_delay - sleep this number of milliseconds before making another attempt, defaults to 2000 :max_retries - maximum number of retry attempts, defaults to 2 (for a total of 3 requests to the server, including the initial one.) Caching options ( cache step): :cache - if true , performs HTTP caching. Defaults to false . :cache_dir - the directory to store the cache, defaults to &lt;user_cache_dir&gt;/req (see: :filename.basedir/3 ) Request adapters: :adapter - adapter to use to make the actual HTTP request. See :adapter field description in the Req.Request module documentation for more information. Defaults to calling run_finch . :plug - if set, calls the given Plug instead of making an HTTP request over the network (via put_plug step). Finch options ( run_finch step) :finch - the Finch pool to use. Defaults to pool automatically started by Req . :finch_options - options passed down to Finch when making the request, defaults to [] . See Finch.request/3 for a list of available options. :http1 - if true , uses an HTTP/1 pool automatically started by Req. :http2 - if true , uses an HTTP/2 pool automatically started by Req. :unix_socket - if set, connect through the given UNIX domain socket Examples With options keywords list: iex&gt; { :ok , response } = Req . request ( url : &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) iex&gt; response . status 200 iex&gt; response . body [ &quot;description&quot; ] &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; With request struct: iex&gt; req = Req . new ( url : &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) iex&gt; { :ok , response } = Req . request ( req ) iex&gt; response . status 200 With request struct and options: iex&gt; req = Req . new ( base_url : &quot;https://api.github.com&quot; ) iex&gt; { :ok , response } = Req . request ( req , url : &quot;/repos/elixir-lang/elixir&quot; ) iex&gt; response . status 200 With mock adapter: iex&gt; adapter = fn request -&gt; ...&gt; response = % Req.Response { status : 200 , body : &quot;it works!&quot; } ...&gt; { request , response } ...&gt; end iex&gt; iex&gt; { :ok , response } = Req . request ( url : &quot;http://example&quot; ) iex&gt; response . body &quot;it works!&quot;","ref":"Req.html#request/1","title":"Req.request/1","type":"function"},{"doc":"Makes an HTTP request. See request/1 for more information.","ref":"Req.html#request/2","title":"Req.request/2","type":"function"},{"doc":"","ref":"Req.html#t:url/0","title":"Req.url/0","type":"type"},{"doc":"The low-level API and the request struct. Req is composed of three main pieces: Req - the high-level API Req.Request - the low-level API and the request struct (you're here!) Req.Steps - the collection of built-in steps The low-level API and the request struct is the foundation of Req's extensibility. Virtually all of the functionality is broken down into individual pieces - steps. Req works by running the request struct through these steps. You can easily reuse or rearrange built-in steps or write new ones. To make using custom steps by others even easier, they can be packaged up into plugins. See &quot;Wriging Plugins&quot; section for more information. The Low-level API Most Req users would use it like this: Req . get! ( &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) . body [ &quot;description&quot; ] #=&gt; &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; Here is the equivalent using the low-level API: url = &quot;https://api.github.com/repos/elixir-lang/elixir&quot; req = % Req.Request { method : :get , url : url } |&gt; Req.Request . append_request_steps ( put_user_agent : &amp; Req.Steps . put_user_agent / 1 , # ... ) |&gt; Req.Request . append_response_steps ( # ... decompress_body : &amp; Req.Steps . decompress_body / 1 , decode_body : &amp; Req.Steps . decode_body / 1 , # ... ) |&gt; Req.Request . append_error_steps ( retry : &amp; Req.Steps . retry / 1 , # ... ) Req.Request . run! ( req ) . body [ &quot;description&quot; ] #=&gt; &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; By putting the request pipeline yourself you have precise control of exactly what is running and in what order. The Request Struct :method - the HTTP request method :url - the HTTP request URL :headers - the HTTP request headers :body - the HTTP request body :options - the options to be used by steps :halted - whether the request pipeline is halted. See halt/1 :adapter - a request step that makes the actual HTTP request. Defaults to Req.Steps.run_finch/1 . See &quot;Adapter&quot; section below for more information. :request_steps - the list of request steps :response_steps - the list of response steps :error_steps - the list of error steps :private - a map reserved for libraries and frameworks to use. Prefix the keys with the name of your project to avoid any future conflicts. Only accepts atom/0 keys. Steps Req has three types of steps: request, response, and error. Request steps are used to refine the data that will be sent to the server. After making the actual HTTP request, we'll either get a HTTP response or an error. The request, along with the response or error, will go through response or error steps, respectively. Nothing is actually executed until we run the pipeline with Req.Request.run/1 . Request steps A request step is a function that accepts a request and returns one of the following: A request A {request, response_or_error} tuple. In that case no further request steps are executed and the return value goes through response or error steps Examples: def put_default_headers ( request ) do update_in ( request . headers , &amp; [ { &quot;user-agent&quot; , &quot;req&quot; } | &amp;1 ] ) end def read_from_cache ( request ) do case ResponseCache . fetch ( request ) do { :ok , response } -&gt; { request , response } :error -&gt; request end end Response and error steps A response step is a function that accepts a {request, response} tuple and returns one of the following: A {request, response} tuple A {request, exception} tuple. In that case, no further response steps are executed but the exception goes through error steps Similarly, an error step is a function that accepts a {request, exception} tuple and returns one of the following: A {request, exception} tuple A {request, response} tuple. In that case, no further error steps are executed but the response goes through response steps Examples: def decode ( { request , response } ) do case List . keyfind ( response . headers , &quot;content-type&quot; , 0 ) do { _ , &quot;application/json&quot; &lt;&gt; _ } -&gt; { request , update_in ( response . body , &amp; Jason . decode! / 1 ) } _ -&gt; { request , response } end end def log_error ( { request , exception } ) do Logger . error ( [ &quot; \#{ request . method } \#{ request . uri } : &quot; , Exception . message ( exception ) ] ) { request , exception } end Halting Any step can call Req.Request.halt/1 to halt the pipeline. This will prevent any further steps from being invoked. Examples: def circuit_breaker ( request ) do if CircuitBreaker . open? ( ) do { Req.Request . halt ( request ) , RuntimeError . exception ( &quot;circuit breaker is open&quot; ) } else request end end Writing Plugins Custom steps can be packaged into plugins so that they are even easier to use by others. Here's an example plugin: defmodule PrintHeaders do @doc &quot;&quot;&quot; Prints request and response headers. ## Request Options * `:print_headers` - if `true`, prints the headers. Defaults to `false`. &quot;&quot;&quot; def attach ( % Req.Request { } = request , options \\\\ [ ] ) do request |&gt; Req.Request . register_options ( [ :print_headers ] ) |&gt; Req.Request . merge_options ( options ) |&gt; Req.Request . append_request_steps ( print_headers : &amp; print_request_headers / 1 ) |&gt; Req.Request . prepend_response_steps ( print_headers : &amp; print_response_headers / 1 ) end defp print_request_headers ( request ) do if request . options [ :print_headers ] do print_headers ( &quot;&gt; &quot; , request . headers ) end request end defp print_response_headers ( { request , response } ) do if request . options [ :print_headers ] do print_headers ( &quot;&lt; &quot; , response . headers ) end { request , response } end defp print_headers ( prefix , headers ) do for { name , value } &lt;- headers do IO . puts ( [ prefix , name , &quot;: &quot; , value ] ) end end end And here is how we can use it: req = Req . new ( ) |&gt; PrintHeaders . attach ( ) Req . get! ( req , url : &quot;https://httpbin.org/json&quot; ) . status 200 Req . get! ( req , url : &quot;https://httpbin.org/json&quot; , print_headers : true ) . status # Outputs: # &gt; accept-encoding: br, gzip, deflate # &gt; user-agent: req/0.3.0-dev # &lt; date: Wed, 11 May 2022 11:10:47 GMT # &lt; content-type: application/json # ... 200 req = Req . new ( ) |&gt; PrintHeaders . attach ( print_headers : true ) Req . get! ( req , url : &quot;https://httpbin.org/json&quot; ) . status # Outputs: # &gt; accept-encoding: br, gzip, deflate # ... 200 As you can see a plugin is simply a module. While this is not enforced, the plugin should follow these conventions: It should export an attach/1 function that takes and returns the request struct The attach functions mostly just adds steps and it is the steps that do the actual work A user should be able to attach your plugin alongside other plugins. For this reason, plugin functionality should usually only happen on a specific &quot;trigger&quot;: on a specific option, on a specific URL scheme or host, etc. This is especially important for plugins that perform authentication; you don't want to accidentally expose a token from service A when a user makes request to service B. If your plugin supports custom options, register them with Req.Request.register_options/2 Sometimes it is useful to pass options when attaching the plugin. For that, export an attach/2 function and call Req.Request.merge_options/2 . Remember to first register options before merging! Adapter As noted in the &quot;Request steps&quot; section, a request step besides returning the request, might also return {request, response} or {request, exception} , thus invoking either response or error steps next. This is exactly how Req makes the underlying HTTP call, by invoking a request step that follows this contract. The default adapter is using Finch via the Req.Steps.run_finch/1 step. Here is a mock adapter that always returns a successful response: adapter = fn request -&gt; response = % Req.Response { status : 200 , body : &quot;it works!&quot; } { request , response } end Req . request! ( url : &quot;http://example&quot; , adapter : adapter ) . body #=&gt; &quot;it works!&quot; And here is a naive Hackney-based implementation: hackney = fn request -&gt; case :hackney . request ( request . method , URI . to_string ( request . url ) , request . headers , request . body , [ :with_body ] ) do { :ok , status , headers , body } -&gt; headers = for { name , value } &lt;- headers , do : { String . downcase ( name ) , value } response = % Req.Response { status : status , headers : headers , body : body } { request , response } { :error , reason } -&gt; { request , RuntimeError . exception ( inspect ( reason ) ) } end end Req . get! ( &quot;https://api.github.com/repos/elixir-lang/elixir&quot; , adapter : hackney ) . body [ &quot;description&quot; ] &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot;","ref":"Req.Request.html","title":"Req.Request","type":"module"},{"doc":"Appends error steps. Examples Req.Request . append_error_steps ( request , noop : fn { request , exception } -&gt; { request , exception } end , inspect : &amp; IO . inspect / 1 )","ref":"Req.Request.html#append_error_steps/2","title":"Req.Request.append_error_steps/2","type":"function"},{"doc":"Appends request steps. Examples Req.Request . append_request_steps ( request , noop : fn request -&gt; request end , inspect : &amp; IO . inspect / 1 )","ref":"Req.Request.html#append_request_steps/2","title":"Req.Request.append_request_steps/2","type":"function"},{"doc":"Appends response steps. Examples Req.Request . append_request_steps ( request , noop : fn { request , response } -&gt; { request , response } end , inspect : &amp; IO . inspect / 1 )","ref":"Req.Request.html#append_response_steps/2","title":"Req.Request.append_response_steps/2","type":"function"},{"doc":"Returns the values of the header specified by key . Examples iex&gt; req = Req . new ( headers : [ { &quot;accept&quot; , &quot;application/json&quot; } ] ) iex&gt; Req.Request . get_header ( req , &quot;accept&quot; ) [ &quot;application/json&quot; ]","ref":"Req.Request.html#get_header/2","title":"Req.Request.get_header/2","type":"function"},{"doc":"Gets the value for a specific private key .","ref":"Req.Request.html#get_private/3","title":"Req.Request.get_private/3","type":"function"},{"doc":"Halts the request pipeline preventing any further steps from executing.","ref":"Req.Request.html#halt/1","title":"Req.Request.halt/1","type":"function"},{"doc":"Merges given options into the request. Examples iex&gt; req = Req . new ( auth : { &quot;alice&quot; , &quot;secret&quot; } , http_errors : :raise ) iex&gt; req = Req.Request . merge_options ( req , auth : { :bearer , &quot;abcd&quot; } , base_url : &quot;https://example.com&quot; ) iex&gt; req . options %{ auth : { :bearer , &quot;abcd&quot; } , base_url : &quot;https://example.com&quot; , http_errors : :raise }","ref":"Req.Request.html#merge_options/2","title":"Req.Request.merge_options/2","type":"function"},{"doc":"Prepends error steps. Examples Req.Request . prepend_error_steps ( request , noop : fn { request , exception } -&gt; { request , exception } end , inspect : &amp; IO . inspect / 1 )","ref":"Req.Request.html#prepend_error_steps/2","title":"Req.Request.prepend_error_steps/2","type":"function"},{"doc":"Prepends request steps. Examples Req.Request . prepend_request_steps ( request , noop : fn request -&gt; request end , inspect : &amp; IO . inspect / 1 )","ref":"Req.Request.html#prepend_request_steps/2","title":"Req.Request.prepend_request_steps/2","type":"function"},{"doc":"Prepends response steps. Examples Req.Request . prepend_request_steps ( request , noop : fn { request , response } -&gt; { request , response } end , inspect : &amp; IO . inspect / 1 )","ref":"Req.Request.html#prepend_response_steps/2","title":"Req.Request.prepend_response_steps/2","type":"function"},{"doc":"Adds a new request header ( key ) if not present, otherwise replaces the previous value of that header with value . Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, requests with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped requests. Examples iex&gt; req = Req . new ( ) iex&gt; Req.Request . put_header ( req , &quot;accept&quot; , &quot;application/json&quot; ) . headers [ { &quot;accept&quot; , &quot;application/json&quot; } ]","ref":"Req.Request.html#put_header/3","title":"Req.Request.put_header/3","type":"function"},{"doc":"Assigns a private key to value .","ref":"Req.Request.html#put_private/3","title":"Req.Request.put_private/3","type":"function"},{"doc":"Registers options to be used by a custom steps. Req ensures that all used options were previously registered which helps finding accidentally mistyped option names. If you're adding custom steps that are accepting options, call this function to register them. Examples iex&gt; Req . request! ( urll : &quot;https://httpbin.org&quot; ) ** (ArgumentError) unknown option :urll. Did you mean :url? iex&gt; Req . new ( bas_url : &quot;https://httpbin.org&quot; ) ** (ArgumentError) unknown option :bas_url. Did you mean :base_url? iex&gt; req = ...&gt; Req . new ( base_url : &quot;https://httpbin.org&quot; ) ...&gt; |&gt; Req.Request . register_options ( [ :foo ] ) ...&gt; iex&gt; Req . get! ( req , url : &quot;/status/201&quot; , foo : :bar ) . status 201","ref":"Req.Request.html#register_options/2","title":"Req.Request.register_options/2","type":"function"},{"doc":"Returns registered option names.","ref":"Req.Request.html#registered_options/1","title":"Req.Request.registered_options/1","type":"function"},{"doc":"Runs a request pipeline and returns a response or raises an error. See run/1 for more information.","ref":"Req.Request.html#run!/1","title":"Req.Request.run!/1","type":"function"},{"doc":"Runs a request pipeline. Returns {:ok, response} or {:error, exception} .","ref":"Req.Request.html#run/1","title":"Req.Request.run/1","type":"function"},{"doc":"","ref":"Req.Request.html#t:t/0","title":"Req.Request.t/0","type":"type"},{"doc":"The response struct. Fields: :status - the HTTP status code :headers - the HTTP response headers :body - the HTTP response body :private - a map reserved for libraries and frameworks to use. Prefix the keys with the name of your project to avoid any future conflicts. Only accepts atom/0 keys.","ref":"Req.Response.html","title":"Req.Response","type":"module"},{"doc":"Returns the values of the header specified by key . Examples iex&gt; Req.Response . get_header ( response , &quot;content-type&quot; ) [ &quot;application/json&quot; ]","ref":"Req.Response.html#get_header/2","title":"Req.Response.get_header/2","type":"function"},{"doc":"Gets the value for a specific private key .","ref":"Req.Response.html#get_private/3","title":"Req.Response.get_private/3","type":"function"},{"doc":"Assigns a private key to value .","ref":"Req.Response.html#put_private/3","title":"Req.Response.put_private/3","type":"function"},{"doc":"","ref":"Req.Response.html#t:t/0","title":"Req.Response.t/0","type":"type"},{"doc":"The collection of built-in steps. Req is composed of three main pieces: Req - the high-level API Req.Request - the low-level API and the request struct Req.Steps - the collection of built-in steps (you're here!)","ref":"Req.Steps.html","title":"Req.Steps","type":"module"},{"doc":"Sets request authentication. auth can be one of: {username, password} - uses Basic HTTP authentication {:bearer, token} - uses Bearer HTTP authentication :netrc - load credentials from .netrc at path specified in NETRC environment variable; if NETRC is not set, load .netrc in user's home directory {:netrc, path} - load credentials from path Examples iex&gt; Req . get! ( &quot;https://httpbin.org/basic-auth/foo/bar&quot; , auth : { &quot;bad&quot; , &quot;bad&quot; } ) . status 401 iex&gt; Req . get! ( &quot;https://httpbin.org/basic-auth/foo/bar&quot; , auth : { &quot;foo&quot; , &quot;bar&quot; } ) . status 200 iex&gt; Req . get! ( &quot;https://httpbin.org/bearer&quot; , auth : { :bearer , &quot;&quot; } ) . status 401 iex&gt; Req . get! ( &quot;https://httpbin.org/bearer&quot; , auth : { :bearer , &quot;foo&quot; } ) . status 200 iex&gt; System . put_env ( &quot;NETRC&quot; , &quot;./test/my_netrc&quot; ) iex&gt; Req . get! ( &quot;https://httpbin.org/basic-auth/foo/bar&quot; , auth : :netrc ) . status 200 iex&gt; Req . get! ( &quot;https://httpbin.org/basic-auth/foo/bar&quot; , auth : { :netrc , &quot;./test/my_netrc&quot; } ) . status 200","ref":"Req.Steps.html#auth/1","title":"Req.Steps.auth/1","type":"function"},{"doc":"Performs HTTP caching using if-modified-since header. Only successful (200 OK) responses are cached. This step also prepends a response step that loads and writes the cache. Be careful when prepending other response steps, make sure the cache is loaded/written as soon as possible. Options :cache - if true , performs caching. Defaults to false . :cache_dir - the directory to store the cache, defaults to &lt;user_cache_dir&gt;/req (see: :filename.basedir/3 ) Examples iex&gt; url = &quot;https://elixir-lang.org&quot; iex&gt; response1 = Req . get! ( url , cache : true ) iex&gt; response2 = Req . get! ( url , cache : true ) iex&gt; response1 == response2 true","ref":"Req.Steps.html#cache/1","title":"Req.Steps.cache/1","type":"function"},{"doc":"Compresses the request body. Request Options :compress_body - if set to true , compresses the request body using gzip. Defaults to false .","ref":"Req.Steps.html#compress_body/1","title":"Req.Steps.compress_body/1","type":"function"},{"doc":"Asks the server to return compressed response. Supported formats: gzip deflate br (if brotli is installed) Request Options :compressed - if set to true , sets the accept-encoding header with compression algorithms that Req supports. Defaults to true . Examples Req automatically decompresses response body ( decompress_body/1 step) so let's disable that by passing raw: true . By default, we ask the server to send compressed response. Let's look at the headers and the raw body. Notice the body starts with &lt;&lt;31, 139&gt;&gt; ( &lt;&lt;0x1F, 0x8B&gt;&gt; ), the &quot;magic bytes&quot; for gzip: iex&gt; response = Req . get! ( &quot;https://elixir-lang.org&quot; , raw : true ) iex&gt; response . headers |&gt; List . keyfind ( &quot;content-encoding&quot; , 0 ) { &quot;content-encoding&quot; , &quot;gzip&quot; } iex&gt; response . body |&gt; binary_part ( 0 , 2 ) &lt;&lt; 31 , 139 &gt;&gt; Now, let's pass compressed: false and notice the raw body was not compressed: iex&gt; response = Req . get! ( &quot;https://elixir-lang.org&quot; , raw : true , compressed : false ) iex&gt; response . headers |&gt; List . keyfind ( &quot;content-encoding&quot; , 0 ) nil iex&gt; response . body |&gt; binary_part ( 0 , 15 ) &quot;&lt;!DOCTYPE html&gt;&quot; If the brotli package is installed, Brotli compression will also be requested: Mix . install ( [ :req , { :brotli , &quot;~&gt; 0.3.0&quot; } ] ) response = Req . get! ( &quot;https://httpbin.org/brotli&quot; ) response . body [ &quot;headers&quot; ] [ &quot;Accept-Encoding&quot; ] #=&gt; &quot;br, gzip, deflate&quot;","ref":"Req.Steps.html#compressed/1","title":"Req.Steps.compressed/1","type":"function"},{"doc":"Decodes response body based on the detected format. Supported formats: Format Decoder json Jason.decode!/1 gzip :zlib.gunzip/1 tar, tgz :erl_tar.extract/2 zip :zip.unzip/2 csv NimbleCSV.RFC4180.parse_string/2 (if nimble_csv is installed) Request Options :decode_body - if set to false , disables automatic response body decoding. Defaults to true . Examples iex&gt; response = Req . get! ( &quot;https://httpbin.org/gzip&quot; ) ...&gt; response . body [ &quot;gzipped&quot; ] true iex&gt; response = Req . get! ( &quot;https://httpbin.org/json&quot; ) ...&gt; response . body [ &quot;slideshow&quot; ] [ &quot;title&quot; ] &quot;Sample Slide Show&quot;","ref":"Req.Steps.html#decode_body/1","title":"Req.Steps.decode_body/1","type":"function"},{"doc":"Decompresses the response body based on the content-encoding header. Supported formats: Format Decoder gzip, x-gzip :zlib.gunzip/1 zip :zlib.unzip/1 br :brotli.decode/1 (if brotli is installed) Examples iex&gt; response = Req . get! ( &quot;https://httpbin.org/gzip&quot; ) iex&gt; response . headers |&gt; List . keyfind ( &quot;content-encoding&quot; , 0 ) { &quot;content-encoding&quot; , &quot;gzip&quot; } iex&gt; response . body [ &quot;gzipped&quot; ] true If the brotli package is installed, Brotli is also supported: Mix . install ( [ :req , { :brotli , &quot;~&gt; 0.3.0&quot; } ] ) response = Req . get! ( &quot;https://httpbin.org/brotli&quot; ) response . headers |&gt; List . keyfind ( &quot;content-encoding&quot; , 0 ) #=&gt; {&quot;content-encoding&quot;, &quot;br&quot;} response . body [ &quot;brotli&quot; ] #=&gt; true","ref":"Req.Steps.html#decompress_body/1","title":"Req.Steps.decompress_body/1","type":"function"},{"doc":"Encodes the request body. Request Options :form - if set, encodes the request body as form data (using URI.encode_query/1 ). :json - if set, encodes the request body as JSON (using Jason.encode_to_iodata!/1 ). Examples iex&gt; Req . post! ( &quot;https://httpbin.org/anything&quot; , form : [ x : 1 ] ) . body [ &quot;form&quot; ] %{ &quot;x&quot; =&gt; &quot;1&quot; } iex&gt; Req . post! ( &quot;https://httpbin.org/post&quot; , json : %{ x : 2 } ) . body [ &quot;json&quot; ] %{ &quot;x&quot; =&gt; 2 }","ref":"Req.Steps.html#encode_body/1","title":"Req.Steps.encode_body/1","type":"function"},{"doc":"Follows redirects. The original request method may be changed to GET depending on the status code: Code Method handling 301, 302, 303 Changed to GET 307, 308 Method not changed Request Options :follow_redirects - if set to false , disables automatic response redirects. Defaults to true . :location_trusted - by default, authorization credentials are only sent on redirects with the same host, scheme and port. If :location_trusted is set to true , credentials will be sent to any host. :max_redirects - the maximum number of redirects, defaults to 10 . If the limit is reached, an erorr is raised. Examples iex&gt; Req . get! ( &quot;http://api.github.com&quot; ) . status # 23:24:11.670 [debug] follow_redirects: redirecting to https://api.github.com/ 200 iex&gt; Req . get! ( &quot;https://httpbin.org/redirect/4&quot; , max_redirects : 3 ) # 23:07:59.570 [debug] follow_redirects: redirecting to /relative-redirect/3 # 23:08:00.068 [debug] follow_redirects: redirecting to /relative-redirect/2 # 23:08:00.206 [debug] follow_redirects: redirecting to /relative-redirect/1 ** (RuntimeError) too many redirects (3)","ref":"Req.Steps.html#follow_redirects/1","title":"Req.Steps.follow_redirects/1","type":"function"},{"doc":"Handles HTTP 4xx/5xx error responses. Request Options :http_errors - how to handle HTTP 4xx/5xx error responses. Can be one of the following: :return (default) - return the response :raise - raise an error Examples iex&gt; Req . get! ( &quot;https://httpbin.org/status/404&quot; ) . status 404 iex&gt; Req . get! ( &quot;https://httpbin.org/status/404&quot; , http_errors : :raise ) ** (RuntimeError) The requested URL returned error: 404 Response body : &quot;&quot;","ref":"Req.Steps.html#handle_http_errors/1","title":"Req.Steps.handle_http_errors/1","type":"function"},{"doc":"Writes the response body to a file. After the output file is written, the response body is set to &quot;&quot; . Request Options :output - if set, writes the response body to a file. Can be one of: path - writes to the given path :remote_name - uses the remote name as the filename in the current working directory Examples iex&gt; Req . get! ( &quot;https://elixir-lang.org/index.html&quot; , output : &quot;/tmp/elixir_home.html&quot; ) iex&gt; File . exists? ( &quot;/tmp/elixir_home.html&quot; ) true iex&gt; Req . get! ( &quot;https://elixir-lang.org/blog/index.html&quot; , output : :remote_name ) iex&gt; File . exists? ( &quot;index.html&quot; ) true","ref":"Req.Steps.html#output/1","title":"Req.Steps.output/1","type":"function"},{"doc":"Sets base URL for all requests. Request Options :base_url - if set, the request URL is prepended with this base URL. If request URL contains a scheme, base URL is ignored. Examples iex&gt; req = Req . new ( base_url : &quot;https://httpbin.org&quot; ) iex&gt; Req . get! ( req , url : &quot;/status/200&quot; ) . status 200 iex&gt; Req . get! ( req , url : &quot;/status/201&quot; ) . status 201","ref":"Req.Steps.html#put_base_url/1","title":"Req.Steps.put_base_url/1","type":"function"},{"doc":"Adds params to request query string. Request Options :params - params to add to the request query string. Defaults to [] . Examples iex&gt; Req . get! ( &quot;https://httpbin.org/anything/query&quot; , params : [ x : 1 , y : 2 ] ) . body [ &quot;args&quot; ] %{ &quot;x&quot; =&gt; &quot;1&quot; , &quot;y&quot; =&gt; &quot;2&quot; }","ref":"Req.Steps.html#put_params/1","title":"Req.Steps.put_params/1","type":"function"},{"doc":"Runs the request against a plug instead of over the network. Request Options :plug - if set, the plug to run the request against. Examples This step is particularly useful to test plugs: defmodule Echo do def call ( conn , _ ) do &quot;/&quot; &lt;&gt; path = conn . request_path Plug.Conn . send_resp ( conn , 200 , path ) end end test &quot;echo&quot; do assert Req . get! ( &quot;http:///hello&quot; , plug : Echo ) . body == &quot;hello&quot; end Here is the same example but with plug as an anonymous function: test &quot;echo&quot; do echo = fn conn -&gt; &quot;/&quot; &lt;&gt; path = conn . request_path Plug.Conn . send_resp ( conn , 200 , path ) end assert Req . get! ( &quot;http:///hello&quot; , plug : echo ) . body == &quot;hello&quot; end Here is another example, let's run the request against Plug.Static pointed to the Req's source code and fetch the README: iex&gt; resp = Req . get! ( &quot;http:///README.md&quot; , plug : { Plug.Static , at : &quot;/&quot; , from : &quot;.&quot; } ) iex&gt; resp . body =~ &quot;Req is a batteries-included HTTP client for Elixir.&quot; true","ref":"Req.Steps.html#put_plug/1","title":"Req.Steps.put_plug/1","type":"function"},{"doc":"Sets the &quot;Range&quot; request header. Request Options :range - can be one of the following: a string - returned as is a first..last range - converted to &quot;bytes=&lt;first&gt;-&lt;last&gt;&quot; Examples iex&gt; response = Req . get! ( &quot;https://httpbin.org/range/100&quot; , range : 0 .. 3 ) iex&gt; response . status 206 iex&gt; response . body &quot;abcd&quot; iex&gt; List . keyfind ( response . headers , &quot;content-range&quot; , 0 ) { &quot;content-range&quot; , &quot;bytes 0-3/100&quot; }","ref":"Req.Steps.html#put_range/1","title":"Req.Steps.put_range/1","type":"function"},{"doc":"Sets the user-agent header. Request Options :user_agent - sets the user-agent header. Defaults to &quot;req/0.3.0-dev&quot; . Examples iex&gt; Req . get! ( &quot;https://httpbin.org/user-agent&quot; ) . body %{ &quot;user-agent&quot; =&gt; &quot;req/0.3.0-dev&quot; } iex&gt; Req . get! ( &quot;https://httpbin.org/user-agent&quot; , user_agent : &quot;foo&quot; ) . body %{ &quot;user-agent&quot; =&gt; &quot;foo&quot; }","ref":"Req.Steps.html#put_user_agent/1","title":"Req.Steps.put_user_agent/1","type":"function"},{"doc":"Retries a request in face of errors. This function can be used as either or both response and error step. Request Options :retry - can be one of the following: :safe (default) - retry GET/HEAD requests on HTTP 408/5xx responses or exceptions :always - always retry :never - never retry fun - a 1-arity function that accepts either a Req.Response or an exception struct and returns boolean whether to retry :retry_delay - sleep this number of milliseconds before making another attempt, defaults to 2000 :max_retries - maximum number of retry attempts, defaults to 2 (for a total of 3 requests to the server, including the initial one.) Examples With default options: iex&gt; Req . get! ( &quot;https://httpbin.org/status/500,200&quot; ) . status # 19:02:08.463 [error] retry: got response with status 500, will retry in 2000ms, 2 attempts left # 19:02:10.710 [error] retry: got response with status 500, will retry in 2000ms, 1 attempt left 200 With custom options: iex&gt; Req . get! ( &quot;http://localhost:9999&quot; , retry_delay : 100 , max_retries : 3 ) # 17:00:38.371 [error] retry: got exception, will retry in 100ms, 3 attempts left # 17:00:38.371 [error] ** (Mint.TransportError) connection refused # 17:00:38.473 [error] retry: got exception, will retry in 100ms, 2 attempts left # 17:00:38.473 [error] ** (Mint.TransportError) connection refused # 17:00:38.575 [error] retry: got exception, will retry in 100ms, 1 attempt left # 17:00:38.575 [error] ** (Mint.TransportError) connection refused ** (Mint.TransportError) connection refused","ref":"Req.Steps.html#retry/1","title":"Req.Steps.retry/1","type":"function"},{"doc":"Runs the request using Finch . This is the default Req adapter . See &quot;Adapter&quot; section in the Req.Request module documentation for more information on adapters. Request Options :finch - the name of the Finch pool. Defaults to a pool automatically started by Req. The default pool uses HTTP/1 although that may change in the future. This option takes precedence over :http1 and :http2 options mentioned below. :finch_options - options passed down to Finch when making the request, defaults to [] . See Finch.request/3 for a list of available options. :http1 - if true , uses an HTTP/1 pool automatically started by Req. :http2 - if true , uses an HTTP/2 pool automatically started by Req. :unix_socket - if set, connect through the given UNIX domain socket Examples Custom :receive_timeout : iex&gt; Req . get! ( url : url , finch_options : [ receive_timeout : 1000 ] ) Connecting through UNIX socket: iex&gt; Req . get! ( &quot;http:///v1.41/_ping&quot; , unix_socket : &quot;/var/run/docker.sock&quot; ) . body &quot;OK&quot;","ref":"Req.Steps.html#run_finch/1","title":"Req.Steps.run_finch/1","type":"function"},{"doc":"Docs Req is a batteries-included HTTP client for Elixir. ( Note : This is the README for the current main branch. See README for Req v0.2.2 )","ref":"readme.html","title":"Req","type":"extras"},{"doc":"An easy to use high-level API in Req module: request/1 , request!/1 , get!/2 , head!/2 , post!/2 , put!/2 , patch!/2 , and delete!/2 Extensibility via request, response, and error steps Request body compression and automatic response body decompression (via compress_body , compressed , and decompress_body steps) Request body encoding and automatic response body decoding (via encode_body and decode_body steps) Encode params as query string (via put_params step) Basic, bearer, and .netrc authentication (via auth step) Range requests (via put_range ) step) Follows redirects (via follow_redirects step) Retries on errors (via retry step) Raise on 4xx/5xx errors (via handle_http_errors step) Basic HTTP caching (via cache step) Setting base URL (via put_base_url step) Running against a plug (via put_plug step) Pluggable adapters. By default, Req uses Finch (via run_finch step).","ref":"readme.html#features","title":"Req - Features","type":"extras"},{"doc":"The easiest way to use Req is with Mix.install/2 (requires Elixir v1.12+): Mix . install ( [ { :req , github : &quot;wojtekmach/req&quot; } ] ) Req . get! ( &quot;https://api.github.com/repos/elixir-lang/elixir&quot; ) . body [ &quot;description&quot; ] #=&gt; &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; If you want to use Req in a Mix project, you can add the above dependency to your mix.exs . If you are planning to make several similar requests, you can build up a request struct with desired common options and re-use it: req = Req . new ( base_url : &quot;https://api.github.com&quot; ) Req . get! ( req , url : &quot;/repos/sneako/finch&quot; ) . body [ &quot;description&quot; ] #=&gt; &quot;Elixir HTTP client, focused on performance&quot; Req . get! ( req , url : &quot;/repos/elixir-mint/mint&quot; ) . body [ &quot;description&quot; ] #=&gt; &quot;Functional HTTP client for Elixir with support for HTTP/1 and HTTP/2.&quot; See Req.request/1 for more information on available options. Virtually all of Req's features are broken down into individual pieces - steps. Req works by running the request struct through these steps. You can easily reuse or rearrange built-in steps or write new ones. Importantly, steps are just regular functions. Here is another example where we append a request step that inspects the URL just before requesting it: req = Req . new ( base_url : &quot;https://api.github.com&quot; ) |&gt; Req.Request . append_request_steps ( debug_url : fn request -&gt; IO . inspect ( URI . to_string ( request . url ) ) request end ) Req . get! ( req , url : &quot;/repos/wojtekmach/req&quot; ) . body [ &quot;description&quot; ] # Outputs: &quot;https://api.github.com/repos/wojtekmach/req&quot; #=&gt; &quot;Req is a batteries-included HTTP client for Elixir.&quot; Custom steps can be packaged into plugins so that they are even easier to use by others. Here are some examples: req_s3 req_hex req_github_oauth See Req.Request module documentation for more information on low-level API, request struct, and developing plugins.","ref":"readme.html#usage","title":"Req - Usage","type":"extras"},{"doc":"Req is built on top of Finch and is inspired by cURL , Requests , Tesla , and many other HTTP clients - thank you!","ref":"readme.html#acknowledgments","title":"Req - Acknowledgments","type":"extras"},{"doc":"Copyright (c) 2021 Wojtek Mach Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","ref":"readme.html#license","title":"Req - License","type":"extras"},{"doc":"","ref":"changelog.html","title":"CHANGELOG","type":"extras"},{"doc":"Req v0.3.0 brings redesigned API, new steps, and improvements to existing steps. New API The new API allows building a request struct with all the built-in steps. It can be then piped to functions like Req.get!/2 : iex&gt; req = Req . new ( base_url : &quot;https://api.github.com&quot; ) iex&gt; req |&gt; Req . get! ( url : &quot;/repos/sneako/finch&quot; ) |&gt; then ( &amp; &amp;1 . body [ &quot;description&quot; ] ) &quot;Elixir HTTP client, focused on performance&quot; iex&gt; req |&gt; Req . get ( url : &quot;/repos/elixir-mint/mint&quot; ) |&gt; then ( &amp; &amp;1 . body [ &quot;description&quot; ] ) &quot;Functional HTTP client for Elixir with support for HTTP/1 and HTTP/2.&quot; Setting body and encoding it to form/JSON is now done through :body/:form/:json options: iex&gt; Req . post! ( &quot;https://httpbin.org/anything&quot; , body : &quot;hello!&quot; ) . body [ &quot;data&quot; ] &quot;hello!&quot; iex&gt; req = Req . new ( url : &quot;https://httpbin.org/anything&quot; ) iex&gt; Req . post! ( req , form : [ x : 1 ] ) . body [ &quot;form&quot; ] %{ &quot;x&quot; =&gt; &quot;1&quot; } iex&gt; Req . post! ( req , json : %{ x : 2 } ) . body [ &quot;form&quot; ] %{ &quot;x&quot; =&gt; 2 } Improved Error Handling Req now validate option names ensuring users didn't accidentally mistyped them. If that happened, it will try to give a helpful error message. Here are some examples: Req . request! ( urll : &quot;https://httpbin.org&quot; ) ** (ArgumentError) unknown option :urll. Did you mean :url? Req . new ( bas_url : &quot;https://httpbin.org&quot; ) ** (ArgumentError) unknown option :bas_url. Did you mean :base_url? Req also has a new option to handle HTTP errors (4xx/5xx). By default it will continue to return the error responses: Req . get! ( &quot;https://httpbin.org/status/404&quot; ) #=&gt; %Req.Response{status: 404, ...} but users can now pass http_errors: :raise to raise an exception instead: Req . get! ( &quot;https://httpbin.org/status/404&quot; , http_errors : :raise ) ** (RuntimeError) The requested URL returned error: 404 Response body : &quot;&quot; This is especially useful in one-off scripts where we only really care about the &quot;happy path&quot; but would still like to get a good error message when something unexpected happened. Plugins From the very beginning, Req could be extended with custom steps. To make using such custom steps by others even easier, they can be packaged up into plugins. Here are some examples: req_s3 req_hex req_github_oauth And here's how they can be used: Mix . install ( [ { :req , github : &quot;wojtekmach/req&quot; } , { :req_s3 , github : &quot;wojtekmach/req_s3&quot; } , { :req_hex , github : &quot;wojtekmach/req_hex&quot; } , { :req_github_oauth , github : &quot;wojtekmach/req_github_oauth&quot; } ] ) req = Req . new ( http_errors : :raise ) |&gt; ReqS3 . attach ( ) |&gt; ReqHex . attach ( ) |&gt; ReqGitHubOAuth . attach ( ) Req . get! ( req , url : &quot;s3://ossci-datasets&quot; ) . body #=&gt; # [ # &quot;mnist/&quot;, # &quot;mnist/t10k-images-idx3-ubyte.gz&quot;, # &quot;mnist/t10k-labels-idx1-ubyte.gz&quot;, # &quot;mnist/train-images-idx3-ubyte.gz&quot;, # &quot;mnist/train-labels-idx1-ubyte.gz&quot; # ] Req . get! ( req , url : &quot;https://hex.pm/tarballs/req-0.1.0.tar&quot; ) . body [ &quot;metadata.config&quot; ] [ &quot;links&quot; ] #=&gt; %{&quot;GitHub&quot; =&gt; &quot;https://github.com/wojtekmach/req&quot;} Req . get! ( req , url : &quot;https://api.github.com/user&quot; ) . body [ &quot;login&quot; ] # Outputs: # paste this user code: # # 6C44-30A8 # # at: # # https://github.com/login/device # # open browser window? [Yn] # 15:22:28.350 [info] response: authorization_pending # 15:22:33.519 [info] response: authorization_pending # 15:22:38.678 [info] response: authorization_pending #=&gt; &quot;wojtekmach&quot; Req . get! ( req , url : &quot;https://api.github.com/user&quot; ) . body [ &quot;login&quot; ] #=&gt; &quot;wojtekmach&quot; Notice all plugins can be attached to the same request struct which makes it really easy to explore different endpoints. See &quot;Writing Plugins&quot; section in Req.Request module documentation for more information. Plug Integration Req can now be used to easily test plugs using the :plug option: defmodule Echo do def call ( conn , _ ) do &quot;/&quot; &lt;&gt; path = conn . request_path Plug.Conn . send_resp ( conn , 200 , path ) end end test &quot;echo&quot; do assert Req . get! ( &quot;http:///hello&quot; , plug : Echo ) . body == &quot;hello&quot; end Request Adapters While Req always used Finch as the underlying HTTP client, it was designed from the day one to easily swap it out. This is now even easier with an :adapter option. Here is a mock adapter that always returns a successful response: adapter = fn request -&gt; response = % Req.Response { status : 200 , body : &quot;it works!&quot; } { request , response } end Req . request! ( url : &quot;http://example&quot; , adapter : adapter ) . body #=&gt; &quot;it works!&quot; And here is a naive Hackney-based adapter and how we can use it: hackney = fn request -&gt; case :hackney . request ( request . method , URI . to_string ( request . url ) , request . headers , request . body , [ :with_body ] ) do { :ok , status , headers , body } -&gt; headers = for { name , value } &lt;- headers , do : { String . downcase ( name ) , value } response = % Req.Response { status : status , headers : headers , body : body } { request , response } { :error , reason } -&gt; { request , RuntimeError . exception ( inspect ( reason ) ) } end end Req . get! ( &quot;https://api.github.com/repos/elixir-lang/elixir&quot; , adapter : hackney ) . body [ &quot;description&quot; ] #=&gt; &quot;Elixir is a dynamic, functional language designed for building scalable and maintainable applications&quot; See &quot;Adapter&quot; seciton in Req.Request module documentation for more information. Major changes Add high-level functional API: Req.new(...) |&gt; Req.request(...) , Req.new(...) |&gt; Req.get!(...) , etc. Add Req.Request.options field that steps can read from. Also, make all steps be arity 1. When using &quot;High-level&quot; API, we now run all steps by default. (The steps, by looking at request.options, can decide to be no-op.) Move low-level API to Req.Request Move built-in steps to Req.Steps Add step names Add Req.head!/2 Add Req.patch!/2 Add Req.Request.adapter field Add Req.Request.merge_options/2 Add Req.Request.register_options/2 Add Req.Request.put_header/3 Add Req.Request.get_header/2 Add Req.Response.get_header/2 Rename put_if_modified_since step to cache Rename decompress step to decompress_body Remove put_default_steps step Remove run_steps step Remove put_default_headers step Remove encode_headers step. The headers are now encoded in Req.new/1 and Req.request/2 Remove Req.Request.unix_socket field. Add option on run_finch step with the same name instead. Step changes put_base_url : Ignore base URL if given URL contains scheme run_finch : Add :http1 and :http2 options that pick appropriate default pool started by Req encode_body : Add :form and :json options (previously used as {:form, data} and {:json, data} ) cache : Include request method in cache key decompress_body : Support Brotli decode_body : Support decode_body: false option to disable automatic body decoding follow_redirects : Change method to GET on 301..303 redirects follow_redirects : Don't send auth headers on redirect to different scheme/host/port unless location_trusted: true is set retry : The :retry option can now be set to :safe (default) to only retry GET/HEAD requests on HTTP 408/5xx responses or exceptions, :always to always retry, :never to never retry, and fun - a 1-arity function that accepts either a Req.Response or an exception struct and returns boolean whether to retry New step: run_plug New step: put_user_agent (replaces part of removed put_default_headers ) New step: compressed (replaces part of removed put_default_headers ) New step: compress_body New step: output New step: handle_http_errors Deprecations Deprecate calling Req.post!(url, body) in favour of Req.post!(url, body: body) . Also, deprecate Req.post!(url, {:form, data}) in favour of Req.post!(url, form: data) . and Req.post!(url, {:json, data}) in favour of Req.post!(url, json: data) . Same for Req.put!/2 . Deprecate setting retry: [delay: delay, max_retries: max_retries] in favour of retry_delay: delay, max_retries: max_retries . Deprecate setting cache: [dir: dir] in favour of cache_dir: dir . Deprecate Req.build/3 in favour of manually building the struct.","ref":"changelog.html#v0-3-0-dev","title":"CHANGELOG - v0.3.0-dev","type":"extras"},{"doc":"Relax Finch version requirement","ref":"changelog.html#v0-2-2-2022-04-04","title":"CHANGELOG - v0.2.2 (2022-04-04)","type":"extras"},{"doc":"Add :private field to Response Update Finch to 0.9.1","ref":"changelog.html#v0-2-1-2021-11-24","title":"CHANGELOG - v0.2.1 (2021-11-24)","type":"extras"},{"doc":"Rename normalize_headers to encode_headers Rename prepend_default_steps to put_default_steps Rename encode and decode to encode_body and decode_body Rename netrc to load_netrc Rename finch step to run_finch Rename if_modified_since to put_if_modified_since Rename range to put_range Rename params to put_params Rename request.uri to request.url Change response/error step contract from f(req, resp_err) to f({req, resp_err}) Support mime 2.x Add Req.Response struct Add put!/3 and delete!/2 Add run_steps/2 Initial support for UNIX domain sockets Accept {module, args} and module as steps Ensure get_private and put_private have atom keys put_default_steps : Use MFArgs instead of captures for the default steps put_if_modified_since : Fix generating internet time encode_headers : Encode header values retry : Rename :max_attempts to :max_retries","ref":"changelog.html#v0-2-0-2021-11-08","title":"CHANGELOG - v0.2.0 (2021-11-08)","type":"extras"},{"doc":"Fix append_request_steps/2 and prepend_request_steps/2 (they did the opposite) Add finch/1","ref":"changelog.html#v0-1-1-2021-07-16","title":"CHANGELOG - v0.1.1 (2021-07-16)","type":"extras"},{"doc":"Initial release","ref":"changelog.html#v0-1-0-2021-07-15","title":"CHANGELOG - v0.1.0 (2021-07-15)","type":"extras"}]